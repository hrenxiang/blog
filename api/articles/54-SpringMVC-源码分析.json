{"title":"SpringMVC 源码分析","uid":"39dbbffa03a8d8ee66fd7af853996d07","slug":"54-SpringMVC-源码分析","date":"2021-09-13T15:31:32.000Z","updated":"2021-09-15T10:57:19.403Z","comments":true,"path":"api/articles/54-SpringMVC-源码分析.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog8.jpg","content":"<h4 id=\"green-book-SpringMVC-运行原理\"><a href=\"#green-book-SpringMVC-运行原理\" class=\"headerlink\" title=\":green_book: SpringMVC 运行原理\"></a>:green_book: SpringMVC 运行原理</h4><h4 id=\"①-总体情形\"><a href=\"#①-总体情形\" class=\"headerlink\" title=\"① 总体情形\"></a>① 总体情形</h4><p><img src=\"https://user-gold-cdn.xitu.io/2018/12/20/167cb9daf729e4cd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"springmvc工作原理图\"></p>\n<ul>\n<li>用户发送请求至DispatcherServlet。</li>\n<li>DispatcherServlet收到请求调用HandlerMapping查询具体的Handler。</li>\n<li>HandlerMapping找到具体的处理器(具体配置的是哪个处理器的实现类)，生成处理器对象及处理器拦截器(HandlerExcutorChain包含了Handler以及拦截器<strong>集合</strong>)返回给DispatcherServlet。</li>\n<li>DispatcherServlet接收到HandlerMapping返回的HandlerExcutorChain后，调用HandlerAdapter(处理器适配器)请求执行具体的Handler(Controller)。</li>\n<li>HandlerAdapter经过适配调用<strong>拦截器链</strong>。然后经过拦截器后在分发给具体的Handler(Controller即后端控制器)。   </li>\n<li>Controller执行完成返回ModelAndView(其中包含逻辑视图和数据)给HandlerAdaptor。</li>\n<li>HandlerAdaptor再将ModelAndView返回给DispatcherServlet。</li>\n<li>DispatcherServlet请求视图解析器ViewReslover解析ModelAndView。</li>\n<li>ViewReslover解析后返回具体View(物理视图)到DispatcherServlet。</li>\n<li>DispatcherServlet请求渲染视图(即将模型数据填充至视图中) 根据View进行渲染视图。</li>\n<li>将渲染后的视图返回给DispatcherServlet。</li>\n<li>DispatcherServlet将响应结果返回给用户。</li>\n</ul>\n<h4 id=\"②-核心组件\"><a href=\"#②-核心组件\" class=\"headerlink\" title=\"② 核心组件\"></a>② 核心组件</h4><ul>\n<li><p>前端控制器DispatcherServlet（配置即可）</p>\n<p>功能: 中央处理器,接收请求,自己不做任何处理,而是将请求发送给其他组件进行处理。DispatcherServlet 是整个流程的控制中心。</p>\n</li>\n<li><p>处理器映射器HandlerMapping(配置即可)</p>\n<p>功能: 根据DispatcherServlet发送的url请求路径查找Handler</p>\n<p>常见的处理器映射器:BeanNameUrlHandlerMapping,SimpleUrlHandlerMapping,</p>\n<p>ControllerClassNameHandlerMapping,DefaultAnnotationHandlerMapping(不建议使用)</p>\n</li>\n<li><p>处理器适配器HandlerAdapter（配置即可）</p>\n<p>功能: 按照特定规则（HandlerAdapter要求的规则）去执行Handler。</p>\n<p>通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展多个适配器对更多类型的处理器进行执行。</p>\n<p>常见的处理器适配器:HttpRequestHandlerAdapter，SimpleControllerHandlerAdapter，AnnotationMethodHandlerAdapter</p>\n</li>\n<li><p>处理器Handler即Controller(程序猿编写)</p>\n<p>功能: 编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler。</p>\n</li>\n<li><p>视图解析器ViewReslover(配置即可)</p>\n<p>功能: 进行视图解析，根据逻辑视图名解析成真正的视图。</p>\n<p>ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。</p>\n<p>springmvc框架提供了多种View视图类型,如:jstlView、freemarkerView、pdfView…</p>\n</li>\n<li><p>视图View(程序猿编写)</p>\n<p>View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）</p>\n</li>\n</ul>\n<h4 id=\"③-常见API\"><a href=\"#③-常见API\" class=\"headerlink\" title=\"③ 常见API\"></a>③ 常见API</h4><ul>\n<li><p>DispatcherServlet：发现他的上级类中有HttpServlet，而Servlet的执行入口是service()，一会就从这个方法入手开始SpringMVC执行过程的讲解。</p>\n<div>\n    <p>\n        图一、DispatcherServlet   图二、HandlerMapping\n    </p>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/springMVC-1.png\" alt=\"image-20210721200252573\" style=\"zoom:45%;\" />\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/SpringMVC-2.png\" alt=\"image-20210721200521441\" style=\"zoom:50%;\" />\n</div></li>\n<li><p>HandlerMapping：项目中会有多个@RequestMapping，每个RequestMapping对应一个类或者一个方法。用户给一个请求路径，如何获取该路径所对应的方法呢？这就要通过HandlerMapping来实现了。返回的结果就是访问路径所对应的处理器。</p>\n<p>查看源码，发现HandlerMapping是一个接口，有多个实现类。该接口只有一个方法。当使用注解方式时，使用的处理器映射器是RequestMappingHandlerMapping。</p>\n</li>\n<li><p>HandlerExecutionChain：为什么请求Handler，要返回HandlerExecutionChain呢。因为Handler的执行前后会有一个或者多个拦截器执行，并且拦截器是链式执行的。所有HandlerExecutionChain中就包含了要执行的一个处理器和多个拦截器的信息。</p>\n<p>处理器就是我们开发的使用@Controller标记的控制器。而拦截器也己经经过，要实现三个方法，分别在不同的时机执行。以后都会看到三个方法执行的代码的。</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/SpirngMVC-3.png\" alt=\"image-20210721201146447\"></p>\n</li>\n<li><p>HandlerAdapter：处理器的执行是通过处理器适配器来执行的。因为会有XML方式、注解方式等处理器形式，具体执行会有不同，通过不同的HandlerAdapter来实现。这里用到了适配器设计模式。HandlerAdapter在SpringMVC中是一个接口。其中的handle()就是执行处理器。当使用注解方式时，使用的处理器映射器是RequestMappingHandlerAdapter。</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/SpringMVC-4.png\" alt=\"image-20210721201453433\"></p>\n</li>\n<li><p>ViewResolver：ViewResolver实现逻辑视图到物理视图的解析，比如：对于如下视图解析器，”main”是逻辑视图，而添加了后缀前缀的“/WEB-INF/jsp/main.jsp”就是物理视图。</p>\n<p>在SpringMVC中ViewResolver作为一个接口存在，可以有不同的实现类，比如上面的InternalResourceViewResolver。</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;\n    &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;&gt;&lt;&#x2F;property&gt;\n    &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&gt;&lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;</code></pre></li>\n</ul>\n<h4 id=\"green-book-DispatcherServlet请求处理过程\"><a href=\"#green-book-DispatcherServlet请求处理过程\" class=\"headerlink\" title=\":green_book: DispatcherServlet请求处理过程\"></a>:green_book: DispatcherServlet请求处理过程</h4><p>整个请求处理过程都是 doDispatch() 方法在宏观上协调和调度，把握了这个方法就理解了 SpringMVC 总体上是如何处理请求的。</p>\n<p>所在类：org.springframework.web.servlet.<strong>DispatcherServlet</strong></p>\n<p>所在方法：doDispatch()</p>\n<h4 id=\"①-入口点：FrameworkServlet\"><a href=\"#①-入口点：FrameworkServlet\" class=\"headerlink\" title=\"① 入口点：FrameworkServlet\"></a>① 入口点：FrameworkServlet</h4><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/SpringMVC-6.png\" alt=\"image-20210721202839729\"></p>\n<p>分析:    FrameworkServlet重写了HttpServlet的service方法, 请求进来的时候, 首先是进入到了这个service方法,    通过从请求中拿到请求方法, 将其转为枚举类HttpMethod, 最后还是<strong>调用了HttpServlet的service方法</strong>。</p>\n<p>之所以重写这个方法, 原因是增加了对请求方法类型为patch的处理, 在HttpServlet的service中是没有对这个类型 的请求进行处理的, 我们先不理会processRequest方法是做啥的, 首先需要知道, 当请求是其他类型的时候, 最终会调用到HttpServlet的service方法的, 在这个方法中有各种doXXX方法, 然而!!FrameworkServlet重写了这些doXXX方法, 以doPost为例:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected final void doPost(HttpServletRequest request, HttpServletResponse response) &#123;           \n    processRequest(request, response);       \n&#125;     </code></pre>\n\n<p>ok, 到这里为止, 大家应该就清楚了, <strong>真正处理请求的是这个processRequest方法</strong>, 所有的请求最终都会到    FrameworkServlet中的doXX方法, 最终用processRequest方法来调用</p>\n<h4 id=\"②-真正处理请求：processRequest\"><a href=\"#②-真正处理请求：processRequest\" class=\"headerlink\" title=\"② 真正处理请求：processRequest\"></a>② 真正处理请求：processRequest</h4><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/SpringMVC-7.png\" alt=\"image-20210721204534325\"></p>\n<p> 第一部分，就是构建LocaleContext、ServletRequestAttributes, 然后将他们保    存到ThreadLocal中, 这样我们在整个请求的任何地方都能获取到这两个对象了。</p>\n<p>第二部分doService方法才是真正用来处理请求的, 这 个方法里面做的事情对执行流程的分析也没多大意义。他会跳转到DispatcherServlet中的 doService方法中，然后调用 doDispatch() 方法</p>\n<h4 id=\"③-处理请求的核心：doDispatch\"><a href=\"#③-处理请求的核心：doDispatch\" class=\"headerlink\" title=\"③ 处理请求的核心：doDispatch\"></a>③ 处理请求的核心：doDispatch</h4><p>processedRequest表示真正的请求对象,</p>\n<p>mappedHandler就 是之前我们分析的, 将handler和HandlerInterceptor封装起来的对象,</p>\n<p>multipartRequestParsed表示是否对文件 上传这样的功能进行了解析</p>\n<p>第六步，将handler和HandlerIntercepter进行合并, 变成一个<strong>HandlerExecutionChain</strong> 对象</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/SpringMVC-8.png\" alt=\"image-20210721205532824\"></p>\n<p>mappedHandler.getHandler()获取对应的handler, 利用这个handler来遍历所有的HandlerAdapter, 找到合适的 <strong>HandlerAdapter</strong>并返回</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/SpringMVC-9.png\" alt=\"image-20210721205839697\"></p>\n<p>遍历HandlerExecutionChain中的所有拦截器, <strong>调用其preHandle方法(正序)</strong>, 如果返回true, 那么就继续执行, 返回 false则就不执行了。</p>\n<p>调用HandlerAdapter的<strong>handle方法</strong>, 若是**@RequestMapping的情况, 则调用的是 AbstractHandlerMethodAdapter的hanlde方法**，返回一个ModelAndView对象。</p>\n<p>applyDefaultViewName是因为当我们返回的ModelAndView中没有View的时候, 比如我们@RequestMapping标注的方 法返回的是void或者有被@ResponseBody标注的时候, 就是没有视图的, 此时会赋予一个默认的视图,。</p>\n<p> 最后调用HandlerExecutionChain中所有拦截器的**postHandle方法(逆序)**，在doDispatch的代码中, 我们可以看到在异常捕获后调用了triggerAfterCompletion方法, 里面其实就是对 HandlerExecutionChain中所有拦截器的afterCompletion方法的调用。</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/SpringMVC-10.png\" alt=\"image-20210721210726500\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>调用 **processDispatchResult，解析和渲染视图，执行拦截器的afterComplation()[逆序]**就全靠它了，第二个红框没用</p></blockquote>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/SpringMVC-11.png\" alt=\"image-20210721211512522\"></p>\n<p>render方法其实就是利用ViewResolver解析viewName, 获取到一个视图View对 象, 然后对http的状态进行一下设置, 最后调用视图对象View的render方法完成渲染, 对于JSP文件来说, 其实就是 forward到对应的jsp文件而已</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/SpringMVC-12.png\" alt=\"image-20210721212128730\"></p>\n<h4 id=\"④-所有断点总结\"><a href=\"#④-所有断点总结\" class=\"headerlink\" title=\"④ 所有断点总结\"></a>④ 所有断点总结</h4><p>断点位置基准：SpringMVC 版本采用 5.3.1 且源码已经下载，包含注释。</p>\n<table>\n<thead>\n<tr>\n<th>所在类</th>\n<th>所在方法</th>\n<th>断点行数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DispatcherServlet</td>\n<td>doDispatch()</td>\n<td>1037</td>\n<td>创建调用链对象</td>\n</tr>\n<tr>\n<td>DispatcherServlet</td>\n<td>doDispatch()</td>\n<td>1044</td>\n<td>创建 HandlerAdapter 对象</td>\n</tr>\n<tr>\n<td>DispatcherServlet</td>\n<td>doDispatch()</td>\n<td>1056</td>\n<td>调用拦截器 preHandle()方法</td>\n</tr>\n<tr>\n<td>DispatcherServlet</td>\n<td>doDispatch()</td>\n<td>1061</td>\n<td>执行目标 handler 方法</td>\n</tr>\n<tr>\n<td>DispatcherServlet</td>\n<td>doDispatch()</td>\n<td>1068</td>\n<td>调用拦截器 postHandle()方法</td>\n</tr>\n<tr>\n<td>DispatcherServlet</td>\n<td>doDispatch()</td>\n<td>1078</td>\n<td>执行所有后续操作</td>\n</tr>\n<tr>\n<td>AbstractHandlerMapping</td>\n<td>getHandlerExecutionChain()</td>\n<td>592</td>\n<td>创建调用链对象</td>\n</tr>\n<tr>\n<td>AbstractHandlerMapping</td>\n<td>getHandlerExecutionChain()</td>\n<td>599</td>\n<td>在调用链中添加拦截器</td>\n</tr>\n<tr>\n<td>HandlerExecutionChain</td>\n<td>applyPreHandle()</td>\n<td>146</td>\n<td>调用拦截器 preHandle()方法</td>\n</tr>\n<tr>\n<td>HandlerExecutionChain</td>\n<td>applyPostHandle()</td>\n<td>163</td>\n<td>调用拦截器 postHandle()方法</td>\n</tr>\n<tr>\n<td>HandlerExecutionChain</td>\n<td>triggerAfterCompletion</td>\n<td>175</td>\n<td>调用拦截器 afterCompletion()方法</td>\n</tr>\n<tr>\n<td>DataBinder</td>\n<td>doBind()</td>\n<td>747</td>\n<td>执行数据绑定</td>\n</tr>\n<tr>\n<td>RequestMappingHandlerAdapter</td>\n<td>invokeHandlerMethod()</td>\n<td>868</td>\n<td>创建 ModelAndViewContainer 对象</td>\n</tr>\n<tr>\n<td>RequestMappingHandlerAdapter</td>\n<td>invokeHandlerMethod()</td>\n<td>893</td>\n<td>将ModelAndViewContainer 对象传入调用目标 handler 的方法</td>\n</tr>\n<tr>\n<td>DispatcherServlet</td>\n<td>processDispatchResult()</td>\n<td>1125</td>\n<td>处理异常</td>\n</tr>\n<tr>\n<td>DispatcherServlet</td>\n<td>processDispatchResult()</td>\n<td>1139</td>\n<td>渲染视图</td>\n</tr>\n<tr>\n<td>DispatcherServlet</td>\n<td>processDispatchResult()</td>\n<td>1157</td>\n<td>调用拦截器 afterCompletion()方法</td>\n</tr>\n<tr>\n<td>WebEngineContext的内部类： RequestAttributesVariablesMap</td>\n<td>setVariable()</td>\n<td>783</td>\n<td>将模型数据存入请求域</td>\n</tr>\n</tbody></table>\n<h4 id=\"green-book-启动过程\"><a href=\"#green-book-启动过程\" class=\"headerlink\" title=\":green_book: 启动过程\"></a>:green_book: 启动过程</h4><h4 id=\"①-Servlet生命周期回顾\"><a href=\"#①-Servlet生命周期回顾\" class=\"headerlink\" title=\"① Servlet生命周期回顾\"></a>① Servlet生命周期回顾</h4><table>\n<thead>\n<tr>\n<th>生命周期环节</th>\n<th>调用的方法</th>\n<th>时机</th>\n<th>次数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>创建对象</td>\n<td>无参构造器</td>\n<td><strong>默认：第一次请求 修改：Web应用启动时</strong></td>\n<td>一次</td>\n</tr>\n<tr>\n<td>初始化</td>\n<td>init(ServletConfig servletConfig)</td>\n<td>创建对象后</td>\n<td>一次</td>\n</tr>\n<tr>\n<td>处理请求</td>\n<td>service(ServletRequest servletRequest, ServletResponse servletResponse)</td>\n<td>接收到请求后</td>\n<td>多次</td>\n</tr>\n<tr>\n<td>清理操作</td>\n<td>destroy()</td>\n<td>Web应用卸载之前</td>\n<td>一次</td>\n</tr>\n</tbody></table>\n<h4 id=\"②-初始化调用路线\"><a href=\"#②-初始化调用路线\" class=\"headerlink\" title=\"② 初始化调用路线\"></a>② 初始化调用路线</h4><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/SpringMVC-13.png\" alt=\"image-20210722002910809\"></p>\n<h4 id=\"③-创建-IOC-容器对象并存入应用域\"><a href=\"#③-创建-IOC-容器对象并存入应用域\" class=\"headerlink\" title=\"③ 创建 IOC 容器对象并存入应用域\"></a>③ 创建 IOC 容器对象并存入应用域</h4><p>所在类：org.springframework.web.servlet.FrameworkServlet</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected WebApplicationContext initWebApplicationContext() &#123;\n    WebApplicationContext rootContext &#x3D;\n            WebApplicationContextUtils.getWebApplicationContext(getServletContext());\n    WebApplicationContext wac &#x3D; null;\n\n    if (this.webApplicationContext !&#x3D; null) &#123;\n        wac &#x3D; this.webApplicationContext;\n        if (wac instanceof ConfigurableWebApplicationContext) &#123;\n            ConfigurableWebApplicationContext cwac &#x3D; (ConfigurableWebApplicationContext) wac;\n            if (!cwac.isActive()) &#123;\n                if (cwac.getParent() &#x3D;&#x3D; null) &#123;\n                    cwac.setParent(rootContext);\n                &#125;\n                configureAndRefreshWebApplicationContext(cwac);\n            &#125;\n        &#125;\n    &#125;\n    if (wac &#x3D;&#x3D; null) &#123;\n        wac &#x3D; findWebApplicationContext();\n    &#125;\n    if (wac &#x3D;&#x3D; null) &#123;\n        &#x2F;&#x2F; 创建 IOC 容器\n        wac &#x3D; createWebApplicationContext(rootContext);\n    &#125;\n\n    if (!this.refreshEventReceived) &#123;\n        synchronized (this.onRefreshMonitor) &#123;\n            onRefresh(wac);\n        &#125;\n    &#125;\n\n    if (this.publishContext) &#123;\n        &#x2F;&#x2F; 获取存入应用域时专用的属性名\n        String attrName &#x3D; getServletContextAttributeName();\n        \n        &#x2F;&#x2F; 存入\n        getServletContext().setAttribute(attrName, wac);\n    &#125;\n\n    return wac;\n&#125;</code></pre>\n\n<p>看到这一点的意义：SpringMVC 有一个工具方法，可以从应用域获取 IOC 容器对象的引用。</p>\n<p>工具类：org.springframework.web.context.support.WebApplicationContextUtils</p>\n<p>工具方法：getWebApplicationContext()</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Nullable\npublic static WebApplicationContext getWebApplicationContext(ServletContext sc) &#123;\n    return getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);\n&#125;</code></pre>\n\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/SpringMVC-16.png\" alt=\"image-20210722010422430\"></p>\n<h4 id=\"④-IOC容器创建\"><a href=\"#④-IOC容器创建\" class=\"headerlink\" title=\"④ IOC容器创建\"></a>④ IOC容器创建</h4><p>所在类：org.springframework.web.servlet.FrameworkServlet</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) &#123;\n    Class&lt;?&gt; contextClass &#x3D; getContextClass();\n    if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;\n        throw new ApplicationContextException(\n                &quot;Fatal initialization error in servlet with name &#39;&quot; + getServletName() +\n                &quot;&#39;: custom WebApplicationContext class [&quot; + contextClass.getName() +\n                &quot;] is not of type ConfigurableWebApplicationContext&quot;);\n    &#125;\n    \n    &#x2F;&#x2F; 通过反射创建 IOC 容器对象\n    ConfigurableWebApplicationContext wac &#x3D;\n            (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);\n\n    wac.setEnvironment(getEnvironment());\n    \n    &#x2F;&#x2F; 设置父容器\n    wac.setParent(parent);\n    String configLocation &#x3D; getContextConfigLocation();\n    if (configLocation !&#x3D; null) &#123;\n        wac.setConfigLocation(configLocation);\n    &#125;\n    configureAndRefreshWebApplicationContext(wac);\n\n    return wac;\n&#125;</code></pre>\n\n<p>注意：创建DispatcherServlet中创建IoC容器时会去应用域中查询已经存在的IoC容器，并作为父容器。如果不存在，父容器就是null，表示没有父容器。这个操作并不多余，下节讲解ContextLoaderListener后就会明白原由。</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/SpringMVC-15.png\" alt=\"image-20210722005528236\"></p>\n<h4 id=\"⑤-获取SpringMVC配置文件名称\"><a href=\"#⑤-获取SpringMVC配置文件名称\" class=\"headerlink\" title=\"⑤ 获取SpringMVC配置文件名称\"></a>⑤ 获取SpringMVC配置文件名称</h4><pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;servlet&gt;\n    &lt;servlet-name&gt;dispatcherServlet&lt;&#x2F;servlet-name&gt;\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;\n    &lt;init-param&gt;\n        &lt;!--指定SpringMVC配置文件的名称和位置，有默认位置 --&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n        &lt;param-value&gt;classpath:springmvc.xml&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;init-param&gt;\n    &lt;!-- 启动服务器时就加载总控制器--&gt;\n    &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;\n&lt;&#x2F;servlet&gt;</code></pre>\n\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/SpringMVC-17.png\" alt=\"image-20210722010607671\"></p>\n<h4 id=\"⑥-配置文件内容解析\"><a href=\"#⑥-配置文件内容解析\" class=\"headerlink\" title=\"⑥ 配置文件内容解析\"></a>⑥ 配置文件内容解析</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>&lt;mvc:annotation-driven&gt; </code></p>\n<p><code>&lt;bean id=&quot;viewResolver&quot; class=&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt;</code></p>\n<p> <code>@RequestMapping(&quot;user/save1&quot;)</code></p></blockquote>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/SpringMVC-19.png\" alt=\"image-20210722012708743\"></p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/SpringMVC-18.png\" alt=\"image-20210722011741870\"></p>\n<h4 id=\"⑦-小结\"><a href=\"#⑦-小结\" class=\"headerlink\" title=\"⑦ 小结\"></a>⑦ 小结</h4><ul>\n<li>DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。</li>\n<li>DispatcherServlet 的父类是 FrameworkServlet。<ul>\n<li>FrameworkServlet 负责框架本身相关的创建和初始化。</li>\n<li>DispatcherServlet 负责请求处理相关的初始化。</li>\n</ul>\n</li>\n<li>FrameworkServlet 创建 IOC 容器对象之后会存入应用域。</li>\n<li>FrameworkServlet 完成初始化会调用 IOC 容器的刷新方法。</li>\n<li>刷新方法完成触发刷新事件，在刷新事件的响应函数中，调用 DispatcherServlet 的初始化方法。</li>\n<li>在 DispatcherServlet 的初始化方法中初始化了请求映射等。</li>\n</ul>\n<hr>\n<h4 id=\"green-book-ContextLoaderListener\"><a href=\"#green-book-ContextLoaderListener\" class=\"headerlink\" title=\":green_book: ContextLoaderListener\"></a>:green_book: ContextLoaderListener</h4><table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>执行时机</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>contextInitialized()</td>\n<td>Web 应用启动时执行</td>\n<td>创建并初始化 IOC 容器</td>\n</tr>\n<tr>\n<td>contextDestroyed()</td>\n<td>Web 应用卸载时执行</td>\n<td>关闭 IOC 容器</td>\n</tr>\n</tbody></table>\n<h4 id=\"①-问题引入\"><a href=\"#①-问题引入\" class=\"headerlink\" title=\"① 问题引入\"></a>① 问题引入</h4><p>SSM整合后，配置文件内容过多，可以分到两个配置文件中。这两个配置文件夹如何加载</p>\n<p>方法1：DispatcherServlet加载所有的配置文件（<strong>用 * 匹配后缀</strong>），<strong>此方法只有一个Ioc容器，存放所有的Bean</strong></p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!--配置SpringMVC总控制器，唯一的Servlet --&gt;  \n\n&lt;servlet&gt;   \n\n    &lt;servlet-name&gt;dispatcherServlet&lt;&#x2F;servlet-name&gt;   \n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;   \n\n    &lt;init-param&gt;     \n        &lt;!--指定SpringMVC配置文件的名称和位置，有默认位置 --&gt;     \n        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;     \n        &lt;param-value&gt;classpath:spring*.xml&lt;&#x2F;param-value&gt;   \n    &lt;&#x2F;init-param&gt;   \n\n    &lt;!-- 启动服务器时就加载总控制器--&gt;   \n    &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;  \n\n&lt;&#x2F;servlet&gt;</code></pre>\n\n\n\n<p>方法2：DispatcherServlet加载springmvc的配置文件，使用ContextLoaderListener加载另外一个配置文件</p>\n<p>会有两个Ioc容器</p>\n<p>使用ContextLoaderListener加载另外一个配置文件创建的IoC容器是父容器。</p>\n<p>DispatcherServlet加载springmvc的配置文件创建的IoC容器是子容器。</p>\n<p>注意：Servlet、Filter、Listener的加载顺序：Listener、Filter、Servlet</p>\n<h4 id=\"②-使用Lister创建IOC容器\"><a href=\"#②-使用Lister创建IOC容器\" class=\"headerlink\" title=\"② 使用Lister创建IOC容器\"></a>② 使用Lister创建IOC容器</h4><p><strong>在web.xml 中引入 监听器</strong></p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;context-param&gt;\n    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n    &lt;param-value&gt;classpath:spring-persist.xml&lt;&#x2F;param-value&gt;\n&lt;&#x2F;context-param&gt;\n&lt;listener&gt;\n    &lt;!-- 该监听器加载的spring配置文件有默认的位置和名称，默认在WEB-INF--&gt;\n    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;\n&lt;&#x2F;listener&gt;</code></pre>\n\n<p>ServletContextListener中 只有两个方法，分别在服务器启动和关闭的时候执行</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface ServletContextListener extends EventListener &#123;\n&#x2F;&#x2F;服务器启动时执行\n    void contextInitialized(ServletContextEvent var1);\n    &#x2F;&#x2F;服务器关闭时执行\n    void contextDestroyed(ServletContextEvent var1);\n&#125;</code></pre>\n\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/SpringMVC-20.png\" alt=\"image-20210722014428166\"></p>\n<h4 id=\"③-探讨两个IoC容器的关系\"><a href=\"#③-探讨两个IoC容器的关系\" class=\"headerlink\" title=\"③ 探讨两个IoC容器的关系\"></a>③ 探讨两个IoC容器的关系</h4><p>结论：两个组件分别创建的 IOC 容器是<strong>父子</strong>关系。</p>\n<ul>\n<li>父容器：ContextLoaderListener 创建的 IOC 容器</li>\n<li>子容器：DispatcherServlet 创建的 IOC 容器</li>\n</ul>\n<p>父子关系是如何决定的？</p>\n<ul>\n<li>ContextLoaderListener 初始化时如果检查到有已经存在的根级别 IOC 容器，那么会抛出异常。</li>\n<li>DispatcherServlet 创建的 IOC 容器会在初始化时先检查当前环境下是否存在已经创建好的 IOC 容器。<ul>\n<li>如果有：则将已存在的这个 IOC 容器设置为自己的父容器</li>\n<li>如果没有：则将自己设置为 root 级别的 IOC 容器</li>\n</ul>\n</li>\n<li>同时 Tomcat 在读取 web.xml 之后，加载组件的顺序就是监听器、过滤器、Servlet。</li>\n</ul>\n<p>DispatcherServlet 创建的 IOC 容器设置父容器的源码截图：</p>\n<p>所在类：org.springframework.web.servlet.FrameworkServlet</p>\n<p>所在方法：createWebApplicationContext()</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/SpringMVC-21.png\" alt=\"image-20210722014905081\"></p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/SpringMVC-22.png\" alt=\"image-20210722014936379\"></p>\n<h4 id=\"④-出现的问题及其解决\"><a href=\"#④-出现的问题及其解决\" class=\"headerlink\" title=\"④ 出现的问题及其解决\"></a>④ 出现的问题及其解决</h4><p>如果<code>&lt;context:component-scan &gt;</code>的路径设置不合理，就会重复的创建Bean。<br>如何查看：将logback的总的日志级别改为DEBUG</p>\n<p>缺点：</p>\n<ol>\n<li><p>重复的bean会多占用资源</p>\n</li>\n<li><p>SpringMVC创建的Controller肯定是调用SpringMVC自己创建的Service和Dao，但是在SpringMVC的配置文件中并没有关于事务的设置，所以调用SpringMVC自己创建的Service和Dao，将无法使用到事务。这绝对不可以。</p>\n</li>\n</ol>\n<h4 id=\"⑤-解决方案1【建议使用】\"><a href=\"#⑤-解决方案1【建议使用】\" class=\"headerlink\" title=\"⑤ 解决方案1【建议使用】\"></a>⑤ 解决方案1【建议使用】</h4><p>==让两个配置文件配置自动扫描的包时，各自扫描各自的组件。==</p>\n<ul>\n<li>SpringMVC 就扫描 XxxHandler</li>\n<li>Spring 扫描 XxxService 和 XxxDao</li>\n</ul>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!-- 配置注解扫描基准路径--&gt;\n&lt;context:component-scan base-package&#x3D;&quot;com.atguigu.controller&quot;&gt;&lt;&#x2F;context:component-scan&gt;\n\n&lt;!-- 配置注解扫描基准路径--&gt;\n&lt;context:component-scan base-package&#x3D;&quot;com.atguigu.service,com.atguigu.dao&quot;&gt;&lt;&#x2F;context:component-scan&gt;</code></pre>\n\n<p>结果：SpringMVC中创建了Controller，Listener中创建了Service并应用了事务。当SpringMVC在自己的IoC容器中找不到Service的时候，就会到父容器中去找Service。问题解决。</p>\n<h4 id=\"⑥-解决方案2\"><a href=\"#⑥-解决方案2\" class=\"headerlink\" title=\"⑥ 解决方案2\"></a>⑥ 解决方案2</h4><p>具体spring-mvc.xml配置文件中的配置方式如下： </p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!-- 两个Spring的配置文件扫描相同的包 --&gt;\n&lt;!-- 为了解决重复创建对象的问题，需要进一步制定扫描组件时的规则 --&gt;\n&lt;!-- 目标：『仅』包含@Controller注解标记的类 --&gt;\n&lt;!-- use-default-filters&#x3D;&quot;false&quot;表示关闭默认规则，表示什么都不扫描，此时不会把任何组件加入IOC容器；\n        再配合context:include-filter实现“『仅』包含”效果 --&gt;\n&lt;context:component-scan base-package&#x3D;&quot;com.atguigu.spring.component&quot; use-default-filters&#x3D;&quot;false&quot;&gt;\n\n    &lt;!-- context:include-filter标签配置一个“扫描组件时要包含的类”的规则，追加到默认规则中 --&gt;\n    &lt;!-- type属性：指定规则的类型，根据什么找到要包含的类，现在使用annotation表示基于注解来查找 --&gt;\n    &lt;!-- expression属性：规则的表达式。如果type属性选择了annotation，那么expression属性配置注解的全类名 --&gt;\n    &lt;context:include-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Controller&quot;&#x2F;&gt;\n&lt;&#x2F;context:component-scan&gt;</code></pre>\n\n<p>具体spring-persist.xml配置文件中的配置方式如下：</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!-- 两个Spring的配置文件扫描相同的包 --&gt;\n&lt;!-- 在默认规则的基础上排除标记了@Controller注解的类 --&gt;\n&lt;context:component-scan base-package&#x3D;&quot;com.atguigu.spring.component&quot;&gt;\n\n    &lt;!-- 配置具体排除规则：把标记了@Controller注解的类排除在扫描范围之外 --&gt;\n    &lt;context:exclude-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Controller&quot;&#x2F;&gt;\n&lt;&#x2F;context:component-scan&gt;</code></pre>\n\n","text":":green_book: SpringMVC 运行原理① 总体情形 用户发送请求至DispatcherServlet。 DispatcherServlet收到请求调用HandlerMapping查询具体的Handler。 HandlerMapping找到具体的处理器(具体配置的是...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"SpringMVC","slug":"SpringMVC","count":3,"path":"api/categories/SpringMVC.json"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","count":3,"path":"api/tags/SpringMVC.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#green-book-SpringMVC-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">:green_book: SpringMVC 运行原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E6%80%BB%E4%BD%93%E6%83%85%E5%BD%A2\"><span class=\"toc-text\">① 总体情形</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">② 核心组件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A2-%E5%B8%B8%E8%A7%81API\"><span class=\"toc-text\">③ 常见API</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#green-book-DispatcherServlet%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">:green_book: DispatcherServlet请求处理过程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E5%85%A5%E5%8F%A3%E7%82%B9%EF%BC%9AFrameworkServlet\"><span class=\"toc-text\">① 入口点：FrameworkServlet</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E7%9C%9F%E6%AD%A3%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%EF%BC%9AprocessRequest\"><span class=\"toc-text\">② 真正处理请求：processRequest</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A2-%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84%E6%A0%B8%E5%BF%83%EF%BC%9AdoDispatch\"><span class=\"toc-text\">③ 处理请求的核心：doDispatch</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A3-%E6%89%80%E6%9C%89%E6%96%AD%E7%82%B9%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">④ 所有断点总结</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#green-book-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">:green_book: 启动过程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A0-Servlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E9%A1%BE\"><span class=\"toc-text\">① Servlet生命周期回顾</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%B0%83%E7%94%A8%E8%B7%AF%E7%BA%BF\"><span class=\"toc-text\">② 初始化调用路线</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A2-%E5%88%9B%E5%BB%BA-IOC-%E5%AE%B9%E5%99%A8%E5%AF%B9%E8%B1%A1%E5%B9%B6%E5%AD%98%E5%85%A5%E5%BA%94%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">③ 创建 IOC 容器对象并存入应用域</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A3-IOC%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">④ IOC容器创建</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A4-%E8%8E%B7%E5%8F%96SpringMVC%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%90%8D%E7%A7%B0\"><span class=\"toc-text\">⑤ 获取SpringMVC配置文件名称</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A5-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">⑥ 配置文件内容解析</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A6-%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">⑦ 小结</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#green-book-ContextLoaderListener\"><span class=\"toc-text\">:green_book: ContextLoaderListener</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5\"><span class=\"toc-text\">① 问题引入</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E4%BD%BF%E7%94%A8Lister%E5%88%9B%E5%BB%BAIOC%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">② 使用Lister创建IOC容器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A2-%E6%8E%A2%E8%AE%A8%E4%B8%A4%E4%B8%AAIoC%E5%AE%B9%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">③ 探讨两个IoC容器的关系</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A3-%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3\"><span class=\"toc-text\">④ 出现的问题及其解决</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A4-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%881%E3%80%90%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E3%80%91\"><span class=\"toc-text\">⑤ 解决方案1【建议使用】</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A5-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882\"><span class=\"toc-text\">⑥ 解决方案2</span></a></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"Dubbo Zookeeper","uid":"6cf45a5bd6abd2bbf495c5388d2d047e","slug":"55-Dubbo Zookeeper","date":"2021-09-13T15:32:32.000Z","updated":"2021-09-15T10:50:00.083Z","comments":true,"path":"api/articles/55-Dubbo Zookeeper.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog9.jpg","text":":basketball: 软件架构的发展过程 ① 单体架构一个归档包（例如war格式或者Jar格式）包含了应用所有功能的应用程序，我们通常称之为单体应用。架构单体应用的方法论，我们称之 为单体应用架构，这是一种比较传统的架构风格。 1. 架构说明：全部功能集中在一个项目内（All...","link":"","photos":[],"count_time":{"symbolsCount":"28k","symbolsTime":"25 mins."},"categories":[{"name":"微服务","slug":"微服务","count":1,"path":"api/categories/微服务.json"}],"tags":[{"name":"微服务","slug":"微服务","count":1,"path":"api/tags/微服务.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"SpringMVC 特定功能","uid":"a17a011b39e721d63806f9eabda18a53","slug":"53-SpringMVC-特定功能","date":"2021-09-13T15:30:32.000Z","updated":"2021-09-15T10:50:28.643Z","comments":true,"path":"api/articles/53-SpringMVC-特定功能.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog11.jpg","text":":cactus: 拦截器① 拦截器前言 SpringMVC提供的拦截器类似于JavaWeb中的过滤器，只不过SpringMVC拦截器只拦截被前端控制器拦截的请求，而过滤器拦截从前端发送的任意请求。 熟练掌握SpringMVC拦截器对于我们开发非常有帮助，在没使用权限框架(shir...","link":"","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"23 mins."},"categories":[{"name":"SpringMVC","slug":"SpringMVC","count":3,"path":"api/categories/SpringMVC.json"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","count":3,"path":"api/tags/SpringMVC.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}