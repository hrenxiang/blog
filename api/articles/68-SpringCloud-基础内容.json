{"title":"SpringCloud 基础内容","uid":"74daf6bfc632564c16acab051038d38a","slug":"68-SpringCloud-基础内容","date":"2021-09-13T15:44:32.000Z","updated":"2021-09-15T10:46:40.017Z","comments":true,"path":"api/articles/68-SpringCloud-基础内容.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog8.jpg","content":"<h4 id=\"1、本章导读\"><a href=\"#1、本章导读\" class=\"headerlink\" title=\"1、本章导读\"></a>1、本章导读</h4><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/springcloud-BasicContent.png\" alt=\"image-20210813175150797\"></p>\n<h4 id=\"2、微服务理论\"><a href=\"#2、微服务理论\" class=\"headerlink\" title=\"2、微服务理论\"></a>2、微服务理论</h4><p>In short, the microservice architectural style <a href=\"https://www.martinfowler.com/articles/microservices.html#footnote-etymology\">[1]</a> is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.</p>\n<p>简而言之，<strong>微服务架构风格</strong><a href=\"https://www.martinfowler.com/articles/microservices.html#footnote-etymology\">[1]</a>是一种<strong>将单个应用程序开发为一组小服务</strong>的方法，每个小服务都在自己的进程中运行，并与轻量级机制（通常是 HTTP 资源 API）进行通信。这些服务是围绕业务能力构建的，并且可以通过完全自动化的部署机制独立部署。这些服务有最低限度的集中管理，它们可以用不同的编程语言编写并使用不同的数据存储技术。</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\">http:&#x2F;&#x2F;blog.cuicc.com&#x2F;blog&#x2F;2015&#x2F;07&#x2F;22&#x2F;microservices&#x2F;</code></pre>\n\n\n\n<h4 id=\"3、架构及服务器间交流方式\"><a href=\"#3、架构及服务器间交流方式\" class=\"headerlink\" title=\"3、架构及服务器间交流方式\"></a>3、架构及服务器间交流方式</h4><hr/>\n\n<h5 id=\"3-1、软件架构演变\"><a href=\"#3-1、软件架构演变\" class=\"headerlink\" title=\"3.1、软件架构演变\"></a>3.1、软件架构演变</h5><div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/springcloud-1-1.png\" alt=\"image-20210813180708783\" style=\"zoom:80%;\" />\n</div>\n\n<ul>\n<li><p>单一应用架构</p>\n<p>当网站流量很小时，只需==一个应用，将所有功能都部署在一起==，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架 (ORM) 是关键。</p>\n</li>\n<li><p>垂直应用架构</p>\n<p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用==拆成互不相干的几个应用（模块，但是模块间还是有联系），以提升效率==。此时，用于加速前端页面开发的Web框架 (MVC) 是关键。</p>\n</li>\n<li><p>分布式服务（RPC）架构</p>\n<p>当垂直应用越来越多，应用之间交互不可避免，==将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心==，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架 (<strong>RPC</strong>) 是关键。</p>\n</li>\n<li><p>流动计算（SOA）架构</p>\n<p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心 (SOA) 是关键。</p>\n</li>\n</ul>\n<h5 id=\"3-1、RPC是什么\"><a href=\"#3-1、RPC是什么\" class=\"headerlink\" title=\"3.1、RPC是什么\"></a>3.1、RPC是什么</h5><p>RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。</p>\n<p>它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。</p>\n<p>即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p>\n<h5 id=\"3-2、RPC思想原理\"><a href=\"#3-2、RPC思想原理\" class=\"headerlink\" title=\"3.2、RPC思想原理\"></a>3.2、RPC思想原理</h5><div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/springcloud-1-2.png\" alt=\"image-20210813181011025\" style=\"zoom:80%;\" />\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/springcloud-1-3.png\" alt=\"image-20210813181040184\" style=\"zoom:65%;\" />\n</div>\n\n<p>客户端（服务消费者）发送请求，底层以流的方式通过网络访问服务端（服务提供者），调用服务端的相关方法并返回相关数据，客户端在进行相应的处理</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">名词</th>\n<th align=\"left\">定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">服务提供者</td>\n<td align=\"left\">服务的被调用方（即：为其他服务提供服务的服务）</td>\n</tr>\n<tr>\n<td align=\"left\">服务消费者</td>\n<td align=\"left\">服务的调用方（即：依赖其他服务的服务）</td>\n</tr>\n</tbody></table>\n<h5 id=\"3-3、服务器间交流的两种方式\"><a href=\"#3-3、服务器间交流的两种方式\" class=\"headerlink\" title=\"3.3、服务器间交流的两种方式\"></a>3.3、服务器间交流的两种方式</h5><p>RPC：Netty（Socket）+自定义序列化</p>\n<p>RestAPI   ==(严格来说，SpringCloud是使用Rest方式进行服务之间交互的，不属于RPC)==：HTTP + JSON</p>\n<h4 id=\"4、分布式概念\"><a href=\"#4、分布式概念\" class=\"headerlink\" title=\"4、分布式概念\"></a>4、分布式概念</h4><hr/>\n\n<h5 id=\"4-1、什么是分布式\"><a href=\"#4-1、什么是分布式\" class=\"headerlink\" title=\"4.1、什么是分布式\"></a>4.1、什么是分布式</h5><p>《分布式系统原理与范型》定义：“分布式系统是==若干独立计算机的集合==，这些计算机对于用户来说就像单个相关系统”。</p>\n<p>分布式系统（distributed system）是建立在网络之上的软件系统。</p>\n<h5 id=\"4-2、分布式和集群的区别\"><a href=\"#4-2、分布式和集群的区别\" class=\"headerlink\" title=\"4.2、分布式和集群的区别\"></a>4.2、分布式和集群的区别</h5><p>集群指的是将几台服务器集中在一起，实现同一业务。</p>\n<p>==分布式中的每一个节点，都可以做集群。 而集群并不一定就是分布式的。==</p>\n<h4 id=\"5、分布式思想\"><a href=\"#5、分布式思想\" class=\"headerlink\" title=\"5、分布式思想\"></a>5、分布式思想</h4><hr/>\n\n<h5 id=\"5-1、高并发\"><a href=\"#5-1、高并发\" class=\"headerlink\" title=\"5.1、高并发\"></a>5.1、高并发</h5><p>通过设计保证系统可以==并行处理很多请求==。应对大量流量与请求</p>\n<p>Tomcat最多支持并发多少用户？</p>\n<ul>\n<li>Tomcat 默认配置的最大请求数是 150，也就是说同时支持 150 个并发，当然了，也可以将其改大。</li>\n<li>当某个应用拥有 250 个以上并发的时候，应考虑应用服务器的集群。</li>\n<li>具体能承载多少并发，需要看硬件的配置，CPU 越多性能越高，分配给 JVM 的内存越多性能也就越高，但也会加重 GC 的负担。</li>\n</ul>\n<p>操作系统对于进程中的线程数有一定的限制：</p>\n<ul>\n<li>Windows 每个进程中的线程数不允许超过 2000，Linux 每个进程中的线程数不允许超过 1000</li>\n<li>另外，在 Java 中每开启一个线程需要耗用 1MB 的 JVM 内存空间用于作为线程栈之用。</li>\n<li>Tomcat 默认的 HTTP 实现是采用阻塞式的 Socket 通信，每个请求都需要创建一个线程处理。这种模式下的并发量受到线程数的限制，但对于 Tomcat 来说几乎没有 BUG 存在了。</li>\n<li>Tomcat 还可以配置 NIO 方式的 Socket 通信，在性能上高于阻塞式的，每个请求也不需要创建一个线程进行处理，并发能力比前者高。但没有阻塞式的成熟。</li>\n</ul>\n<p>这个并发能力还与应用的逻辑密切相关：</p>\n<ul>\n<li><p>如果逻辑很复杂需要大量的计算，那并发能力势必会下降。如果每个请求都含有很多的数据库操作，那么对于数据库的性能也是非常高的。</p>\n</li>\n<li><p>对于单台数据库服务器来说，允许客户端的连接数量是有限制的。并发能力问题涉及整个系统架构和业务逻辑。</p>\n</li>\n</ul>\n<p>系统环境不同，Tomcat版本不同、JDK版本不同、以及修改的设定参数不同。并发量的差异还是满大的。</p>\n<ul>\n<li>maxThreads=”1000” 最大并发数 ，默认值为200</li>\n<li>minSpareThreads=”100”//初始化时创建的线程数，默认值为10</li>\n<li>acceptCount=”700”// 指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理，默认值为100，<a href=\"https://tomcat.apache.org/tomcat-8.0-doc/config/http.html\">https://tomcat.apache.org/tomcat-8.0-doc/config/http.html</a></li>\n</ul>\n<p><strong>高并发衡量指标如下：</strong></p>\n<ul>\n<li><p>响应时间(RT) ：请求做出响应的时间，即一个http请求返回所用的时间</p>\n</li>\n<li><p>吞吐量：系统在单位时间内处理请求的数量</p>\n</li>\n<li><p>QPS(Query/Request Per Second)、 TPS（Transaction Per Second）：每秒查询（请求）数、每秒事务数</p>\n</li>\n<li><p>专业的测试工具：Load Runner            Apache ab            Apache JMeter</p>\n</li>\n<li><p>并发用户数：承载的正常使用系统功能的用户的数量</p>\n</li>\n</ul>\n<h5 id=\"5-2、高可用\"><a href=\"#5-2、高可用\" class=\"headerlink\" title=\"5.2、高可用\"></a>5.2、高可用</h5><p>服务集群部署，数据库主从+双机热备</p>\n<ul>\n<li><p>主-备方式（Active-Standby方式）</p>\n<p>主-备方式即指的是==一台服务器处于某种业务的激活状态==（即Active状态），另==一台服务器处于该业务的备用状态==（即Standby状态)。</p>\n</li>\n<li><p>双主机方式（Active-Active方式）</p>\n<p>双主机方式即指==两种不同业务分别在两台服务器上互为主备状态==（即Active-Standby和Standby-Active状态）</p>\n</li>\n</ul>\n<h5 id=\"5-3、注册中心\"><a href=\"#5-3、注册中心\" class=\"headerlink\" title=\"5.3、注册中心\"></a>5.3、注册中心</h5><p>保存某个服务所在地址等信息，方便调用者实时获取其他服务信息</p>\n<p>服务注册：服务提供者</p>\n<p>服务发现：服务消费者</p>\n<h5 id=\"5-4、负载均衡\"><a href=\"#5-4、负载均衡\" class=\"headerlink\" title=\"5.4、负载均衡\"></a>5.4、负载均衡</h5><p>动态将请求派发给比较闲的服务器，有以下策略</p>\n<ul>\n<li>==轮询(Round Robin)==</li>\n<li>==加权轮询(Weighted Round Robin)==</li>\n<li>==随机Random==</li>\n<li>哈希Hash</li>\n<li>最小连接数LC</li>\n<li>最短响应时间LRT</li>\n</ul>\n<h5 id=\"5-5、服务雪崩\"><a href=\"#5-5、服务雪崩\" class=\"headerlink\" title=\"5.5、服务雪崩\"></a>5.5、服务雪崩</h5><div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/springcloud-1-4.png\" alt=\"image-20210813193326854\" style=\"zoom: 67%;\" />\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/springcloud-1-5%E3%80%81.png\" alt=\"image-20210813193543501\" style=\"zoom:87%;\" />\n</div>\n\n<p>上面是一组简单的服务依赖关系A，B服务同时依赖于基础服务C，基础服务C又调用了服务D</p>\n<p>服务D是一个辅助类型服务，整个业务不依赖于D服务，某天D服务突然响应时间变长，却没有返回任何消息，导致了核心服务C还在等待D的响应，响应时间变长，而后续的请求也继续进来，其上请求越积越多，C服务也出现了响应变慢的情况，由于A，B强依赖于服务C，故而一个无关紧要的服务却影响了整个系统的可用。</p>\n<p>雪崩是系统中的蝴蝶效应导致其发生的原因多种多样，有不合理的容量设计，或者是高并发下某一个方法响应变慢，亦或是某台机器的资源耗尽。从源头上我们无法完全杜绝雪崩源头的发生，但是雪崩的根本原因来源于服务之间的强依赖，所以我们可以提前评估，做好<strong>熔断，隔离，限流。</strong></p>\n<h5 id=\"5-6、熔断\"><a href=\"#5-6、熔断\" class=\"headerlink\" title=\"5.6、熔断\"></a>5.6、熔断</h5><p>简单来说就是在服务D前加一个阀门，某个服务频繁超时，直接将其短路，快速返回mock（模拟/虚拟）值</p>\n<p>说到熔断器，第一时间会想到Hystrix。下面我们一起来看下熔断器的实现原理</p>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/springcloud-1-6.png\" alt=\"img\" style=\"zoom: 80%;\" />\n</div>\n\n<p>熔断器实际上是一个简单的有限状态机(Finite State Machine)</p>\n<ol>\n<li><p>请求错误率达到某一阈值，熔断器<strong>全开</strong>，产生熔断（熔断期间会对所有请求采用降级处理）</p>\n</li>\n<li><p>到熔断时间窗口之后，熔断器会进入<strong>半开</strong>状态，此时hystrix会放过1个试验性请求</p>\n</li>\n<li><p>如果该试验性请求成功，熔断器进入<strong>关闭</strong>状态</p>\n</li>\n<li><p>如果该试验性请求失败，熔断器重新进入<strong>全开</strong>状态</p>\n</li>\n</ol>\n<h5 id=\"5-7、限流\"><a href=\"#5-7、限流\" class=\"headerlink\" title=\"5.7、限流\"></a>5.7、限流</h5><p>限流可以认为服务降级的一种，限流就是限制某个服务每秒的调用本服务的频率，限制系统的输入和输出流量已达到保护系统的目的。</p>\n<p>一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。</p>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/springcloud-1-7.png\" alt=\"image-20210813194712508\" style=\"zoom: 67%;\" />\n</div>\n\n\n\n<h5 id=\"5-8、API网关\"><a href=\"#5-8、API网关\" class=\"headerlink\" title=\"5.8、API网关\"></a>5.8、API网关</h5><p>API网关要做很多工作，它作为一个系统的后端总入口，承载着所有<strong>服务的组合路由转换</strong>等工作。除此之外，我们一般也会把<strong>安全，限流，缓存，日志，监控，重试，熔断</strong>等放到 API 网关来做。</p>\n<p>简单说，API网关是微服务架构中的“指路人”与“守护者”。首先，它会提供最基本的路由服务，将调用转发到上游服务。其次，作为一个入口，它还可以进行认证，鉴权，限流等操作，对上游服务保护。所以说，有了API网关，就可以做到“一夫当关，万夫莫开”。</p>\n<p>由于API网关在整个架构系统中位置特别重要，而且承受巨大的压力。所以，高性能和高可用都需要考虑。比较常用的做法是在网关的前面，加上负载均衡，这样，网关既能水平扩展，又能保证高可用。</p>\n<h5 id=\"5-9、服务跟踪\"><a href=\"#5-9、服务跟踪\" class=\"headerlink\" title=\"5.9、服务跟踪\"></a>5.9、服务跟踪</h5><p>追踪服务的调用链，记录整个系统执行请求过程。如：请求响应时间，判断链中的哪些服务属于慢服务（可能存在问题，需要改善）。</p>\n<p>随着业务的发展,系统规模也会变得越来越大,各微服务间的调用关系也变得越来越错综复杂。通常一个由客户端发起的请求在后端系统中会经过多个不同的微服务调用来协同产生最后的请求结果,在复杂的微服务架构系统中,几乎每一个前端请求都会形成一条复杂的分布式服务调用链路,在每条链路中任何一个依赖服务出现延迟过高或错误的时候都有可能引起请求最后的失败。这时候, 对于每个请求,全链路调用的跟踪就变得越来越重要,通过实现对请求调用的跟踪可以帮助我们快速发现错误根源以及监控分析每条请求链路上的性能瓶颈等。</p>\n<h5 id=\"6-0、弹性云\"><a href=\"#6-0、弹性云\" class=\"headerlink\" title=\"6.0、弹性云\"></a>6.0、弹性云</h5><p>Elastic Compute Service（ECS）弹性计算服务</p>\n<p>动态扩容，压榨服务器闲时能力</p>\n<p>例如：双11,618，高峰时多配置些服务器，平时减少多余的服务器配置（用于其他服务应用），避免资源浪费</p>\n<h4 id=\"6、微服务内容\"><a href=\"#6、微服务内容\" class=\"headerlink\" title=\"6、微服务内容\"></a>6、微服务内容</h4><hr/>\n\n<h5 id=\"6-1、微服务架构\"><a href=\"#6-1、微服务架构\" class=\"headerlink\" title=\"6.1、微服务架构\"></a>6.1、微服务架构</h5><div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/springcloud-1-8.png\" alt=\"image-20210813200115635\" style=\"zoom:80%;\" />\n</div>\n\n<p>物联网（ IoT ，Internet of things ）即“万物相连的互联网”，是互联网基础上的延伸和扩展的网络，将各种信息传感设备与互联网结合起来而形成的一个巨大网络，实现在任何时间、任何地点，人、机、物的互联互通。</p>\n<p>Breaker dashboard 断路器仪表板</p>\n<p>Distributed Tracing分布式跟踪 （分布式处理程序链跟踪用于监视网络等待时间，并可视化通过微服务的请求流）</p>\n<h5 id=\"6-2、微服务是什么\"><a href=\"#6-2、微服务是什么\" class=\"headerlink\" title=\"6.2、微服务是什么\"></a>6.2、微服务是什么</h5><p>微服务架是从SOA架构演变过来，比SOA架构粒度会更加精细，让专业的人去做专业的事情（专注），目的提高效率，每个服务于服务之间互不影响，微服务架构中，每个服务必须独立部署，互不影响，微服务架构更加体现轻巧、轻量级，是适合于互联网公司敏捷开发。</p>\n<h5 id=\"6-3、微服务理论\"><a href=\"#6-3、微服务理论\" class=\"headerlink\" title=\"6.3、微服务理论\"></a>6.3、微服务理论</h5><p>简而言之，<strong>微服务架构风格</strong>是一种<strong>将单个应用程序开发为一组小服务</strong>的方法，每个小服务都在自己的进程中运行，并与轻量级机制（通常是 HTTP 资源 API）进行通信。这些服务是围绕业务能力构建的，并且可以通过完全自动化的部署机制独立部署。这些服务有最低限度的集中管理，它们可以用不同的编程语言编写并使用不同的数据存储技术。</p>\n<h5 id=\"6-4、微服务架构特征\"><a href=\"#6-4、微服务架构特征\" class=\"headerlink\" title=\"6.4、微服务架构特征\"></a>6.4、微服务架构特征</h5><p>微服务架构倡导应用程序设计程多个独立、可配置、可运行和可微服务的子服务。</p>\n<p>服务与服务通讯协议采用Http协议，使用restful风格API形式来进行通讯，数据交换格式轻量级json格式通讯，整个传输过程中，采用二进制，所以http协议可以跨语言平台，并且可以和其他不同的语言进行相互的通讯，所以很多开放平台都采用http协议接口。</p>\n<h5 id=\"6-5、微服务架构如何拆分\"><a href=\"#6-5、微服务架构如何拆分\" class=\"headerlink\" title=\"6.5、微服务架构如何拆分\"></a>6.5、微服务架构如何拆分</h5><p>1、微服务把每一个职责单一功能存放在独立的服务中</p>\n<p>2、每个服务运行在单独的进程中</p>\n<p>3、每个服务有自己独立数据库存储、实际上有自己独立的缓存、数据库、消息队列等资源。</p>\n<h5 id=\"6-6、微服务架构与SOA架构区别\"><a href=\"#6-6、微服务架构与SOA架构区别\" class=\"headerlink\" title=\"6.6、微服务架构与SOA架构区别\"></a>6.6、微服务架构与SOA架构区别</h5><p>1、微服务架构基于 SOA架构 演变过来，继承 SOA架构的优点，在微服务架构中去除 SOA 架构中的 ESB 消息总线，<strong>采用 http+json（restful）进行传输。</strong></p>\n<p>2、微服务架构比 SOA 架构<strong>粒度会更加精细</strong>，让专业的人去做专业的事情（专注），目的提高效率，每个服务于服务之间互不影响，微服务架构中，每个服务必须独立部署，微服务架构更加轻巧，轻量级。</p>\n<p>3、SOA 架构中可能数据库存储会发生共享，微服务强调独每个服务都是单独数据库，<strong>保证每个服务于服务之间互不影响</strong>。</p>\n<p>4、项目体现特征微服务架构比 SOA 架构更加适合与互联网公司敏捷开发、快速迭代版本，因为粒度非常精细。</p>\n<h4 id=\"7、SpringCloud介绍及组件\"><a href=\"#7、SpringCloud介绍及组件\" class=\"headerlink\" title=\"7、SpringCloud介绍及组件\"></a>7、SpringCloud介绍及组件</h4><hr/>\n\n<h5 id=\"7-1、为什么选择SpringCloud\"><a href=\"#7-1、为什么选择SpringCloud\" class=\"headerlink\" title=\"7.1、为什么选择SpringCloud\"></a>7.1、为什么选择SpringCloud</h5><p>因为SpringCloud出现，对微服务技术提供了非常大的帮助，因为SpringCloud <strong>提供了一套完整的微服务解决方案</strong>，不像其他框架只是解决了微服务中某个问题。</p>\n<p>服务治理：阿里巴巴开源的Dubbo和当当网在其基础上扩展的Dubbox、Eureka、Apache 的Consul等。</p>\n<p>分布式配置中心：百度的disconf、Netfix的Archaius、360的QConf、SpringCloud Config、携程的阿波罗等。</p>\n<p>分布式任务：xxl-job、elastic-job、springcloud的task等。</p>\n<p>服务跟踪：京东的hyra、springcloud的sleuth等。</p>\n<h5 id=\"7-2、SpringCloud介绍\"><a href=\"#7-2、SpringCloud介绍\" class=\"headerlink\" title=\"7.2、SpringCloud介绍\"></a>7.2、SpringCloud介绍</h5><p>Spring Cloud为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理，服务发现，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁定，领导选举，分布式会话，集群状态）。分布式系统的协调导致了样板模式，使用Spring Cloud开发人员可以快速站起来实现这些模式的服务和应用程序。它们适用于任何分布式环境，包括开发人员自己的笔记本电脑，裸机数据中心和Cloud Foundry等托管平台。</p>\n<h5 id=\"7-3、SpringCloud组件\"><a href=\"#7-3、SpringCloud组件\" class=\"headerlink\" title=\"7.3、SpringCloud组件\"></a>7.3、SpringCloud组件</h5><p>Spring Cloud构建微服务是<strong>基于SpringBoot开发</strong>的，<strong>服务之间通过基于 HTTP 的 RESTFUL API 进行通信协作</strong>的。</p>\n<p>版本选择：SpringBoot-2.2.2.RELEASE版和SpringCloud Hoxton.SR1版，后面会改用 SpringCloud Alibaba 2.1</p>\n<p>Spring Boot：<a href=\"https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/\">https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/</a></p>\n<p>Spring Cloud：<a href=\"https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/\">https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/</a></p>\n<p>中文版：<a href=\"https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md\">https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md</a></p>\n<p>Spring Cloud组件由20多个组件组成的，常用的组件有如下：</p>\n<p><strong>主要组件</strong>：</p>\n<ul>\n<li>Eureka：服务注册中心，特性有失效剔除、服务保护</li>\n<li>Dashboard，Hystrix仪表盘：监控集群模式和单点模式，其中集群模式需要收集器Turbine配合</li>\n<li>Zuul：API服务网关，功能有路由分发和过滤</li>\n<li>Config：分布式配置中心，支持本地仓库、SVN、Git、Jar包内配置等模式</li>\n</ul>\n<p>融合：融合在每个微服务中、依赖其它组件并为其提供服务</p>\n<ul>\n<li>Ribbon：客户端负载均衡，特性有区域亲和、重试机制</li>\n<li>Hystrix：客户端容错保护，特性有服务降级、服务熔断、请求缓存、请求合并、依赖隔离</li>\n<li>Feign：声明式服务调用，本质上就是Ribbon+Hystrix，类似于Dubbo的调用</li>\n<li>Stream：消息驱动，有Sink、Source、Processor三种通道，特性有订阅发布、消费组、消息分区</li>\n<li>Bus：消息总线，配合Config仓库修改的一种Stream实现</li>\n<li>Sleuth：分布式服务追踪，需要搞清楚TraceID和SpanID以及抽样，并且与ZipKin整合</li>\n<li>在此还会涉及到SpringBoot的SpringBoot Admin（一个管理和监控 Spring Boot 应用程序的开源项目）</li>\n</ul>\n<p><strong>组件的作用</strong>：</p>\n<p>每个组件都不是平白无故的产生的，是为了解决某一特定的问题而存在</p>\n<ul>\n<li>Eureka：分为客户端和服务端，客户端是一个java客户端，用来连接Eureka服务端(说白了服务端就是Eureka注册中心)，与服务端进行交互，负载均衡，服务的故障切换等。。。作用类似于zookeeper</li>\n<li>Ribbon：是一个基于HTTP和TCP的客户端负载均衡器，当使用Ribbon对服务进行访问的时候，他会扩展Eureka客户端的服务发现功能，实现从Eureka注册中心获取服务端列表，并通过Eureka客户端来确定服务端是否已经启动。Ribbon在Eureka客户端服务发现的基础上，实现对服务实例的选择策略，从而实现对服务的负载均衡消费。</li>\n</ul>\n<p>总结：Eureka和Ribbon，是最基础的组件，一个注册服务，一个负载均衡消费服务。</p>\n<ul>\n<li>Hystrix(断路器/熔断器)：为了优化Ribbon、防止整个微服务架构因为某个服务节点的问题导致崩溃，是个保险丝的作用，防止服务雪崩。</li>\n<li>Dashboard：给Hystrix统计和展示用的，而且监控服务节点的整体压力和健康情况。</li>\n<li>Turbine：是集群收集器，服务于Dashboard的。</li>\n<li>Feign：是Netflix公司开发的一个声明式的REST调用客户端，Ribbon负载均衡，Hystrix服务熔断是Spring Cloud中进行微服务开发的最基础的组件，在使用过程中我一般发现他们都是一起存在的，而且配置也相似，每次开发都有相同的代码，因此Spring Cloud基于<strong>Netflix Feign 整合了Ribbon和Hystrix两个组件</strong>，让开发更简单</li>\n<li>Zuul：是加在整个微服务最前沿的防火墙和代理器，隐藏微服务结点IP端口信息，加强安全保护的。</li>\n<li>Config：是为了解决所有微服务各自维护各自的配置，设置一个统一的配置中心，方便修改配置的。</li>\n<li>Bus：是因为config修改完配置后各个结点都要refresh才能生效实在太麻烦，所以交给bus来通知服务节点刷新配置的。</li>\n<li>Stream：是为了简化研发人员对MQ使用的复杂度，弱化MQ的差异性，达到程序和MQ松耦合。目前只支持RabbitMQ和Kafka</li>\n<li>Sleuth：是因为单次请求在微服务节点中跳转无法追溯，解决任务链日志追踪问题的</li>\n</ul>\n<h5 id=\"7-4、Cloud和Boot的依赖关系\"><a href=\"#7-4、Cloud和Boot的依赖关系\" class=\"headerlink\" title=\"7.4、Cloud和Boot的依赖关系\"></a>7.4、Cloud和Boot的依赖关系</h5><p><a href=\"https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/\">https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/</a></p>\n<p><a href=\"https://cloud.spring.io/spring-cloud-static/Hoxton.SR3/reference/html/spring-cloud.html\">https://cloud.spring.io/spring-cloud-static/Hoxton.SR3/reference/html/spring-cloud.html</a></p>\n<p>更详细的版本对应查看方法： <a href=\"https://start.spring.io/actuator/info\">https://start.spring.io/actuator/info</a> </p>\n<h4 id=\"8、SpringCloud入门程序\"><a href=\"#8、SpringCloud入门程序\" class=\"headerlink\" title=\"8、SpringCloud入门程序\"></a>8、SpringCloud入门程序</h4><hr/>\n\n<h5 id=\"8-1、父工程（cloud-parent）\"><a href=\"#8-1、父工程（cloud-parent）\" class=\"headerlink\" title=\"8.1、父工程（cloud-parent）\"></a>8.1、父工程（cloud-parent）</h5><pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n\n    &lt;groupId&gt;com.atguigu&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;cloud-parent&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;!-- 统一管理jar包版本 --&gt;\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;\n        &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;\n        &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;\n        &lt;junit.version&gt;4.12&lt;&#x2F;junit.version&gt;\n        &lt;log4j.version&gt;1.2.17&lt;&#x2F;log4j.version&gt;\n        &lt;lombok.version&gt;1.16.18&lt;&#x2F;lombok.version&gt;\n        &lt;mysql.version&gt;5.1.47&lt;&#x2F;mysql.version&gt;\n        &lt;druid.version&gt;1.1.16&lt;&#x2F;druid.version&gt;\n        &lt;mybatis.spring.boot.version&gt;1.3.0&lt;&#x2F;mybatis.spring.boot.version&gt;\n    &lt;&#x2F;properties&gt;\n\n    &lt;!-- 子模块继承之后，提供作用：锁定版本+子modlue不用写groupId和version  --&gt;\n    &lt;dependencyManagement&gt;\n        &lt;dependencies&gt;\n            &lt;!--spring boot 2.2.2--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;2.2.2.RELEASE&lt;&#x2F;version&gt;\n                &lt;type&gt;pom&lt;&#x2F;type&gt;\n                &lt;scope&gt;import&lt;&#x2F;scope&gt;\n            &lt;&#x2F;dependency&gt;\n            &lt;!--spring cloud Hoxton.SR1--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;Hoxton.SR1&lt;&#x2F;version&gt;\n                &lt;type&gt;pom&lt;&#x2F;type&gt;\n                &lt;scope&gt;import&lt;&#x2F;scope&gt;\n            &lt;&#x2F;dependency&gt;\n            &lt;!--spring cloud alibaba 2.1.0.RELEASE--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;2.1.0.RELEASE&lt;&#x2F;version&gt;\n                &lt;type&gt;pom&lt;&#x2F;type&gt;\n                &lt;scope&gt;import&lt;&#x2F;scope&gt;\n            &lt;&#x2F;dependency&gt;\n\n            &lt;dependency&gt;\n                &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;$&#123;mysql.version&#125;&lt;&#x2F;version&gt;\n            &lt;&#x2F;dependency&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;$&#123;druid.version&#125;&lt;&#x2F;version&gt;\n            &lt;&#x2F;dependency&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;$&#123;mybatis.spring.boot.version&#125;&lt;&#x2F;version&gt;\n            &lt;&#x2F;dependency&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;$&#123;junit.version&#125;&lt;&#x2F;version&gt;\n            &lt;&#x2F;dependency&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;$&#123;log4j.version&#125;&lt;&#x2F;version&gt;\n            &lt;&#x2F;dependency&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;$&#123;lombok.version&#125;&lt;&#x2F;version&gt;\n                &lt;optional&gt;true&lt;&#x2F;optional&gt;\n            &lt;&#x2F;dependency&gt;\n        &lt;&#x2F;dependencies&gt;\n    &lt;&#x2F;dependencyManagement&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;fork&gt;true&lt;&#x2F;fork&gt;\n                    &lt;addResources&gt;true&lt;&#x2F;addResources&gt;\n                &lt;&#x2F;configuration&gt;\n            &lt;&#x2F;plugin&gt;\n        &lt;&#x2F;plugins&gt;\n    &lt;&#x2F;build&gt;\n\n&lt;&#x2F;project&gt;</code></pre>\n\n\n\n<h5 id=\"8-2、Rest微服务，服务提供者\"><a href=\"#8-2、Rest微服务，服务提供者\" class=\"headerlink\" title=\"8.2、Rest微服务，服务提供者\"></a>8.2、Rest微服务，服务提供者</h5><pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;cloud-parent&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;com.atguigu&lt;&#x2F;groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n\n    &lt;artifactId&gt;cloud-provider-payment8001&lt;&#x2F;artifactId&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;1.1.10&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;</code></pre>\n\n<p>YML配置文件</p>\n<pre class=\"line-numbers language-yml\" data-language=\"yml\"><code class=\"language-yml\">server:\n  port: 8001\n\nspring:\n  application:\n    name: cloud-payment-service\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springcloud?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;false\n    username: root\n    password: root\n\nmybatis:\n  mapperLocations: classpath:&#x2F;mapper&#x2F;*.xml\n  type-aliases-package: com.atguigu.springcloud.entities</code></pre>\n\n<p>主启动器</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class PaymentMain8001 &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(PaymentMain8001.class,args);\n    &#125;\n&#125;</code></pre>\n\n<p>建表</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE DATABASE  IF NOT EXISTS springcloud DEFAULT CHARACTER SET utf8 ;\n\nUSE springcloud;\n\nDROP TABLE IF EXISTS payment ;\n\nCREATE TABLE payment (\n  id BIGINT (20) NOT NULL AUTO_INCREMENT COMMENT &#39;ID&#39;,\n  SERIAL VARCHAR (300) DEFAULT NULL,\n  PRIMARY KEY (id)\n) ENGINE &#x3D; INNODB AUTO_INCREMENT &#x3D; 33 DEFAULT CHARSET &#x3D; utf8 ;\n\nINSERT INTO payment (id, SERIAL) VALUES(31, &#39;尚硅谷001&#39;),(32, &#39;atguigu002&#39;) ;</code></pre>\n\n<p>实体</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.springcloud.entities;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport java.io.Serializable;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Payment implements Serializable &#123;\n    private Long id;\n    private String serial;\n&#125;</code></pre>\n\n<p>结果封装实体类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.springcloud.entities;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class CommonResult &lt;T&gt; implements Serializable&#123;\n\n    private Integer code;\n    private String message;\n    private T data;\n\n    public CommonResult(Integer code,String message)&#123;\n        this(code,message,null);&#x2F;&#x2F;如果这行报错，请安装lombok插件\n    &#125;\n&#125;</code></pre>\n\n<p>dao</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.springcloud.dao;\n\nimport com.atguigu.springcloud.entities.Payment;\nimport org.apache.ibatis.annotations.Mapper;\nimport org.apache.ibatis.annotations.Param;\nimport org.springframework.stereotype.Repository;\n\n@Component       &#x2F;&#x2F;代替@Repository声明bean\n@Mapper               &#x2F;&#x2F;mybatis提供的，等价：@MapperScan(&quot;com.atguigu.springcloud.dao&quot;)\n&#x2F;&#x2F;@Repository     &#x2F;&#x2F;spring提供的。在此，只是为了声明bean对象\npublic interface PaymentDao &#123;\n    public int create(Payment payment);    \n    public Payment getPaymentById(@Param(&quot;id&quot;) Long id);\n&#125;</code></pre>\n\n<p>mapper</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;\n\n&lt;mapper namespace&#x3D;&quot;com.atguigu.springcloud.dao.PaymentDao&quot;&gt;\n    &lt;insert id&#x3D;&quot;create&quot;  useGeneratedKeys&#x3D;&quot;true&quot; keyProperty&#x3D;&quot;id&quot;&gt;\n            insert into payment(serial) values(#&#123;serial&#125;);\n    &lt;&#x2F;insert&gt;\n\n    \n\n    &lt;select id&#x3D;&quot;getPaymentById&quot;  parameterType&#x3D;&quot;Long&quot; resultType&#x3D;“payment”&gt;\n            select * from payment where id&#x3D;#&#123;id&#125;\n    &lt;&#x2F;select&gt;\n\n&lt;&#x2F;mapper&gt;</code></pre>\n\n<p>service</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.springcloud.service;\n\nimport com.atguigu.springcloud.entities.Payment;\nimport org.apache.ibatis.annotations.Param;\n\npublic interface PaymentService &#123;\n    public int create(Payment payment); &#x2F;&#x2F;写\n    public Payment getPaymentById(Long id);  &#x2F;&#x2F;读取\n&#125;</code></pre>\n\n<p>serviceimpl</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.springcloud.service.impl;\n\nimport com.atguigu.springcloud.dao.PaymentDao;\nimport com.atguigu.springcloud.entities.Payment;\nimport com.atguigu.springcloud.service.PaymentService;\nimport org.apache.ibatis.annotations.Param;\nimport org.springframework.stereotype.Service;\nimport javax.annotation.Resource;\n\n@Service\npublic class PaymentServiceImpl implements PaymentService &#123;\n\n    @Resource\n    &#x2F;&#x2F;@Autowired\n    private PaymentDao paymentDao;\n\n    public int create(Payment payment)&#123;\n        return paymentDao.create(payment);\n    &#125;\n\n    public Payment getPaymentById( Long id)&#123;\n        return paymentDao.getPaymentById(id);\n    &#125;\n&#125;</code></pre>\n\n<p>controller（restful风格）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.springcloud.controller;\n\nimport com.atguigu.springcloud.entities.CommonResult;\nimport com.atguigu.springcloud.entities.Payment;\nimport com.atguigu.springcloud.service.PaymentService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport javax.annotation.Resource;\n\n@RestController\n@Slf4j\npublic class PaymentController &#123;\n\n    @Resource\n    private PaymentService paymentService;\n\n    @PostMapping(value &#x3D; &quot;&#x2F;payment&#x2F;create&quot;)\n    public CommonResult&lt;Payment&gt; create(Payment payment)&#123; &#x2F;&#x2F;埋雷\n       int result &#x3D; paymentService.create(payment);\n       log.info(&quot;*****插入结果：&quot;+result);\n       if (result&gt;0)&#123;  &#x2F;&#x2F;成功\n           return new CommonResult(200,&quot;插入数据库成功&quot;,result);\n       &#125;else &#123;\n           return new CommonResult(444,&quot;插入数据库失败&quot;,null);\n       &#125;\n    &#125;\n\n    @GetMapping(value &#x3D; &quot;&#x2F;payment&#x2F;get&#x2F;&#123;id&#125;&quot;)\n    public CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(&quot;id&quot;) Long id)&#123;\n        Payment payment &#x3D; paymentService.getPaymentById(id);\n        log.info(&quot;*****查询结果：&quot;+payment);\n        if (payment!&#x3D;null)&#123;  &#x2F;&#x2F;说明有数据，能查询成功\n            return new CommonResult(200,&quot;查询成功&quot;,payment);\n        &#125;else &#123;\n            return new CommonResult(444,&quot;没有对应记录，查询ID：&quot;+id,null);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h5 id=\"8-3、Rest微服务，服务消费者\"><a href=\"#8-3、Rest微服务，服务消费者\" class=\"headerlink\" title=\"8.3、Rest微服务，服务消费者\"></a>8.3、Rest微服务，服务消费者</h5><p>pom和上述一样</p>\n<p>yml</p>\n<pre class=\"line-numbers language-yml\" data-language=\"yml\"><code class=\"language-yml\">server:\n  port: 80\nspring:\n  application:\n    name: cloud-consumer-order80</code></pre>\n\n<p>写启动类</p>\n<p>写业务类</p>\n<ul>\n<li>创建entities<br>(将cloud-provider-payment8001工程下的entities包下的两个实体类复制过来)</li>\n<li>RestTemplate是什么<br>RestTemplate提供了多种便捷访问远程Http服务的方法，是一种简单便捷的访问Restful服务模板类，是Spring 提供的用于访问Rest服务的客户端模板工具集</li>\n<li>官网及使用<br>官网地址： <a href=\"https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html\">https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html</a></li>\n<li>使用RestTemplate访问Restful接口非常的简单粗暴无脑。（url，requestMap，ResponseBean.class）这三个参数分别代表REST请求地址、请求参数、Http响应转换被转换成的对象类型。</li>\n</ul>\n<p>config配置类ApplicationContextConfig</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.springcloud.config;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.client.RestTemplate;\n\n&#x2F;&#x2F;@Configuration\n@SpringBootConfiguration\npublic class ApplicationContextConfig &#123;\n    @Bean\n    &#x2F;&#x2F;@LoadBalanced\n    public RestTemplate getRestTemplate()&#123;\n        return new RestTemplate();\n    &#125;\n&#125;</code></pre>\n\n\n<p>创建controller</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.springcloud.controller;\nimport com.atguigu.springcloud.entities.CommonResult;\nimport com.atguigu.springcloud.entities.Payment;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.client.RestTemplate;\nimport javax.annotation.Resource;\n\n@RestController\n@Slf4j\npublic class OrderController &#123;\n    public static final String PAYMENT_URL &#x3D; &quot;http:&#x2F;&#x2F;localhost:8001&quot;;\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @PostMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;create&quot;)\n    public CommonResult&lt;Payment&gt;   create(Payment payment)&#123;\n        return restTemplate.postForObject(PAYMENT_URL+&quot;&#x2F;payment&#x2F;create&quot;,payment,CommonResult.class);  &#x2F;&#x2F;写操作\n    &#125;\n\n    @GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;get&#x2F;&#123;id&#125;&quot;)\n    public CommonResult&lt;Payment&gt; getPayment(@PathVariable(&quot;id&quot;) Long id)&#123;\n        return restTemplate.getForObject(PAYMENT_URL+&quot;&#x2F;payment&#x2F;get&#x2F;&quot;+id,CommonResult.class);\n    &#125;\n&#125;</code></pre>\n<p>测试</p>\n<ol>\n<li><p>先启动cloud-provider-payment8001</p>\n</li>\n<li><p>再启动cloud-consumer-order80</p>\n</li>\n<li><p><a href=\"http://localhost/consumer/payment/get/32\">http://localhost/consumer/payment/get/32</a></p>\n</li>\n<li><p>不要忘记@RequestBody注解</p>\n</li>\n<li><p>服务提供者接口方法需要增加@RequestBody注解(踩雷or破雷)；否则，接收不到数据。</p>\n</li>\n</ol>\n<h5 id=\"8-4、提取重复代码，重构\"><a href=\"#8-4、提取重复代码，重构\" class=\"headerlink\" title=\"8.4、提取重复代码，重构\"></a>8.4、提取重复代码，重构</h5><p>观察消费者和提供者模块中的内容，我们发现实体类是重复的</p>\n<p>新建：cloud-api-commons<br>编写POM</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;cloud-parent&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;com.atguigu&lt;&#x2F;groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n    &lt;artifactId&gt;cloud-api-commons&lt;&#x2F;artifactId&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;cn.hutool&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;hutool-all&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;5.1.0&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;</code></pre>\n\n<p>编写entities</p>\n<ul>\n<li>Payment实体</li>\n<li>CommonResult通用封装类</li>\n</ul>\n<p>服务消费者和提供者模块删除这两个实体类，并在两个pom中添加：</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;cloud-api-commons&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;$&#123;project.version&#125;&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n","text":"1、本章导读 2、微服务理论In short, the microservice architectural style [1] is an approach to developing a single application as a suite of small servi...","link":"","photos":[],"count_time":{"symbolsCount":"28k","symbolsTime":"25 mins."},"categories":[{"name":"SpringCloud","slug":"SpringCloud","count":4,"path":"api/categories/SpringCloud.json"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","count":4,"path":"api/tags/SpringCloud.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%9C%AC%E7%AB%A0%E5%AF%BC%E8%AF%BB\"><span class=\"toc-text\">1、本章导读</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA\"><span class=\"toc-text\">2、微服务理论</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%B4%E4%BA%A4%E6%B5%81%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">3、架构及服务器间交流方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-1%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98\"><span class=\"toc-text\">3.1、软件架构演变</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-1%E3%80%81RPC%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">3.1、RPC是什么</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-2%E3%80%81RPC%E6%80%9D%E6%83%B3%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">3.2、RPC思想原理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-3%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%B4%E4%BA%A4%E6%B5%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">3.3、服务器间交流的两种方式</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">4、分布式概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F\"><span class=\"toc-text\">4.1、什么是分布式</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-2%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E5%92%8C%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4.2、分布式和集群的区别</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">5、分布式思想</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-1%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91\"><span class=\"toc-text\">5.1、高并发</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-2%E3%80%81%E9%AB%98%E5%8F%AF%E7%94%A8\"><span class=\"toc-text\">5.2、高可用</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-3%E3%80%81%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83\"><span class=\"toc-text\">5.3、注册中心</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-4%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\"><span class=\"toc-text\">5.4、负载均衡</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-5%E3%80%81%E6%9C%8D%E5%8A%A1%E9%9B%AA%E5%B4%A9\"><span class=\"toc-text\">5.5、服务雪崩</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-6%E3%80%81%E7%86%94%E6%96%AD\"><span class=\"toc-text\">5.6、熔断</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-7%E3%80%81%E9%99%90%E6%B5%81\"><span class=\"toc-text\">5.7、限流</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-8%E3%80%81API%E7%BD%91%E5%85%B3\"><span class=\"toc-text\">5.8、API网关</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-9%E3%80%81%E6%9C%8D%E5%8A%A1%E8%B7%9F%E8%B8%AA\"><span class=\"toc-text\">5.9、服务跟踪</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-0%E3%80%81%E5%BC%B9%E6%80%A7%E4%BA%91\"><span class=\"toc-text\">6.0、弹性云</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">6、微服务内容</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-1%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">6.1、微服务架构</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-2%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">6.2、微服务是什么</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA\"><span class=\"toc-text\">6.3、微服务理论</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-4%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%89%B9%E5%BE%81\"><span class=\"toc-text\">6.4、微服务架构特征</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-5%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%A6%82%E4%BD%95%E6%8B%86%E5%88%86\"><span class=\"toc-text\">6.5、微服务架构如何拆分</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-6%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8ESOA%E6%9E%B6%E6%9E%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">6.6、微服务架构与SOA架构区别</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7%E3%80%81SpringCloud%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">7、SpringCloud介绍及组件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7-1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9SpringCloud\"><span class=\"toc-text\">7.1、为什么选择SpringCloud</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7-2%E3%80%81SpringCloud%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">7.2、SpringCloud介绍</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7-3%E3%80%81SpringCloud%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">7.3、SpringCloud组件</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7-4%E3%80%81Cloud%E5%92%8CBoot%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">7.4、Cloud和Boot的依赖关系</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8%E3%80%81SpringCloud%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">8、SpringCloud入门程序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-1%E3%80%81%E7%88%B6%E5%B7%A5%E7%A8%8B%EF%BC%88cloud-parent%EF%BC%89\"><span class=\"toc-text\">8.1、父工程（cloud-parent）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-2%E3%80%81Rest%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%8C%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85\"><span class=\"toc-text\">8.2、Rest微服务，服务提供者</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-3%E3%80%81Rest%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%8C%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85\"><span class=\"toc-text\">8.3、Rest微服务，服务消费者</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-4%E3%80%81%E6%8F%90%E5%8F%96%E9%87%8D%E5%A4%8D%E4%BB%A3%E7%A0%81%EF%BC%8C%E9%87%8D%E6%9E%84\"><span class=\"toc-text\">8.4、提取重复代码，重构</span></a></li></ol></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"SpringCloud Hoxton","uid":"7782f77d73b91eb2c8a016712795b746","slug":"69-SpringCloud-Hoxton","date":"2021-09-13T15:45:32.000Z","updated":"2021-09-15T10:46:34.911Z","comments":true,"path":"api/articles/69-SpringCloud-Hoxton.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog7.jpg","text":"01、Eureka 基本内容 在微服务架构中，服务注册与发现是核心组件之一，手动指定每个服务是很低效的，Spring cloud提供了多种服务注册与发现的实现方式,例如: Eureka、Consu、 Zookeeper SringCloud支持得最好的是 Eureka,其次是 C...","link":"","photos":[],"count_time":{"symbolsCount":"48k","symbolsTime":"44 mins."},"categories":[{"name":"SpringCloud","slug":"SpringCloud","count":4,"path":"api/categories/SpringCloud.json"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","count":4,"path":"api/tags/SpringCloud.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"RabbitMQ 高级部分","uid":"572316d3a9d6ae4c1865a38d55232e93","slug":"67-RabbitMQ-高级部分","date":"2021-09-13T15:43:32.000Z","updated":"2021-09-15T10:46:44.360Z","comments":true,"path":"api/articles/67-RabbitMQ-高级部分.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog9.jpg","text":"01、消息的可靠性投递 1.1、消息投递可靠性的简介在使用 RabbitMQ 时，作为消息发送方希望杜绝任何消息丢失或者失败的场景。RabbitMQ 为我们提供了两种方式用来控制消息的投递可靠性模式：==① confirm 确认模式 ② return 退回模式== rabbitm...","link":"","photos":[],"count_time":{"symbolsCount":"46k","symbolsTime":"42 mins."},"categories":[{"name":"消息队列","slug":"消息队列","count":2,"path":"api/categories/消息队列.json"}],"tags":[{"name":"消息队列","slug":"消息队列","count":2,"path":"api/tags/消息队列.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}