{"title":"集合（下）","uid":"88ccd4775101a2a1232ec4d83ea6f5c4","slug":"12-集合（下）","date":"2021-09-13T14:47:32.000Z","updated":"2021-09-14T15:54:58.927Z","comments":true,"path":"api/articles/12-集合（下）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","content":"<h3 id=\"一、Collections\"><a href=\"#一、Collections\" class=\"headerlink\" title=\"一、Collections\"></a>一、Collections</h3><table>\n<thead>\n<tr>\n<th>要点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><font color=\"ff6473\">工具类，随机排序方法shuffle，，反转元素方法reverse以及升序排序方法sort</font></td>\n</tr>\n</tbody></table>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">collection：单列集合的父接口\n\ncollections：他是集合操作的一种 工具类，类中的方法全部是静态的，可以进行查找，排序等操作\n\nCollections类的常用方法\n    * public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)：将指定的列表按升序排序\n    * public static void reverse(List&lt;?&gt; list)：反转指定列表中元素的顺序\n    * public static void shuffle(List&lt;?&gt; list)：使用默认的随机源随机排列指定的列表（随机排列，洗牌）</code></pre>\n\n<h3 id=\"二、Map\"><a href=\"#二、Map\" class=\"headerlink\" title=\"二、Map\"></a>二、Map</h3><h4 id=\"1、map简介\"><a href=\"#1、map简介\" class=\"headerlink\" title=\"1、map简介\"></a>1、map简介</h4><ul>\n<li>一次添加一对元素，是双列集合</li>\n<li>其实map中存储的就是键值对</li>\n<li>map集合必须保证键的唯一性</li>\n</ul>\n<h4 id=\"2、map常用方法\"><a href=\"#2、map常用方法\" class=\"headerlink\" title=\"2、map常用方法\"></a>2、map常用方法</h4><ul>\n<li>V put(K key,V value)：添加元素<br>put方法中，若键第一次添加，则进行添加，若不是第一次添加，则对原有元素进行修改</li>\n<li>V remove(Object key)：根据键删除键值对元素</li>\n<li>void clear()：清空map集合内所有键值对</li>\n<li>boolean containsKey(Object key)：判断集合是否包含指定的键</li>\n<li>boolean containsValue(Object value)：判断集合是否包含指定的值</li>\n<li>boolean isEmpty()：判断集合是否为空</li>\n<li>int size()：集合的长度，也就是集合中键值对的个数</li>\n</ul>\n<h4 id=\"3、map获取功能\"><a href=\"#3、map获取功能\" class=\"headerlink\" title=\"3、map获取功能\"></a>3、map获取功能</h4><ul>\n<li>V get(Objectkey)：根据键获取值</li>\n<li>Set<K> keySet()：获取所有键的集合</li>\n<li>Collection<V> values()：获取所有值的集合</li>\n<li>Set&lt;Map.Entry&lt;K,V&gt; &gt; entrySet()：获取所有键值对对象的集合</li>\n</ul>\n<h4 id=\"4、map两种遍历操作\"><a href=\"#4、map两种遍历操作\" class=\"headerlink\" title=\"4、map两种遍历操作\"></a>4、map两种遍历操作</h4><p>常用第二种，还有只获取值的方法，不过只获取值没意义</p>\n<ol>\n<li>获取所有 键的集合 使用 KeySet方法<br>增强for遍历键的集合，得到每一个键<br>随后使用map的 get方法，以键找值</li>\n<li>获取所有 键值对对象集合 使用entrySet方法<br>遍历键值对对象集合，得到每一个对象<br>使用 getKey和getValue 得到每个对象的键和值</li>\n</ol>\n<h4 id=\"5、map的常用子类\"><a href=\"#5、map的常用子类\" class=\"headerlink\" title=\"5、map的常用子类\"></a>5、map的常用子类</h4><p>子类中的方法和map中的差不多</p>\n<ul>\n<li>HashTable: 内部结构是哈希表，是同步的，不允许 Null 作为建，null 作为值， </li>\n<li>Properties：用来存储键值对型配置文件的信息，可以和 IO 技术相结合。 </li>\n<li>HashMap：内部构造是哈希表，不是同步的。允许 null 键，null 为 null </li>\n<li>TreeMap：内部构造是二叉树，不是同步的，可以对 map 集合进行排序</li>\n</ul>\n<h3 id=\"三、HashMap源码分析\"><a href=\"#三、HashMap源码分析\" class=\"headerlink\" title=\"三、HashMap源码分析\"></a>三、HashMap源码分析</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>引用：<a href=\"https://blog.csdn.net/qq_31903733/article/details/95075601\">https://blog.csdn.net/qq_31903733/article/details/95075601</a></p></blockquote>\n<h4 id=\"1、整体介绍\"><a href=\"#1、整体介绍\" class=\"headerlink\" title=\"1、整体介绍\"></a>1、整体介绍</h4><p>HashMap实现Map接口，用于存储key-value结构，能够根据其key快速查找其value。底层实现为采用一个table数组的hash表，数组中的每一项为一个链表结构。对于每个key，先计算其hash值，然后根据hash值计算其在table数组中的位置，若该位置没有元素，则直接将其放置在该位置，否则，则出现hash冲突，需要遍历查看其所在bucket是否已经有该key了（通过hash和key进行比较），若有了直接替换该key对应的value，否则在链表头部插入。</p>\n<p>需要注意的是如果一个桶中元素大于某个阈值，在JDK8中会将其右链表转换为红黑树。而且对于哈希表（table数组）太满时（大于负载因子），需要对其进行再散列，负载因子默认为0.75，如果表中超过了75%的位置已经填入了元素，那么这个表就会用双倍的桶数自动进行再散列。</p>\n<h4 id=\"2、源码解析\"><a href=\"#2、源码解析\" class=\"headerlink\" title=\"2、源码解析\"></a>2、源码解析</h4><h5 id=\"1-成员变量\"><a href=\"#1-成员变量\" class=\"headerlink\" title=\"1. 成员变量\"></a>1. 成员变量</h5><p>主要有以下几个成员变量</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;*静态常量*&#x2F;\n&#x2F;&#x2F;初始容量：16\nstatic final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16\n&#x2F;&#x2F;负载因子：0.75\nstatic final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;\n&#x2F;&#x2F;链表转换为红黑树的阈值：大于8\nstatic final int TREEIFY_THRESHOLD &#x3D; 8;\n&#x2F;&#x2F;红黑数转换为链表的阈值：小于6\nstatic final int UNTREEIFY_THRESHOLD &#x3D; 6;\n\n&#x2F;*成员变量*&#x2F;\n&#x2F;&#x2F;哈希表数组\ntransient Node&lt;K,V&gt;[] table;\n&#x2F;&#x2F;存储HashMap中的key-value对\ntransient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;\n&#x2F;&#x2F;元素实际个数\ntransient int size;\n&#x2F;&#x2F;是否重新散列的阈值\nint threshold;\n&#x2F;&#x2F;负载因子\nfinal float loadFactor;\n123456789101112131415161718192021</code></pre>\n\n<h5 id=\"2-存储结构\"><a href=\"#2-存储结构\" class=\"headerlink\" title=\"2. 存储结构\"></a>2. 存储结构</h5><p>主要存储结构为<code>Node&lt;K,V&gt;</code></p>\n<p>的结点，用于表示链表结构。</p>\n<p><img src=\"https://gitee.com/xiuxiuai/picture/raw/master/img/HashMap1.png\" alt=\"img\"></p>\n<p>还有用于表示红黑树结构的</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">TreeNode&lt;K,V&gt;</code></pre>\n\n<p><img src=\"https://gitee.com/xiuxiuai/picture/raw/master/img/HashMap2.png.png\" alt=\"img\"></p>\n<h5 id=\"3-构造函数\"><a href=\"#3-构造函数\" class=\"headerlink\" title=\"3. 构造函数\"></a>3. 构造函数</h5><p><img src=\"https://gitee.com/xiuxiuai/picture/raw/master/img/HashMap3.png\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://gitee.com/xiuxiuai/picture/raw/master/img/HashMap4.png\" alt=\"在这里插入图片描述\"></p>\n<p>可以看到，构造函数里并没有对table数组初始化，JDK8的初始化是放在第一次添加的时候进行的。</p>\n<h5 id=\"4-put方法\"><a href=\"#4-put方法\" class=\"headerlink\" title=\"4. put方法\"></a>4. put方法</h5><p>这是HashMap里的最核心的方法了。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public V put(K key, V value) &#123;\n    return putVal(hash(key), key, value, false, true);\n&#125;\n123</code></pre>\n\n<p>首先计算key的hash值，然后调用putValue方法。计算hash值的代码如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">static final int hash(Object key) &#123;\n    int h;\n    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n&#125;\n1234</code></pre>\n\n<h5 id=\"5、hash函数\"><a href=\"#5、hash函数\" class=\"headerlink\" title=\"5、hash函数\"></a>5、hash函数</h5><p>这里有个问题：为什么这样不是直接计算hashCode呢，还要与高16位做异或运算？</p>\n<p>这里的hash函数相当于是一个打扰函数，最终是减少碰撞。因为我们是要根据hash值来计算其在table数组中的位置，也就是后面的<code>tab[i = (n - 1) &amp; hash]</code>，这里<code>(n-1) &amp; hash</code></p>\n<p>相当于取模运算，但比取模更高效，因为table的长度始终是2的n次方(初始容量16，后面扩容时也始终&lt;&lt;1)，所以其低位相当于全是1，高位全是0，最终&amp;运算只保留hash的低位。所以在table容量较小时，如n-1为15(1111)，hash和其相与后真正参与运算的也就是低4位，高位都为0了，这样可能会增加碰撞。所以在计算hash函数中将其和右移16位的值（高位16位变成0，低16位为之前的高16位）进行异或，由于右移始终为0，所以异或后原来的高位保持不变（原来是1的还是1，0的为0），低位变成低位与高位的异或，这样增加了低位的随机性，混合了高位和低位，高位的信息也被保留在低位中了。</p>\n<p><img src=\"https://gitee.com/xiuxiuai/picture/raw/master/img/Hashmap.png\" alt=\"在这里插入图片描述\"></p>\n<h5 id=\"6、putVal方法\"><a href=\"#6、putVal方法\" class=\"headerlink\" title=\"6、putVal方法\"></a>6、putVal方法</h5><p><img src=\"https://gitee.com/xiuxiuai/picture/raw/master/img/HashMap5.png\" alt=\"在这里插入图片描述\"></p>\n<p>上述有几处需要注意的地方：</p>\n<ul>\n<li>1 首先是判断table是否为空，即初次添加，是则调用<code>resize()</code>函数进行初始化</li>\n<li>2 当没有发生碰撞时，即<code>tab[(n-1) &amp; hash]</code>位置为null，直接添加元素</li>\n<li>3 如果发生碰撞，则首先判断该位置的hash以及key是否相等，如相等则记录下来（后续直接替换）</li>\n<li>4 判断该位置结点是否是红黑树结构，是的话就执行红黑树的插入方法</li>\n<li>5 遍历找是否有和待插入元素相等的key，找到则替换，没有的话则直接在尾部插入（JDK8以前是在头部插入），插入后如果发现其大于转换为红黑树的阈值，则将其转换为红黑树结构</li>\n</ul>\n<h5 id=\"7、resize方法\"><a href=\"#7、resize方法\" class=\"headerlink\" title=\"7、resize方法\"></a>7、resize方法</h5><p><img src=\"https://gitee.com/xiuxiuai/picture/raw/master/img/HashMap6.png\" alt=\"img\"></p>\n<p><img src=\"https://gitee.com/xiuxiuai/picture/raw/master/img/HashMap7.png\" alt=\"在这里插入图片描述\"></p>\n<h5 id=\"8-get方法\"><a href=\"#8-get方法\" class=\"headerlink\" title=\"8. get方法\"></a>8. get方法</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">public V get(Object key) &#123;\n    Node&lt;K,V&gt; e;\n    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;\n&#125;\n1234</code></pre>\n\n<p>其调用的是getNode方法，根据key的hash和key找到该值。</p>\n<p><img src=\"https://gitee.com/xiuxiuai/picture/raw/master/img/HashMap8.png\" alt=\"在这里插入图片描述\"></p>\n<h5 id=\"9-remove方法\"><a href=\"#9-remove方法\" class=\"headerlink\" title=\"9. remove方法\"></a>9. remove方法</h5><p>也是和get方法相似，根据key的hash值找到对应位置，然后分情况删除。</p>\n<h4 id=\"3、HashMap总结\"><a href=\"#3、HashMap总结\" class=\"headerlink\" title=\"3、HashMap总结\"></a>3、HashMap总结</h4><ul>\n<li>底层实现：数组+链表+红黑树，允许key为null</li>\n<li>负载因子的默认值是0.75：初始值大了，可减少哈希表的再散列(扩容的次数)，但同时会导致散列冲突的可能性变大。初始值小了，可以减小散列冲突的可能性，但同时扩容的次数可能就会变多。</li>\n<li>初始容量的默认值是16：初始容量过大，遍历时速度就会受影响，初始容量过小，散列表再散列(扩容的次数)可能就变得多</li>\n<li>HashMap在计算hash值并不是直接根据key的hashCode，而是将其和高16位进行异或，增加其随机性。</li>\n<li>并不是桶子上有8位元素的时候它就能变成红黑树，它得同时满足我们的散列表容量大于64才行.</li>\n</ul>\n<h4 id=\"4、线程安全的HashMap\"><a href=\"#4、线程安全的HashMap\" class=\"headerlink\" title=\"4、线程安全的HashMap\"></a>4、线程安全的HashMap</h4><p>由于HashMap是线程不安全的,即多个线程可以同时put、get等，这在多线程环境下会出现问题，所以java又提供了线程安全的HashMap。</p>\n<h5 id=\"1-Hashtable\"><a href=\"#1-Hashtable\" class=\"headerlink\" title=\"1. Hashtable\"></a>1. Hashtable</h5><p>与HashMap存储结构基本相同，底层实现是数组+链表，其是线程安全的，实现方式是对整个Hashtable加锁（基本在所有操纵Hashtable的方法上都加了sysynchronized进行同步，所以同一时间只允许一个线程操作），且不允许key和value为null，但是其实现效率较低，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。Hashtable默认初始容量为11，扩容方式为原始容量x2 + 1.</p>\n<h5 id=\"2-ConcurrentHashMap\"><a href=\"#2-ConcurrentHashMap\" class=\"headerlink\" title=\"2. ConcurrentHashMap\"></a>2. ConcurrentHashMap</h5><p>与Hashtable一样都是用来实现线程安全的HashMap，但是却比Hashtable效率高很多。主要是因为其采用了锁分段的机制，将数据分段存储，每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，所以可以供多个线程同时访问，而不是像Hashtable那样锁住整个表，同一时刻只能有一个线程访问。</p>\n<p>ConcurrentHashMap从JDK1.5开始随java.util.concurrent包一起引入JDK中，主要为了解决HashMap线程不安全和Hashtable效率不高的问题。</p>\n<h4 id=\"3、补充：JDK8和7实现差异\"><a href=\"#3、补充：JDK8和7实现差异\" class=\"headerlink\" title=\"3、补充：JDK8和7实现差异\"></a>3、补充：JDK8和7实现差异</h4><ul>\n<li>JDK7中使用的是分段锁机制，即将整个table分成多个Segment，对每个Segment加锁，即有一个Segment数组，每一个Segment都是一个单独的哈希表。在执行put操作时首先根据hash算法定位到元素属于哪个Segment，然后对该Segment加锁即可</li>\n<li>JDK8对其进行了优化，底层采用和Node数组+链表+红黑树（和HashMap类似），并发控制使用Synchronized和CAS来操作，其与HashMap更接近。</li>\n</ul>\n","text":"一、Collections 要点 工具类，随机排序方法shuffle，，反转元素方法reverse以及升序排序方法sort collection：单列集合的父接口 collections：他是集合操作的一种 工具类，类中的方法全部是静态的，可以进行查找，排序等操作 Collect...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/tags/JavaSE.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81Collections\"><span class=\"toc-text\">一、Collections</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81Map\"><span class=\"toc-text\">二、Map</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81map%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">1、map简介</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81map%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2、map常用方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81map%E8%8E%B7%E5%8F%96%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">3、map获取功能</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81map%E4%B8%A4%E7%A7%8D%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">4、map两种遍历操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%E3%80%81map%E7%9A%84%E5%B8%B8%E7%94%A8%E5%AD%90%E7%B1%BB\"><span class=\"toc-text\">5、map的常用子类</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\"><span class=\"toc-text\">三、HashMap源码分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">1、整体介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">2、源码解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">1. 成员变量</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">2. 存储结构</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">3. 构造函数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-put%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">4. put方法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5%E3%80%81hash%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">5、hash函数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6%E3%80%81putVal%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">6、putVal方法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7%E3%80%81resize%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">7、resize方法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-get%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">8. get方法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#9-remove%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">9. remove方法</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81HashMap%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">3、HashMap总结</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84HashMap\"><span class=\"toc-text\">4、线程安全的HashMap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-Hashtable\"><span class=\"toc-text\">1. Hashtable</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-ConcurrentHashMap\"><span class=\"toc-text\">2. ConcurrentHashMap</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E8%A1%A5%E5%85%85%EF%BC%9AJDK8%E5%92%8C7%E5%AE%9E%E7%8E%B0%E5%B7%AE%E5%BC%82\"><span class=\"toc-text\">3、补充：JDK8和7实现差异</span></a></li></ol></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"你好\thexo","uid":"28f9cbb3f87fb083ac5744977081fb5c","slug":"你好 hexo !","date":"2021-09-13T14:28:32.000Z","updated":"2021-09-14T15:55:21.732Z","comments":true,"path":"api/articles/你好 hexo !.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:13-50.jpg","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the ...","link":"","photos":[],"count_time":{"symbolsCount":440,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Mac终端","slug":"Mac终端","count":3,"path":"api/tags/Mac终端.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"feature":true},"next_post":{"title":"集合（上）","uid":"42c17c71eb42c16b2fd355c959a76eb9","slug":"11-集合（上）","date":"2021-09-13T14:46:32.000Z","updated":"2021-09-14T15:54:50.726Z","comments":true,"path":"api/articles/11-集合（上）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog11.jpg","text":"一、为什么使用集合为什么我们不采用数组存对象呢？ 因为数组长度是固定，而我们很多时候对对象的个数是 不确定的。 所以，我们产生了集合框架，它是用于存储对象的。 二、集合和数组的区别 集合长度是可变的，集合中不能存储基本数据类型值，只能存储对象(引用数据类型)。 数组的长度是固定的...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/tags/JavaSE.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}