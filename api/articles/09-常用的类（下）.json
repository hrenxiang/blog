{"title":"常用的类（下）","uid":"2d669717a3bf1c4b448259cbc4c2654a","slug":"09-常用的类（下）","date":"2021-09-13T14:43:32.000Z","updated":"2021-09-14T15:54:31.839Z","comments":true,"path":"api/articles/09-常用的类（下）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog9.jpg","content":"<h3 id=\"一、Arrays类\"><a href=\"#一、Arrays类\" class=\"headerlink\" title=\"一、Arrays类\"></a>一、Arrays类</h3><h4 id=\"1、概述\"><a href=\"#1、概述\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h4><p>Arrays类包含用于操作数组的各种方法，是操作属猪的工具类</p>\n<h4 id=\"2、常用方法\"><a href=\"#2、常用方法\" class=\"headerlink\" title=\"2、常用方法\"></a>2、常用方法</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">toString():将数组变成字符串\nint[] arr &#x3D; &#123;1, 2, 3&#125;;\nString x &#x3D; java.util.Arrays.toString(arr);\nSystem.out.pritnln(x);\n\nbinarySearch:二分查找\n\ncopyOf:从一个数组里赋值指定长度的数据\n\ncopyOfRange:从一个数组里赋值指定范围的数据\n\nequals:比较两个数组里的数据是否相等\n\nfill:使用指定的数据对数组进行填充\n\nsort:用来对数组里数据进行排序。如果是数字或者字符数组，会按照快速排序进行升序排序；如果是对象，这个对象必须要实现一个Compareable接口，并且实现compareTo方法\n\ntoString:用来将数组变成&quot;[元素1,元素2,....]&quot;格式的字符串。如果是一个对象类型的数组，会调用这个对象的toString方法，如果这个对象没有重写toString方法，默认会打印对象的类型以及hashCode.\n\ndeepToString:将多维数组转换成为字符串\n\nList&lt;String&gt; list &#x3D; Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);\n该方法是将数组转化成List集合的方法。\n注意：\n（1）该方法适用于对象型数据的数组（String、Integer...）\n（2）该方法不建议使用于基本数据类型的数组（byte,short,int,long,float,double,boolean）\n（3）该方法将数组与List列表链接起来：当更新其一个时，另一个自动更新\n（4）不支持add()、remove()、clear()等方法\n    \n【2.Arrays.asList()是个坑】\n用此方法得到的List的长度是不可改变的，\n当你向这个List添加或删除一个元素时（例如 list.add(&quot;d&quot;);）程序就会抛出异常（java.lang.UnsupportedOperationException）。 </code></pre>\n\n<h4 id=\"3、数组转集合\"><a href=\"#3、数组转集合\" class=\"headerlink\" title=\"3、数组转集合\"></a>3、数组转集合</h4><p>可以对数组中的元素通过集合中的方法进行操作，只要不影响其长度，可以使用集合中的任意方法</p>\n<h4 id=\"4、集合转数组\"><a href=\"#4、集合转数组\" class=\"headerlink\" title=\"4、集合转数组\"></a>4、集合转数组</h4><p>为了限制集合中的元素操作，他只有一个length属性可以进行操作</p>\n<h4 id=\"5、注意\"><a href=\"#5、注意\" class=\"headerlink\" title=\"5、注意\"></a>5、注意</h4><p>无论是集合转数组还是数组转集合，长度是 不可以改变的，不能对其进行增删操作</p>\n<ol start=\"4\">\n<li>增强for循环和普通for循环的区别<br>循环多次的时候，普通for可以对其循环条件进行控制，而增强for不能</li>\n<li>什么时候用map？<br>当问题中存在着映射关系时，首先考虑数组和map<br>当映射关系中有一方是有序编号时，可以考虑数组，反之，就不用考虑了</li>\n</ol>\n<h3 id=\"二、Date类\"><a href=\"#二、Date类\" class=\"headerlink\" title=\"二、Date类\"></a>二、Date类</h3><h4 id=\"1、构造方法\"><a href=\"#1、构造方法\" class=\"headerlink\" title=\"1、构造方法\"></a>1、构造方法</h4><ul>\n<li><code>public Date()</code>：创建一个当前时间的日期对象。</li>\n<li><code>public Date(long date)</code>：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。</li>\n</ul>\n<h4 id=\"2、常用方法-1\"><a href=\"#2、常用方法-1\" class=\"headerlink\" title=\"2、常用方法\"></a>2、常用方法</h4><ul>\n<li><code>public long getTime()</code> ：把日期对象转换成对应的时间毫秒值。</li>\n<li><code>public boolean after(Date when)</code>：判断是否在<code>when</code>时间之后。</li>\n<li><code>public boolean before(Date when)</code>：判断是否在<code>when</code>时间之前。</li>\n<li><code>public int compareTo(Date anotherDate)</code>：判断时间和指定时间的大小关系。</li>\n</ul>\n<h3 id=\"三、DateFormat类\"><a href=\"#三、DateFormat类\" class=\"headerlink\" title=\"三、DateFormat类\"></a>三、DateFormat类</h3><h4 id=\"1、概述-1\"><a href=\"#1、概述-1\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h4><p>是一个抽象类，通常情况下使用SimpleDateFormat类来进行日期格式化</p>\n<ul>\n<li><strong>格式化</strong>：按照指定的格式，从Date对象转换为String对象。</li>\n<li><strong>解析</strong>：按照指定的格式，从String对象转换为Date对象。</li>\n</ul>\n<h4 id=\"2、构造方法\"><a href=\"#2、构造方法\" class=\"headerlink\" title=\"2、构造方法\"></a>2、构造方法</h4><p><code>DateFormat</code>是一个抽象类，不能直接创建对象，通常我们会选择创建一个**<code>SimpleDateFormat</code>**类型的对象。</p>\n<p><code>public SimpleDateFormat(String pattern)</code>：通常会传入一个格式化字符串参数。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-mm-dd HH:MM:SS&quot;);</code></pre>\n\n<p>参数pattern是一个字符串，代表日期时间的自定义格式。</p>\n<h4 id=\"3、常见方法\"><a href=\"#3、常见方法\" class=\"headerlink\" title=\"3、常见方法\"></a>3、常见方法</h4><ul>\n<li><code>public String format(Date date)</code>：将Date对象格式化为字符串。</li>\n<li><code>public Date parse(String source)</code>：将字符串解析为Date对象。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">yyyy     四位数年\nMM       两位数的月\ndd       在月里日期\nDD       在年里的天数\nHH       小时\nmm       分钟\nss       秒</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 创建一个 SimpleDateFormat 对象\nSimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-mm-dd HH:MM:SS&quot;);\n&#x2F;&#x2F; 创建一个 Date 对象\nDate date &#x3D; new Date();\n\n&#x2F;&#x2F; 将当前时间以指定的格式转换成为字符串\nString str1 &#x3D; sdf.format(date);\nSystem.out.println(str1);  &#x2F;&#x2F; 2020-03-15 11:22:35\n\n&#x2F;&#x2F; 按照格式创建一个字符串对象\nString dateStr &#x3D; &quot;2008-08-08 12:34:45&quot;;\n\n&#x2F;&#x2F; 将字符串加载成为一个 Date 对象\nDate newDate &#x3D; sdf.parse(dateStr);</code></pre>\n\n<h3 id=\"四、Calendar类\"><a href=\"#四、Calendar类\" class=\"headerlink\" title=\"四、Calendar类\"></a>四、Calendar类</h3><h4 id=\"1、概述-2\"><a href=\"#1、概述-2\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h4><p><code>java.util.Calendar</code>是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。</p>\n<h4 id=\"2、构造方法-1\"><a href=\"#2、构造方法-1\" class=\"headerlink\" title=\"2、构造方法\"></a>2、构造方法</h4><p>Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象。</p>\n<ul>\n<li><code>public static Calendar getInstance()</code>：使用默认时区和语言环境获得一个日历。</li>\n</ul>\n<h4 id=\"3、-常见方法\"><a href=\"#3、-常见方法\" class=\"headerlink\" title=\"3、 常见方法\"></a>3、 常见方法</h4><p><code>Calendar</code>类里通常使用两个方法:</p>\n<ul>\n<li><code>public int get(int field)</code>：获取指定字段（年月日等）的值。</li>\n<li><code>public void set(int filed, int vale)</code>：给指定的字段设置值。</li>\n</ul>\n<h4 id=\"4、Calendar里的字段\"><a href=\"#4、Calendar里的字段\" class=\"headerlink\" title=\"4、Calendar里的字段\"></a>4、Calendar里的字段</h4><p>Calendar类中提供很多成员常量，代表给定的日历字段：</p>\n<table>\n<thead>\n<tr>\n<th>字段值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>YEAR</td>\n<td>年</td>\n</tr>\n<tr>\n<td>MONTH</td>\n<td>月（从0开始，可以+1使用）</td>\n</tr>\n<tr>\n<td>DAY_OF_MONTH</td>\n<td>月中的天（几号）</td>\n</tr>\n<tr>\n<td>HOUR</td>\n<td>时（12小时制）</td>\n</tr>\n<tr>\n<td>HOUR_OF_DAY</td>\n<td>时（24小时制）</td>\n</tr>\n<tr>\n<td>MINUTE</td>\n<td>分</td>\n</tr>\n<tr>\n<td>SECOND</td>\n<td>秒</td>\n</tr>\n<tr>\n<td>DAY_OF_WEEK</td>\n<td>周中的天（周几，周日为1，可以-1使用）</td>\n</tr>\n</tbody></table>\n<h3 id=\"五、其他日期类\"><a href=\"#五、其他日期类\" class=\"headerlink\" title=\"五、其他日期类\"></a>五、其他日期类</h3><h4 id=\"1、概述-3\"><a href=\"#1、概述-3\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h4><p>JDK8里还提供了<code>LocalDate</code>类，<code>LocalTime</code>类,以及<code>LocalDateTime</code>类来分别用来表示<strong>日期</strong>，<strong>时间</strong>以及<strong>日期和时间</strong>。</p>\n<p>这三个类的构造方法都是私有的，不要直接创建对象，都是通过静态方法<code>now</code>来获取到当前的日期和时间</p>\n<h4 id=\"2、DateTimeFormatter\"><a href=\"#2、DateTimeFormatter\" class=\"headerlink\" title=\"2、DateTimeFormatter\"></a>2、DateTimeFormatter</h4><ul>\n<li>用来将日期和字符串之间相互转换</li>\n<li>获取实例对象<ul>\n<li>不允许调用构造方法直接创建实例对象</li>\n<li>只能调用 ofPattern 等静态方法，返回一个实例对象</li>\n</ul>\n</li>\n<li>日期转换成为字符串，调用  format 方法</li>\n<li>把字符串加载成为日期，不是调用 DateTimeFormatter的parse方法，因为获取到结果是一个父接口，无法获取到日期时间等数据。<br>分别使用 LocalDate / LocalTime / LocalDateTime 的 parse静态方法，将字符串和formatter传入，实现加载。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class FormatDemo &#123;\n    public static void main(String[] args) throws ParseException &#123;\n        Date date &#x3D; new Date();\n\n        SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy年MM月dd日 HH点mm分ss秒&quot;);\n\n        &#x2F;&#x2F; 把 Date 类型的对象转换成为指定格式的字符串\n        String dateStr &#x3D; sdf.format(date);\n        System.out.println(dateStr);\n\n        String str &#x3D; &quot;2012-03-12 12:34:12&quot;;\n        SimpleDateFormat sdf2 &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n        Date date1 &#x3D; sdf2.parse(str);\n        System.out.println(date1.getYear());\n\n        DateTimeFormatter formatter &#x3D; DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);\n\n        &#x2F;&#x2F; 将日期变成字符串\n        LocalDate now &#x3D; LocalDate.now();\n        System.out.println(formatter.format(now));\n\n\n        String str1 &#x3D; &quot;2021-04-17&quot;;\n&#x2F;&#x2F;        LocalDate time &#x3D; (LocalDate) formatter.parse(str1);\n&#x2F;&#x2F;        System.out.println(time.getYear());\n        LocalDate d &#x3D; LocalDate.parse(str1, formatter);\n        System.out.println(d.getYear());\n\n        LocalTime time &#x3D; LocalTime.parse(&quot;12:34:56&quot;, DateTimeFormatter.ofPattern(&quot;HH:mm:ss&quot;));\n        System.out.println(time.getHour());\n\n        LocalDateTime ldt &#x3D; LocalDateTime.parse(&quot;2021年04月17日 15:09:20&quot;, DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH:mm:ss&quot;));\n        System.out.println(ldt.getYear());\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"六、String类\"><a href=\"#六、String类\" class=\"headerlink\" title=\"六、String类\"></a>六、String类</h3><h4 id=\"1、概述-4\"><a href=\"#1、概述-4\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h4><p>String（字符串）在 Java中属于对象，Java提供了String类来创建和操作字符串。</p>\n<p>String的值是不可变的，所以导致每次对String的操作都会生成String对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String str &#x3D; &quot;hello&quot;;\nstr &#x3D; &quot;hello&quot;+&quot;world&quot;;\n上述world需要开辟一个堆内存\n相加时再开辟一个内存空间存储相加的值\n最后把str指向上一个开辟的空间（这个时候“hello”的对象已经丢弃了）\n\n上述开辟了三次内存空间，如果这种操作放到循环中，会造成内存极大浪费，引入StringBuffer与StringBuild处理这种问题</code></pre>\n\n<h4 id=\"2、字符串的特点\"><a href=\"#2、字符串的特点\" class=\"headerlink\" title=\"2、字符串的特点\"></a>2、字符串的特点</h4><ul>\n<li>字符串不可变, 它们的值在创健后不能被更改</li>\n<li>虽然 String的值是不可变的,但是它们可以被共享</li>\n<li>字符串效果上相当于字符数组( char[]).但是底层原理是字节数组( byte[])</li>\n</ul>\n<h4 id=\"3、String-构造方法\"><a href=\"#3、String-构造方法\" class=\"headerlink\" title=\"3、String 构造方法\"></a>3、String 构造方法</h4><table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public String()</td>\n<td>创建一个空白字符审对象，不含有任何内容</td>\n</tr>\n<tr>\n<td>public String(char[] chs)</td>\n<td>根据字符数组的内容，来创建字符串对象</td>\n</tr>\n<tr>\n<td>public String(byte[] bys)</td>\n<td>根据字节数组的内容，来创建字符串对象</td>\n</tr>\n<tr>\n<td>String s= “abc” ;</td>\n<td>直接赋值的方式创建字符串对象，内容就是abc</td>\n</tr>\n</tbody></table>\n<h4 id=\"4、字符串比较\"><a href=\"#4、字符串比较\" class=\"headerlink\" title=\"4、字符串比较\"></a>4、字符串比较</h4><p>使用==做比较</p>\n<ul>\n<li>基本类型:  比较的是数据值是否相同</li>\n<li>引用类型:  比较的是地址值是否相同</li>\n</ul>\n<p>字符串是对象，它比较内容是否相同，需要equals()</p>\n<ul>\n<li>public boolean equals(Object a): 将此字符串与指定对象进行比较。</li>\n<li>由于我们比较的是字符串对象，所以参数直接传递一个字符串</li>\n</ul>\n<h4 id=\"5、Split方法\"><a href=\"#5、Split方法\" class=\"headerlink\" title=\"5、Split方法\"></a>5、Split方法</h4><p>public String[] split(String regex)将此字符串<strong>拆分为给定的字符数组</strong> </p>\n<p>例如，字符串”boo:and:foo”使用以下表达式得到以下结果：</p>\n<ul>\n<li><p>regex = : </p>\n<p>{ “boo”, “and”, “foo” } </p>\n</li>\n<li><p>regex = o </p>\n<p>{ “b”, “”, “:and:f” } </p>\n</li>\n</ul>\n<h3 id=\"七、StringBuilder类\"><a href=\"#七、StringBuilder类\" class=\"headerlink\" title=\"七、StringBuilder类\"></a>七、StringBuilder类</h3><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder类。这两个类的对象能被多次修改，并且不产生新的未使用对象</p>\n<p>StringBuffer 和 StringBuilder的区别在于，StringBuilder的方法不是线程安全的（不能同步访问）<br>但是 StringBulider速度较快，所以一般情况下建议使用 StirngBuilder类。<br>然而在程序要求线程安全的情况下，必须使用StirngBuffer类</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">方法描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">public StringBuffer append(String s) 将指定的字符串追加到此字符序列。</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">public StringBuffer reverse()  将此字符序列用其反转形式取代。</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">public delete(int start, int end) 移除此序列的子字符串中的字符。</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">public insert(int offset, int i) 将 <code>int</code> 参数的字符串表示形式插入此序列中。</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">replace(int start, int end, String str) 使用给定 <code>String</code> 中的字符替换此序列的子字符串中的字符。</td>\n</tr>\n</tbody></table>\n<p>下面的列表里的方法和 String 类的方法类似：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">方法描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">char charAt(int index) 返回此序列中指定索引处的 <code>char</code> 值。</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">int indexOf(String str) 返回第一次出现的指定子字符串在该字符串中的索引。</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">int indexOf(String str, int fromIndex) 从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">int lastIndexOf(String str) 返回最右边出现的指定子字符串在此字符串中的索引。</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">int length()  返回长度（字符数）。</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">void setCharAt(int index, char ch) 将给定索引处的字符设置为 <code>ch</code>。</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">void setLength(int newLength) 设置字符序列的长度。</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">String substring(int start) 返回一个新的 <code>String</code>，它包含此字符序列当前所包含的字符子序列。</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">String substring(int start, int end) 返回一个新的 <code>String</code>，它包含此序列当前所包含的字符子序列。</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">String toString() 返回此序列中数据的字符串表示形式。</td>\n</tr>\n</tbody></table>\n<p><strong>注意</strong></p>\n<p>都可以直接赋为空值 String s = null；StringBuffer s1 = null;  StringBuilder s3 = null;</p>\n<p><strong>小结</strong></p>\n<p>（1）如果要操作少量的数据用 String；</p>\n<p>（2）多线程操作字符串缓冲区下操作大量数据 StringBuffer；</p>\n<p>（3）<strong>单线程操作字符串缓冲区下操作大量数据 StringBuilder</strong></p>\n","text":"一、Arrays类1、概述Arrays类包含用于操作数组的各种方法，是操作属猪的工具类 2、常用方法toString():将数组变成字符串 int[] arr &#x3D; &#123;1, 2, 3&#125;; String x &#x3D; java.util.Arrays...","link":"","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/tags/JavaSE.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81Arrays%E7%B1%BB\"><span class=\"toc-text\">一、Arrays类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1、概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2、常用方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%95%B0%E7%BB%84%E8%BD%AC%E9%9B%86%E5%90%88\"><span class=\"toc-text\">3、数组转集合</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E9%9B%86%E5%90%88%E8%BD%AC%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">4、集合转数组</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%E3%80%81%E6%B3%A8%E6%84%8F\"><span class=\"toc-text\">5、注意</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81Date%E7%B1%BB\"><span class=\"toc-text\">二、Date类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1、构造方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1\"><span class=\"toc-text\">2、常用方法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81DateFormat%E7%B1%BB\"><span class=\"toc-text\">三、DateFormat类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%A6%82%E8%BF%B0-1\"><span class=\"toc-text\">1、概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2、构造方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">3、常见方法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81Calendar%E7%B1%BB\"><span class=\"toc-text\">四、Calendar类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%A6%82%E8%BF%B0-2\"><span class=\"toc-text\">1、概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1\"><span class=\"toc-text\">2、构造方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81-%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">3、 常见方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81Calendar%E9%87%8C%E7%9A%84%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">4、Calendar里的字段</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E5%85%B6%E4%BB%96%E6%97%A5%E6%9C%9F%E7%B1%BB\"><span class=\"toc-text\">五、其他日期类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%A6%82%E8%BF%B0-3\"><span class=\"toc-text\">1、概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81DateTimeFormatter\"><span class=\"toc-text\">2、DateTimeFormatter</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81String%E7%B1%BB\"><span class=\"toc-text\">六、String类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%A6%82%E8%BF%B0-4\"><span class=\"toc-text\">1、概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">2、字符串的特点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81String-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">3、String 构造方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">4、字符串比较</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%E3%80%81Split%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">5、Split方法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%83%E3%80%81StringBuilder%E7%B1%BB\"><span class=\"toc-text\">七、StringBuilder类</span></a></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"异常处理","uid":"5a74204f11299c4fc6660b81cabe549b","slug":"10-异常处理","date":"2021-09-13T14:45:32.000Z","updated":"2021-09-14T15:54:43.423Z","comments":true,"path":"api/articles/10-异常处理.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog10.jpg","text":"一、概述在使用计算机语言进行项目开发的过程中，即使程序员把代码写得尽善尽美，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避免的，比如：客户输入数据的格式，读取文件是否存在，网络是否始终保持通畅等等。 异常的出现就是为了记录程序在执行过程中，出现的非正常的情况，...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/tags/JavaSE.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"常用的类（中）","uid":"c660642989e58d8f24bf7e09ddf846f0","slug":"08-常用的类（中）","date":"2021-09-13T14:42:32.000Z","updated":"2021-09-14T15:54:22.816Z","comments":true,"path":"api/articles/08-常用的类（中）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog8.jpg","text":"一、Math类1、特点提供了操作数学元素的方法，都是静态的 2、常用方法int abs(int a)：返回整数的绝对值 int max(int a, int b)：返回两个整数的最大值 double random()：返回一个伪随机值(0--1 之间) double sqrt(d...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/tags/JavaSE.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}