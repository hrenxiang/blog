{"title":"Servlet（下）","uid":"5be9ff575c28645ffc905ea202238d73","slug":"36-Servlet（下）","date":"2021-09-13T15:12:32.000Z","updated":"2021-09-15T10:27:25.523Z","comments":true,"path":"api/articles/36-Servlet（下）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","content":"<h3 id=\"1-HttpServletRequest类\"><a href=\"#1-HttpServletRequest类\" class=\"headerlink\" title=\"1. HttpServletRequest类\"></a>1. HttpServletRequest类</h3><h4 id=\"1-1-作用\"><a href=\"#1-1-作用\" class=\"headerlink\" title=\"1.1 作用\"></a>1.1 作用</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">每次只要有请求进入 Tomcat 服务器，Tomcat 服务器就会把请求过来的 HTTP 协议信息**解析好封装**到 Request 对象中。 然后传递到 service 方法（doGet 和 doPost）中给我们使用。我们可以通过 HttpServletRequest 对象，获取到所有请求的 信息。</code></pre>\n\n<h4 id=\"1-2-常用方法\"><a href=\"#1-2-常用方法\" class=\"headerlink\" title=\"1.2 常用方法\"></a>1.2 常用方法</h4><table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">getRequestURI()</td>\n<td align=\"center\">获取请求的资源路径</td>\n</tr>\n<tr>\n<td align=\"center\">getRequestURL()</td>\n<td align=\"center\">获取请求的统一资源定位符（绝对路径）</td>\n</tr>\n<tr>\n<td align=\"center\">getRemoteHost()</td>\n<td align=\"center\">获取客户端的 ip 地址</td>\n</tr>\n<tr>\n<td align=\"center\">getHeader()</td>\n<td align=\"center\">获取请求头</td>\n</tr>\n<tr>\n<td align=\"center\">getParameter()</td>\n<td align=\"center\">获取请求的参数</td>\n</tr>\n<tr>\n<td align=\"center\">getParameterValues()</td>\n<td align=\"center\">获取请求的参数（多个值的时候使用）</td>\n</tr>\n<tr>\n<td align=\"center\">getMethod()</td>\n<td align=\"center\">获取请求的方式 GET 或 POST</td>\n</tr>\n<tr>\n<td align=\"center\">setAttribute(key, value);</td>\n<td align=\"center\">设置域数据</td>\n</tr>\n<tr>\n<td align=\"center\">getAttribute(key);</td>\n<td align=\"center\">获取域数据</td>\n</tr>\n<tr>\n<td align=\"center\">getRequestDispatcher()</td>\n<td align=\"center\">获取请求转发对象</td>\n</tr>\n<tr>\n<td align=\"center\">setCharacterEncoding()</td>\n<td align=\"center\">设置请求参数字符集编吗（<em><strong>此方法只对服务器编码进行设置</strong></em>）</td>\n</tr>\n</tbody></table>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n\n    &#x2F;*1.getRequestURI() 获取请求的资源路径*&#x2F;\n    System.out.println(&quot;URI &#x3D;&gt; &quot;+request.getRequestURI());\n    System.out.println(&quot;----URI &#x3D;&gt; &#x2F;Servlet&#x2F;HSR2----&quot;);\n\n    &#x2F;*2.getRequestURL() 获取请求的统一资源定位符（绝对路径）*&#x2F;\n    System.out.println(&quot;URL &#x3D;&gt; &quot;+request.getRequestURL());\n    System.out.println(&quot;---URL &#x3D;&gt; http:&#x2F;&#x2F;localhost:8080&#x2F;Servlet&#x2F;HSR2---&quot;);\n\n    &#x2F;*3. getRemoteHost() 获取客户端的 ip 地址*&#x2F;\n    System.out.println(&quot;访问ip &#x3D;&gt; &quot;+request.getRemoteHost());\n    &#x2F;*用localhost访问：得到0:0:0:0:0:0:0:1（ipv6地址，相当于ipv4的127.0.0.1）*&#x2F;\n    &#x2F;*用127.0.0.访问，得到127.0.0.1*&#x2F;\n    &#x2F;*用本机ip192.168.1.6范文，得到的是192.168.1.6*&#x2F;\n    System.out.println(&quot;---------------&quot;);\n\n    &#x2F;*4.getHeader() 获取请求头*&#x2F;\n    System.out.println(&quot;请求头 &#x3D;&gt; &quot;+request.getHeader(&quot;User-Agent&quot;));\n    System.out.println(&quot;----请求头 &#x3D;&gt; Mozilla&#x2F;5.0 (...) AppleWebKit&#x2F;537.36 (...) &quot; +\n                        &quot;Chrome&#x2F;83.0.4103.97 Safari&#x2F;537.36---&quot;);\n\n    &#x2F;*5.getMethod() 获取请求的方式 GET 或 POST*&#x2F;\n    System.out.println(&quot;Method &#x3D;&gt; &quot;+request.getMethod());\n    System.out.println(&quot;----Method &#x3D;&gt; GET----&quot;);\n&#125;</code></pre>\n\n<h4 id=\"1-3-获取请求参数\"><a href=\"#1-3-获取请求参数\" class=\"headerlink\" title=\"1.3 获取请求参数\"></a>1.3 获取请求参数</h4><p><span style=\"color:red;\">返回多个参数时，一定要做转换，Arrays.toString()或者Arrays.asList()</span></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*1. getParameter() 获取请求的参数*&#x2F;\n   System.out.println(&quot;单个参数(username) &#x3D;》 &quot; + request.getParameter(&quot;username&quot;));\n   System.out.println(&quot;单个参数(password) &#x3D;》 &quot; + request.getParameter(&quot;password&quot;));\n\n   &#x2F;*2.getParameterValues() 获取请求的参数（多个值的时候使用）*&#x2F;\n   System.out.println(&quot;多个参数 &#x3D;》 &quot; + Arrays.toString(request.getParameterValues(&quot;hobby&quot;)));\n   String[] hobbies &#x3D; request.getParameterValues(&quot;hobby&quot;);\n   System.out.println(Arrays.toString(hobbies));</code></pre>\n\n<p><strong>doGet请求乱码问题</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 获取请求参数\nString username &#x3D; req.getParameter(&quot;username&quot;);\n&#x2F;&#x2F;1 先以 iso8859-1 进行编码\n&#x2F;&#x2F;2 再以 utf-8 进行解码\nusername &#x3D; new String(username.getBytes(&quot;iso-8859-1&quot;), &quot;UTF-8&quot;);</code></pre>\n\n<h4 id=\"1-4-解决-Post请求乱码-问题\"><a href=\"#1-4-解决-Post请求乱码-问题\" class=\"headerlink\" title=\"1.4 解决 Post请求乱码 问题\"></a>1.4 解决 <strong>Post请求乱码</strong> 问题</h4><p><span style=\"color:red;\">设置请求参数字符集编码为 <strong>utf8</strong></span></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*1.设置请求参数字符集编码为utf8*&#x2F;\n&#x2F;*2.要写在获取请求参数之前，尽量写在一开始 *&#x2F;\nrequest.setCharacterEncoding(&quot;UTF-8&quot;);</code></pre>\n\n<h4 id=\"1-5-请求转发\"><a href=\"#1-5-请求转发\" class=\"headerlink\" title=\"1.5 请求转发\"></a><strong><span style=\"color:#e36387;\">1.5 请求转发</span></strong></h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">* 什么是请求的转发? \n\n  请求转发是指，服务器收到请求后，从一次资源跳转到另一个资源的操作叫请求转发。\n\n* 请求转发特点\n\n  1. 浏览器  **地址栏的地址没有变化** （a找b做手术，打麻药晕了，b突然发现不会治转给了c，c治疗好a后，a醒的时候还是以为a治疗的）\n  2. 他们是  **一次请求**\n  3. 他们可以共享Request域中的数据\n  4. 可以转发到WEB-INF目录下\n  5. 不可以访问工程以外的资源</code></pre>\n\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91.png\" alt=\"img\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Servlet1 代码\n    public class Servlet1 extends HttpServlet &#123;\n    @Override\n        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException,\n            IOException &#123;\n            &#x2F;&#x2F; 获取请求的参数（办事的材料）查看\n            String username &#x3D; req.getParameter(&quot;username&quot;);\n            System.out.println(&quot;在 Servlet1（柜台 1）中查看参数（材料）：&quot; + username);\n            &#x2F;&#x2F; 给材料 盖一个章，并传递到 Servlet2（柜台 2）去查看\n            req.setAttribute(&quot;key1&quot;,&quot;柜台 1 的章&quot;);\n            &#x2F;&#x2F; 问路：Servlet2（柜台 2）怎么走\n            &#x2F;&#x2F; 请求转发必须要以斜杠打头，&#x2F; 斜杠表示地址为：http:&#x2F;&#x2F;ip:port&#x2F;工程名&#x2F; , 映射到 IDEA 代码的 web 目录\n            RequestDispatcher requestDispatcher &#x3D; req.getRequestDispatcher(&quot;&#x2F;servlet2&quot;);\n            &#x2F;&#x2F; RequestDispatcher requestDispatcher &#x3D; req.getRequestDispatcher(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;);\n            &#x2F;&#x2F; 走向 Sevlet2（柜台 2）\n            requestDispatcher.forward(req,resp);\n            &#125;\n        &#125;\n        \nServlet2 代码\n    public class Servlet2 extends HttpServlet &#123;\n    @Override\n        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException,\n            IOException &#123;\n            &#x2F;&#x2F; 获取请求的参数（办事的材料）查看\n            String username &#x3D; req.getParameter(&quot;username&quot;);\n            System.out.println(&quot;在 Servlet2（柜台 2）中查看参数（材料）：&quot; + username);\n            &#x2F;&#x2F; 查看 柜台 1 是否有盖章\n            Object key1 &#x3D; req.getAttribute(&quot;key1&quot;);\n            System.out.println(&quot;柜台 1 是否有章：&quot; + key1);\n            &#x2F;&#x2F; 处理自己的业务\n            System.out.println(&quot;Servlet2 处理自己的业务 &quot;);\n            &#125;\n\t\t&#125;</code></pre>\n\n<h4 id=\"1-6-base-标签的作用\"><a href=\"#1-6-base-标签的作用\" class=\"headerlink\" title=\"1.6 base 标签的作用\"></a>1.6 base 标签的作用</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;!-- base标签设置页面相对路径工作时参照的地址\n   herf属性就是参数的地址值\n   --&gt;\n&lt;base href&#x3D;&quot;http:&#x2F;&#x2F;localhost:8088&#x2F;hhh&#x2F;a&#x2F;b&#x2F;c.html&quot;&gt;</code></pre>\n\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/base%E7%9A%84%E4%BD%9C%E7%94%A8.jpg\" alt=\"request_02_base\"></p>\n<h3 id=\"2-绝对与相对路径\"><a href=\"#2-绝对与相对路径\" class=\"headerlink\" title=\"2. 绝对与相对路径\"></a>2. 绝对与相对路径</h3><h4 id=\"2-1-相对路径-不建议使用\"><a href=\"#2-1-相对路径-不建议使用\" class=\"headerlink\" title=\"2.1 相对路径(不建议使用)\"></a>2.1 相对路径(不建议使用)</h4><h5 id=\"2-1-1-目标\"><a href=\"#2-1-1-目标\" class=\"headerlink\" title=\"2.1.1 目标\"></a>2.1.1 目标</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">目标: 在A资源中访问B资源\n\nA资源的uri路径: &#96;&#x2F;app&#x2F;pages&#x2F;a.html&#96;\n\nB资源的uri路径:&#96;&#x2F;app&#x2F;static&#x2F;vue.js&#96;</code></pre>\n\n<h5 id=\"2-2-相对路径的概念\"><a href=\"#2-2-相对路径的概念\" class=\"headerlink\" title=\"2.2 相对路径的概念\"></a>2.2 相对路径的概念</h5><p>相对路径是不以<code>/</code>开头的路径写法，编写相对路径的原则是以目标资源的uri路径相对当前资源的uri路径</p>\n<h5 id=\"2-3-相对路径实例\"><a href=\"#2-3-相对路径实例\" class=\"headerlink\" title=\"2.3 相对路径实例\"></a>2.3 相对路径实例</h5><p>那么要实现在A资源中访问B资源的相对路径写法是<code>../static/vue.js</code>,其中<code>../static</code>表示找到当前资源的上一级目录下的static目录</p>\n<h4 id=\"2-2-绝对路径-建议使用\"><a href=\"#2-2-绝对路径-建议使用\" class=\"headerlink\" title=\"2.2 绝对路径(建议使用)\"></a>2.2 绝对路径(建议使用)</h4><h5 id=\"2-2-1-目标\"><a href=\"#2-2-1-目标\" class=\"headerlink\" title=\"2.2.1 目标\"></a>2.2.1 目标</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">目标: 在A资源中访问B资源\n\nA资源的uri路径: &#96;&#x2F;app&#x2F;pages&#x2F;a.html&#96;\n\nB资源的uri路径:&#96;&#x2F;app&#x2F;static&#x2F;vue.js&#96;</code></pre>\n\n<h5 id=\"2-2-2-绝对路径的概念\"><a href=\"#2-2-2-绝对路径的概念\" class=\"headerlink\" title=\"2.2.2 绝对路径的概念\"></a>2.2.2 绝对路径的概念</h5><p>绝对路径是以<code>/</code>开头的路径写法，编写绝对路径的原则是通过目标资源的uri访问目标资源，但是特殊情况是<strong>请求转发</strong>，如果是请求转发访问目标资源的话，那么绝对路径是在uri的基础之上省略<code>/项目部署名</code></p>\n<h5 id=\"2-2-3-绝对路径实例\"><a href=\"#2-2-3-绝对路径实例\" class=\"headerlink\" title=\"2.2.3 绝对路径实例\"></a>2.2.3 绝对路径实例</h5><p>那么要实现在A资源中访问B资源的绝对路径写法是<code>/app/static/vue.js</code></p>\n<h5 id=\"2-2-4-在请求转发的时候使用绝对路径\"><a href=\"#2-2-4-在请求转发的时候使用绝对路径\" class=\"headerlink\" title=\"2.2.4 在请求转发的时候使用绝对路径\"></a>2.2.4 在请求转发的时候使用绝对路径</h5><p>请求转发在后续内容中会讲解，现在我们只需要搞懂在请求转发的时候绝对路径的写法是<code>/资源名</code>，其实就是在uri的基础上省略<code>/项目部署名</code></p>\n<h4 id=\"2-3-动态获取上下文路径\"><a href=\"#2-3-动态获取上下文路径\" class=\"headerlink\" title=\"2.3 动态获取上下文路径\"></a>2.3 动态获取上下文路径</h4><h5 id=\"2-3-1-上下文路径的概念\"><a href=\"#2-3-1-上下文路径的概念\" class=\"headerlink\" title=\"2.3.1 上下文路径的概念\"></a>2.3.1 上下文路径的概念</h5><p>上下文路径（context path）=/Web应用名称</p>\n<h5 id=\"2-3-2-为什么要动态获取上下文路径\"><a href=\"#2-3-2-为什么要动态获取上下文路径\" class=\"headerlink\" title=\"2.3.2 为什么要动态获取上下文路径\"></a>2.3.2 为什么要动态获取上下文路径</h5><p>因为我们使用绝对路径的时候需要用到资源的uri路径，而uri路径中是包含上下文路径的，所以如果采用静态方式写绝对路径，那么就会将上下文路径写死在绝对路径中；而我们在部署项目的时候，上下文路径是可变的，所以这样就会因为部署时设置的上下文路径不同从而导致绝对路径出错的问题</p>\n<h5 id=\"2-3-3-动态获取上下文路径的API\"><a href=\"#2-3-3-动态获取上下文路径的API\" class=\"headerlink\" title=\"2.3.3 动态获取上下文路径的API\"></a>2.3.3 动态获取上下文路径的API</h5><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">request.getContextPath()</code></pre>\n\n<p>使用上述API可以动态获取项目的上下文路径，每一次获取的都是当前环境下实际的上下文路径的值</p>\n<h4 id=\"2-4-（斜杠）-不同的意义\"><a href=\"#2-4-（斜杠）-不同的意义\" class=\"headerlink\" title=\"2.4  /（斜杠） 不同的意义\"></a>2.4  /（斜杠） 不同的意义</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">1. 在 web 中 &#x2F; 斜杠 是一种绝对路径。\n\n2. &#x2F; 斜杠 如果被浏览器解析，得到的地址是：http:&#x2F;&#x2F;ip:port&#x2F; [斜杠]() \n\n3. &#x2F; 斜杠 如果被&lt;kbd&gt;服务器解析&lt;&#x2F;kbd&gt;，得到的地址是：http:&#x2F;&#x2F;ip:port&#x2F;工程路径 \n   * &#x2F;servlet\n   * servletContext.getRealPath(“&#x2F;”); \n   * request.getRequestDispatcher(“&#x2F;”);\n   \n4. &lt;kbd&gt;特殊情况&lt;&#x2F;kbd&gt;： response.sendRediect(“&#x2F;”); 把斜杠发送给浏览器解析。得到 http:&#x2F;&#x2F;ip:port&#x2F;</code></pre>\n\n<h3 id=\"3-HttpServletResponse类\"><a href=\"#3-HttpServletResponse类\" class=\"headerlink\" title=\"3. HttpServletResponse类\"></a>3. HttpServletResponse类</h3><h4 id=\"3-1-概念\"><a href=\"#3-1-概念\" class=\"headerlink\" title=\"3.1 概念\"></a>3.1 概念</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">HttpServletResponse 类和 HttpServletRequest 类一样。每次请求进来，Tomcat 服务器都会创建一个 Response 对象传 递给 Servlet 程序去使用。HttpServletRequest 表示请求过来的信息，HttpServletResponse 表示所有响应的信息， 我们如果需要设置返回给客户端的信息，都可以通过 HttpServletResponse 对象来进行设置</code></pre>\n\n<h4 id=\"3-2-两个输出流的说明\"><a href=\"#3-2-两个输出流的说明\" class=\"headerlink\" title=\"3.2 两个输出流的说明\"></a>3.2 两个输出流的说明</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">* 字节流：getOutputStream();\t常用于下载（传递二进制数据）\n\n* 字符流：getWriter();\t常用语回传字符串（常用）\n\n* 注意：&#x2F;*两个流同时只能使用一个，选择其一，第二个就不能再用*&#x2F;\n\n* 如何回传数据， &#x2F;*字符流的write方法*&#x2F;</code></pre>\n\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/response%E4%B8%A4%E4%B8%AA%E6%B5%81%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E9%94%99%E8%AF%AF.png\" alt=\"image-20200629090129671\"></p>\n<h4 id=\"3-3-响应的中文乱码解决\"><a href=\"#3-3-响应的中文乱码解决\" class=\"headerlink\" title=\"3.3 响应的中文乱码解决\"></a>3.3 响应的中文乱码解决</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">0.无论使用下列两种方法的哪一个，都必须在获取流对象前进行设置，否则无效\n    \n1.先修改服务器端的编码：setCharacterEncoding（）;(&#x2F;&#x2F;此方法只对服务器编码进行设置)\n  再设置浏览器端的编码：setHeader(&quot;Content-Type&quot;,&quot;text&#x2F;html;Charset&#x3D;utf-8&quot;)\n    \n2.直接调用方法：setContentType(&quot;text&#x2F;html;Charset&#x3D;utf-8&quot;);(&#x2F;&#x2F;此方法对服务器和浏览器编码同时设置)\n  注意：括号内的参数必须完整，两个参数之间必须是分号（;）\n        \n  &#x2F;&#x2F; 设置服务器字符集为 UTF-8\n  resp.setCharacterEncoding(&quot;UTF-8&quot;);\n  &#x2F;&#x2F; 通过响应头，设置浏览器也使用 UTF-8 字符集\n  resp.setHeader(&quot;Content-Type&quot;, &quot;text&#x2F;html; charset&#x3D;UTF-8&quot;);   \n\n  &#x2F;&#x2F; 它会同时设置服务器和客户端都使用 UTF-8 字符集，还设置了响应头\n  &#x2F;&#x2F; 此方法一定要在获取流对象之前调用才有效\n  resp.setContentType(&quot;text&#x2F;html&quot;); </code></pre>\n\n<h4 id=\"3-4-请求重定向\"><a href=\"#3-4-请求重定向\" class=\"headerlink\" title=\"3.4 请求重定向\"></a>3.4 请求重定向</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">* 重定向的特点\n  1. 能访问工程以外的路径（例如百度）\n  2. 无法访问WEB-INF目录下的内容（例如web.xml）\n  3. 浏览器地址栏的地址发生改变\n  4. 进行了两次请求（请求转发是一次）\n  5. 不共享request域中的数据\n  \n* 设置重定向的两种方法\n  1. 设置响应状态码 302 ，表示重定向，（已搬迁）\n     resp.setStatus(302);\n     设置响应头，说明 新的地址在哪里\n     resp.setHeader(&quot;Location&quot;, &quot;http(新地址)&quot;);\n  2. resp.sendRedirect(&quot;新地址&quot;);</code></pre>\n\n<h3 id=\"4-javaEE三层架构\"><a href=\"#4-javaEE三层架构\" class=\"headerlink\" title=\"4. javaEE三层架构\"></a>4. javaEE<strong>三层架构</strong></h3><p><span style=\"color:red;\">分层的目的是为了解耦。解耦就是为了降低代码的耦合度。方便项目后期的维护和升级。</span></p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/javaEE%E4%B8%89%E6%88%90%E6%9E%B6%E6%9E%84.png\" alt=\"javaEE三成架构\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">* web层\t\t\t  web&#x2F;servlet&#x2F;controller \n\n* service层 \t\t  service Service              接口包 \n\n  \t\t\t\t   service.impl Service         接口实现类 \n\n* dao 持久层        dao Dao                      接口包 \n\n                   dao.impl Dao \t\t\t\t接口实现类 实体 bean 对象 \n\n* pojo&#x2F;entity&#x2F;domain&#x2F;bean  JavaBean 类 \n\n* 测试包             test&#x2F;junit \n\n* 工具类             utils</code></pre>\n\n<h3 id=\"5-url-uri介绍-request获取路径\"><a href=\"#5-url-uri介绍-request获取路径\" class=\"headerlink\" title=\"5. url uri介绍 request获取路径\"></a>5. url uri介绍 request获取路径</h3><h4 id=\"5-1-url的介绍\"><a href=\"#5-1-url的介绍\" class=\"headerlink\" title=\"5.1 url的介绍\"></a>5.1 url的介绍</h4><h5 id=\"5-1-1-url的概念\"><a href=\"#5-1-1-url的概念\" class=\"headerlink\" title=\"5.1.1 url的概念\"></a>5.1.1 url的概念</h5><p>url是<code>uniform Resource Locater</code>的简写，中文翻译为<code>统一资源定位符</code>，它是某个互联网资源的唯一访问地址，客户端可以通过url访问到具体的互联网资源</p>\n<h5 id=\"5-1-2-url的组成\"><a href=\"#5-1-2-url的组成\" class=\"headerlink\" title=\"5.1.2 url的组成\"></a>5.1.2 url的组成</h5><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/url%E7%9A%84%E7%BB%84%E6%88%90.png\" alt=\"images\"></p>\n<h5 id=\"5-1-3-url的使用场景\"><a href=\"#5-1-3-url的使用场景\" class=\"headerlink\" title=\"5.1.3 url的使用场景\"></a>5.1.3 url的使用场景</h5><p>客户端访问服务器的资源，或者一台服务器中要访问另外一台服务器的资源都是通过url访问</p>\n<h4 id=\"5-2-uri的介绍\"><a href=\"#5-2-uri的介绍\" class=\"headerlink\" title=\"5.2 uri的介绍\"></a>5.2 uri的介绍</h4><h5 id=\"5-2-1-uri的概念\"><a href=\"#5-2-1-uri的概念\" class=\"headerlink\" title=\"5.2.1 uri的概念\"></a>5.2.1 uri的概念</h5><p>uri是<code>Uniform Resource identifier</code>的缩写，中文翻译为<code>统一资源标识符</code>, 它是服务器中某个资源的唯一标识，通过uri可以实现同一项目中的某个资源中访问另一个资源</p>\n<h5 id=\"5-2-2-uri的组成\"><a href=\"#5-2-2-uri的组成\" class=\"headerlink\" title=\"5.2.2 uri的组成\"></a>5.2.2 uri的组成</h5><p>uri的写法是<code>/项目部署名/资源路径</code></p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/urid%E7%9A%84%E7%BB%84%E6%88%90.png\"></p>\n<h5 id=\"5-2-3-uri的使用场景\"><a href=\"#5-2-3-uri的使用场景\" class=\"headerlink\" title=\"5.2.3 uri的使用场景\"></a>5.2.3 uri的使用场景</h5><p>在同一个项目的某个资源中访问该项目中的另一个资源</p>\n<h4 id=\"5-3-request获取路径介绍\"><a href=\"#5-3-request获取路径介绍\" class=\"headerlink\" title=\"5.3 request获取路径介绍\"></a>5.3 request获取路径介绍</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;%&#x3D; request.getRequestURL()%&gt;  &lt;%-- http:&#x2F;&#x2F;192.168.124.7:8080&#x2F;bookstore&#x2F;index.jsp --%&gt;\n&lt;%&#x3D; request.getRequestURI()%&gt;  &lt;%--&#x2F;bookstore&#x2F;index.jsp--%&gt;\n&lt;%&#x3D; request.getScheme()%&gt;      &lt;%--http--%&gt;\n&lt;%&#x3D; request.getServerName()%&gt;  &lt;%-- 192.168.124.7 --%&gt;\n&lt;%&#x3D; request.getServerPort()%&gt;  &lt;%-- 8080 --%&gt;\n&lt;%&#x3D; request.getContextPath()%&gt; &lt;%-- &#x2F;bookstore --%&gt;\n&lt;%&#x3D; request.getServletPath()%&gt; &lt;%-- &#x2F;index.jsp --%&gt;</code></pre>\n\n","text":"1. HttpServletRequest类1.1 作用每次只要有请求进入 Tomcat 服务器，Tomcat 服务器就会把请求过来的 HTTP 协议信息**解析好封装**到 Request 对象中。 然后传递到 service 方法（doGet 和 doPost）中给我们使用。...","link":"","photos":[],"count_time":{"symbolsCount":"9.5k","symbolsTime":"9 mins."},"categories":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/categories/JavaWeb.json"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/tags/JavaWeb.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-HttpServletRequest%E7%B1%BB\"><span class=\"toc-text\">1. HttpServletRequest类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">1.1 作用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1.2 常用方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">1.3 获取请求参数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-4-%E8%A7%A3%E5%86%B3-Post%E8%AF%B7%E6%B1%82%E4%B9%B1%E7%A0%81-%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">1.4 解决 Post请求乱码 问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-5-%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91\"><span class=\"toc-text\">1.5 请求转发</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-6-base-%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">1.6 base 标签的作用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E7%BB%9D%E5%AF%B9%E4%B8%8E%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">2. 绝对与相对路径</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84-%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">2.1 相对路径(不建议使用)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-1-1-%E7%9B%AE%E6%A0%87\"><span class=\"toc-text\">2.1.1 目标</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">2.2 相对路径的概念</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-3-%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">2.3 相对路径实例</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84-%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">2.2 绝对路径(建议使用)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-1-%E7%9B%AE%E6%A0%87\"><span class=\"toc-text\">2.2.1 目标</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-2-%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">2.2.2 绝对路径的概念</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-3-%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">2.2.3 绝对路径实例</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-4-%E5%9C%A8%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E7%9A%84%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">2.2.4 在请求转发的时候使用绝对路径</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%E4%B8%8A%E4%B8%8B%E6%96%87%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">2.3 动态获取上下文路径</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-3-1-%E4%B8%8A%E4%B8%8B%E6%96%87%E8%B7%AF%E5%BE%84%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">2.3.1 上下文路径的概念</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-3-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%E4%B8%8A%E4%B8%8B%E6%96%87%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">2.3.2 为什么要动态获取上下文路径</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-3-3-%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%E4%B8%8A%E4%B8%8B%E6%96%87%E8%B7%AF%E5%BE%84%E7%9A%84API\"><span class=\"toc-text\">2.3.3 动态获取上下文路径的API</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-4-%EF%BC%88%E6%96%9C%E6%9D%A0%EF%BC%89-%E4%B8%8D%E5%90%8C%E7%9A%84%E6%84%8F%E4%B9%89\"><span class=\"toc-text\">2.4  &#x2F;（斜杠） 不同的意义</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-HttpServletResponse%E7%B1%BB\"><span class=\"toc-text\">3. HttpServletResponse类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">3.1 概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-%E4%B8%A4%E4%B8%AA%E8%BE%93%E5%87%BA%E6%B5%81%E7%9A%84%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">3.2 两个输出流的说明</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-3-%E5%93%8D%E5%BA%94%E7%9A%84%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3\"><span class=\"toc-text\">3.3 响应的中文乱码解决</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-4-%E8%AF%B7%E6%B1%82%E9%87%8D%E5%AE%9A%E5%90%91\"><span class=\"toc-text\">3.4 请求重定向</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-javaEE%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">4. javaEE三层架构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-url-uri%E4%BB%8B%E7%BB%8D-request%E8%8E%B7%E5%8F%96%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">5. url uri介绍 request获取路径</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-url%E7%9A%84%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">5.1 url的介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-1-1-url%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">5.1.1 url的概念</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-1-2-url%E7%9A%84%E7%BB%84%E6%88%90\"><span class=\"toc-text\">5.1.2 url的组成</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-1-3-url%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">5.1.3 url的使用场景</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-2-uri%E7%9A%84%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">5.2 uri的介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-2-1-uri%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">5.2.1 uri的概念</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-2-2-uri%E7%9A%84%E7%BB%84%E6%88%90\"><span class=\"toc-text\">5.2.2 uri的组成</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-2-3-uri%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">5.2.3 uri的使用场景</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-3-request%E8%8E%B7%E5%8F%96%E8%B7%AF%E5%BE%84%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">5.3 request获取路径介绍</span></a></li></ol></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"listener，filter，cookie，session","uid":"5e2a4e0d14846d085ea5bb260a2f8b57","slug":"37-listener filter cookie session","date":"2021-09-13T15:13:32.000Z","updated":"2021-09-15T10:28:17.089Z","comments":true,"path":"api/articles/37-listener filter cookie session.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"1. Listener监听器1.1 Listener是什么？* Listener 监听器是 JavaWeb 的三大组件之一。 * JavaWeb 的三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监 听器。 * Listener 它是 JavaEE ...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/categories/JavaWeb.json"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/tags/JavaWeb.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"Servlet（上）","uid":"e273b80f255b91b744fcbcd9e45a6bf0","slug":"35-Servlet（上）","date":"2021-09-13T15:11:32.000Z","updated":"2021-09-15T10:27:04.368Z","comments":true,"path":"api/articles/35-Servlet（上）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"1. JavaEE概述1.1 什么是API？ 包括什么？* API：应用程序编程接口（这里所描述的接口不是interface） * API包括：源码，字节码，帮助文档（使用的时候要注意版本一致） 1.2 什么是JavaSE？* Java 标准版本 * SUN公司为程序员提供的一套...","link":"","photos":[],"count_time":{"symbolsCount":"8.3k","symbolsTime":"8 mins."},"categories":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/categories/JavaWeb.json"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/tags/JavaWeb.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}