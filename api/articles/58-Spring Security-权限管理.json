{"title":"SpringSecurity 权限管理","uid":"57895ac4a5b71846b764434fcb138119","slug":"58-Spring Security-权限管理","date":"2021-09-13T15:35:32.000Z","updated":"2021-09-15T10:47:49.376Z","comments":true,"path":"api/articles/58-Spring Security-权限管理.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog6.jpg","content":"<h4 id=\"open-umbrella-权限控制\"><a href=\"#open-umbrella-权限控制\" class=\"headerlink\" title=\":open_umbrella: 权限控制\"></a>:open_umbrella: 权限控制</h4><hr>\n<h4 id=\"1、认证和授权的概念\"><a href=\"#1、认证和授权的概念\" class=\"headerlink\" title=\"1、认证和授权的概念\"></a>1、认证和授权的概念</h4><p>前面我们已经完成了旅游后台管理系统的部分功能，例如自由行管理、跟团游管理、套餐管理、预约设置等。接下来我们需要思考2个问题：</p>\n<p>问题1：在生产环境下我们如果不登录后台系统就可以完成这些功能操作吗？</p>\n<p>答案显然是否定的，要操作这些功能必须首先登录到系统才可以。（用户登录系统–&gt;认证）</p>\n<p>问题2：是不是所有用户，只要登录成功就都可以操作所有功能呢？</p>\n<p>答案是否定的，并不是所有的用户都可以操作这些功能。不同的用户可能拥有不同的权限，这就需要进行授权了。（用户登录之后，对每个用户进行授权，通过授权去访问系统中不同的功能–&gt;授权）</p>\n<p><font color=\"#ee3f4d\">认证</font>：系统提供的用于识别用户身份的功能，通常提供用户名和密码进行登录其实就是在进行认证，认证的目的是让系统知道你是谁。</p>\n<p><font color=\"#ee3f4d\">授权</font>：用户认证成功后，需要为用户授权，其实就是指定当前用户可以操作哪些功能。</p>\n<h4 id=\"2、权限模块的数据模型\"><a href=\"#2、权限模块的数据模型\" class=\"headerlink\" title=\"2、权限模块的数据模型\"></a>2、权限模块的数据模型</h4><p>前面已经分析了认证和授权的概念，要实现最终的权限控制，需要有一套表结构支撑：</p>\n<p>用户表 t_user       权限表 t_permission       角色表 t_role        用户角色关系表 t_user_role       角色权限关系表 t_role_permission</p>\n<p><font color=\"#ee3f4d\">RBAC（Role-Based Access Control，基于角色的访问控制）</font>，就是用户通过角色与权限进行关联。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般者是多对多的关系。（如下图）</p>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/spring-security-rbac1.png\" alt=\"image-20210802185950547\" style=\"zoom:67%;\" />\n</div>\n\n\n<p><strong>角色是什么</strong>？</p>\n<p>可以理解为一定数量的权限的集合，权限的载体。</p>\n<p>例如：一个论坛系统，“超级管理员”、“版主”都是角色。版主可管理版内的帖子、可管理版内的用户等，这些是权限。要给某个用户授予这些权限，不需要直接将权限授予用户，可将“版主”这个角色赋予该用户。</p>\n<p><strong>权限表现成什么</strong>？</p>\n<p>在应用系统中，对功能模块的操作，对上传文件的删改，菜单的访问，甚至页面上某个按钮、某个图片的可见性控制，都可属于权限的范畴。</p>\n<p><strong>具体过程</strong>？</p>\n<p>认证过程：只需要用户表就可以了，在用户登录时可以查询用户表t_user进行校验，判断用户输入的用户名和密码是否正确。</p>\n<p>授权过程：用户必须完成认证之后才可以进行授权，首先可以根据用户查询其角色t_role，再根据角色查询对应的权限t_permission以及资源(如：t_menu)。</p>\n<h4 id=\"3、权限模块数据模型的扩展\"><a href=\"#3、权限模块数据模型的扩展\" class=\"headerlink\" title=\"3、权限模块数据模型的扩展\"></a>3、权限模块数据模型的扩展</h4><div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/spring-security-rbac2.png\" alt=\"image-20210802190857670\" style=\"zoom: 80%;\" />\n</div>\n\n\n<p>权限表现成什么？</p>\n<p>​        在应用系统中，对功能模块的操作，对上传文件的删改，菜单的访问，甚至页面上某个按钮、某个图片的可见性控制，都可属于权限的范畴。有些权限设计，会把功能操作作为一类，而把文件、菜单、页面元素等作为另一类，这样构成“用户-角色-权限-资源”的授权模型。而在做数据表建模时，可把功能操作和资源统一管理，也就是都直接与权限表进行关联，这样可能更具便捷性和易扩展性。如“T_MENU”表示菜单的访问权限、“T_ELEMENT”表示页面元素的可见性、“T_FILE”表示文件的修改权限、“T_OPERATION”表示功能模块的操作权限控制等。</p>\n<p>以上模型作为基准模型，在实际的生产环境中可能会有变化，需要灵活掌握。如：</p>\n<p>​        建立角色组，对角色进行分类管理，但角色组不参与权限分配。</p>\n<p>​        建立用户组，对用户进行层级，分类管理。便于新增用户进行授权。</p>\n<p>​        建立用户和权限的多对多关联，实现ACL模型权限控制。</p>\n<p>​        本项目中将角色和菜单直接进行关联，便于查询该用户角色下的菜单权限集合。</p>\n<h4 id=\"4、表之间关系\"><a href=\"#4、表之间关系\" class=\"headerlink\" title=\"4、表之间关系\"></a>4、表之间关系</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">用户和角色是多对多关系     权限和角色是多对多关系      菜单和权限是多对多关系</code></pre>\n\n\n\n<h4 id=\"open-umbrella-Spring-Security\"><a href=\"#open-umbrella-Spring-Security\" class=\"headerlink\" title=\":open_umbrella: Spring Security\"></a>:open_umbrella: Spring Security</h4><hr>\n<h4 id=\"1、Spring-Security简介\"><a href=\"#1、Spring-Security简介\" class=\"headerlink\" title=\"1、Spring Security简介\"></a>1、Spring Security简介</h4><p>Spring Security是 Spring提供的安全认证服务的框架。 使用Spring Security可以帮助我们来简化认证和授权的过程。</p>\n<p>SpringSecurity内部封装了Filter（只需要在web.xml容器中配置一个过滤器–代理过滤器，真实的过滤器在spring的容器中配置）</p>\n<p>官网：<a href=\"https://spring.io/projects/spring-security/\">https://spring.io/projects/spring-security/</a>  </p>\n<p>中文官网：<a href=\"https://www.w3cschool.cn/springsecurity/\">https://www.w3cschool.cn/springsecurity/</a> </p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!--maven坐标如下--&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.security&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;spring-security-web&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.security&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;spring-security-config&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>常见的安全框架：Spring的 SpringSecurity，Apache的Shiro <a href=\"http://shiro.apache.org/\">http://shiro.apache.org/</a></p>\n<h4 id=\"2、Spring-Security初体验\"><a href=\"#2、Spring-Security初体验\" class=\"headerlink\" title=\"2、Spring Security初体验\"></a>2、Spring Security初体验</h4><p>首先我们为 Spring Security 专门建立一个 Spring 的配置文件，该文件就专门用来作为 Spring Security 的配置。</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n  xmlns:security&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security&quot;\n  xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n  xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n          http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-3.1.xsd\n          http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security\n          http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security&#x2F;spring-security-3.1.xsd&quot;&gt;\n\n&lt;&#x2F;beans&gt;</code></pre>\n\n<p>Spring Security 命名空间的引入可以简化我们的开发，它涵盖了大部分 Spring Security 常用的功能。它的设计是基于框架内大范围的依赖的，可以被划分为以下几块。</p>\n<ul>\n<li>Web/Http 安全：这是最复杂的部分。通过建立 filter 和相关的 service bean 来实现框架的认证机制。当访问受保护的 URL 时会将用户引入登录界面或者是错误提示界面。</li>\n<li>业务对象或者方法的安全：控制方法访问权限的。</li>\n<li>AuthenticationManager：处理来自于框架其他部分的认证请求。</li>\n<li>AccessDecisionManager：为 Web 或方法的安全提供访问决策。会注册一个默认的，但是我们也可以通过普通 bean 注册的方式使用自定义的 AccessDecisionManager。</li>\n<li>AuthenticationProvider：AuthenticationManager 是通过它来认证用户的。</li>\n<li>UserDetailsService：跟 AuthenticationProvider 关系密切，用来获取用户信息的。</li>\n</ul>\n<p>① http 元素是用于定义 Web 相关权限控制的，security 只是我们使用命名空间的一个前缀。</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;security:http auto-config&#x3D;&quot;true&quot;&gt;\n   &lt;security:intercept-url pattern&#x3D;&quot;&#x2F;**&quot; access&#x3D;&quot;ROLE_USER&quot;&#x2F;&gt;\n&lt;&#x2F;security:http&gt; </code></pre>\n\n<p>可能你会奇怪，我们没有建立登录页面，为什么 Spring Security 会跳到登录页面呢？这是我们设置 http 的 auto-config=”true” 时 Spring Security 自动为我们生成的。</p>\n<p>当指定 http 元素的 auto-config=”true” 时，就相当于如下内容的简写。这些元素<font color=\"#ee3f4d\">负责建立表单登录、基本的认证和登出处理</font>。它们都可以通过指定对应的属性来改变它们的行为。</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;security:http&gt;\n   &lt;security:form-login&#x2F;&gt;\n   &lt;security:http-basic&#x2F;&gt;\n   &lt;security:logout&#x2F;&gt;\n&lt;&#x2F;security:http&gt;</code></pre>\n\n<p>intercept-url 定义了一个权限控制的规则。</p>\n<p>pattern 属性表示我们将对哪些 url 进行权限控制，其也可以是一个正则表达式，如上的写法表示我们将对所有的 URL 进行权限控制</p>\n<p>access 属性表示在请求对应的 URL 时需要什么权限，默认配置时它应该是一个以逗号分隔的角色列表，请求的用户只需拥有其中的一个角色就能成功访问对应的 URL。这里的 “ROLE_USER” 表示请求的用户应当具有 ROLE<em>USER 角色。</em></p>\n<p><em>“ROLE</em>” 前缀是一个提示 Spring 使用<font color=\"#ee3f4d\">基于角色的检查的标记</font>。</p>\n<p>② 有了权限控制的规则，我们需要定义一个 AuthenticationManager 用于认证</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;security:authentication-manager&gt;\n    &lt;security:authentication-provider&gt;\n        &lt;security:user-service&gt;\n            &lt;security:user name&#x3D;&quot;user&quot; password&#x3D;&quot;user&quot; authorities&#x3D;&quot;ROLE_USER&quot;&#x2F;&gt;\n            &lt;security:user name&#x3D;&quot;admin&quot; password&#x3D;&quot;admin&quot; authorities&#x3D;&quot;ROLE_USER, ROLE_ADMIN&quot;&#x2F;&gt;\n        &lt;&#x2F;security:user-service&gt;\n    &lt;&#x2F;security:authentication-provider&gt; \n&lt;&#x2F;security:authentication-manager&gt;</code></pre>\n\n<p>authentication-manager 元素指定了一个 AuthenticationManager</p>\n<p>其需要一个 AuthenticationProvider（对应 authentication-provider 元素）来进行真正的认证，默认情况下 authentication-provider 对应一个 DaoAuthenticationProvider，其需要 UserDetailsService（对应 user-service 元素）来获取用户信息 UserDetails（对应 user 元素）。这里我们只是简单的使用 user 元素来定义用户，而实际应用中这些信息通常都是需要从数据库等地方获取的，这个将放到后续再讲。我们可以看到通过 user 元素我们可以指定 user 对应的用户名、密码和拥有的权限。user-service 还支持通过 properties 文件来指定用户信息，如：</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;security:user-service properties&#x3D;&quot;&#x2F;WEB-INF&#x2F;config&#x2F;users.properties&quot;&#x2F;&gt;</code></pre>\n\n<p>其中属性文件应遵循如下格式：</p>\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\">username&#x3D;password,grantedAuthority[,grantedAuthority][,enabled|disabled]</code></pre>\n\n<p>所以，对应上面的配置文件，我们的 users.properties 文件的内容应该如下所示：</p>\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\">#username&#x3D;password,grantedAuthority[,grantedAuthority][,enabled|disabled]\nuser&#x3D;user,ROLE_USER\nadmin&#x3D;admin,ROLE_USER,ROLE_ADMIN</code></pre>\n\n<p>至此，我们的 Spring Security 配置文件的配置就完成了。完整配置文件将如下所示。</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n  xmlns:security&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security&quot;\n  xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n  xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n          http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-3.1.xsd\n          http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security\n          http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security&#x2F;spring-security-3.1.xsd&quot;&gt;\n\n   &lt;security:http auto-config&#x3D;&quot;true&quot;&gt;\n      &lt;security:intercept-url pattern&#x3D;&quot;&#x2F;**&quot; access&#x3D;&quot;ROLE_USER&quot;&#x2F;&gt;\n   &lt;&#x2F;security:http&gt;    \n\n   &lt;security:authentication-manager&gt;\n      &lt;security:authentication-provider&gt;\n         &lt;security:user-service&gt;\n            &lt;security:user name&#x3D;&quot;user&quot; password&#x3D;&quot;user&quot; authorities&#x3D;&quot;ROLE_USER&quot;&#x2F;&gt;\n            &lt;security:user name&#x3D;&quot;admin&quot; password&#x3D;&quot;admin&quot; authorities&#x3D;&quot;ROLE_USER, ROLE_ADMIN&quot;&#x2F;&gt;\n         &lt;&#x2F;security:user-service&gt;\n      &lt;&#x2F;security:authentication-provider&gt;\n   &lt;&#x2F;security:authentication-manager&gt;\n\n&lt;&#x2F;beans&gt;</code></pre>\n\n<p>之后我们告诉 Spring 加载这个配置文件。通常，我们可以在 web.xml 文件中通过 context-param 把它指定为 Spring 的初始配置文件，也可以在对应 Spring 的初始配置文件中引入它。这里我们采用前者。</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;context-param&gt;\n   &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n   &lt;param-value&gt;&#x2F;WEB-INF&#x2F;config&#x2F;applicationContext.xml,&#x2F;WEB-INF&#x2F;config&#x2F;spring-security.xml&lt;&#x2F;param-value&gt;\n&lt;&#x2F;context-param&gt;\n\n&lt;listener&gt;\n   &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;\n&lt;&#x2F;listener&gt;</code></pre>\n\n<p>Spring 的配置文件是通过对应的 ContextLoaderListener 来加载和初始化的，上述代码中的 applicationContext.xml 文件就是对应的 Spring 的配置文件，如果没有可以不用配置。</p>\n<p>接下来我们还需要在 web.xml 中定义一个 filter 用来拦截需要交给 Spring Security 处理的请求，<font color=\"#ee3f4d\">需要注意的是该 filter 一定要定义在其它如 SpringMVC 等拦截请求之前。</font>这里我们将拦截所有的请求，具体做法如下所示：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>DelegatingFilterProxy用于整合第三方框架（代理过滤器，非真正的过滤器，真正的过滤器需要在spring的配置文件）</p>\n<p>整合Spring Security时过滤器的名称必须为<font color=\"#ee3f4d\">springSecurityFilterChain</font>，否则会抛出NoSuchBeanDefinitionException异常</p></blockquote>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;filter&gt;\n   &lt;filter-name&gt;springSecurityFilterChain&lt;&#x2F;filter-name&gt;\n   &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;&#x2F;filter-class&gt;\n&lt;&#x2F;filter&gt;\n&lt;filter-mapping&gt;\n   &lt;filter-name&gt;springSecurityFilterChain&lt;&#x2F;filter-name&gt;\n   &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;filter-mapping&gt;</code></pre>\n\n\n\n<p>总体代码（web.xml）</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_0.xsd&quot;\n         id&#x3D;&quot;WebApp_ID&quot; version&#x3D;&quot;3.0&quot;&gt;\n\n    &lt;filter&gt;\n        &lt;!--\n         1：DelegatingFilterProxy用于整合第三方框架（代理过滤器，非真正的过滤器，真正的过滤器需要在spring的配置文件）\n          整合Spring Security时过滤器的名称必须为springSecurityFilterChain，\n          否则会抛出NoSuchBeanDefinitionException异常\n        --&gt;\n        &lt;filter-name&gt;springSecurityFilterChain&lt;&#x2F;filter-name&gt;\n        &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;&#x2F;filter-class&gt;\n    &lt;&#x2F;filter&gt;\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;springSecurityFilterChain&lt;&#x2F;filter-name&gt;\n        &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n    &lt;&#x2F;filter-mapping&gt;\n    &lt;!-- 2：springmvc的核心控制器--&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;\n        &lt;!-- 指定加载的配置文件 ，通过参数contextConfigLocation加载 --&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n            &lt;param-value&gt;classpath:spring-security.xml&lt;&#x2F;param-value&gt;\n        &lt;&#x2F;init-param&gt;\n        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;\n    &lt;&#x2F;servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;\n        &lt;url-pattern&gt;*.do&lt;&#x2F;url-pattern&gt;\n    &lt;&#x2F;servlet-mapping&gt;\n&lt;&#x2F;web-app&gt;</code></pre>\n\n<p>总体代码（spring-security.xml）</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:dubbo&#x3D;&quot;http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&quot;\n       xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;\n       xmlns:security&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n                  http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n                  http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc\n                  http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd\n                  http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo\n                  http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd\n                  http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context\n                  http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd\n                          http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security\n                          http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security&#x2F;spring-security.xsd&quot;&gt;\n\n     &lt;!--\n       ① 配置哪些链接可以放行(没有认证通过也可以访问的资源)\n       security&#x3D;&quot;none&quot;：没有权限\n       pattern&#x3D;&quot;&#x2F;login.html&quot;：没有任何权限，可以访问login.html\n     --&gt;\n    &lt;!--&lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;login.html&quot;&gt;&lt;&#x2F;security:http&gt;--&gt;\n\n    &lt;!--\n    ② 定义哪些链接不可以放行(必须通过认证才能访问的资源)，及需要有角色，有权限才可以放行访问资源\n    &lt;security:http auto-config&#x3D;&quot;true&quot; use-expressions&#x3D;&quot;true&quot;&gt;\n          auto-config&#x3D;&quot;true&quot;:开启自动配置 由springsecurity提供登录页面，提供登录的url地址，退出的url地址\n          use-expressions&#x3D;&quot;true&quot;：使用表达式的方式控制权限\n             security:intercept-url：定义哪些链接不可以放行，需要当前角色和权限才能放行\n                pattern&#x3D;&quot;&#x2F;**&quot;：要求系统中的所有资源，都必须通过角色和权限才能访问\n                access：指定角色和权限\n                   如果使用表达式use-expressions&#x3D;&quot;true&quot;\n                       access&#x3D;&quot;hasRole(&#39;ROLE_ADMIN&#39;)：表示具有ROLE_ADMIN的角色才能访问系统的资源\n                   如果不使用表达式use-expressions&#x3D;&quot;false&quot;\n                       access&#x3D;&quot;ROLE_ADMIN：表示具有ROLE_ADMIN的角色才能访问系统的资源\n    --&gt;\n    &lt;security:http auto-config&#x3D;&quot;true&quot; use-expressions&#x3D;&quot;true&quot;&gt;\n        &lt;security:intercept-url pattern&#x3D;&quot;&#x2F;**&quot; access&#x3D;&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot;&gt;&lt;&#x2F;security:intercept-url&gt;\n    &lt;&#x2F;security:http&gt;\n\n    &lt;!--\n      ③ 认证管理：定义登录账号和密码，并授予当前用户访问的角色或权限\n        （1）：将用户名和密码：当前用户具有的角色，写死到配置文件中（现在:入门）\n                security:user name&#x3D;&quot;admin&quot; :登录名\n                authorities&#x3D;&quot;ROLE_ADMIN&quot;   ：角色(ROLE_ADMIN),权限\n                password&#x3D;&quot;admin&quot;          ：密码\n         （2）：用户名和密码，当前用户具有的角色，从数据库中查询（后续）\n    --&gt;\n    &lt;security:authentication-manager&gt;\n        &lt;security:authentication-provider&gt;\n            &lt;security:user-service&gt;\n                &lt;security:user name&#x3D;&quot;admin&quot; authorities&#x3D;&quot;ROLE_ADMIN&quot; password&#x3D;&quot;admin&quot;&gt;&lt;&#x2F;security:user&gt;\n            &lt;&#x2F;security:user-service&gt;\n        &lt;&#x2F;security:authentication-provider&gt;\n    &lt;&#x2F;security:authentication-manager&gt;\n&lt;&#x2F;beans&gt;</code></pre>\n\n<p>入门案例里面<strong>没有指定密码加密</strong>方式的. 配置密码的时候的加**{noop}**</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">security:user-service&gt;\n  &lt;security:user name&#x3D;&quot;admin&quot; password&#x3D;&quot;&#123;noop&#125;admin&quot; authorities&#x3D;&quot;ROLE_ADMIN&quot;&#x2F;&gt;\n&lt;&#x2F;security:user-service&gt;</code></pre>\n\n<p>加密的方式</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;security:authentication-manager&gt;\n    &lt;!-- authentication-provider：认证提供者，执行具体的认证逻辑  --&gt;\n    &lt;security:authentication-provider&gt;\n\t\t&lt;security:user name&#x3D;&quot;admin&quot; authorities&#x3D;&quot;ROLE_ADMIN&quot; password&#x3D;&quot;admin&quot;&gt;&lt;&#x2F;security:user&gt;\n        \n        &lt;!--指定密码加密策略--&gt;\n        &lt;security:password-encoder ref&#x3D;&quot;passwordEncoder&quot;&gt;&lt;&#x2F;security:password-encoder&gt;\n\n    &lt;&#x2F;security:authentication-provider&gt;\n\n&lt;&#x2F;security:authentication-manager&gt;\n\n&lt;!--配置密码加密对象--&gt;\n&lt;bean id&#x3D;&quot;passwordEncoder&quot; class&#x3D;&quot;org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder&quot; &#x2F;&gt;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserService implements UserDetailsService &#123;\n\n    &#x2F;&#x2F;模拟数据库中的用户数据\n    static Map&lt;String, User&gt; map &#x3D; new HashMap&lt;String, User&gt;();\n\n    static &#123;\n        com.atguigu.pojo.User user1 &#x3D; new com.atguigu.pojo.User();\n        user1.setUsername(&quot;admin&quot;);\n        user1.setPassword(&quot;admin&quot;);\n        user1.setTelephone(&quot;123&quot;);\n\n        com.atguigu.pojo.User user2 &#x3D; new com.atguigu.pojo.User();\n        user2.setUsername(&quot;zhangsan&quot;);\n        user2.setPassword(&quot;123&quot;);\n        user2.setTelephone(&quot;321&quot;);\n\n        map.put(user1.getUsername(), user1);\n        map.put(user2.getUsername(), user2);\n    &#125;\n\n    @Override\n    public UserDetails loadUserByUsername(String name) throws UsernameNotFoundException &#123;\n        User userInDb &#x3D; map.get(name);\n        if (userInDb &#x3D;&#x3D; null) &#123;\n            &#x2F;&#x2F;根据用户名没有查询到用户，抛出异常，表示登录名输入有误\n            return null;\n        &#125;\n\n        String password &#x3D; userInDb.getPassword();\n\n        List&lt;GrantedAuthority&gt; list &#x3D; new ArrayList&lt;&gt;();\n        SimpleGrantedAuthority role_user &#x3D; new SimpleGrantedAuthority(&quot;ROLE_USER&quot;);\n        SimpleGrantedAuthority add &#x3D; new SimpleGrantedAuthority(&quot;ADD&quot;);\n        SimpleGrantedAuthority del &#x3D; new SimpleGrantedAuthority(&quot;DEL&quot;);\n        SimpleGrantedAuthority query &#x3D; new SimpleGrantedAuthority(&quot;QUERY&quot;);\n        list.add(role_user);\n        list.add(add);\n        list.add(del);\n        list.add(query);\n\n        &lt;!--对数据库中的密码进行加密--&gt;\n        &#x2F;&#x2F;String encodePassword &#x3D; new BCryptPasswordEncoder().encode(password);\n\n        &lt;!--若配置了加密，就使用者一句代码，没使用就不用，还要给encodePassword前加上&#123;noop&#125;--&gt;\n        return new org.springframework.security.core.userdetails.User(name, encodePassword, list);\n    &#125;\n&#125;</code></pre>\n\n\n\n<h4 id=\"3、Spring-Security执行流程\"><a href=\"#3、Spring-Security执行流程\" class=\"headerlink\" title=\"3、Spring Security执行流程\"></a>3、Spring Security执行流程</h4><div>\n<img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/spring-security-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B1\" alt=\"Spring Security 执行流程\" style=\"zoom:67%;\" />\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/spring-security-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B2\" alt=\"分析解析 token ，检查权限的过程\" style=\"zoom: 80%;\" />\n</div>\n\n\n\n\n<h4 id=\"4、问题\"><a href=\"#4、问题\" class=\"headerlink\" title=\"4、问题\"></a>4、问题</h4><p>在配置类中配置，我们就要指定 PasswordEncoder 了，这是一个非常关键的东西。</p>\n<p>考虑到有的小伙伴对于 PasswordEncoder 还不太熟悉，因此，我这里先稍微给大家介绍一下 PasswordEncoder 到底是干嘛用的。要说 PasswordEncoder ，就得先说密码加密。</p>\n<h5 id=\"为什么要加密？\"><a href=\"#为什么要加密？\" class=\"headerlink\" title=\"为什么要加密？\"></a>为什么要加密？</h5><p>2011 年 12 月 21 日，有人在网络上公开了一个包含 600 万个 CSDN 用户资料的数据库，数据全部为明文储存，包含用户名、密码以及注册邮箱。事件发生后 CSDN 在微博、官方网站等渠道发出了声明，解释说此数据库系 2009 年备份所用，因不明原因泄露，已经向警方报案，后又在官网发出了公开道歉信。在接下来的十多天里，金山、网易、京东、当当、新浪等多家公司被卷入到这次事件中。整个事件中最触目惊心的莫过于 CSDN 把用户密码明文存储，由于很多用户是多个网站共用一个密码，因此一个网站密码泄露就会造成很大的安全隐患。由于有了这么多前车之鉴，我们现在做系统时，密码都要加密处理。</p>\n<p>这次泄密，也留下了一些有趣的事情，特别是对于广大程序员设置密码这一项。人们从 CSDN 泄密的文件中，发现了一些好玩的密码，例如如下这些：</p>\n<ul>\n<li><code>ppnn13%dkstFeb.1st</code> 这段密码的中文解析是：娉娉袅袅十三余，豆蔻梢头二月初。</li>\n<li><code>csbt34.ydhl12s</code> 这段密码的中文解析是：池上碧苔三四点，叶底黄鹂一两声</li>\n<li>…</li>\n</ul>\n<p>等等不一而足，你会发现很多程序员的人文素养还是非常高的，让人啧啧称奇。</p>\n<h5 id=\"加密方案\"><a href=\"#加密方案\" class=\"headerlink\" title=\"加密方案\"></a>加密方案</h5><p>密码加密我们一般会用到散列函数，又称散列算法、哈希函数，这是一种从任何数据中创建数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来，然后将数据打乱混合，重新创建一个散列值。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。我们常用的散列函数有 MD5 消息摘要算法、安全散列算法（Secure Hash Algorithm）。</p>\n<p>但是仅仅使用散列函数还不够，为了增加密码的安全性，一般在密码加密过程中还需要加盐，所谓的盐可以是一个随机数也可以是用户名，加密之后，即使密码明文相同的用户生成的密码密文也不相同，这可以极大的提高密码的安全性。但是传统的加盐方式需要在数据库中有专门的字段来记录盐值，这个字段可能是用户名字段（因为用户名唯一），也可能是一个专门记录盐值的字段，这样的配置比较繁琐。</p>\n<p>Spring Security 提供了多种密码加密方案，官方推荐使用 BCryptPasswordEncoder，BCryptPasswordEncoder 使用 BCrypt 强哈希函数，开发者在使用时可以选择提供 strength 和 SecureRandom 实例。strength 越大，密钥的迭代次数越多，密钥迭代次数为 2^strength。strength 取值在 4~31 之间，默认为 10。</p>\n<p>不同于 Shiro 中需要自己处理密码加盐，在 Spring Security 中，BCryptPasswordEncoder 就自带了盐，处理起来非常方便。</p>\n<p>而 BCryptPasswordEncoder 就是 PasswordEncoder 接口的实现类。</p>\n<h4 id=\"open-umbrella-​Spring集成-Spring-Security\"><a href=\"#open-umbrella-​Spring集成-Spring-Security\" class=\"headerlink\" title=\":open_umbrella: ​Spring集成 Spring Security\"></a>:open_umbrella: ​Spring集成 Spring Security</h4><hr>\n<h4 id=\"1、配置匿名访问资源\"><a href=\"#1、配置匿名访问资源\" class=\"headerlink\" title=\"1、配置匿名访问资源\"></a>1、配置匿名访问资源</h4><p> http：用于定义相关权限控制</p>\n<p>security=”none”：没有权限</p>\n<p>pattern=””：可以访问的地址，可以使用通配符</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!--开启匿名访问的资源--&gt;\n&lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;css&#x2F;**&quot;&#x2F;&gt;\n&lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;img&#x2F;**&quot;&#x2F;&gt;\n&lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;js&#x2F;**&quot;&#x2F;&gt;\n&lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;plugins&#x2F;**&quot;&#x2F;&gt;\n&lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;login.html&quot;&#x2F;&gt;</code></pre>\n\n\n\n<h4 id=\"2、form-login元素介绍\"><a href=\"#2、form-login元素介绍\" class=\"headerlink\" title=\"2、form-login元素介绍\"></a>2、form-login元素介绍</h4><p>http 元素下的 form-login 元素是用来定义表单登录信息的。当我们什么属性都不指定的时候 Spring Security 会为我们生成一个默认的登录页面。如果不想使用默认的登录页面，我们可以指定自己的登录页面。</p>\n<h4 id=\"3、form-login的几个属性\"><a href=\"#3、form-login的几个属性\" class=\"headerlink\" title=\"3、form-login的几个属性\"></a>3、form-login的几个属性</h4><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>释义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>form-login</td>\n<td>定义表单登录信息</td>\n</tr>\n<tr>\n<td>login-page=”/login.html”</td>\n<td>表示指定登录页</td>\n</tr>\n<tr>\n<td>username-parameter=”username”</td>\n<td>使用登录名的名称，默认值是username</td>\n</tr>\n<tr>\n<td>password-parameter=”password”</td>\n<td>使用登录名的密码，默认值是password</td>\n</tr>\n<tr>\n<td>login-processing-url=”/login.do”</td>\n<td>表示登录的url地址</td>\n</tr>\n<tr>\n<td>default-target-url=”/index.html”</td>\n<td>登录成功后的url地址</td>\n</tr>\n<tr>\n<td>authentication-failure-url=”/login.html”</td>\n<td>认证失败后跳转的url地址，失败后指定/login.html</td>\n</tr>\n<tr>\n<td>always-use-default-target=”true”</td>\n<td>登录成功后，始终跳转到default-target-url指定的地址，即登录成功的默认地址</td>\n</tr>\n</tbody></table>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;security:form-login login-page&#x3D;&quot;&#x2F;login.html&quot;\n                     login-processing-url&#x3D;&quot;&#x2F;login.do&quot;\n                     username-parameter&#x3D;&quot;username&quot;\n                     password-parameter&#x3D;&quot;password&quot;\n                     default-target-url&#x3D;&quot;&#x2F;pages&#x2F;main.html&quot;\n                     authentication-failure-url&#x3D;&quot;&#x2F;login.html&quot;\n                     always-use-default-target&#x3D;&quot;true&quot;\n                     &#x2F;&gt;\n\n&lt;security:csrf disabled&#x3D;&quot;true&quot;&#x2F;&gt;</code></pre>\n\n<p>csrf：对应CsrfFilter过滤器</p>\n<p>disabled：是否启用CsrfFilter过滤器，如果使用==自定义登录页面需要关闭此项==，否则登录操作会被禁用（403）</p>\n<p>Spring-security采用盗链机制，其中_csrf使用token标识和随机字符，每次访问页面都会随机生成，然后和服务器进行比较，成功可以访问，不成功不能访问。</p>\n<h4 id=\"4、使用数据库查询的信息\"><a href=\"#4、使用数据库查询的信息\" class=\"headerlink\" title=\"4、使用数据库查询的信息\"></a>4、使用数据库查询的信息</h4><p>认证管理，定义登录账号名和密码，并授予访问的角色、权限</p>\n<p>authentication-manager：认证管理器，用于处理认证操作</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!--对继承UserDetailsService的认证提供者使用注解，@component，进行扫描，就能直接注入--&gt;\n&lt;context:component-scan base-package&#x3D;&quot;com.atguigu&quot;&#x2F;&gt;\n\n&lt;security:authentication-manager&gt;\n\n    &lt;!-- authentication-provider：认证提供者，执行具体的认证逻辑 --&gt;\n\n    &lt;security:authentication-provider user-service-ref&#x3D;&quot;userService&quot;&#x2F;&gt;\n\n&lt;&#x2F;security:authentication-manager&gt;</code></pre>\n\n<p>==下面代码中引用了 service，这个引用是dubbo中的注解，因为我们要使用userService，所以在配置中，我们一定要修改dubbo扫描的包，让其也扫描到SecurityUserServiceImpl所在的包==</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\npublic class SecurityUserServiceImpl implements UserDetailsService &#123;\n\n    @Reference\n    private UserService userService;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        &#x2F;&#x2F;根据名字获取用户信息\n        User user &#x3D; userService.getUserByName(username);\n\n        if (user &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n\n        &#x2F;&#x2F;新建用户权限集合\n        List&lt;GrantedAuthority&gt; authorityList &#x3D; new ArrayList&lt;&gt;();\n\n        &#x2F;&#x2F;查询用户相应权限\n        Set&lt;Role&gt; roles &#x3D; user.getRoles();\n        for (Role role : roles) &#123;\n            Set&lt;Permission&gt; permissions &#x3D; role.getPermissions();\n            for (Permission permission : permissions) &#123;\n                authorityList.add(new SimpleGrantedAuthority(permission.getKeyword()));\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F;将数据返回给权限框架，在内部进行比较\n        return new org.springframework.security.core.userdetails.User(username, user.getPassword(), authorityList);\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li><p>dao层进行具体查询逻辑处理时需要注意！！！使用分步查询，注意sql及resultMap的映射</p>\n</li>\n<li><p>这里返回给框架的User 不是我们定义的pojo中的，而是框架提供的User类：org.springframework.security.core.userdetails.User</p>\n</li>\n</ul>\n<h4 id=\"5、密码加密解密\"><a href=\"#5、密码加密解密\" class=\"headerlink\" title=\"5、密码加密解密\"></a>5、密码加密解密</h4><p>前面我们使用的密码都是明文的，这是非常不安全的。一般情况下用户的密码需要进行加密后再保存到数据库中。</p>\n<p>常见的密码加密方式有：</p>\n<ul>\n<li><p>3DES、AES、DES：使用对称加密算法，可以通过解密来还原出原始密码</p>\n</li>\n<li><p>MD5、SHA1：使用单向HASH算法，无法通过计算还原出原始密码，但是可以建立彩虹表进行查表破解</p>\n</li>\n</ul>\n<p>MD5可进行加盐加密，保证安全</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestMD5 &#123;\n    @Test\n    public void testMD5()&#123;\n        &#x2F;&#x2F; 密码同样是1234却变成了密码不相同\n        System.out.println(MD5Utils.md5(&quot;1234xiaowang&quot;)); &#x2F;&#x2F;a8231077b3d5b40ffadee7f4c8f66cb7\n        System.out.println(MD5Utils.md5(&quot;1234xiaoli&quot;)); &#x2F;&#x2F;7d5250d8620fcdb53b25f96a1c7be591\n    &#125;\n&#125;</code></pre>\n\n<p>同样的密码值，盐值不同，加密的结果不同。</p>\n<p>bcrypt：将salt随机并混入最终加密后的密码，验证时也无需单独提供之前的salt，从而无需单独处理salt问题</p>\n<p>==spring security中的BCryptPasswordEncoder方法采用SHA-256 +随机盐+密钥对密码进行加密==。SHA系列是Hash算法，不是加密算法，使用加密算法意味着可以解密（这个与编码/解码一样），但是采用Hash处理，其过程是不可逆的。</p>\n<ol>\n<li>加密(encode)：注册用户时，使用SHA-256+随机盐+密钥把用户输入的密码进行hash处理，得到密码的hash值，然后将其存入数据库中。</li>\n<li>密码匹配(matches)：用户登录时，密码匹配阶段并没有进行密码解密（因为密码经过Hash处理，是不可逆的），而是使用相同的算法把用户输入的密码进行hash处理，得到密码的hash值，然后将其与从数据库中查询到的密码hash值进行比较。如果两者相同，说明用户输入的密码正确。</li>\n</ol>\n<p>这正是为什么处理密码时要用hash算法，而不用加密算法。因为这样处理即使数据库泄漏，黑客也很难破解密码。</p>\n<p>在 meinian_common项目的 test 文件夹下面新建测试代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.security.test;\nimport org.junit.Test;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\n\npublic class TestSpringSecurity &#123;\n\n    &#x2F;&#x2F; SpringSecurity加盐加密\n    @Test\n    public void testSpringSecurity()&#123;\n\n        BCryptPasswordEncoder encoder &#x3D; new BCryptPasswordEncoder();\n\n        String s &#x3D; encoder.encode(&quot;abc&quot;);\n        System.out.println(s);\n\n        String s1 &#x3D; encoder.encode(&quot;abc&quot;);\n        System.out.println(s1);\n\n        &#x2F;&#x2F; 进行判断\n        boolean b &#x3D; encoder.matches(&quot;abc&quot;, &quot;$2a$10$dyIf5fOjCRZs&#x2F;pYXiBYy8uOiTa1z7I.mpqWlK5B&#x2F;0icpAKijKCgxe&quot;);\n        System.out.println(b);\n    &#125;\n&#125;</code></pre>\n\n<p>加密后的格式一般为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$2a$10$&#x2F;bTVvqqlH9UiE0ZJZ7N2Me3RIgUCdgMheyTgV0B4cMCSokPa.6oCa</code></pre>\n\n<p>加密后字符串的长度为固定的60位。其中：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$是分割符，无意义；\n\n2a是bcrypt加密版本号；\n\n10是cost的值；\n\n而后的前22位是salt值；\n\n再然后的字符串就是密码的密文了。</code></pre>\n\n<p>在spring-security.xml文件中指定密码加密对象</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;security:authentication-manager&gt;\n    &lt;!-- authentication-provider：认证提供者，执行具体的认证逻辑  --&gt;\n    &lt;security:authentication-provider user-service-ref&#x3D;&quot;userService&quot;&gt;\n\n        &lt;!--指定密码加密策略--&gt;\n        &lt;security:password-encoder ref&#x3D;&quot;passwordEncoder&quot;&gt;&lt;&#x2F;security:password-encoder&gt;\n\n    &lt;&#x2F;security:authentication-provider&gt;\n\n&lt;&#x2F;security:authentication-manager&gt;\n\n&lt;!--配置密码加密对象--&gt;\n&lt;bean id&#x3D;&quot;passwordEncoder&quot; class&#x3D;&quot;org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder&quot; &#x2F;&gt;</code></pre>\n\n<p>配置以后表示，以后每次登录，都会进行密码加密，然后再与数据库中取出的密码（已加密）进行匹配，匹配成功则证明认证成功</p>\n<h4 id=\"6、配置多种校验规则（对页面）\"><a href=\"#6、配置多种校验规则（对页面）\" class=\"headerlink\" title=\"6、配置多种校验规则（对页面）\"></a>6、配置多种校验规则（对页面）</h4><p>前提：&lt;security:http auto-config=“true” use-expressions=“true”&gt;</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;security:http auto-config&#x3D;&quot;true&quot; use-expressions&#x3D;&quot;true&quot;&gt;\n\n    &lt;!--&lt;security:intercept-url pattern&#x3D;&quot;&#x2F;**&quot; access&#x3D;&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot;&gt;&lt;&#x2F;security:intercept-url&gt;--&gt;\n\n    &lt;!--只要认证通过就可以访问--&gt;\n    &lt;security:intercept-url pattern&#x3D;&quot;&#x2F;index.html&quot; access&#x3D;&quot;isAuthenticated()&quot; &#x2F;&gt;\n    &lt;security:intercept-url pattern&#x3D;&quot;&#x2F;a.html&quot; access&#x3D;&quot;isAuthenticated()&quot; &#x2F;&gt;\n\n    &lt;!--拥有add权限就可以访问b.html页面--&gt;\n    &lt;!--hasAnyAuthority(&#39;add&#39;,&#39;del&#39;,&#39;edit&#39;)：表示具有其中任何一个权限就可以访问--&gt;\n    &lt;security:intercept-url pattern&#x3D;&quot;&#x2F;b.html&quot; access&#x3D;&quot;hasAuthority(&#39;add&#39;)&quot; &#x2F;&gt;\n\n    &lt;!--拥有ROLE_ADMIN角色就可以访问c.html页面，注意：此处虽然写的是ADMIN角色，框架会自动加上前缀ROLE_--&gt;\n    &lt;security:intercept-url pattern&#x3D;&quot;&#x2F;c.html&quot; access&#x3D;&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot; &#x2F;&gt;\n\n    &lt;!--拥有ROLE_ADMIN角色就可以访问d.html页面--&gt;\n    &lt;security:intercept-url pattern&#x3D;&quot;&#x2F;d.html&quot; access&#x3D;&quot;hasRole(&#39;ABC&#39;)&quot; &#x2F;&gt;\n\n&lt;&#x2F;security:http&gt;</code></pre>\n\n\n\n<h4 id=\"7、注解方式权限控制（对类）\"><a href=\"#7、注解方式权限控制（对类）\" class=\"headerlink\" title=\"7、注解方式权限控制（对类）\"></a>7、注解方式权限控制（对类）</h4><p>Spring Security除了可以在配置文件中配置权限校验规则，还可以使用注解方式控制类中方法的调用。</p>\n<p>例如Controller中的某个方法要求必须具有某个权限才可以访问，此时就可以使用Spring Security框架提供的注解方式进行控制。</p>\n<p>1：在spring-security.xml文件中配置组件扫描，用于扫描Controller</p>\n<p>2：在spring-security.xml文件中开启权限注解支持</p>\n<p>3：创建Controller类并在Controller的方法上加入注解（@PreAuthorize）进行权限控制</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!--整合时，因为需要把spring-security.xml导入到spring-mvc.xml中进行加载，又因为mvc中配置了dubbo扫描，所以可知直接把这个去掉，让dubbo扫描到使用了@PreAuthorize的包，又因为SecurityUserServiceImpl中引用了dubbo中提供的service服务，所以让dubbo扫描到包，这一步必不可少--&gt;\n&lt;context:component-scan base-package&#x3D;&quot;com.atguigu&quot;&#x2F;&gt;</code></pre>\n\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!--开启全局的方法上注解方式权限控制--&gt;\n&lt;security:global-method-security pre-post-annotations&#x3D;&quot;enabled&quot; &#x2F;&gt;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RestController\n@RequestMapping(&quot;&#x2F;hello&quot;)\npublic class HelloController &#123;\n\n    @RequestMapping(&quot;&#x2F;add&quot;)\n    @PreAuthorize(&quot;hasAuthority(&#39;add&#39;)&quot;)&#x2F;&#x2F;表示用户必须拥有add权限才能调用当前方法\n    public String add()&#123;\n        return &quot;success&quot;;\n    &#125;\n\n    @RequestMapping(&quot;&#x2F;update&quot;)\n    @PreAuthorize(&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot;)&#x2F;&#x2F;表示用户必须拥有ROLE_ADMIN角色才能调用当前方法\n    public String update()&#123;\n        return &quot;success&quot;;\n    &#125;\n\n    @RequestMapping(&quot;&#x2F;delete&quot;)\n    @PreAuthorize(&quot;hasRole(&#39;ABC&#39;)&quot;)&#x2F;&#x2F;表示用户必须拥有ABC角色才能调用当前方法\n    public String delete()&#123;\n        return &quot;success&quot;;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h4 id=\"8、logout退出登录\"><a href=\"#8、logout退出登录\" class=\"headerlink\" title=\"8、logout退出登录\"></a>8、logout退出登录</h4><pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;a href&#x3D;&quot;&#x2F;logout.do&quot;&gt;退出登录&lt;&#x2F;a&gt;</code></pre>\n\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!--\n  logout：退出登录\n  logout-url：退出登录操作对应的请求路径\n  logout-success-url：退出登录后的跳转页面\n  invalidate-session&#x3D;&quot;true&quot; 默认为true,用户在退出后Http session失效\n--&gt;\n&lt;security:logout logout-url&#x3D;&quot;&#x2F;logout.do&quot; logout-success-url&#x3D;&quot;&#x2F;login.html&quot; invalidate-session&#x3D;&quot;true&quot;&#x2F;&gt;</code></pre>\n\n<p>通过上面的配置可以发现，如果用户要退出登录，只需要请求/logout.do这个URL地址就可以，同时会将当前session失效，最后页面会跳转到login.html页面。</p>\n<h4 id=\"9、登录后回显用户名\"><a href=\"#9、登录后回显用户名\" class=\"headerlink\" title=\"9、登录后回显用户名\"></a>9、登录后回显用户名</h4><pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&#x2F;&#x2F;发送请求获取当前登录用户的用户名\ncreated: function () &#123;\n    &#x2F;&#x2F;发送请求获取当前登录用户的用户名\n    axios(&#123;\n        method: &quot;post&quot;,\n        url: &quot;&#x2F;user&#x2F;getUserName.do&quot;\n    &#125;).then((res) &#x3D;&gt; &#123;\n        if (res.data.flag) &#123;\n            this.username &#x3D; res.data.data.username;\n        &#125; else &#123;\n            this.$message.error(res.data.message);\n        &#125;\n    &#125;)\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意：获取到用户信息后，强转的User，不是pojo中自定义的，而==是security中提供的User==</p></blockquote>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;获取当前登录用户的用户名\n@RequestMapping(&quot;&#x2F;getUserName&quot;)\npublic Result getUsername() throws Exception &#123;\n    try &#123;\n        &#x2F;&#x2F;这里的User，是org.springframework.security.core.userdetails.User;\n        User user &#x3D; (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n        return new Result(true, MessageConstant.GET_USERNAME_SUCCESS, user);\n    &#125; catch (Exception e) &#123;\n        return new Result(false, MessageConstant.GET_USERNAME_FAIL);\n    &#125;\n&#125;</code></pre>\n\n\n\n<h4 id=\"10、403无权限异常消息提示\"><a href=\"#10、403无权限异常消息提示\" class=\"headerlink\" title=\"10、403无权限异常消息提示\"></a>10、403无权限异常消息提示</h4><p>在<code>&lt;security:http&gt;</code>标签中增加<code>&lt;security:access-denied-handler&gt;</code></p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!--自定义异常处理--&gt;\n&lt;security:access-denied-handler ref&#x3D;&quot;customAccessDeniedHandler&quot;&#x2F;&gt;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\npublic class CustomAccessDeniedController implements AccessDeniedHandler &#123;\n\n    &#x2F;**\n     * 在页面上没有权限时，设置页面回显的消息或要跳转的页面\n     * @param request 请求\n     * @param response 响应\n     * @param e 访问没有权限异常\n     * @throws IOException io异常\n     * @throws ServletException servlet异常\n     *&#x2F;\n    @Override\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException &#123;\n        if (isAjaxRequest(request))&#123;\n\n            Result result &#x3D; new Result(false ,&quot;您还没有此权限，请申请权限！！！&quot;);\n            String jsonStr &#x3D; JSON.toJSONString(result);\n            response.getWriter().print(jsonStr);\n        &#125;else &#123;\n            request.getRequestDispatcher(&quot;&#x2F;pages&#x2F;error&#x2F;403.html&quot;).forward(request,response);\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 判断是否为ajax请求\n     *&#x2F;\n    public static boolean isAjaxRequest(HttpServletRequest request) &#123;\n        return request.getHeader(&quot;accept&quot;).contains(&quot;application&#x2F;json&quot;)\n            || (request.getHeader(&quot;X-Requested-With&quot;) !&#x3D; null &amp;&amp; request.getHeader(&quot;X-Requested-With&quot;).equalsIgnoreCase(&quot;XMLHttpRequest&quot;));\n    &#125;\n&#125;</code></pre>\n\n\n\n<h4 id=\"11、总结\"><a href=\"#11、总结\" class=\"headerlink\" title=\"11、总结\"></a>11、总结</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意：此时数据库中存储的密码是加密过后的</p></blockquote>\n<p>web.xml</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;filter&gt;\n    &lt;!--\n         1：DelegatingFilterProxy用于整合第三方框架（代理过滤器，非真正的过滤器，真正的过滤器需要在spring的配置文件）\n          整合Spring Security时过滤器的名称必须为springSecurityFilterChain，\n          否则会抛出NoSuchBeanDefinitionException异常\n        --&gt;\n    &lt;filter-name&gt;springSecurityFilterChain&lt;&#x2F;filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;&#x2F;filter-class&gt;\n&lt;&#x2F;filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;springSecurityFilterChain&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;filter-mapping&gt;</code></pre>\n\n<p>spring-security.xml</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:security&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security&#x2F;spring-security.xsd&quot;&gt;\n\n    &lt;!--开启注解扫描 dubbo已经扫描，如果dubbo中不扫描此包，那么引用将不可用--&gt;\n    &lt;!--&lt;context:component-scan base-package&#x3D;&quot;com.atguigu.security&quot;&#x2F;&gt;--&gt;\n    &lt;!--开启注解方式权限控制--&gt;\n    &lt;security:global-method-security pre-post-annotations&#x3D;&quot;enabled&quot;&#x2F;&gt;\n\n    &lt;!--开启匿名访问的资源--&gt;\n    &lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;css&#x2F;**&quot;&#x2F;&gt;\n    &lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;img&#x2F;**&quot;&#x2F;&gt;\n    &lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;js&#x2F;**&quot;&#x2F;&gt;\n    &lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;plugins&#x2F;**&quot;&#x2F;&gt;\n    &lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;login.html&quot;&#x2F;&gt;\n\n    &lt;security:http auto-config&#x3D;&quot;true&quot; use-expressions&#x3D;&quot;true&quot;&gt;\n        &lt;security:intercept-url access&#x3D;&quot;isAuthenticated()&quot; pattern&#x3D;&quot;&#x2F;pages&#x2F;**&quot;&#x2F;&gt;\n        &lt;!--\n            form-login：定义表单登录信息\n            login-page&#x3D;&quot;&#x2F;login.html&quot;：表示指定登录页面\n            username-parameter&#x3D;&quot;username&quot;：使用登录名的名称，默认值是username\n            password-parameter&#x3D;&quot;password&quot;：使用登录名的密码，默认值是password\n            login-processing-url&#x3D;&quot;&#x2F;login.do&quot;：表示登录的url地址\n            default-target-url&#x3D;&quot;&#x2F;index.html&quot;：登录成功后的url地址\n            authentication-failure-url&#x3D;&quot;&#x2F;login.html&quot;：认证失败后跳转的url地址，失败后指定&#x2F;login.html\n            always-use-default-target&#x3D;&quot;true&quot;：登录成功后，始终跳转到default-target-url指定的地址，即登录成功的默认地址\n            --&gt;\n        &lt;security:form-login login-page&#x3D;&quot;&#x2F;login.html&quot;\n                             login-processing-url&#x3D;&quot;&#x2F;login.do&quot;\n                             username-parameter&#x3D;&quot;username&quot;\n                             password-parameter&#x3D;&quot;password&quot;\n                             default-target-url&#x3D;&quot;&#x2F;pages&#x2F;main.html&quot;\n                             authentication-failure-url&#x3D;&quot;&#x2F;login.html&quot;\n                             always-use-default-target&#x3D;&quot;true&quot;\n        &#x2F;&gt;\n        &lt;!--禁用CsrfFilter过滤器--&gt;\n        &lt;security:csrf disabled&#x3D;&quot;true&quot;&#x2F;&gt;\n        &lt;!--登出--&gt;\n        &lt;security:logout logout-url&#x3D;&quot;&#x2F;logout.do&quot; invalidate-session&#x3D;&quot;true&quot; logout-success-url&#x3D;&quot;&#x2F;login.html&quot;&#x2F;&gt;\n\n        &lt;security:headers&gt;\n            &lt;!--设置在页面可以通过iframe访问受保护的页面，默认为不允许访问--&gt;\n            &lt;security:frame-options policy&#x3D;&quot;SAMEORIGIN&quot;&#x2F;&gt;\n        &lt;&#x2F;security:headers&gt;\n\n        &lt;!--设置用户在没有权限时，进行消息提示--&gt;\n        &lt;security:access-denied-handler ref&#x3D;&quot;customAccessDeniedController&quot;&#x2F;&gt;\n    &lt;&#x2F;security:http&gt;\n\n    &lt;!--认证管理：定义登录账号名和密码，并授予访问的角色、权限--&gt;\n    &lt;security:authentication-manager&gt;\n        &lt;!--authentication-provider：认证提供者，执行具体的认证逻辑--&gt;\n        &lt;security:authentication-provider user-service-ref&#x3D;&quot;securityUserServiceImpl&quot;&gt;\n            &lt;!--指定密码加密策略--&gt;\n            &lt;security:password-encoder ref&#x3D;&quot;passwordEncoder&quot;&#x2F;&gt;\n        &lt;&#x2F;security:authentication-provider&gt;\n    &lt;&#x2F;security:authentication-manager&gt;\n\n    &lt;!--配置密码加密对象--&gt;\n    &lt;bean id&#x3D;&quot;passwordEncoder&quot;\n          class&#x3D;&quot;org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder&quot; &#x2F;&gt;\n\n&lt;&#x2F;beans&gt;</code></pre>\n\n<p>从数据库获取用户信息</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.security;\n\nimport com.alibaba.dubbo.config.annotation.Reference;\nimport com.atguigu.pojo.Permission;\nimport com.atguigu.pojo.Role;\nimport com.atguigu.pojo.User;\nimport com.atguigu.service.UserService;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Component;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\n&#x2F;**\n * @author hrenxiang\n * @create 2021&#x2F;8&#x2F;3 15:00\n *&#x2F;\n\n@Component\npublic class SecurityUserServiceImpl implements UserDetailsService &#123;\n\n    @Reference\n    private UserService userService;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        &#x2F;&#x2F;根据名字获取用户信息\n        User user &#x3D; userService.getUserByName(username);\n\n        if (user &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n\n        &#x2F;&#x2F;新建用户权限集合\n        List&lt;GrantedAuthority&gt; authorityList &#x3D; new ArrayList&lt;&gt;();\n\n        &#x2F;&#x2F;查询用户相应权限\n        Set&lt;Role&gt; roles &#x3D; user.getRoles();\n        for (Role role : roles) &#123;\n            Set&lt;Permission&gt; permissions &#x3D; role.getPermissions();\n            for (Permission permission : permissions) &#123;\n                authorityList.add(new SimpleGrantedAuthority(permission.getKeyword()));\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F;将数据返回给权限框架，在内部进行比较\n        return new org.springframework.security.core.userdetails.User(username, user.getPassword(), authorityList);\n    &#125;\n&#125;</code></pre>\n\n<p>403没有权限时消息提示</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\npublic class CustomAccessDeniedController implements AccessDeniedHandler &#123;\n\n    &#x2F;**\n     * 在页面上没有权限时，设置页面回显的消息或要跳转的页面\n     * @param request 请求\n     * @param response 响应\n     * @param e 访问没有权限异常\n     * @throws IOException io异常\n     * @throws ServletException servlet异常\n     *&#x2F;\n    @Override\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException &#123;\n        if (isAjaxRequest(request))&#123;\n\n            Result result &#x3D; new Result(false ,&quot;您还没有此权限，请申请权限！！！&quot;);\n            String jsonStr &#x3D; JSON.toJSONString(result);\n            response.getWriter().print(jsonStr);\n        &#125;else &#123;\n            request.getRequestDispatcher(&quot;&#x2F;pages&#x2F;error&#x2F;403.html&quot;).forward(request,response);\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 判断是否为ajax请求\n     *&#x2F;\n    public static boolean isAjaxRequest(HttpServletRequest request) &#123;\n        return request.getHeader(&quot;accept&quot;).contains(&quot;application&#x2F;json&quot;)\n            || (request.getHeader(&quot;X-Requested-With&quot;) !&#x3D; null &amp;&amp; request.getHeader(&quot;X-Requested-With&quot;).equalsIgnoreCase(&quot;XMLHttpRequest&quot;));\n    &#125;\n&#125;</code></pre>\n\n<p>进行用户名回显（从 SecurityContextHolder.getContext() 中获取数据）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.controller;\n\nimport com.alibaba.dubbo.config.annotation.Reference;\nimport com.atguigu.constant.MessageConstant;\nimport com.atguigu.entity.Result;\nimport com.atguigu.service.UserService;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.core.userdetails.User;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n&#x2F;**\n * @author hrenxiang\n * @create 2021&#x2F;8&#x2F;3 20:51\n *&#x2F;\n@RestController\n@RequestMapping(&quot;&#x2F;user&quot;)\npublic class UserController &#123;\n    @Reference\n    private UserService userService;\n\n    &#x2F;&#x2F;获取当前登录用户的用户名\n    @RequestMapping(&quot;&#x2F;getUserName&quot;)\n    public Result getUsername() throws Exception &#123;\n        try &#123;\n            &#x2F;&#x2F;这里的User，是org.springframework.security.core.userdetails.User;\n            User user &#x3D; (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n            return new Result(true, MessageConstant.GET_USERNAME_SUCCESS, user);\n        &#125; catch (Exception e) &#123;\n            return new Result(false, MessageConstant.GET_USERNAME_FAIL);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n","text":":open_umbrella: 权限控制 1、认证和授权的概念前面我们已经完成了旅游后台管理系统的部分功能，例如自由行管理、跟团游管理、套餐管理、预约设置等。接下来我们需要思考2个问题： 问题1：在生产环境下我们如果不登录后台系统就可以完成这些功能操作吗？ 答案显然是否定的，要操...","link":"","photos":[],"count_time":{"symbolsCount":"41k","symbolsTime":"37 mins."},"categories":[{"name":"Spring","slug":"Spring","count":6,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":6,"path":"api/tags/Spring.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#open-umbrella-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">:open_umbrella: 权限控制</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1、认证和授权的概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%9D%83%E9%99%90%E6%A8%A1%E5%9D%97%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">2、权限模块的数据模型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%9D%83%E9%99%90%E6%A8%A1%E5%9D%97%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%89%A9%E5%B1%95\"><span class=\"toc-text\">3、权限模块数据模型的扩展</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E8%A1%A8%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">4、表之间关系</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#open-umbrella-Spring-Security\"><span class=\"toc-text\">:open_umbrella: Spring Security</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81Spring-Security%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">1、Spring Security简介</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81Spring-Security%E5%88%9D%E4%BD%93%E9%AA%8C\"><span class=\"toc-text\">2、Spring Security初体验</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81Spring-Security%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">3、Spring Security执行流程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">4、问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0%E5%AF%86%EF%BC%9F\"><span class=\"toc-text\">为什么要加密？</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E5%AF%86%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">加密方案</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#open-umbrella-%E2%80%8BSpring%E9%9B%86%E6%88%90-Spring-Security\"><span class=\"toc-text\">:open_umbrella: ​Spring集成 Spring Security</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E9%85%8D%E7%BD%AE%E5%8C%BF%E5%90%8D%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90\"><span class=\"toc-text\">1、配置匿名访问资源</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81form-login%E5%85%83%E7%B4%A0%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">2、form-login元素介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81form-login%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">3、form-login的几个属性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">4、使用数据库查询的信息</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%E3%80%81%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86\"><span class=\"toc-text\">5、密码加密解密</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6%E3%80%81%E9%85%8D%E7%BD%AE%E5%A4%9A%E7%A7%8D%E6%A0%A1%E9%AA%8C%E8%A7%84%E5%88%99%EF%BC%88%E5%AF%B9%E9%A1%B5%E9%9D%A2%EF%BC%89\"><span class=\"toc-text\">6、配置多种校验规则（对页面）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7%E3%80%81%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AF%B9%E7%B1%BB%EF%BC%89\"><span class=\"toc-text\">7、注解方式权限控制（对类）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8%E3%80%81logout%E9%80%80%E5%87%BA%E7%99%BB%E5%BD%95\"><span class=\"toc-text\">8、logout退出登录</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9%E3%80%81%E7%99%BB%E5%BD%95%E5%90%8E%E5%9B%9E%E6%98%BE%E7%94%A8%E6%88%B7%E5%90%8D\"><span class=\"toc-text\">9、登录后回显用户名</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10%E3%80%81403%E6%97%A0%E6%9D%83%E9%99%90%E5%BC%82%E5%B8%B8%E6%B6%88%E6%81%AF%E6%8F%90%E7%A4%BA\"><span class=\"toc-text\">10、403无权限异常消息提示</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#11%E3%80%81%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">11、总结</span></a></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"SpringSecurity 源码剖析","uid":"29737e157e321f39ed60992860349925","slug":"59-Spring Security-源码剖析","date":"2021-09-13T15:36:32.000Z","updated":"2021-09-15T10:47:39.755Z","comments":true,"path":"api/articles/59-Spring Security-源码剖析.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog5.jpg","text":"我们在 spring_security.xml 中配置过后，为什么权限框架就能做到这些权限管理的事情呢，背后的执行流程到底又是什么呢？ ==Spring Security Filter 并不是直接嵌入到 Web Filter 中的，而是通过 FilterChainProxy 来统...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"Spring","slug":"Spring","count":6,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":6,"path":"api/tags/Spring.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"ApachePOI 文档读写","uid":"fc61a710e2053b4421eaf30d8ac4fc38","slug":"57-ApachePOI-文档读写","date":"2021-09-13T15:34:32.000Z","updated":"2021-09-15T10:48:51.931Z","comments":true,"path":"api/articles/57-ApachePOI-文档读写.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog7.jpg","text":":whale: Apache POI基础 ① Apache POI简介Apache POI是一种流行的API，它允许程序员使用Java程序创建，修改和显示MS Office文件。这由Apache软件基金会开发使用Java分布式设计或修改Microsoft Office文件的开源库...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[{"name":"文档读写","slug":"文档读写","count":1,"path":"api/categories/文档读写.json"}],"tags":[{"name":"文档读写","slug":"文档读写","count":1,"path":"api/tags/文档读写.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}