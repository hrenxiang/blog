{"title":"Spring 面向切面编程","uid":"e2df2a86487823e0935863049b9742d3","slug":"50-Spring-面向切面编程","date":"2021-09-13T15:27:32.000Z","updated":"2021-09-15T10:50:56.442Z","comments":true,"path":"api/articles/50-Spring-面向切面编程.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog11.jpg","content":"<h3 id=\"1-AOP是什么\"><a href=\"#1-AOP是什么\" class=\"headerlink\" title=\"1. AOP是什么\"></a>1. AOP是什么</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>AOP是Aspect Oriented Programming的缩写，意思是：面向切面编程，它是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p>\n<p>可以认为AOP是对OOP(Object Oriented Programming 面向对象编程)的补充，主要使用在日志记录，性能统计，安全控制等场景，使用AOP可以使得业务逻辑各部分之间的耦合度降低，只专注于各自的业务逻辑实现，从而提高程序的可读性及维护性。</p>\n<p>比如，我们需要记录项目中所有对外接口的入参和出参，以便出现问题时定位原因，在每一个对外接口的代码中添加代码记录入参和出参当然也可以达到目的，但是这种硬编码的方式非常不友好，也不够灵活，而且记录日志本身和接口要实现的核心功能没有任何关系。</p>\n<p>此时，我们可以将记录日志的功能定义到1个切面中，然后通过声明的方式定义要在何时何地使用这个切面，而不用修改任何1个外部接口。</p>\n<p>在讲解具体的实现方式之前，我们先了解几个AOP中的术语。</p></blockquote>\n<hr>\n<h3 id=\"2-AOP核心概念\"><a href=\"#2-AOP核心概念\" class=\"headerlink\" title=\"2. AOP核心概念\"></a>2. AOP核心概念</h3><h4 id=\"2-1-通知-Advice\"><a href=\"#2-1-通知-Advice\" class=\"headerlink\" title=\"2.1 通知 (Advice)\"></a>2.1 通知 (Advice)</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在AOP术语中，切面要完成的工作被称为通知，通知定义了切面是什么以及何时使用。</p></blockquote>\n<p>Spring切面有5种类型的通知，分别是：</p>\n<ul>\n<li>前置通知(Before)：在目标方法被调用之前调用通知功能</li>\n<li>后置通知(After)：在目标方法完成调用的最后（finally）通知，此时不关心方法的输出结果是什么</li>\n<li>返回通知(After-returning)：在目标方法成功执行之后调用通知</li>\n<li>异常通知(After-throwing)：在目标方法抛出异常后调用通知</li>\n<li>环绕通知(Around)：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为</li>\n</ul>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/spring-aop-advice.png\" alt=\"image-20210713204100641\"></p>\n<h4 id=\"2-2-连接-Join-point\"><a href=\"#2-2-连接-Join-point\" class=\"headerlink\" title=\"2.2 连接 (Join point)\"></a>2.2 连接 (Join point)</h4><p><strong>连接点</strong>是在应用执行过程中能够插入切面的一个点，这个点可以是调用方法时、抛出异常时、修改某个字段时。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>插入通知的位置，Spring中的连接点肯定是一个方法。比如给Calculator的add()方法添加日志功能。add()就是一个连接点</p></blockquote>\n<h4 id=\"2-3-切点-Pointcut\"><a href=\"#2-3-切点-Pointcut\" class=\"headerlink\" title=\"2.3 切点 (Pointcut)\"></a>2.3 切点 (Pointcut)</h4><p>切点是为了缩小切面所通知的连接点的范围，即切面在何处执行。我们通常使用明确的类和方法名称，或者利用正则表达式定义所匹配的类和方法名称来指定切点。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>其实是一个表达式，指出了所有满足条件的连接点的完整路径。类似过滤器的过滤路径。execution(* com.spring.service.impl..(..))</p></blockquote>\n<h4 id=\"2-4-切面-Aspect\"><a href=\"#2-4-切面-Aspect\" class=\"headerlink\" title=\"2.4 切面 (Aspect)\"></a>2.4 切面 (Aspect)</h4><p>切面是通知和切点的结合。通知和切点共同定义了切面的全部内容：它是什么，在何时和何处完成其功能。</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/spring-aop-aspect.png\" alt=\"images\"></p>\n<h4 id=\"2-5-引入-Introduction\"><a href=\"#2-5-引入-Introduction\" class=\"headerlink\" title=\"2.5 引入 (Introduction)\"></a>2.5 引入 (Introduction)</h4><p>引入允许我们在不修改现有类的基础上，向现有类添加新方法或属性。</p>\n<h4 id=\"2-6-织入-Weaving\"><a href=\"#2-6-织入-Weaving\" class=\"headerlink\" title=\"2.6 织入 (Weaving)\"></a>2.6 织入 (Weaving)</h4><p>织入是把切面应用到目标对象并创建新的代理对象的过程。</p>\n<p>切面在指定的连接点被织入到目标对象中，在目标对象的生命周期里，有以下几个点可以进行织入：</p>\n<ul>\n<li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li>\n<li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器(ClassLoader)，它可以在目标类被引入应用之前增强该目标类的字节码。</li>\n<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。</li>\n</ul>\n<h4 id=\"2-7-目标-代理\"><a href=\"#2-7-目标-代理\" class=\"headerlink\" title=\"2.7 目标 代理\"></a>2.7 目标 代理</h4><p>target: 被代理的对象</p>\n<p>proxy: 添加了通知以后的目标</p>\n<hr>\n<h3 id=\"3-代理选择\"><a href=\"#3-代理选择\" class=\"headerlink\" title=\"3. 代理选择\"></a>3. 代理选择</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Spring 实现AOP 思想使用的是动态代理技术</p>\n<ul>\n<li><p>默认情况下</p>\n<p>如果 被代理类 <strong>实现接口</strong> ⇒ 选择 JDK 动态代理</p>\n<p>否则 ⇒ 选择 CGLIB 动态代理</p>\n</li>\n<li><p>可通过配置方式设置强制使用 CGLIB 动态代理</p>\n</li>\n</ul></blockquote>\n<h4 id=\"3-1-What-代理\"><a href=\"#3-1-What-代理\" class=\"headerlink\" title=\"3.1 What 代理\"></a>3.1 What 代理</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类<strong>间接</strong>调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——<strong>解耦</strong>。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。</p></blockquote>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/spring-aop-proxy.png\" alt=\"images\"></p>\n<h4 id=\"3-1-静态代理\"><a href=\"#3-1-静态代理\" class=\"headerlink\" title=\"3.1 静态代理\"></a>3.1 静态代理</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>要想采用静态代理方式，需要具备以下条件：<br>1.目标类具有接口，并实现了其接口。<br>2.代理类也得实现目标类的接口，并有一个属性是目标类接口。<br>3.代理类的得有一个无参构造方法和一个构造方法，参数为目标类接口类型，用于接收目标对象赋值给代理类的目标类接口属性。<br>4.代理类必须实现接口的所有方法，并在在方法中访问目标类对象的方法，在访问之前和之后都可以进行一些代理操作。</p></blockquote>\n<p>代码实现（接口，实现类，代理类，测试）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Calculator &#123;\n    void abc();\n    int add(int i, int j);\n    int sub(int i, int j);\n    int mul(int i, int j);\n    int div(int i, int j);\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CalculatorPureImpl implements Calculator &#123;\n    @Override\n    public void abc() &#123;\n        System.out.println(&quot;abc&quot;);\n    &#125;\n\n    @Override\n    public int add(int i, int j) &#123;\n        int result &#x3D; i + j;\n        System.out.println(&quot;方法内部 result &#x3D; &quot; + result);\n        return result;\n    &#125;\n\t... ...\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class StaticProxy implements Calculator&#123;\n    private CalculatorPureImpl target;\n    \n    public StaticProxy(CalculatorPureImpl target) &#123;\n        this.target &#x3D; target;\n    &#125;\n\n    public void before(int i,int j)&#123;\n        System.out.println(&quot;静态代理 -- 计算数字前：&quot;+i+&quot;、&quot;+j);\n    &#125;\n\n    public void after()&#123;\n        System.out.println(&quot;静态代理 -- 计算数字后：successful&quot;);\n    &#125;\n\n    @Override\n    public void abc() &#123;\n        before(1,1);\n        after();\n    &#125;\n\n    @Override\n    public int add(int i, int j) &#123;\n        before(i,j);\n        int result &#x3D; this.target.add(i, j);\n        after();\n        return result;\n    &#125;\n    ... ...\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Test\npublic void test()&#123;\n    StaticProxy staticProxy &#x3D; new StaticProxy(new CalculatorPureImpl());\n    staticProxy.abc();\n    staticProxy.add(10,20);\n    staticProxy.div(10,2);\n&#125;\n\n&#x2F;* 结果\n静态代理 -- 计算数字前：1、1\n静态代理 -- 计算数字后：successful\n\n静态代理 -- 计算数字前：10、20\n方法内部 result &#x3D; 30\n静态代理 -- 计算数字后：successful\n\n静态代理 -- 计算数字前：10、2\n方法内部 result &#x3D; 5\n静态代理 -- 计算数字后：successful*&#x2F;</code></pre>\n\n<p><strong>静态代理的优缺点</strong></p>\n<ol>\n<li><p>优点</p>\n<p>静态代理对客户（测试类）隐藏了被代理类接口（目标类接口）的具体实现类，在一定程度上实现了解耦合，同时提高了安全性！</p>\n</li>\n<li><p>缺点</p>\n<p>静态代理类需要实现目标类（被代理类）的接口，并实现其方法，造成了代码的大量冗余。</p>\n<p>静态代理只能对某个固定接口的实现类进行代理服务，其灵活性不强。故一般大项目不会选择静态代理</p>\n</li>\n</ol>\n<h4 id=\"3-2-动态代理\"><a href=\"#3-2-动态代理\" class=\"headerlink\" title=\"3.2 动态代理\"></a>3.2 动态代理</h4><h5 id=\"3-2-1-JDK-动态代理\"><a href=\"#3-2-1-JDK-动态代理\" class=\"headerlink\" title=\"3.2.1 JDK 动态代理\"></a>3.2.1 JDK 动态代理</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>动态代理能够实现代理类<strong>无需和被代理类直接关联</strong>，但是动态代理类<strong>必须实现Invocation接口，并且实现invoke() 方法</strong>，在invoke()方法中需要完成两件事情：一是添加服务，二是调用业务逻辑方法。代理服务就是在代理类中的invoke中执行的。我们可以通过反射机制获取目标对象的加载类、接口，还有实现了Invocation接口的代理类传到**Proxy.newProxyInstance(被代理类，被代理类接口，代理类)**方法中获取到代理类的对象实例。</p></blockquote>\n<p>代码实现（接口，实现类，代理类，测试）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Calculator &#123;\n    void abc();\n    int add(int i, int j);\n    int sub(int i, int j);\n    int mul(int i, int j);\n    int div(int i, int j);\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CalculatorPureImpl implements Calculator &#123;\n    @Override\n    public void abc() &#123;\n        System.out.println(&quot;abc&quot;);\n    &#125;\n\n    @Override\n    public int add(int i, int j) &#123;\n        int result &#x3D; i + j;\n        System.out.println(&quot;方法内部 result &#x3D; &quot; + result);\n        return result;\n    &#125;\n\t... ...\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class DynamicProxy&lt;T&gt; &#123;\n\n    private T target;\n\n    public DynamicProxy(T target) &#123;\n        this.target &#x3D; target;\n    &#125;\n\n    public T getProxy() &#123;\n\n        ClassLoader classLoader &#x3D; this.target.getClass().getClassLoader();\n\n        Class&lt;?&gt;[] interfaces &#x3D; this.target.getClass().getInterfaces();\n\n        InvocationHandler handler &#x3D; new InvocationHandler() &#123;\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n\n                String methodName &#x3D; method.getName();\n                Object result &#x3D; null;\n                try &#123;\n                    System.out.println(&quot;前置：&quot; + methodName);\n                    result &#x3D; method.invoke(target, args);\n                    System.out.println(&quot;完成：&quot; + methodName);\n                &#125; catch (Exception e) &#123;\n                    e.printStackTrace();\n                    System.out.println(&quot;异常：&quot; + methodName);\n                &#125; finally &#123;\n                    System.out.println(&quot;后置：&quot; + methodName);\n                &#125;\n\n                return result;\n            &#125;\n        &#125;;\n\n        T proxy &#x3D; (T) Proxy.newProxyInstance(classLoader, interfaces, handler);\n        return proxy;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Test\npublic void testDemo2()&#123;\n        DynamicProxy&lt;CalculatorPureImpl&gt; proxy &#x3D; new DynamicProxy&lt;&gt;(new CalculatorPureImpl());\n        Calculator proxy1 &#x3D; proxy.getProxy();\n\n        proxy1.add(10,20);\n&#125;\n\n&#x2F;* 结果\n前置：add\n方法内部 result &#x3D; 30\n完成：add\n后置：add*&#x2F;</code></pre>\n\n<p><strong>JDK动态代理的优缺点</strong></p>\n<p>1.优点</p>\n<ul>\n<li>动态代理实现了只需要将被代理对象作为参数传入代理类就可以获取代理类对象，从而实现类代理，具有较强的灵活性。</li>\n<li>动态代理的服务内容不需要像静态代理一样写在每个代码块中，只需要写在invoke()方法中即可，降低了代码的冗余度。</li>\n</ul>\n<p>2.缺点</p>\n<ul>\n<li>动态代理类仍然需要实现接口。</li>\n</ul>\n<h5 id=\"3-2-2-CGLIB-动态代理\"><a href=\"#3-2-2-CGLIB-动态代理\" class=\"headerlink\" title=\"3.2.2 CGLIB 动态代理\"></a>3.2.2 CGLIB 动态代理</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>“代理”的目的是构造一个和被代理的对象有同样行为的对象，一个对象的行为是在类中定义的，对象只是类的实例。所以构造代理，不一定非得通过持有、包装对象这一种方式。</p>\n<p><strong>通过“继承”</strong>可以继承父类所有的公开方法，然后可以重写这些方法，在重写时对这些方法增强，这就是cglib的思想。根据里氏代换原则（LSP），父类需要出现的地方，子类可以出现，所以cglib实现的代理也是可以被正常使用的</p></blockquote>\n<h4 id=\"3-3-AOP-中Bean的代理\"><a href=\"#3-3-AOP-中Bean的代理\" class=\"headerlink\" title=\"3.3 AOP 中Bean的代理\"></a>3.3 AOP 中Bean的代理</h4><p>第一种：具有接口，且实现了接口需要注入的Bean</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Calculator &#123;\n    void abc();\n    int add(int i, int j);\n    int sub(int i, int j);\n    int mul(int i, int j);\n    int div(int i, int j);\n&#125;\n\n@Component\npublic class CalculatorImpl implements Calculator &#123;\n    @Override\n    public void abc() &#123;\n        System.out.println(&quot;abc&quot;);\n    &#125;\n    \n    @Override\n    public int add(int i, int j) &#123;\n        int result &#x3D; i + j;\n        System.out.println(&quot;方法内部 result &#x3D; &quot; + result);\n        return result;\n    &#125;\n\t... ...\n&#125;</code></pre>\n\n<p>第二种：没有接口，需要注入的Bean</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\npublic class Happy &#123;\n    public void doWork() &#123;\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;HappyComponentDaoImpl&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p>测试代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ContextConfiguration(value &#x3D; &#123;&quot;classpath:applicationContext.xml&quot;&#125;)\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class EnableAspect &#123;\n    @Autowired\n    private Calculator calculator;\n    \n    @Autowired\n    private Happy happy;\n    \n    @Test\n    public void testDemo1()&#123;\n        calculator.add(10,20);\n        System.out.println();\n        happy.doWork();\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"C:\\Users\\john\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210714205102527.png\" alt=\"image-20210714205102527\"></p>\n<h4 id=\"3-4-代理知识总结\"><a href=\"#3-4-代理知识总结\" class=\"headerlink\" title=\"3.4 代理知识总结\"></a>3.4 代理知识总结</h4><p>Spring 在运行期， 生成动态代理对象， 不需要特殊的编译器<br>Spring AOP 的底层就是通过 JDK 动态代理或 CGLib 动态代理技术 为目标Bean 执行横向织入</p>\n<ul>\n<li><p>1.若目标对象实现了若干接口， spring 使用 JDK 的 <code>java.lang.reflect.Proxy</code> 类代理。</p>\n</li>\n<li><p>2.若目标对象没有实现任何接口， spring 使用 CGLIB 库生成目标对象的子类。</p>\n</li>\n<li><p>程序中应优先对接口创建代理， 便于程序解耦维护</p>\n</li>\n<li><p>标记为 final 的方法， 不能被代理， 因为无法进行覆盖</p>\n</li>\n<li><p>JDK 动态代理， 是针对接口生成子类， 接口中方法不能使用 final 修饰</p>\n</li>\n<li><p>CGLib 是针对目标类生产子类， 因此类或方法 不能使 final 的</p>\n</li>\n<li><p>Spring 只支持方法连接点， 不提供属性连接</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"4-AOP基于注解的实现\"><a href=\"#4-AOP基于注解的实现\" class=\"headerlink\" title=\"4. AOP基于注解的实现\"></a>4. AOP基于注解的实现</h3><h4 id=\"4-1-初步实现\"><a href=\"#4-1-初步实现\" class=\"headerlink\" title=\"4.1 初步实现\"></a>4.1 初步实现</h4><p>添加依赖</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-aspects&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.3.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>准备被代理的资源</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Calculator &#123;\n    void abc();\n    int add(int i, int j);\n    int sub(int i, int j);\n    int mul(int i, int j);\n    int div(int i, int j);\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@component(value&#x3D;&quot;calculator1&quot;)\npublic class CalculatorPureImpl implements Calculator &#123;\n    @Override\n    public void abc() &#123;\n        System.out.println(&quot;abc&quot;);\n    &#125;\n\n    @Override\n    public int add(int i, int j) &#123;\n        int result &#x3D; i + j;\n        System.out.println(&quot;方法内部 result &#x3D; &quot; + result);\n        return result;\n    &#125;\n\t... ...\n&#125;</code></pre>\n\n<p>创建切面类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@org.aspectj.lang.annotation.Aspect\n@Component\npublic class Aspect &#123;\n    @Before(value &#x3D; &quot;execution(public int com.hrenxiang.calculator.CalculatorPureImpl.*(..))&quot;)\n    public void beforeLog()&#123;\n        System.out.println(&quot;[AOP前置通知] 方法开始了&quot;);\n    &#125;\n\n    @After(value &#x3D; &quot;execution(public int com.hrenxiang.calculator.CalculatorPureImpl.*(..))&quot;)\n    public void afterLog()&#123;\n        System.out.println(&quot;[AOP后置通知] 方法最终结束了&quot;);\n    &#125;\n\n    @AfterReturning(value &#x3D; &quot;execution(public int com.hrenxiang.calculator.CalculatorPureImpl.*(..))&quot;)\n    public void afterReturningLog()&#123;\n        System.out.println(&quot;[AOP正常运行结束] 方法结束了&quot;);\n    &#125;\n\n    @AfterThrowing(value &#x3D; &quot;execution(public int com.hrenxiang.calculator.CalculatorPureImpl.*(..))&quot;)\n    public void afterThrowingLog()&#123;\n        System.out.println(&quot;[AOP运行异常结束了] 方法结束了了&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p>测试</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ContextConfiguration(value &#x3D; &#123;&quot;classpath:applicationContext.xml&quot;&#125;)\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class TestCalculator &#123;\n\n    @Autowired\n    @Qualifier(value &#x3D; &quot;calculator1&quot;)\n    private Calculator calculator;\n\n    @Test\n    public void testDemo()&#123;\n        calculator.add(10,20);\n\n        System.out.println(&quot;\\n&quot;);\n\n        &#x2F;*calculator.div(10,0);*&#x2F;\n        calculator.sub(100,500);\n\n        System.out.println(&quot;\\n&quot;);\n\n        calculator.abc();\n    &#125;\n    \n&#x2F;*结果\n[AOP前置通知] 方法开始了\n方法内部 result &#x3D; 30\n[AOP正常运行结束] 方法结束了\n[AOP后置通知] 方法最终结束了\n\n\n[AOP前置通知] 方法开始了\n方法内部 result &#x3D; -400\n[AOP正常运行结束] 方法结束了\n[AOP后置通知] 方法最终结束了\n\n\nabc*&#x2F;</code></pre>\n\n<h4 id=\"4-2-通知执行顺序\"><a href=\"#4-2-通知执行顺序\" class=\"headerlink\" title=\"4.2 通知执行顺序\"></a>4.2 通知执行顺序</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">通知执行顺序\nSpring版本5.3.x以前：\n\n前置通知\n目标操作\n后置通知\n返回通知或异常通知\nSpring版本5.3.x以后：\n\n前置通知\n目标操作\n返回通知或异常通知\n后置通知</code></pre>\n\n<hr>\n<h3 id=\"5-AOP获取细节信息\"><a href=\"#5-AOP获取细节信息\" class=\"headerlink\" title=\"5. AOP获取细节信息\"></a>5. AOP获取细节信息</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 在前置通知方法形参位置声明一个JoinPoint类型的参数，Spring就会将这个对象传入\n@Before(value &#x3D; &quot;execution(public int com.hrenxiang.calculator.CalculatorPureImpl.*(..))&quot;)\npublic void beforeLog(JoinPoint joinPoint)&#123;\n\n        &#x2F;&#x2F; 0.通过JoinPoint对象获取外界调用目标方法时传入的实参列表\n        Object[] args &#x3D; joinPoint.getArgs();\n        System.out.println(Arrays.toString(args));\n\n        String kind &#x3D; joinPoint.getKind();\n        System.out.println(kind);\n\n        String s &#x3D; joinPoint.toString();\n        System.out.println(s);\n\n        &#x2F;&#x2F; 1.通过JoinPoint对象获取目标方法签名对象\n        &#x2F;&#x2F; 方法的签名：一个方法的全部声明信息\n        Signature signature &#x3D; joinPoint.getSignature();\n        System.out.println(signature);\n        &#x2F;&#x2F; 2.获取声明的类型\n        Class declaringType &#x3D; signature.getDeclaringType();\n\n        String declaringTypeName &#x3D; signature.getDeclaringTypeName();\n        int modifiers &#x3D; signature.getModifiers();\n        System.out.println(declaringType+&quot;,&quot;+declaringTypeName+&quot;,&quot;+modifiers);\n        &#x2F;&#x2F; 3.通过方法的签名对象获取目标方法的详细信息\n        String methodName &#x3D; signature.getName();\n        System.out.println(&quot;methodName &#x3D; &quot; + methodName);\n\n        SourceLocation sourceLocation &#x3D; joinPoint.getSourceLocation();\n        System.out.println(sourceLocation);\n\n        Object target &#x3D; joinPoint.getTarget();\n        System.out.println(target);\n\n        System.out.println(&quot;[AOP前置通知] 方法开始了&quot;);\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">[10, 20]\nmethod-execution\nexecution(int com.hrenxiang.calculator.Calculator.add(int,int))\nint com.hrenxiang.calculator.Calculator.add(int,int)\ninterface com.hrenxiang.calculator.Calculator,com.hrenxiang.calculator.Calculator,1025\norg.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint$SourceLocationImpl@290222c1\ncom.hrenxiang.calculator.CalculatorPureImpl@67f639d3\n[AOP前置通知] 方法开始了\n\n&#x2F;*方法内部 result &#x3D; 30\n[AOP正常运行结束] 方法结束了\n[AOP后置通知] 方法最终结束了*&#x2F;</code></pre>\n\n<h4 id=\"5-1-方法返回值\"><a href=\"#5-1-方法返回值\" class=\"headerlink\" title=\"5.1 方法返回值\"></a>5.1 方法返回值</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@AfterReturning(\n    value &#x3D; &quot;execution(public int com.hrenxiang.calculator.CalculatorPureImpl.*(..))&quot;,\n    returning &#x3D; &quot;returnValue&quot;)\n\n    public void afterReturningLog(JoinPoint joinPoint , Object returnValue)&#123;\n\n        System.out.println(&quot;[AOP正常运行结束] 方法结束了&quot;+&quot;返回值：&quot;+returnValue);\n    &#125;\n\n[AOP正常运行结束] 方法结束了返回值：30</code></pre>\n\n<h4 id=\"5-2-目标方法抛出异常\"><a href=\"#5-2-目标方法抛出异常\" class=\"headerlink\" title=\"5.2 目标方法抛出异常\"></a>5.2 目标方法抛出异常</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@AfterThrowing(\n\tvalue &#x3D; &quot;execution(public int com.hrenxiang.calculator.CalculatorPureImpl.*(..))&quot;,\n\tthrowing &#x3D; &quot;throwInfo&quot;)\n\t\n    public void afterThrowingLog(Throwable throwInfo)&#123;\n        System.out.println(&quot;[AOP运行异常结束了] 方法结束了了&quot;+&quot;,异常原因：&quot;+throwInfo);\n    &#125;\n\n@ContextConfiguration(value &#x3D; &#123;&quot;classpath:applicationContext.xml&quot;&#125;)\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class TestCalculator &#123;\n\n    @Autowired\n    @Qualifier(value &#x3D; &quot;calculator1&quot;)\n    private Calculator calculator;\n\n    @Test\n    public void testDemo()&#123;\n        calculator.div(10,0);\n    &#125;\n&#125;\n\n[AOP前置通知] 方法开始了\n[AOP运行异常结束了] 方法结束了了,异常原因：java.lang.ArithmeticException: &#x2F; by zero\n[AOP后置通知] 方法最终结束了</code></pre>\n\n<h4 id=\"5-3-重用切入表达式\"><a href=\"#5-3-重用切入表达式\" class=\"headerlink\" title=\"5.3 重用切入表达式\"></a>5.3 重用切入表达式</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在一处声明切入点表达式之后，其他有需要的地方引用这个切入点表达式。易于维护，一处修改，处处生效</p>\n<p>而作为存放切入点表达式的类，可以把整个项目中所有切入点表达式全部集中过来，便于统一管理</p></blockquote>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class pointcuts &#123;\n    @Pointcut(value &#x3D; &quot;execution(* *.*.*.*.*(..))&quot;)\n    public void declarePointCut() &#123;&#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Before(value &#x3D; &quot;com.hrenxiang.config.pointcuts.declarePointCut()&quot;)\n    public void beforeLog()&#123;\n        System.out.println(&quot;[AOP前置通知] 方法开始了&quot;);\n    &#125;</code></pre>\n\n<h3 id=\"6-表达式语法细节\"><a href=\"#6-表达式语法细节\" class=\"headerlink\" title=\"6. 表达式语法细节\"></a>6. 表达式语法细节</h3><ul>\n<li>用*<strong>号代替“权限修饰符”和“返回值”</strong>部分表示“权限修饰符”和“返回值”不限</li>\n<li>在包名的部分，一个“*”号只能代表包的层次结构中的一层，表示这一层是任意的。<ul>\n<li>例如：***.Hello匹配com.Hello，不匹配com.atguigu.Hello**</li>\n</ul>\n</li>\n<li>在包名的部分，使用“***..”表示包名任意、包的层次深度任意**</li>\n<li>在类名的部分，类名部分整体用*号代替，表示类名任意</li>\n<li>在类名的部分，可以使用*<strong>号代替类名的一部分</strong></li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">*Service</code></pre>\n\n<p>上面例子表示匹配所有名称以Service结尾的类或接口</p>\n<ul>\n<li>在方法名部分，可以使用*<strong>号表示方法名任意</strong></li>\n<li>在方法名部分，可以使用*<strong>号代替方法名的一部分</strong></li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">*Operation</code></pre>\n\n<p>上面例子表示匹配所有方法名以Operation结尾的方法</p>\n<ul>\n<li>在方法参数列表部分，使用**(..)表示参数列表任意**</li>\n<li>在方法参数列表部分，使用**(int,..)表示参数列表以一个int类型的参数开头**</li>\n<li>在方法参数列表部分，基本数据类型和对应的包装类型是不一样的<ul>\n<li><strong>切入点表达式中使用 int 和实际方法中 Integer 是不匹配的</strong></li>\n</ul>\n</li>\n<li>在方法返回值部分，<strong>如果想要明确指定一个返回值类型，那么必须同时写明权限修饰符</strong></li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">execution(public int *..*Service.*(.., int))</code></pre>\n\n<p>上面例子是对的，下面例子是错的：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">execution(* int *..*Service.*(.., int))</code></pre>\n\n<p>但是public *表示权限修饰符明确，返回值任意是可以的。</p>\n<ul>\n<li>对于execution()表达式整体<strong>可以使用三个逻辑运算符号</strong><ul>\n<li>execution() || execution()表示满足两个execution()中的任何一个即可</li>\n<li>execution() &amp;&amp; execution()表示两个execution()表达式必须都满足</li>\n<li>!execution()表示不满足表达式的其他方法</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/spring-aop-pointcutDetail.png\" alt=\"images\"></p>\n<hr>\n<h3 id=\"7-环绕通知\"><a href=\"#7-环绕通知\" class=\"headerlink\" title=\"7. 环绕通知\"></a>7. 环绕通知</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>环绕通知对应整个try…catch…finally结构，包括前面四种通知的所有功能。</p></blockquote>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\n&#x2F;&#x2F; 使用@Around注解标明环绕通知方法\n@Around(value &#x3D; &quot;com.atguigu.aop.aspect.AtguiguPointCut.transactionPointCut()&quot;)\npublic Object manageTransaction(\n    \n        &#x2F;&#x2F; 通过在通知方法形参位置声明ProceedingJoinPoint类型的形参，\n        &#x2F;&#x2F; Spring会将这个类型的对象传给我们\n        ProceedingJoinPoint joinPoint) &#123;\n    \n    &#x2F;&#x2F; 通过ProceedingJoinPoint对象获取外界调用目标方法时传入的实参数组\n    Object[] args &#x3D; joinPoint.getArgs();\n    \n    &#x2F;&#x2F; 通过ProceedingJoinPoint对象获取目标方法的签名对象\n    Signature signature &#x3D; joinPoint.getSignature();\n    \n    &#x2F;&#x2F; 通过签名对象获取目标方法的方法名\n    String methodName &#x3D; signature.getName();\n    \n    &#x2F;&#x2F; 声明变量用来存储目标方法的返回值\n    Object targetMethodReturnValue &#x3D; null;\n    \n    try &#123;\n    \n        &#x2F;&#x2F; 在目标方法执行前：开启事务（模拟）\n        System.out.println(&quot;[AOP 环绕通知] 开启事务，方法名：&quot; + methodName + &quot;，参数列表：&quot; + Arrays.asList(args));\n    \n        &#x2F;&#x2F; 过ProceedingJoinPoint对象调用目标方法\n        &#x2F;&#x2F; 目标方法的返回值一定要返回给外界调用者\n        targetMethodReturnValue &#x3D; joinPoint.proceed(args);\n    \n        &#x2F;&#x2F; 在目标方法成功返回后：提交事务（模拟）\n        System.out.println(&quot;[AOP 环绕通知] 提交事务，方法名：&quot; + methodName + &quot;，方法返回值：&quot; + targetMethodReturnValue);\n    \n    &#125;catch (Throwable e)&#123;\n    \n        &#x2F;&#x2F; 在目标方法抛异常后：回滚事务（模拟）\n        System.out.println(&quot;[AOP 环绕通知] 回滚事务，方法名：&quot; + methodName + &quot;，异常：&quot; + e.getClass().getName());\n    \n    &#125;finally &#123;\n    \n        &#x2F;&#x2F; 在目标方法最终结束后：释放数据库连接\n        System.out.println(&quot;[AOP 环绕通知] 释放数据库连接，方法名：&quot; + methodName);\n    \n    &#125;\n    \n    return targetMethodReturnValue;\n&#125;</code></pre>\n\n<hr>\n<h3 id=\"8-切面的优先级\"><a href=\"#8-切面的优先级\" class=\"headerlink\" title=\"8. 切面的优先级\"></a>8. 切面的优先级</h3><p>相同目标方法上同时存在多个切面时，切面的优先级控制切面的<strong>内外嵌套</strong>顺序。</p>\n<ul>\n<li>优先级高的切面：外面</li>\n<li>优先级低的切面：里面</li>\n</ul>\n<p>使用@Order注解可以控制切面的优先级：</p>\n<ul>\n<li>@Order(较小的数)：优先级高</li>\n<li>@Order(较大的数)：优先级低</li>\n</ul>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/spring-aop-aspect2.png\" alt=\"image-20210714210352907\" style=\"zoom:40%;\" />\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/spring-aop-aspect3.png\" alt=\"images\" style=\"zoom:40%;\" />\n</div>\n\n<p>实际开发时，如果有多个切面嵌套的情况，要慎重考虑。例如：如果事务切面优先级高，那么在缓存中命中数据的情况下，事务切面的操作都浪费了。</p>\n<img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/spring-aop-aspect4.png\" alt=\"image-20210714210841431\"  />\n\n<hr>\n<h3 id=\"9-AOP对IOC-DI影响\"><a href=\"#9-AOP对IOC-DI影响\" class=\"headerlink\" title=\"9. AOP对IOC DI影响\"></a>9. AOP对IOC DI影响</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>IOC 是控制反转 DI是依赖注入</p></blockquote>\n<p>没有使用AOP之前</p>\n<p>​        有接口的实现类：如果实现类唯一，按照接口和实现类都可以拿到</p>\n<p>​        没有接口的类：按照类名可以拿到</p>\n<p>使用了AOP之后</p>\n<p>​        <strong>有接口的实现类</strong>：如果实现类唯一，<strong>按照接口</strong>可以拿到，按照<strong>实现类拿不到</strong></p>\n<p>​        没有接口的类：按照类名依旧可以拿到</p>\n<p><strong>原因</strong></p>\n<p>有接口的，aop底层使用 jdk动态代理，采用实现接口的形式代理，因为jdk动态代理直接继承了Proxy，java中是单继承，所以和被代理类接实现类没有直接关系</p>\n<p>没有接口的，aop底层使用CGLIB动态代理，CGLIB直接继承了被代理类</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/spring-aop-ioc.png\" alt=\"image-20210714211718716\"></p>\n<hr>\n<h3 id=\"10-AOP基于XML的实现\"><a href=\"#10-AOP基于XML的实现\" class=\"headerlink\" title=\"10. AOP基于XML的实现\"></a>10. AOP基于XML的实现</h3><pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!-- 配置目标类的bean --&gt;\n&lt;bean id&#x3D;&quot;calculatorPure&quot; class&#x3D;&quot;com.atguigu.aop.imp.CalculatorPureImpl&quot;&#x2F;&gt;\n    \n&lt;!-- 配置切面类的bean --&gt;\n&lt;bean id&#x3D;&quot;logAspect&quot; class&#x3D;&quot;com.atguigu.aop.aspect.LogAspect&quot;&#x2F;&gt;\n    \n&lt;!-- 配置AOP --&gt;\n&lt;aop:config&gt;\n    \n    &lt;!-- 配置切入点表达式 --&gt;\n    &lt;aop:pointcut id&#x3D;&quot;logPointCut&quot; expression&#x3D;&quot;execution(* *..*.*(..))&quot;&#x2F;&gt;\n    \n    &lt;!-- aop:aspect标签：配置切面 --&gt;\n    &lt;!-- ref属性：关联切面类的bean --&gt;\n    &lt;aop:aspect ref&#x3D;&quot;logAspect&quot;&gt;\n        &lt;!-- aop:before标签：配置前置通知 --&gt;\n        &lt;!-- method属性：指定前置通知的方法名 --&gt;\n        &lt;!-- pointcut-ref属性：引用切入点表达式 --&gt;\n        &lt;aop:before method&#x3D;&quot;printLogBeforeCore&quot; pointcut-ref&#x3D;&quot;logPointCut&quot;&#x2F;&gt;\n    \n        &lt;!-- aop:after-returning标签：配置返回通知 --&gt;\n        &lt;!-- returning属性：指定通知方法中用来接收目标方法返回值的参数名 --&gt;\n        &lt;aop:after-returning\n                method&#x3D;&quot;printLogAfterCoreSuccess&quot;\n                pointcut-ref&#x3D;&quot;logPointCut&quot;\n                returning&#x3D;&quot;targetMethodReturnValue&quot;&#x2F;&gt;\n    \n        &lt;!-- aop:after-throwing标签：配置异常通知 --&gt;\n        &lt;!-- throwing属性：指定通知方法中用来接收目标方法抛出异常的异常对象的参数名 --&gt;\n        &lt;aop:after-throwing\n                method&#x3D;&quot;printLogAfterCoreException&quot;\n                pointcut-ref&#x3D;&quot;logPointCut&quot;\n                throwing&#x3D;&quot;targetMethodException&quot;&#x2F;&gt;\n    \n        &lt;!-- aop:after标签：配置后置通知 --&gt;\n        &lt;aop:after method&#x3D;&quot;printLogCoreFinallyEnd&quot; pointcut-ref&#x3D;&quot;logPointCut&quot;&#x2F;&gt;\n    \n        &lt;!-- aop:around标签：配置环绕通知 --&gt;\n        &lt;!--&lt;aop:around method&#x3D;&quot;……&quot; pointcut-ref&#x3D;&quot;logPointCut&quot;&#x2F;&gt;--&gt;\n    &lt;&#x2F;aop:aspect&gt;\n    \n&lt;&#x2F;aop:config&gt;</code></pre>\n\n","text":"1. AOP是什么 AOP是Aspect Oriented Programming的缩写，意思是：面向切面编程，它是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 可以认为AOP是对OOP(Object Oriented Programming 面向对象编程)的...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"Spring","slug":"Spring","count":6,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":6,"path":"api/tags/Spring.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-AOP%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">1. AOP是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-AOP%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">2. AOP核心概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-%E9%80%9A%E7%9F%A5-Advice\"><span class=\"toc-text\">2.1 通知 (Advice)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-%E8%BF%9E%E6%8E%A5-Join-point\"><span class=\"toc-text\">2.2 连接 (Join point)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-%E5%88%87%E7%82%B9-Pointcut\"><span class=\"toc-text\">2.3 切点 (Pointcut)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-4-%E5%88%87%E9%9D%A2-Aspect\"><span class=\"toc-text\">2.4 切面 (Aspect)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-5-%E5%BC%95%E5%85%A5-Introduction\"><span class=\"toc-text\">2.5 引入 (Introduction)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-6-%E7%BB%87%E5%85%A5-Weaving\"><span class=\"toc-text\">2.6 织入 (Weaving)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-7-%E7%9B%AE%E6%A0%87-%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">2.7 目标 代理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BB%A3%E7%90%86%E9%80%89%E6%8B%A9\"><span class=\"toc-text\">3. 代理选择</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-What-%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">3.1 What 代理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">3.1 静态代理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">3.2 动态代理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-2-1-JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">3.2.1 JDK 动态代理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-2-2-CGLIB-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">3.2.2 CGLIB 动态代理</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-3-AOP-%E4%B8%ADBean%E7%9A%84%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">3.3 AOP 中Bean的代理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-4-%E4%BB%A3%E7%90%86%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">3.4 代理知识总结</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-AOP%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">4. AOP基于注解的实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-1-%E5%88%9D%E6%AD%A5%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">4.1 初步实现</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-2-%E9%80%9A%E7%9F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">4.2 通知执行顺序</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-AOP%E8%8E%B7%E5%8F%96%E7%BB%86%E8%8A%82%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">5. AOP获取细节信息</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">5.1 方法返回值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-2-%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">5.2 目标方法抛出异常</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-3-%E9%87%8D%E7%94%A8%E5%88%87%E5%85%A5%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">5.3 重用切入表达式</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82\"><span class=\"toc-text\">6. 表达式语法细节</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5\"><span class=\"toc-text\">7. 环绕通知</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E5%88%87%E9%9D%A2%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">8. 切面的优先级</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-AOP%E5%AF%B9IOC-DI%E5%BD%B1%E5%93%8D\"><span class=\"toc-text\">9. AOP对IOC DI影响</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-AOP%E5%9F%BA%E4%BA%8EXML%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">10. AOP基于XML的实现</span></a></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"Spring 声明式事务","uid":"a69a9b95a293fad60680e3e8965ab8da","slug":"51-Spirng-声明式事务","date":"2021-09-13T15:28:32.000Z","updated":"2021-09-15T10:50:45.764Z","comments":true,"path":"api/articles/51-Spirng-声明式事务.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"1、JdbcTemplate Spring提供了整合JDBC的JDBCTemplate，先有Spring，再出现MyBatis，所以整合包不是Spring提供的，而是第三方提供的。 JDBCTemplate和MyBatis共同点：都是对JDBC进行了封装 不同点：肯定是MyBat...","link":"","photos":[],"count_time":{"symbolsCount":"30k","symbolsTime":"27 mins."},"categories":[{"name":"Spring","slug":"Spring","count":6,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":6,"path":"api/tags/Spring.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"Spring 基础和IOC","uid":"8ec558949bfff1ff48dc8dd0d9de915c","slug":"49-Spring-基础与IOC","date":"2021-09-13T15:26:32.000Z","updated":"2021-09-15T10:51:05.577Z","comments":true,"path":"api/articles/49-Spring-基础与IOC.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog10.jpg","text":"01. Spring框架简介 Spring 框架是一个 Java 平台，为开发 Java 应用程序提供全面的基础架构支持。 Spring 处理基础结构，因此您可以专注于应用程序。 Spring 使您能够从“普通的 Java 对象”(POJO)构建应用程序，并将企业服务非侵入性地应...","link":"","photos":[],"count_time":{"symbolsCount":"33k","symbolsTime":"30 mins."},"categories":[{"name":"Spring","slug":"Spring","count":6,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":6,"path":"api/tags/Spring.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}