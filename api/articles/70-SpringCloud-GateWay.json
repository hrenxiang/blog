{"title":"SpringCloud GateWay","uid":"6dd02a05274ef2720cdd348b80b5ceee","slug":"70-SpringCloud-GateWay","date":"2021-09-13T15:46:32.000Z","updated":"2021-09-15T10:46:26.355Z","comments":true,"path":"api/articles/70-SpringCloud-GateWay.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog6.jpg","content":"<h3 id=\"一、SpringCloud-Gateway-网关\"><a href=\"#一、SpringCloud-Gateway-网关\" class=\"headerlink\" title=\"一、SpringCloud Gateway 网关\"></a>一、SpringCloud Gateway 网关</h3><hr/>\n\n<h4 id=\"1、Gateway-的概念\"><a href=\"#1、Gateway-的概念\" class=\"headerlink\" title=\"1、Gateway 的概念\"></a>1、Gateway 的概念</h4><p>SpringCloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p>\n<p>SpringCloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Zuul，在Spring Cloud 2.0以上版本中，没有对新版本的Zuul 2.0以上最新高性能版本进行集成，仍然还是使用的Zuul 2.0之前的非Reactor模式的老版本。而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。</p>\n<p>Spring Cloud Gateway 的目标，不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，和限流。</p>\n<p>提前声明：<strong>Spring Cloud Gateway 底层使用了高性能的通信框架Netty</strong>。</p>\n<h4 id=\"2、Gateway-的作用\"><a href=\"#2、Gateway-的作用\" class=\"headerlink\" title=\"2、Gateway 的作用\"></a>2、Gateway 的作用</h4><p> 网关是整个微服务API请求的入口，负责拦截所有请求，分发到服务上去。可以实现反向代理、日志拦截、权限控制、解决跨域问题、限流、熔断、负载均衡，隐藏服务端的ip，黑名单与白名单拦截、授权等</p>\n<h4 id=\"3、过滤器和网关的对比\"><a href=\"#3、过滤器和网关的对比\" class=\"headerlink\" title=\"3、过滤器和网关的对比\"></a>3、过滤器和网关的对比</h4><p>过滤器：对单个服务器的请求进行拦截控制</p>\n<p>网关：对所有的服务器的请求进行拦截控制</p>\n<h4 id=\"4、zuul-和-gateway的对比\"><a href=\"#4、zuul-和-gateway的对比\" class=\"headerlink\" title=\"4、zuul 和 gateway的对比\"></a>4、zuul 和 gateway的对比</h4><p>zuul：是Netflix的，是基于servlet实现的，阻塞式的api，不支持长连接。</p>\n<p>gateway：是springcloud自己研制的微服务网关，是基于Spring5构建，能够实现响应式非阻塞式的Api，支持长连接</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Spring在2017年下半年迎来了Webflux，Webflux的出现填补了Spring在响应式编程上的空白，Webflux的响应式编程不仅仅是编程风格的改变，而且对于一系列的著名框架，都提供了响应式访问的开发包，比如Netty、Redis等等。</p>\n<p>==SpringCloud Gateway 使用的Webflux中的reactor-netty响应式编程组件，底层使用了Netty通讯框架。==</p></blockquote>\n<h4 id=\"5、Gateway-和-Nginx-的却别\"><a href=\"#5、Gateway-和-Nginx-的却别\" class=\"headerlink\" title=\"5、Gateway 和 Nginx 的却别\"></a>5、Gateway 和 Nginx 的却别</h4><p>相同点：都是可以实现对api接口的拦截，负载均衡、反向代理、请求过滤等，可以实现和网关一样的效果。</p>\n<p>不同点：Nginx采用C语言编写，Gateway属于Java语言编写的， 能够更好让我们使用java语言来实现对请求的处理。</p>\n<p>Nginx 属于服务器端负载均衡器。</p>\n<p>Gateway 属于本地负载均衡器，因为是java 编写，所以速度上可能会较慢</p>\n<h4 id=\"6、Gateway-的组成\"><a href=\"#6、Gateway-的组成\" class=\"headerlink\" title=\"6、Gateway 的组成\"></a>6、Gateway 的组成</h4><ul>\n<li><p>Filter 过滤器</p>\n<p>和Zuul的过滤器在概念上类似，可以使用它拦截和修改请求，并且对上游的响应，进行二次处理。过滤器为org.springframework.cloud.gateway.filter.GatewayFilter类的实例。</p>\n</li>\n<li><p>Route 路由</p>\n<p>网关配置的基本组成模块，和Zuul的路由配置模块类似。一个<strong>Route模块</strong>由一个 ID，一个目标 URI，一组断言和一组过滤器定义。如果断言为真，则路由匹配，目标URI会被访问。</p>\n</li>\n<li><p>Predicate 断言</p>\n<p>这是一个 Java 8 的 Predicate，可以使用它来匹配来自 HTTP 请求的任何内容，例如 headers 或参数。<strong>断言的</strong>输入类型是一个 ServerWebExchange。</p>\n</li>\n</ul>\n<h4 id=\"7、Gateway-流程\"><a href=\"#7、Gateway-流程\" class=\"headerlink\" title=\"7、Gateway 流程\"></a>7、Gateway 流程</h4><div>\n  <img src=\"https://upload-images.jianshu.io/upload_images/23484242-f4e3147373cd2e08.png?imageMogr2/auto-orient/strip|imageView2/2/w/443/format/webp\" alt=\"img\" style=\"zoom:50%;\" />\n</div>\n\n<p>a. 客户端发送请求，会到达网关的DispatcherHandler处理，匹配到RoutePredicateHandlerMapping。</p>\n<p>b. 根据RoutePredicateHandlerMapping匹配到具体的路由策略。</p>\n<p>c. FilteringWebHandler获取的路由的GatewayFilter数组，创建 GatewayFilterChain 处理过滤请求</p>\n<p>d. 执行我们的代理业务逻辑访问。</p>\n<h3 id=\"二、路由配置方式\"><a href=\"#二、路由配置方式\" class=\"headerlink\" title=\"二、路由配置方式\"></a>二、路由配置方式</h3><hr/>\n\n<h4 id=\"1、基础-URI-路由配置方式\"><a href=\"#1、基础-URI-路由配置方式\" class=\"headerlink\" title=\"1、基础 URI 路由配置方式\"></a>1、基础 URI 路由配置方式</h4><p>如果请求的目标地址，匹配的是单个的Uri 资源路径，配置文件示例如下：</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:10-10:26:21.png\" alt=\"image-20210910102621365\"></p>\n<p>各字段含义如下：</p>\n<p>id：我们自定义的路由 ID，保持唯一</p>\n<p>uri：目标服务地址</p>\n<p>predicates：路由条件，Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。</p>\n<p>上面这段配置的意思是，配置了一个 id 为 url-proxy-1的URI代理规则，路由的规则为：</p>\n<p>当访问地址<a href=\"http://localhost:8080/csdn/1.jsp%E6%97%B6%EF%BC%8C\">http://localhost:8080/csdn/1.jsp时，</a></p>\n<p>会路由到上游地址<a href=\"https://blog.csdn.net/1.jsp%E3%80%82\">https://blog.csdn.net/1.jsp。</a></p>\n<h4 id=\"2、基于代码的路由配置方式\"><a href=\"#2、基于代码的路由配置方式\" class=\"headerlink\" title=\"2、基于代码的路由配置方式\"></a>2、基于代码的路由配置方式</h4><p>转发功能同样可以通过代码来实现，我们可以在启动类 GateWayApplication 中添加方法 customRouteLocator() 来定制转发规则。</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:10-10:28:25.png\" alt=\"image-20210910102825073\"></p>\n<p>我们在yaml配置文件中注销掉相关路由的配置，重启服务，访问链接：<a href=\"http://localhost:8080/\">http://localhost:8080/</a> csdn， 可以看到和上面一样的页面，证明我们测试成功。</p>\n<p>上面两个示例中 uri 都是指向了我的CSDN博客，在实际项目使用中可以将 uri 指向对外提供服务的项目地址，统一对外输出接口。</p>\n<h4 id=\"3、和注册中心相结合的路由配置\"><a href=\"#3、和注册中心相结合的路由配置\" class=\"headerlink\" title=\"3、和注册中心相结合的路由配置\"></a>3、和注册中心相结合的路由配置</h4><p>在uri的schema协议部分为自定义的lb:类型，表示从微服务注册中心（如Eureka）订阅服务，并且进行服务的路由。</p>\n<p>一个典型的示例如下：</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:10-10:30:06.png\" alt=\"image-20210910103006362\"></p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">#lb是一个动态路由协议，后面的是要跳转的服务名称。</code></pre>\n\n<p>注册中心相结合的路由配置方式，与单个URI的路由配置，区别其实很小，仅仅在于URI的schema协议不同。单个URI的地址的schema协议，一般为http或者https协议。</p>\n<h3 id=\"三、路由匹配规则\"><a href=\"#三、路由匹配规则\" class=\"headerlink\" title=\"三、路由匹配规则\"></a>三、路由匹配规则</h3><hr/>\n\n<p>Spring Cloud Gateway 的功能很强大，我们仅仅通过 Predicates 的设计就可以看出来，前面我们只是使用了 predicates 进行了简单的条件匹配，其实 Spring Cloud Gataway 帮我们内置了很多 Predicates 功能。</p>\n<p>Spring Cloud Gateway 是通过 Spring WebFlux 的 HandlerMapping 做为底层支持来匹配到转发路由，Spring Cloud Gateway 内置了很多 Predicates 工厂，这些 Predicates 工厂通过不同的 HTTP 请求参数来匹配，多个 Predicates 工厂可以组合使用。</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:10-10:32:22.png\" alt=\"在这里插入图片描述\"></p>\n<table>\n<thead>\n<tr>\n<th>三大元素</th>\n<th>解释</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Route（路由）</td>\n<td>路由是网关的基本单元，由ID、URI、一组Predicate、一组Filter组成，根据Predicate进行匹配转发。</td>\n<td></td>\n</tr>\n<tr>\n<td>Predicate（谓语、断言）</td>\n<td>路由转发的判断条件，目前SpringCloud Gateway支持多种方式，常见如：Path、Query、Method、Header等，写法必须遵循 key=vlue的形式</td>\n<td></td>\n</tr>\n<tr>\n<td>Filter（过滤器）</td>\n<td>过滤器是路由转发请求时所经过的过滤逻辑，可用于修改请求、响应内容</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>==其中Route和Predicate必须同时申明==</p>\n<p>例子：</p>\n<pre class=\"line-numbers language-yml\" data-language=\"yml\"><code class=\"language-yml\">&#x2F;&#x2F;通过配置文件配置\nspring:\n  cloud:\n    gateway:\n      routes:\n        - id: gate_route\n          uri: http:&#x2F;&#x2F;localhost:9023\n          predicates:\n          ## 当请求的路径为gate、rule开头的时，转发到http:&#x2F;&#x2F;localhost:9023服务器上\n            - Path&#x3D;&#x2F;gate&#x2F;**,&#x2F;rule&#x2F;**\n        ### 请求路径前加上&#x2F;app\n          filters:\n          - PrefixPath&#x3D;&#x2F;app</code></pre>\n\n\n\n<h4 id=\"1、Predicate-断言条件-转发规则-介绍\"><a href=\"#1、Predicate-断言条件-转发规则-介绍\" class=\"headerlink\" title=\"1、Predicate 断言条件(转发规则)介绍\"></a>1、Predicate 断言条件(转发规则)介绍</h4><p>Predicate 来源于 Java 8，是 Java 8 中引入的一个函数，Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。可以用于接口请求参数校验、判断新老数据是否有变化需要进行更新操作。</p>\n<p>在 Spring Cloud Gateway 中 Spring 利用 Predicate 的特性实现了各种路由匹配规则，有通过 Header、请求参数等不同的条件来进行作为条件匹配到对应的路由。网上有一张图总结了 Spring Cloud 内置的几种 Predicate 的实现。</p>\n<div>\n  <img src=\"https://upload-images.jianshu.io/upload_images/19816137-bb046dbf19bee1b4.gif?imageMogr2/auto-orient/strip\" alt=\"在这里插入图片描述\" style=\"zoom:100%;\" />\n</div>\n\n<p>说白了 Predicate 就是为了实现一组匹配规则，方便让请求过来找到对应的 Route 进行处理，接下来我们接下 Spring Cloud GateWay 内置几种 Predicate 的使用。</p>\n<ul>\n<li>转发规则（predicates），假设 转发uri都设定为***<a href=\"http://localhost:9023/\">http://localhost:9023</a>***</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>规则</th>\n<th>实例</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Path</td>\n<td>- Path=/gate/<strong>,/rule/</strong></td>\n<td>## 当请求的路径为gate、rule开头的时，转发到<a href=\"http://localhost:9023服务器上\">http://localhost:9023服务器上</a></td>\n</tr>\n<tr>\n<td>Before</td>\n<td>- Before=2017-01-20T17:42:47.789-07:00[America/Denver]</td>\n<td>在某个时间之前的请求才会被转发到 <a href=\"http://localhost:9023服务器上\">http://localhost:9023服务器上</a></td>\n</tr>\n<tr>\n<td>After</td>\n<td>- After=2017-01-20T17:42:47.789-07:00[America/Denver]</td>\n<td>在某个时间之后的请求才会被转发</td>\n</tr>\n<tr>\n<td>Between</td>\n<td>- Between=2017-01-20T17:42:47.789-07:00[America/Denver],2017-01-21T17:42:47.789-07:00[America/Denver]</td>\n<td>在某个时间段之间的才会被转发</td>\n</tr>\n<tr>\n<td>Cookie</td>\n<td>- Cookie=chocolate, ch.p</td>\n<td>名为chocolate的表单或者满足正则ch.p的表单才会被匹配到进行请求转发</td>\n</tr>\n<tr>\n<td>Header</td>\n<td>- Header=X-Request-Id, \\d+</td>\n<td>携带参数X-Request-Id或者满足\\d+的请求头才会匹配</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>- Host=<a href=\"http://www.hd123.com/\">www.hd123.com</a></td>\n<td>当主机名为<a href=\"http://www.hd123.com的时候直接转发到http//localhost:9023%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A\">www.hd123.com的时候直接转发到http://localhost:9023服务器上</a></td>\n</tr>\n<tr>\n<td>Method</td>\n<td>- Method=GET</td>\n<td>只有GET方法才会匹配转发请求，还可以限定POST、PUT等请求方式</td>\n</tr>\n</tbody></table>\n<h4 id=\"2、通过请求参数匹配\"><a href=\"#2、通过请求参数匹配\" class=\"headerlink\" title=\"2、通过请求参数匹配\"></a>2、通过请求参数匹配</h4><p>Query Route Predicate 支持传入两个参数，一个是属性名一个为属性值，属性值可以是正则表达式。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">server:\n  port: 8080\nspring:\n  application:\n  \t name: api-gateway\n  cloud:\n    gateway:\n      routes:\n        -id: gateway-service\n          uri: https:&#x2F;&#x2F;www.baidu.com\n          order: 0\n          predicates:\n            -Query&#x3D;smile</code></pre>\n\n<p>这样配置，只要请求中包含 smile 属性的参数即可匹配路由。</p>\n<p>使用 curl 测试，命令行输入:</p>\n<p>curl localhost:8080?smile=x&amp;id=2</p>\n<p>经过测试发现只要请求汇总带有 smile 参数即会匹配路由，不带 smile 参数则不会匹配。</p>\n<p>还可以将 Query 的值以键值对的方式进行配置，这样在请求过来时会对属性值和正则进行匹配，匹配上才会走路由。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">server:\n\n  port: 8080\n\nspring:\n\n  application:\n\n    name: api-gateway\n\n  cloud:\n\n    gateway:\n\n      routes:\n\n        -id: gateway-service\n\n          uri: https:&#x2F;&#x2F;www.baidu.com\n\n          order: 0\n\n          predicates:\n\n            -Query&#x3D;keep, pu.</code></pre>\n\n<p>这样只要当请求中包含 keep 属性并且参数值是以 pu 开头的长度为三位的字符串才会进行匹配和路由。</p>\n<p>使用 curl 测试，命令行输入:</p>\n<p>curl localhost:8080?keep=pub</p>\n<p>测试可以返回页面代码，将 keep 的属性值改为 pubx 再次访问就会报 404,证明路由需要匹配正则表达式才会进行路由。</p>\n<h4 id=\"3、通过-Header-属性匹配\"><a href=\"#3、通过-Header-属性匹配\" class=\"headerlink\" title=\"3、通过 Header 属性匹配\"></a>3、通过 Header 属性匹配</h4><p>Header Route Predicate 和 Cookie Route Predicate 一样，也是接收 2 个参数，一个 header 中属性名称和一个正则表达式，这个属性值和正则表达式匹配则执行。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">server:\n\n  port: 8080\n\nspring:\n\n  application:\n\n    name: api-gateway\n\n  cloud:\n\n    gateway:\n\n      routes:\n\n        -id: gateway-service\n\n          uri: https:&#x2F;&#x2F;www.baidu.com\n\n          order: 0\n\n          predicates:\n\n            - Header&#x3D;X-Request-Id, \\d+</code></pre>\n\n<p>使用 curl 测试，命令行输入:</p>\n<p>curl <a href=\"http://localhost:8080/\">http://localhost:8080</a> -H “X-Request-Id:88”</p>\n<p>则返回页面代码证明匹配成功。将参数-H “X-Request-Id:88”改为-H “X-Request-Id:spring”再次执行时返回404证明没有匹配。</p>\n<h4 id=\"4、通过-Cookie-匹配\"><a href=\"#4、通过-Cookie-匹配\" class=\"headerlink\" title=\"4、通过 Cookie 匹配\"></a>4、通过 Cookie 匹配</h4><p>Cookie Route Predicate 可以接收两个参数，一个是 Cookie name ,一个是正则表达式，路由规则会通过获取对应的 Cookie name 值和正则表达式去匹配，如果匹配上就会执行路由，如果没有匹配上则不执行。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">server:\n  port: 8080\nspring:\n  application:\n    name: api-gateway\n  cloud:\n    gateway:\n      routes:\n        -id: gateway-service\n          uri: https:&#x2F;&#x2F;www.baidu.com\n          order: 0\n          predicates:\n            - Cookie&#x3D;sessionId, test</code></pre>\n\n<p>使用 curl 测试，命令行输入:</p>\n<p>curl <a href=\"http://localhost:8080/\">http://localhost:8080</a> –cookie “sessionId=test”</p>\n<p>则会返回页面代码，如果去掉–cookie “sessionId=test”，后台汇报 404 错误。</p>\n<h4 id=\"5、通过-Host-匹配\"><a href=\"#5、通过-Host-匹配\" class=\"headerlink\" title=\"5、通过 Host 匹配\"></a>5、通过 Host 匹配</h4><p>Host Route Predicate 接收一组参数，一组匹配的域名列表，这个模板是一个 ant 分隔的模板，用.号作为分隔符。它通过参数中的主机地址作为匹配规则。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">server:\n\n  port: 8080\n\nspring:\n\n  application:\n\n    name: api-gateway\n\n  cloud:\n\n    gateway:\n\n      routes:\n\n        -id: gateway-service\n\n          uri: https:&#x2F;&#x2F;www.baidu.com\n\n          order: 0\n\n          predicates:\n\n            - Host&#x3D;**.baidu.com</code></pre>\n\n<p>使用 curl 测试，命令行输入:</p>\n<p>curl <a href=\"http://localhost:8080/\">http://localhost:8080</a> -H “Host: <a href=\"http://www.baidu.com&quot;/\">www.baidu.com&quot;</a></p>\n<p>curl <a href=\"http://localhost:8080/\">http://localhost:8080</a> -H “Host: md.baidu.com”</p>\n<p>经测试以上两种 host 均可匹配到 host_route 路由，去掉 host 参数则会报 404 错误。</p>\n<h4 id=\"6、通过请求方式匹配\"><a href=\"#6、通过请求方式匹配\" class=\"headerlink\" title=\"6、通过请求方式匹配\"></a>6、通过请求方式匹配</h4><p>可以通过是 POST、GET、PUT、DELETE 等不同的请求方式来进行路由。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">server:\n\n  port: 8080\n\nspring:\n\n  application:\n\n    name: api-gateway\n\n  cloud:\n\n    gateway:\n\n      routes:\n\n        -id: gateway-service\n\n          uri: https:&#x2F;&#x2F;www.baidu.com\n\n          order: 0\n\n          predicates:\n\n            - Method&#x3D;GET</code></pre>\n\n<p>使用 curl 测试，命令行输入:</p>\n<p># curl 默认是以 GET 的方式去请求</p>\n<p>curl <a href=\"http://localhost:8080/\">http://localhost:8080</a></p>\n<p>测试返回页面代码，证明匹配到路由，我们再以 POST 的方式请求测试。</p>\n<p># curl 默认是以 GET 的方式去请求</p>\n<p>curl -X POST <a href=\"http://localhost:8080/\">http://localhost:8080</a></p>\n<p>返回 404 没有找到，证明没有匹配上路由</p>\n<h4 id=\"7、通过请求路径匹配\"><a href=\"#7、通过请求路径匹配\" class=\"headerlink\" title=\"7、通过请求路径匹配\"></a>7、通过请求路径匹配</h4><p>Path Route Predicate 接收一个匹配路径的参数来判断是否走路由。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">server:\n\n  port: 8080\n\nspring:\n\n  application:\n\n    name: api-gateway\n\n  cloud:\n\n    gateway:\n\n      routes:\n\n        -id: gateway-service\n\n          uri: http:&#x2F;&#x2F;ityouknow.com\n\n          order: 0\n\n          predicates:\n\n            -Path&#x3D;&#x2F;foo&#x2F;&#123;segment&#125;</code></pre>\n\n<p>如果请求路径符合要求，则此路由将匹配，例如：/foo/1 或者 /foo/bar。</p>\n<p>使用 curl 测试，命令行输入:</p>\n<p>curl <a href=\"http://localhost:8080/foo/1\">http://localhost:8080/foo/1</a></p>\n<p>curl <a href=\"http://localhost:8080/foo/xx\">http://localhost:8080/foo/xx</a></p>\n<p>curl <a href=\"http://localhost:8080/boo/xx\">http://localhost:8080/boo/xx</a></p>\n<p>经过测试第一和第二条命令可以正常获取到页面返回值，最后一个命令报404，证明路由是通过指定路由来匹配。</p>\n<h4 id=\"8、通过请求-ip-地址进行匹配\"><a href=\"#8、通过请求-ip-地址进行匹配\" class=\"headerlink\" title=\"8、通过请求 ip 地址进行匹配\"></a>8、通过请求 ip 地址进行匹配</h4><p>Predicate 也支持通过设置某个 ip 区间号段的请求才会路由，RemoteAddr Route Predicate 接受 cidr 符号(IPv4 或 IPv6 )字符串的列表(最小大小为1)，例如 192.168.0.1/16 (其中 192.168.0.1 是 IP 地址，16 是子网掩码)。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">server:\n\n  port: 8080\n\nspring:\n\n  application:\n\n    name: api-gateway\n\n  cloud:\n\n    gateway:\n\n      routes:\n\n        - id: gateway-service\n\n          uri: https:&#x2F;&#x2F;www.baidu.com\n\n          order: 0\n\n          predicates:\n\n            - RemoteAddr&#x3D;192.168.1.1&#x2F;24</code></pre>\n\n<p>可以将此地址设置为本机的 ip 地址进行测试。</p>\n<p>curl localhost:8080</p>\n<p>如果请求的远程地址是 192.168.1.10，则此路由将匹配。</p>\n<h4 id=\"9、组合使用\"><a href=\"#9、组合使用\" class=\"headerlink\" title=\"9、组合使用\"></a>9、<strong>组合使用</strong></h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">server:\n  port: 8080\nspring:\n  application:\n    name: api-gateway\n  cloud:\n    gateway:\n      routes:\n        - id: gateway-service\n          uri: https:&#x2F;&#x2F;www.baidu.com\n          order: 0\n          predicates:\n            - Host&#x3D;**.foo.org\n            - Path&#x3D;&#x2F;headers\n            - Method&#x3D;GET\n            - Header&#x3D;X-Request-Id, \\d+\n            - Query&#x3D;foo, ba.\n            - Query&#x3D;baz\n            - Cookie&#x3D;chocolate, ch.p</code></pre>\n\n<p>各种 Predicates 同时存在于同一个路由时，请求必须同时满足所有的条件才被这个路由匹配。</p>\n<p>一个请求满足多个路由的断言条件时，请求只会被首个成功匹配的路由转发</p>\n<h3 id=\"四、过滤器规则（Filter）\"><a href=\"#四、过滤器规则（Filter）\" class=\"headerlink\" title=\"四、过滤器规则（Filter）\"></a>四、过滤器规则（Filter）</h3><p>Gateway filter 多达31种</p>\n<p><a href=\"#gatewayfilter-factories\">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.2.RELEASE/reference/html/#gatewayfilter-factories</a></p>\n<table>\n<thead>\n<tr>\n<th>过滤规则</th>\n<th>实例</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PrefixPath</td>\n<td>- PrefixPath=/app</td>\n<td>在请求路径前加上app</td>\n</tr>\n<tr>\n<td>RewritePath</td>\n<td>- RewritePath=/test, /app/test</td>\n<td>访问localhost:9022/test,请求会转发到localhost:8001/app/test</td>\n</tr>\n<tr>\n<td>SetPath</td>\n<td>SetPath=/app/{path}</td>\n<td>通过模板设置路径，转发的规则时会在路径前增加app，{path}表示原请求路径</td>\n</tr>\n<tr>\n<td>RedirectTo</td>\n<td></td>\n<td>重定向</td>\n</tr>\n<tr>\n<td>RemoveRequestHeader</td>\n<td></td>\n<td>去掉某个请求头信息</td>\n</tr>\n</tbody></table>\n<p>注：当配置多个filter时，优先定义的会被调用，剩余的filter将不会生效</p>\n<h4 id=\"PrefixPath\"><a href=\"#PrefixPath\" class=\"headerlink\" title=\"PrefixPath\"></a>PrefixPath</h4><p>对所有的请求路径添加前缀：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">spring:\n  cloud:\n    gateway:\n      routes:\n      - id: prefixpath_route\n        uri: https:&#x2F;&#x2F;example.org\n        filters:\n        - PrefixPath&#x3D;&#x2F;mypath</code></pre>\n\n<p>访问/hello的请求被发送到<a href=\"https://example.org/mypath/hello%E3%80%82\">https://example.org/mypath/hello。</a></p>\n<h4 id=\"RedirectTo\"><a href=\"#RedirectTo\" class=\"headerlink\" title=\"RedirectTo\"></a>RedirectTo</h4><p>重定向，配置包含重定向的返回码和地址：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">spring:\n  cloud:\n    gateway:\n      routes:\n      - id: prefixpath_route\n        uri: https:&#x2F;&#x2F;example.org\n        filters:\n        - RedirectTo&#x3D;302, https:&#x2F;&#x2F;acme.org</code></pre>\n\n<h4 id=\"RemoveRequestHeader\"><a href=\"#RemoveRequestHeader\" class=\"headerlink\" title=\"RemoveRequestHeader\"></a>RemoveRequestHeader</h4><p>去掉某个请求头信息：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">spring:\n  cloud:\n    gateway:\n      routes:\n      - id: removerequestheader_route\n        uri: https:&#x2F;&#x2F;example.org\n        filters:\n        - RemoveRequestHeader&#x3D;X-Request-Foo</code></pre>\n\n<p>去掉请求头信息 X-Request-Foo</p>\n<h4 id=\"RemoveResponseHeader\"><a href=\"#RemoveResponseHeader\" class=\"headerlink\" title=\"RemoveResponseHeader\"></a>RemoveResponseHeader</h4><p>去掉某个回执头信息：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">spring:\n  cloud:\n    gateway:\n      routes:\n      - id: removerequestheader_route\n        uri: https:&#x2F;&#x2F;example.org\n        filters:\n        - RemoveResponseHeader&#x3D;X-Request-Foo</code></pre>\n\n<h4 id=\"RemoveRequestParameter\"><a href=\"#RemoveRequestParameter\" class=\"headerlink\" title=\"RemoveRequestParameter\"></a>RemoveRequestParameter</h4><p>去掉某个请求参数信息：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">spring:\n  cloud:\n    gateway:\n      routes:\n      - id: removerequestparameter_route\n        uri: https:&#x2F;&#x2F;example.org\n        filters:\n        - RemoveRequestParameter&#x3D;red</code></pre>\n\n<h4 id=\"RewritePath\"><a href=\"#RewritePath\" class=\"headerlink\" title=\"RewritePath\"></a>RewritePath</h4><p>改写路径：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">spring:\n  cloud:\n    gateway:\n      routes:\n      - id: rewrite_filter\n        uri: http:&#x2F;&#x2F;localhost:8081\n        predicates:\n        - Path&#x3D;&#x2F;test&#x2F;**\n        filters:\n        - RewritePath&#x3D;&#x2F;where(?&lt;segment&gt;&#x2F;?.*), &#x2F;test(?&lt;segment&gt;&#x2F;?.*)</code></pre>\n\n<p>/where/… 改成 test/…</p>\n<p>使用代码改下路径</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">RouteLocatorBuilder.Builder builder &#x3D; routeLocatorBuilder.routes();\n   builder\n           .route(&quot;path_rote_at_guigu&quot;, r -&gt; r.path(&quot;&#x2F;guonei&quot;)\n                   .uri(&quot;http:&#x2F;&#x2F;news.baidu.com&#x2F;guonei&quot;))\n           .route(&quot;csdn_route&quot;, r -&gt; r.path(&quot;&#x2F;csdn&quot;)\n                   .uri(&quot;https:&#x2F;&#x2F;blog.csdn.net&quot;))\n           .route(&quot;blog3_rewrite_filter&quot;, r -&gt; r.path(&quot;&#x2F;blog3&#x2F;**&quot;)\n                   .filters(f -&gt; f.rewritePath(&quot;&#x2F;blog3&#x2F;(?&lt;segment&gt;.*)&quot;, &quot;&#x2F;$\\\\&#123;segment&#125;&quot;))\n                   .uri(&quot;https:&#x2F;&#x2F;blog.csdn.net&quot;))\n           .route(&quot;rewritepath_route&quot;, r -&gt; r.path(&quot;&#x2F;baidu&#x2F;**&quot;)\n                   .filters(f -&gt; f.rewritePath(&quot;&#x2F;baidu&#x2F;(?&lt;segment&gt;.*)&quot;, &quot;&#x2F;$\\\\&#123;segment&#125;&quot;))\n                   .uri(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;))\n\n           .build();</code></pre>\n\n<h4 id=\"SetPath\"><a href=\"#SetPath\" class=\"headerlink\" title=\"SetPath\"></a>SetPath</h4><p>设置请求路径，与RewritePath类似。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">spring:\n  cloud:\n    gateway:\n      routes:\n      - id: setpath_route\n        uri: https:&#x2F;&#x2F;example.org\n        predicates:\n        - Path&#x3D;&#x2F;red&#x2F;&#123;segment&#125;\n        filters:\n        - SetPath&#x3D;&#x2F;&#123;segment&#125;</code></pre>\n\n<p>如/red/blue的请求被转发到/blue。</p>\n<h4 id=\"SetRequestHeader\"><a href=\"#SetRequestHeader\" class=\"headerlink\" title=\"SetRequestHeader\"></a>SetRequestHeader</h4><p>设置请求头信息。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">spring:\n  cloud:\n    gateway:\n      routes:\n      - id: setrequestheader_route\n        uri: https:&#x2F;&#x2F;example.org\n        filters:\n        - SetRequestHeader&#x3D;X-Request-Red, Blue</code></pre>\n\n<h4 id=\"SetStatus\"><a href=\"#SetStatus\" class=\"headerlink\" title=\"SetStatus\"></a>SetStatus</h4><p>设置回执状态码。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">spring:\n  cloud:\n    gateway:\n      routes:\n      - id: setstatusint_route\n        uri: https:&#x2F;&#x2F;example.org\n        filters:\n        - SetStatus&#x3D;401</code></pre>\n\n<h4 id=\"StripPrefix\"><a href=\"#StripPrefix\" class=\"headerlink\" title=\"StripPrefix\"></a>StripPrefix</h4><p>跳过指定路径。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">spring:\n  cloud:\n    gateway:\n      routes:\n      - id: nameRoot\n        uri: https:&#x2F;&#x2F;nameservice\n        predicates:\n        - Path&#x3D;&#x2F;name&#x2F;**\n        filters:\n        - StripPrefix&#x3D;2</code></pre>\n\n<p>请求/name/blue/red会转发到/red。</p>\n<h4 id=\"RequestSize\"><a href=\"#RequestSize\" class=\"headerlink\" title=\"RequestSize\"></a>RequestSize</h4><p>请求大小。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">spring:\n  cloud:\n    gateway:\n      routes:\n      - id: request_size_route\n        uri: http:&#x2F;&#x2F;localhost:8080&#x2F;upload\n        predicates:\n        - Path&#x3D;&#x2F;upload\n        filters:\n        - name: RequestSize\n          args:\n            maxSize: 5000000</code></pre>\n\n<p>超过5M的请求会返回413错误。</p>\n<h4 id=\"Default-filters\"><a href=\"#Default-filters\" class=\"headerlink\" title=\"Default-filters\"></a>Default-filters</h4><p>对所有请求添加过滤器。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">spring:\n  cloud:\n    gateway:\n      default-filters:\n      - AddResponseHeader&#x3D;X-Response-Default-Red, Default-Blue\n      - PrefixPath&#x3D;&#x2F;httpbin</code></pre>\n\n<h4 id=\"通过代码进行配置\"><a href=\"#通过代码进行配置\" class=\"headerlink\" title=\"通过代码进行配置\"></a>通过代码进行配置</h4><p>通过代码进行配置，将路由规则设置为一个Bean即可：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Bean\npublic RouteLocator customRouteLocator(RouteLocatorBuilder builder) &#123;\n\treturn builder.routes()\n\t\t.route(&quot;path_route&quot;, r -&gt; r.path(&quot;&#x2F;get&quot;)\n\t\t\t.uri(&quot;http:&#x2F;&#x2F;httpbin.org&quot;))\n\t\t.route(&quot;host_route&quot;, r -&gt; r.host(&quot;*.myhost.org&quot;)\n\t\t\t.uri(&quot;http:&#x2F;&#x2F;httpbin.org&quot;))\n\t\t.route(&quot;rewrite_route&quot;, r -&gt; r.host(&quot;*.rewrite.org&quot;)\n\t\t\t.filters(f -&gt; f.rewritePath(&quot;&#x2F;foo&#x2F;(?&lt;segment&gt;.*)&quot;, &quot;&#x2F;$&#123;segment&#125;&quot;))\n\t\t\t.uri(&quot;http:&#x2F;&#x2F;httpbin.org&quot;))\n\t\t.route(&quot;hystrix_route&quot;, r -&gt; r.host(&quot;*.hystrix.org&quot;)\n\t\t\t.filters(f -&gt; f.hystrix(c -&gt; c.setName(&quot;slowcmd&quot;)))\n\t\t\t.uri(&quot;http:&#x2F;&#x2F;httpbin.org&quot;))\n\t\t.route(&quot;hystrix_fallback_route&quot;, r -&gt; r.host(&quot;*.hystrixfallback.org&quot;)\n\t\t\t.filters(f -&gt; f.hystrix(c -&gt; c.setName(&quot;slowcmd&quot;).setFallbackUri(&quot;forward:&#x2F;hystrixfallback&quot;)))\n\t\t\t.uri(&quot;http:&#x2F;&#x2F;httpbin.org&quot;))\n\t\t.route(&quot;limit_route&quot;, r -&gt; r\n\t\t\t.host(&quot;*.limited.org&quot;).and().path(&quot;&#x2F;anything&#x2F;**&quot;)\n\t\t\t.filters(f -&gt; f.requestRateLimiter(c -&gt; c.setRateLimiter(redisRateLimiter())))\n\t\t\t.uri(&quot;http:&#x2F;&#x2F;httpbin.org&quot;))\n\t\t.build();\n&#125;</code></pre>\n\n\n\n<h3 id=\"五、实现熔断降级\"><a href=\"#五、实现熔断降级\" class=\"headerlink\" title=\"五、实现熔断降级\"></a>五、实现熔断降级</h3><p>为什么要实现熔断降级？</p>\n<p>在分布式系统中，网关作为流量的入口，因此会有大量的请求进入网关，向其他服务发起调用，其他服务不可避免的会出现调用失败（超时、异常），失败时不能让请求堆积在网关上，需要快速失败并返回给客户端，想要实现这个要求，就必须在网关上做熔断、降级操作。</p>\n<p>为什么在网关上请求失败需要快速返回给客户端？</p>\n<p>因为当一个客户端请求发生故障的时候，这个请求会一直堆积在网关上，当然只有一个这种请求，网关肯定没有问题（如果一个请求就能造成整个系统瘫痪，那这个系统可以下架了），但是网关上堆积多了就会给网关乃至整个服务都造成巨大的压力，甚至整个服务宕掉。因此要对一些服务和页面进行有策略的降级，以此缓解服务器资源的的压力，以保证核心业务的正常运行，同时也保持了客户和大部分客户的得到正确的相应，所以需要网关上请求失败需要快速返回给客户端。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">server.port: 8082\n\nspring:\n  application:\n    name: gateway\n  redis:\n      host: localhost\n      port: 6379\n      password: 123456\n  cloud:\n    gateway:\n      routes:\n        - id: rateLimit_route\n          uri: http:&#x2F;&#x2F;localhost:8000\n          order: 0\n          predicates:\n            - Path&#x3D;&#x2F;test&#x2F;**\n          filters:\n            - StripPrefix&#x3D;1\n            - name: Hystrix\n              args:\n                name: fallbackCmdA\n                fallbackUri: forward:&#x2F;fallbackA\n\n  hystrix.command.fallbackCmdA.execution.isolation.thread.timeoutInMilliseconds: 5000</code></pre>\n\n<p>这里的配置，使用了两个过滤器：</p>\n<p>（1）过滤器StripPrefix，作用是去掉请求路径的最前面n个部分截取掉。</p>\n<p>StripPrefix=1就代表截取路径的个数为1，比如前端过来请求/test/good/1/view，匹配成功后，路由到后端的请求路径就会变成<a href=\"http://localhost:8888/good/1/view%E3%80%82\">http://localhost:8888/good/1/view。</a></p>\n<p>（2）过滤器Hystrix，作用是通过Hystrix进行熔断降级</p>\n<p>当上游的请求，进入了Hystrix熔断降级机制时，就会调用fallbackUri配置的降级地址。需要注意的是，还需要单独设置Hystrix的commandKey的超时时间</p>\n<p>fallbackUri配置的降级地址的代码如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package org.gateway.controller;\n\nimport org.gateway.response.Response;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class FallbackController &#123;\n\n    @GetMapping(&quot;&#x2F;fallbackA&quot;)\n    public Response fallbackA() &#123;\n        Response response &#x3D; new Response();\n        response.setCode(&quot;100&quot;);\n        response.setMessage(&quot;服务暂时不可用&quot;);\n        return response;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h3 id=\"六、高级配置\"><a href=\"#六、高级配置\" class=\"headerlink\" title=\"六、高级配置\"></a>六、高级配置</h3><hr/>\n\n<h4 id=\"1、分布式限流\"><a href=\"#1、分布式限流\" class=\"headerlink\" title=\"1、分布式限流\"></a>1、分布式限流</h4><p>从某种意义上讲，令牌桶算法是对漏桶算法的一种改进，桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。在令牌桶算法中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝。放令牌这个动作是持续不断的进行，如果桶中令牌数达到上限，就丢弃令牌，所以就存在这种情况，桶中一直有大量的可用令牌，这时进来的请求就可以直接拿到令牌执行，比如设置qps为100，那么限流器初始化完成一秒后，桶中就已经有100个令牌了，这时服务还没完全启动好，等启动完成对外提供服务时，该限流器可以抵挡瞬时的100个请求。所以，只有桶中没有令牌时，请求才会进行等待，最后相当于以一定的速率执行。<br><img src=\"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:10-10:52:44.jpeg\" alt=\"在这里插入图片描述\" style=\"zoom:50%;\" /></p>\n<p>在Spring Cloud Gateway中，有Filter过滤器，因此可以在“pre”类型的Filter中自行实现上述三种过滤器。但是限流作为网关最基本的功能，Spring Cloud Gateway官方就提供了RequestRateLimiterGatewayFilterFactory这个类，适用在Redis内的通过执行Lua脚本实现了令牌桶的方式。具体实现逻辑在RequestRateLimiterGatewayFilterFactory类中，lua脚本在如下图所示的文件夹中：<br><img src=\"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:10-10:50:58.jpeg\" alt=\"在这里插入图片描述\"></p>\n<p>首先在工程的pom文件中引入gateway的起步依赖和redis的reactive依赖，代码如下：</p>\n<p>配置如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">server:\n  port: 8081\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: limit_route\n        uri: http:&#x2F;&#x2F;httpbin.org:80&#x2F;get\n        predicates:\n        - After&#x3D;2017-01-20T17:42:47.789-07:00[America&#x2F;Denver]\n        filters:\n        - name: RequestRateLimiter\n          args:\n            key-resolver: &#39;#&#123;@userKeyResolver&#125;&#39;\n            redis-rate-limiter.replenishRate: 1\n            redis-rate-limiter.burstCapacity: 3\n  application:\n    name: cloud-gateway\n  redis:\n    host: localhost\n    port: 6379\n    database: 0</code></pre>\n\n<p>在上面的配置文件，指定程序的端口为8081，配置了 redis的信息，并配置了RequestRateLimiter的限流过滤器，该过滤器需要配置三个参数：</p>\n<ul>\n<li>burstCapacity，令牌桶总容量。</li>\n<li>replenishRate，令牌桶每秒填充平均速率。</li>\n<li>key-resolver，用于限流的键的解析器的 Bean 对象的名字。它使用 SpEL 表达式根据#{@beanName}从 Spring 容器中获取 Bean 对象。</li>\n</ul>\n<p>这里根据用户ID限流，请求路径中必须携带userId参数</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Bean\n\nKeyResolver userKeyResolver() &#123;\n  return exchange -&gt; Mono.just(exchange.getRequest().getQueryParams().getFirst(&quot;user&quot;));\n&#125;\n\n </code></pre>\n\n<p>KeyResolver需要实现resolve方法，比如根据userid进行限流，则需要用userid去判断。实现完KeyResolver之后，需要将这个类的Bean注册到Ioc容器中。</p>\n<p>如果需要根据IP限流，定义的获取限流Key的bean为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Bean\npublic KeyResolver ipKeyResolver() &#123;\n  return exchange -&gt; Mono.just(exchange.getRequest().getRemoteAddress().getHostName());\n&#125;</code></pre>\n\n<p>通过exchange对象可以获取到请求信息，这边用了HostName，如果你想根据用户来做限流的话这边可以获取当前请求的用户ID或者用户名就可以了，比如：</p>\n<p>如果需要根据接口的URI进行限流，则需要获取请求地址的uri作为限流key，定义的Bean对象为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Bean\nKeyResolver apiKeyResolver() &#123;\n  return exchange -&gt; Mono.just(exchange.getRequest().getPath().value());\n&#125;</code></pre>\n\n<p>通过exchange对象可以获取到请求信息，这边用了HostName，如果你想根据用户来做限流的话这边可以获取当前请求的用户ID或者用户名就可以了，比如：</p>\n<p>如果需要根据接口的URI进行限流，则需要获取请求地址的uri作为限流key，定义的Bean对象为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Bean\nKeyResolver apiKeyResolver() &#123;\n  return exchange -&gt; Mono.just(exchange.getRequest().getPath().value());\n&#125;</code></pre>\n\n\n\n<h4 id=\"2、健康检查配置\"><a href=\"#2、健康检查配置\" class=\"headerlink\" title=\"2、健康检查配置\"></a>2、健康检查配置</h4><p>admin-client、actuator健康检查配置，为之后的功能提供支持，此部分比较简单，不再赘述，加入以下maven依赖和配置</p>\n<h5 id=\"maven依赖\"><a href=\"#maven依赖\" class=\"headerlink\" title=\"maven依赖\"></a>maven依赖</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">  &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;\n &lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n        &lt;groupId&gt;de.codecentric&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-admin-starter-client&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.1.0&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;</code></pre>\n\n<h5 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">spring:\n  application:\n    name: mas-cloud-gateway\n  boot:\n    admin:\n      client:\n      ### 本地搭建的admin-server\n        url: http:&#x2F;&#x2F;localhost:8011\neureka:\n  client:\n    registerWithEureka: true\n    fetchRegistry: true\n    healthcheck:\n      enabled: true\n    serviceUrl:\n      defaultZone: http:&#x2F;&#x2F;localhost:6887&#x2F;eureka&#x2F;\n    enabled: true\nfeign:\n  sentinel:\n    enabled: true\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: &#39;*&#39;\n  endpoint:\n    health:\n      show-details: ALWAYS</code></pre>\n\n<p>若转发的目标地址为微服务中组件，不为具体ip:port形式的，应写成lb://mas-openapi-service形式，目标地址会从注册中心直接拉取</p>\n<h4 id=\"3、统一配置跨域请求\"><a href=\"#3、统一配置跨域请求\" class=\"headerlink\" title=\"3、统一配置跨域请求\"></a>3、统一配置跨域请求</h4><p>现在的请求通过经过gateWay网关时，需要在网关统一配置跨域请求，需求所有请求通过</p>\n<pre class=\"line-numbers language-yml\" data-language=\"yml\"><code class=\"language-yml\">spring:\n  cloud:\n    gateway:\n      globalcors:\n        cors-configurations:\n          &#39;[&#x2F;**]&#39;:\n            allowed-origins: &quot;*&quot; # 允许的请求源\n            allowed-headers: &quot;*&quot; # 允许携带的请求头\n            allow-credentials: true # 是否允许携带cookie\n            allowed-methods: # 允许的http方法\n              - GET\n              - POST\n              - DELETE\n              - PUT\n              - OPTION</code></pre>\n\n<p>java代码方式书写</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.guli.infrastructure.apigateway.config;\n\n@Configuration\npublic class CorsConfig &#123;\n    @Bean\n    public CorsWebFilter corsFilter() &#123;\n        &#x2F;&#x2F;CorsConfiguration 相关配置说明\n        &#x2F;&#x2F; 是否允许携带cookies\n        &#x2F;&#x2F;private Boolean allowCredentials;\n        &#x2F;&#x2F; 允许的请求源\n        &#x2F;&#x2F; private List&lt;String&gt; allowedOrigins;\n        &#x2F;&#x2F; 允许的http方法\n        &#x2F;&#x2F;private List&lt;String&gt; allowedMethods;\n        &#x2F;&#x2F; 允许的请求头\n        &#x2F;&#x2F;private List&lt;String&gt; allowedHeaders;\n        CorsConfiguration config &#x3D; new CorsConfiguration();\n        config.setAllowCredentials(true);\n        config.addAllowedOrigin(&quot;*&quot;);\n        config.addAllowedHeader(&quot;*&quot;);\n        config.addAllowedMethod(&quot;*&quot;);\n\n        UrlBasedCorsConfigurationSource source &#x3D; new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(&quot;&#x2F;**&quot;, config);\n\n        return new CorsWebFilter(source);\n    &#125;\n&#125;</code></pre>\n\n\n\n<h4 id=\"4、鉴权\"><a href=\"#4、鉴权\" class=\"headerlink\" title=\"4、鉴权\"></a>4、鉴权</h4><h3 id=\"七、整合Sentinel完成流控和降级\"><a href=\"#七、整合Sentinel完成流控和降级\" class=\"headerlink\" title=\"七、整合Sentinel完成流控和降级\"></a>七、整合Sentinel完成流控和降级</h3><h4 id=\"maven依赖-1\"><a href=\"#maven依赖-1\" class=\"headerlink\" title=\"maven依赖\"></a>maven依赖</h4><p>使用Sentinel作为gateWay的限流、降级、系统保护工具</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;!--alibaba 流量卫士--&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;com.alibaba.csp&lt;&#x2F;groupId&gt;\n       &lt;artifactId&gt;sentinel-core&lt;&#x2F;artifactId&gt;\n       &lt;version&gt;$&#123;sentinel.version&#125;&lt;&#x2F;version&gt;\n   &lt;&#x2F;dependency&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n       &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;&#x2F;artifactId&gt;\n   &lt;&#x2F;dependency&gt;\n  &lt;dependency&gt;\n       &lt;groupId&gt;com.alibaba.csp&lt;&#x2F;groupId&gt;\n       &lt;artifactId&gt;sentinel-spring-cloud-gateway-adapter&lt;&#x2F;artifactId&gt;\n       &lt;version&gt;1.7.1&lt;&#x2F;version&gt;\n   &lt;&#x2F;dependency&gt;</code></pre>\n\n<h4 id=\"配置文件-1\"><a href=\"#配置文件-1\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h4><p>客户端配置：在配置文件中增加下列配置，dashboard就可以轻松管理客户端了，还有一种方式是在启动时加入</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">spring:\n  cloud:\n    sentinel:\n      transport:\n        ## VM\n        ##-Djava.net.preferIPv4Stack&#x3D;true -Dcsp.sentinel.dashboard.server&#x3D;localhost:8080 -Dcsp.sentinel.api.port&#x3D;8666 -Dproject.name&#x3D;gateway -Dcsp.sentinel.app.type&#x3D;1\n        dashboard: localhost:8880\n        port: 8880</code></pre>\n\n<h4 id=\"限流规则通用配置\"><a href=\"#限流规则通用配置\" class=\"headerlink\" title=\"限流规则通用配置\"></a>限流规则通用配置</h4><p>由于sentinel的工作原理其实借助于全局的filter进行请求拦截并计算出是否进行限流、熔断等操作的，增加SentinelGateWayFilter配置</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Bean&#x2F;&#x2F;拦截请求\n@Order(Ordered.HIGHEST_PRECEDENCE)\npublic GlobalFilter sentinelGatewayFilter() &#123;\n  return new SentinelGatewayFilter();\n&#125;</code></pre>\n\n<p>sentinel 不仅支持通过硬代码方式进行资源的申明，还能通过注解方式进行声明，为了让注解生效，还需要配置切面类SentinelResourceAspect</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"> @Bean\npublic SentinelResourceAspect sentinelResourceAspect() &#123;\n  return new SentinelResourceAspect();\n&#125;</code></pre>\n\n<p>sentinel拦截包括了视图、静态资源等，需要配置viewResolvers以及拦截之后的异常，我们也可以自定义抛出异常的提示</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public SentinelConfig(ObjectProvider&lt;List&lt;ViewResolver&gt;&gt; viewResolversProvider,\n                      ServerCodecConfigurer serverCodecConfigurer) &#123;\n  this.viewResolvers &#x3D; viewResolversProvider.getIfAvailable(Collections::emptyList);\n  this.serverCodecConfigurer &#x3D; serverCodecConfigurer;\n&#125;\n\n@Bean&#x2F;&#x2F;自定义异常\n@Order(Ordered.HIGHEST_PRECEDENCE)\npublic ExceptionHandler sentinelGatewayBlockExceptionHandler() &#123;\n  &#x2F;&#x2F; Register the block exception handler for Spring Cloud Gateway.\n  return new ExceptionHandler(viewResolvers, serverCodecConfigurer);\n&#125;</code></pre>\n\n<p>自定义异常提示：当发生限流、熔断异常时，会返回定义的提示信息。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">    &#x2F;**\n     * 配置限流的异常处理器:SentinelGatewayBlockExceptionHandler\n     *&#x2F;\n    @Bean\n    @Order(Ordered.HIGHEST_PRECEDENCE)\n    public SentinelGatewayBlockExceptionHandler sentinelGatewayBlockExceptionHandler() &#123;\n        return new SentinelGatewayBlockExceptionHandlerEX(viewResolvers, serverCodecConfigurer);\n    &#125;\n不需要额外的配置，sentinel就已经可以正常工作了</code></pre>\n\n<h4 id=\"限流规则设置\"><a href=\"#限流规则设置\" class=\"headerlink\" title=\"限流规则设置\"></a>限流规则设置</h4><p>1 资源定义：定义API组</p>\n<p>2 定义限流规则</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>具体请参见学习视频</p></blockquote>\n<h4 id=\"网关限流参数\"><a href=\"#网关限流参数\" class=\"headerlink\" title=\"网关限流参数\"></a>网关限流参数</h4><p>其中网关限流规则 GatewayFlowRule的字段解释如下：</p>\n<ul>\n<li><p>resource：资源名称，可以是网关中的 route 名称或者用户自定义的 API 分组名称。</p>\n</li>\n<li><p>resourceMode：规则是针对 API Gateway 的 route（RESOURCE_MODE_ROUTE_ID）还是用户在 Sentinel 中定义的 API 分组（RESOURCE_MODE_CUSTOM_API_NAME），默认是 route。</p>\n</li>\n<li><p>grade：限流指标维度，同限流规则的 grade 字段。</p>\n</li>\n<li><p>count：限流阈值</p>\n</li>\n<li><p>intervalSec：统计时间窗口，单位是秒，默认是 1 秒。</p>\n</li>\n<li><p>controlBehavior：流量整形的控制效果，同限流规则的 controlBehavior 字段，目前支持快速失败和匀速排队两种模式，默认是快速失败。</p>\n</li>\n<li><p>burst：应对突发请求时额外允许的请求数目。</p>\n</li>\n<li><p>maxQueueingTimeoutMs：匀速排队模式下的最长排队时间，单位是毫秒，仅在匀速排队模式下生效。</p>\n</li>\n<li><p>paramItem</p>\n<p>参数限流配置。若不提供，则代表不针对参数进行限流，该网关规则将会被转换成普通流控规则；否则会转换成热点规则。其中的字段：</p>\n<ul>\n<li>parseStrategy：从请求中提取参数的策略，目前支持提取来源 IP（PARAM_PARSE_STRATEGY_CLIENT_IP）、Host（PARAM_PARSE_STRATEGY_HOST）、任意 Header（PARAM_PARSE_STRATEGY_HEADER）和任意 URL 参数（PARAM_PARSE_STRATEGY_URL_PARAM）四种模式。</li>\n<li>fieldName：若提取策略选择 Header 模式或 URL 参数模式，则需要指定对应的 header 名称或 URL 参数名称。</li>\n<li>pattern：参数值的匹配模式，只有匹配该模式的请求属性值会纳入统计和流控；若为空则统计该请求属性的所有值。（1.6.2 版本开始支持）</li>\n<li>matchStrategy：参数值的匹配策略，目前支持精确匹配（PARAM_MATCH_STRATEGY_EXACT）、子串匹配（PARAM_MATCH_STRATEGY_CONTAINS）和正则匹配（PARAM_MATCH_STRATEGY_REGEX）。（1.6.2 版本开始支持）</li>\n</ul>\n</li>\n</ul>\n<p>用户可以通过 GatewayRuleManager.loadRules(rules) 手动加载网关规则，或通过 GatewayRuleManager.register2Property(property) 注册动态规则源动态推送（推荐方式）。</p>\n<h3 id=\"八、Gatway-网关的过滤器开发\"><a href=\"#八、Gatway-网关的过滤器开发\" class=\"headerlink\" title=\"八、Gatway 网关的过滤器开发\"></a>八、Gatway 网关的过滤器开发</h3><h4 id=\"过滤器的执行次序\"><a href=\"#过滤器的执行次序\" class=\"headerlink\" title=\"过滤器的执行次序\"></a>过滤器的执行次序</h4><p>Spring-Cloud-Gateway 基于过滤器实现，同 zuul 类似，有<strong>pre</strong>和<strong>post</strong>两种方式的 filter,分别处理<strong>前置逻辑</strong>和<strong>后置逻辑</strong>。客户端的请求先经过<strong>pre</strong>类型的 filter，然后将请求转发到具体的业务服务，收到业务服务的响应之后，再经过<strong>post</strong>类型的 filter 处理，最后返回响应到客户端。</p>\n<p>过滤器执行流程如下，<strong>order 越大，优先级越低</strong></p>\n<div>\n  <img src=\"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:10-11:07:45.png\" alt=\"img\" style=\"zoom:50%;\" />\n</div>\n\n\n\n<p>分为全局过滤器和局部过滤器</p>\n<ul>\n<li><strong>全局过滤器：</strong></li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>对所有路由生效</p>\n<p>2、接口用时统计</p></blockquote>\n<ul>\n<li><strong>局部过滤器：</strong></li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>对指定路由生效</p></blockquote>\n<h4 id=\"定义全局过滤器\"><a href=\"#定义全局过滤器\" class=\"headerlink\" title=\"定义全局过滤器\"></a>定义全局过滤器</h4><p>实现 GlobalFilter 和 Ordered，重写相关方法，加入到spring容器管理即可，无需配置，全局过滤器对所有的路由都有效。</p>\n<p>全局过滤器举例：代码如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.crazymaker.cloud.nacos.demo.gateway.config;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.cloud.gateway.filter.GatewayFilterChain;\nimport org.springframework.cloud.gateway.filter.GlobalFilter;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.web.server.ServerWebExchange;\nimport reactor.core.publisher.Mono;\n\n@Configuration\npublic class FilterConfig\n&#123;\n\n    @Bean\n    @Order(-1)\n    public GlobalFilter a()\n    &#123;\n        return new AFilter();\n    &#125;\n\n    @Bean\n    @Order(0)\n    public GlobalFilter b()\n    &#123;\n        return new BFilter();\n    &#125;\n\n    @Bean\n    @Order(1)\n    public GlobalFilter c()\n    &#123;\n        return new CFilter();\n    &#125;\n\n\n    @Slf4j\n    public class AFilter implements GlobalFilter, Ordered\n    &#123;\n\n        @Override\n        public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain)\n        &#123;\n            log.info(&quot;AFilter前置逻辑&quot;);\n            return chain.filter(exchange).then(Mono.fromRunnable(() -&gt;\n            &#123;\n                log.info(&quot;AFilter后置逻辑&quot;);\n            &#125;));\n        &#125;\n\n        &#x2F;&#x2F;   值越小，优先级越高\n&#x2F;&#x2F;    int HIGHEST_PRECEDENCE &#x3D; -2147483648;\n&#x2F;&#x2F;    int LOWEST_PRECEDENCE &#x3D; 2147483647;\n        @Override\n        public int getOrder()\n        &#123;\n            return HIGHEST_PRECEDENCE + 100;\n        &#125;\n    &#125;\n\n    @Slf4j\n    public class BFilter implements GlobalFilter, Ordered\n    &#123;\n        @Override\n        public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain)\n        &#123;\n            log.info(&quot;BFilter前置逻辑&quot;);\n            return chain.filter(exchange).then(Mono.fromRunnable(() -&gt;\n            &#123;\n                log.info(&quot;BFilter后置逻辑&quot;);\n            &#125;));\n        &#125;\n\n\n        &#x2F;&#x2F;   值越小，优先级越高\n&#x2F;&#x2F;    int HIGHEST_PRECEDENCE &#x3D; -2147483648;\n&#x2F;&#x2F;    int LOWEST_PRECEDENCE &#x3D; 2147483647;\n        @Override\n        public int getOrder()\n        &#123;\n            return HIGHEST_PRECEDENCE + 200;\n        &#125;\n    &#125;\n\n    @Slf4j\n    public class CFilter implements GlobalFilter, Ordered\n    &#123;\n\n        @Override\n        public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain)\n        &#123;\n            log.info(&quot;CFilter前置逻辑&quot;);\n            return chain.filter(exchange).then(Mono.fromRunnable(() -&gt;\n            &#123;\n                log.info(&quot;CFilter后置逻辑&quot;);\n            &#125;));\n        &#125;\n\n        &#x2F;&#x2F;   值越小，优先级越高\n&#x2F;&#x2F;    int HIGHEST_PRECEDENCE &#x3D; -2147483648;\n&#x2F;&#x2F;    int LOWEST_PRECEDENCE &#x3D; 2147483647;\n        @Override\n        public int getOrder()\n        &#123;\n            return HIGHEST_PRECEDENCE + 300;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h4 id=\"定义局部过滤器\"><a href=\"#定义局部过滤器\" class=\"headerlink\" title=\"定义局部过滤器\"></a>定义局部过滤器</h4><p>步骤：</p>\n<p>1 需要实现GatewayFilter, Ordered，实现相关的方法</p>\n<p>2 加入到过滤器工厂，并且注册到spring容器中。</p>\n<p>3、在配置文件中进行配置，如果不配置则不启用此过滤器规则。</p>\n<p>局部过滤器举例, 对请求头部的 user-id 进行校验，代码如下：</p>\n<p>1 需要实现GatewayFilter, Ordered，实现相关的方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.crazymaker.cloud.nacos.demo.gateway.filter;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.lang3.StringUtils;\nimport org.springframework.cloud.gateway.filter.GatewayFilter;\nimport org.springframework.cloud.gateway.filter.GatewayFilterChain;\nimport org.springframework.cloud.gateway.filter.GlobalFilter;\nimport org.springframework.core.Ordered;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.server.ServerWebExchange;\nimport reactor.core.publisher.Mono;\n\n&#x2F;&#x2F;@Component\n@Slf4j\npublic class UserIdCheckGateWayFilter implements GatewayFilter, Ordered\n&#123;\n    @Override\n    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain)\n    &#123;\n        String url &#x3D; exchange.getRequest().getPath().pathWithinApplication().value();\n        log.info(&quot;请求URL:&quot; + url);\n        log.info(&quot;method:&quot; + exchange.getRequest().getMethod());\n       &#x2F;*   String secret &#x3D; exchange.getRequest().getHeaders().getFirst(&quot;secret&quot;);\n        if (StringUtils.isBlank(secret))\n        &#123;\n            return chain.filter(exchange);\n        &#125;*&#x2F;\n         &#x2F;&#x2F;获取param 请求参数\n        String uname &#x3D; exchange.getRequest().getQueryParams().getFirst(&quot;uname&quot;);\n        &#x2F;&#x2F;获取header\n        String userId &#x3D; exchange.getRequest().getHeaders().getFirst(&quot;user-id&quot;);\n        log.info(&quot;userId：&quot; + userId);\n\n        if (StringUtils.isBlank(userId))\n        &#123;\n            log.info(&quot;*****头部验证不通过，请在头部输入  user-id&quot;);\n            &#x2F;&#x2F;终止请求，直接回应\n            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);\n            return exchange.getResponse().setComplete();\n        &#125;\n        return chain.filter(exchange);\n    &#125;\n\n    &#x2F;&#x2F;   值越小，优先级越高\n&#x2F;&#x2F;    int HIGHEST_PRECEDENCE &#x3D; -2147483648;\n&#x2F;&#x2F;    int LOWEST_PRECEDENCE &#x3D; 2147483647;\n    @Override\n    public int getOrder()\n    &#123;\n        return HIGHEST_PRECEDENCE;\n    &#125;\n&#125;</code></pre>\n\n<p>2 加入到过滤器工厂，并且注册到spring容器中。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.crazymaker.cloud.nacos.demo.gateway.config;\n\nimport com.crazymaker.cloud.nacos.demo.gateway.filter.UserIdCheckGateWayFilter;\nimport org.springframework.cloud.gateway.filter.GatewayFilter;\nimport org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;\nimport org.springframework.stereotype.Component;\n\n\n@Component\npublic class UserIdCheckGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;Object&gt;\n&#123;\n    @Override\n    public GatewayFilter apply(Object config)\n    &#123;\n        return new UserIdCheckGateWayFilter();\n    &#125;\n&#125;</code></pre>\n\n<p>3、在配置文件中进行配置，如果不配置则不启用此过滤器规则。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">- id: service_provider_demo_route_filter\n  uri: lb:&#x2F;&#x2F;service-provider-demo\n  predicates:\n    - Path&#x3D;&#x2F;filter&#x2F;**\n  filters:\n    - RewritePath&#x3D;&#x2F;filter&#x2F;(?&lt;segment&gt;.*), &#x2F;provider&#x2F;$\\&#123;segment&#125;\n    - UserIdCheck</code></pre>","text":"一、SpringCloud Gateway 网关 1、Gateway 的概念SpringCloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网...","link":"","photos":[],"count_time":{"symbolsCount":"33k","symbolsTime":"30 mins."},"categories":[{"name":"SpringCloud","slug":"SpringCloud","count":4,"path":"api/categories/SpringCloud.json"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","count":4,"path":"api/tags/SpringCloud.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81SpringCloud-Gateway-%E7%BD%91%E5%85%B3\"><span class=\"toc-text\">一、SpringCloud Gateway 网关</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81Gateway-%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1、Gateway 的概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81Gateway-%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">2、Gateway 的作用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%BD%91%E5%85%B3%E7%9A%84%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">3、过滤器和网关的对比</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81zuul-%E5%92%8C-gateway%E7%9A%84%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">4、zuul 和 gateway的对比</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%E3%80%81Gateway-%E5%92%8C-Nginx-%E7%9A%84%E5%8D%B4%E5%88%AB\"><span class=\"toc-text\">5、Gateway 和 Nginx 的却别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6%E3%80%81Gateway-%E7%9A%84%E7%BB%84%E6%88%90\"><span class=\"toc-text\">6、Gateway 的组成</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7%E3%80%81Gateway-%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">7、Gateway 流程</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">二、路由配置方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%9F%BA%E7%A1%80-URI-%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">1、基础 URI 路由配置方式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">2、基于代码的路由配置方式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%92%8C%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9B%B8%E7%BB%93%E5%90%88%E7%9A%84%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">3、和注册中心相结合的路由配置</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99\"><span class=\"toc-text\">三、路由匹配规则</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81Predicate-%E6%96%AD%E8%A8%80%E6%9D%A1%E4%BB%B6-%E8%BD%AC%E5%8F%91%E8%A7%84%E5%88%99-%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">1、Predicate 断言条件(转发规则)介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E9%80%9A%E8%BF%87%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">2、通过请求参数匹配</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E9%80%9A%E8%BF%87-Header-%E5%B1%9E%E6%80%A7%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">3、通过 Header 属性匹配</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E9%80%9A%E8%BF%87-Cookie-%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">4、通过 Cookie 匹配</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%E3%80%81%E9%80%9A%E8%BF%87-Host-%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">5、通过 Host 匹配</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6%E3%80%81%E9%80%9A%E8%BF%87%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">6、通过请求方式匹配</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7%E3%80%81%E9%80%9A%E8%BF%87%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">7、通过请求路径匹配</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8%E3%80%81%E9%80%9A%E8%BF%87%E8%AF%B7%E6%B1%82-ip-%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8C%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">8、通过请求 ip 地址进行匹配</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9%E3%80%81%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">9、组合使用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8%E8%A7%84%E5%88%99%EF%BC%88Filter%EF%BC%89\"><span class=\"toc-text\">四、过滤器规则（Filter）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#PrefixPath\"><span class=\"toc-text\">PrefixPath</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#RedirectTo\"><span class=\"toc-text\">RedirectTo</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#RemoveRequestHeader\"><span class=\"toc-text\">RemoveRequestHeader</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#RemoveResponseHeader\"><span class=\"toc-text\">RemoveResponseHeader</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#RemoveRequestParameter\"><span class=\"toc-text\">RemoveRequestParameter</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#RewritePath\"><span class=\"toc-text\">RewritePath</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#SetPath\"><span class=\"toc-text\">SetPath</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#SetRequestHeader\"><span class=\"toc-text\">SetRequestHeader</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#SetStatus\"><span class=\"toc-text\">SetStatus</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#StripPrefix\"><span class=\"toc-text\">StripPrefix</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#RequestSize\"><span class=\"toc-text\">RequestSize</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Default-filters\"><span class=\"toc-text\">Default-filters</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">通过代码进行配置</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E5%AE%9E%E7%8E%B0%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7\"><span class=\"toc-text\">五、实现熔断降级</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">六、高级配置</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81\"><span class=\"toc-text\">1、分布式限流</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">2、健康检查配置</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#maven%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">maven依赖</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">配置文件</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">3、统一配置跨域请求</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E9%89%B4%E6%9D%83\"><span class=\"toc-text\">4、鉴权</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%83%E3%80%81%E6%95%B4%E5%90%88Sentinel%E5%AE%8C%E6%88%90%E6%B5%81%E6%8E%A7%E5%92%8C%E9%99%8D%E7%BA%A7\"><span class=\"toc-text\">七、整合Sentinel完成流控和降级</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#maven%E4%BE%9D%E8%B5%96-1\"><span class=\"toc-text\">maven依赖</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-1\"><span class=\"toc-text\">配置文件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%99%90%E6%B5%81%E8%A7%84%E5%88%99%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">限流规则通用配置</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%99%90%E6%B5%81%E8%A7%84%E5%88%99%E8%AE%BE%E7%BD%AE\"><span class=\"toc-text\">限流规则设置</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BD%91%E5%85%B3%E9%99%90%E6%B5%81%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">网关限流参数</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AB%E3%80%81Gatway-%E7%BD%91%E5%85%B3%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E5%BC%80%E5%8F%91\"><span class=\"toc-text\">八、Gatway 网关的过滤器开发</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%AC%A1%E5%BA%8F\"><span class=\"toc-text\">过滤器的执行次序</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8\"><span class=\"toc-text\">定义全局过滤器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89%E5%B1%80%E9%83%A8%E8%BF%87%E6%BB%A4%E5%99%A8\"><span class=\"toc-text\">定义局部过滤器</span></a></li></ol></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"SpringCloud Slueth","uid":"2254a0dbf3036d34e7e7cb5837d981ff","slug":"71-SpringCloud-Slueth","date":"2021-09-13T15:47:32.000Z","updated":"2021-09-15T10:46:21.111Z","comments":true,"path":"api/articles/71-SpringCloud-Slueth.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog5.jpg","text":"1、概述随着业务发展，系统拆分导致系统调用链路愈发复杂一个前端请求可能最终需要调用很多次后端服务才能完成，当整个请求变慢或不可用时，我们是无法得知该请求是由某个或某些后端服务引起的，这时就需要解决如何快读定位服务故障点，以对症下药。于是就有了分布式系统调用跟踪的诞生。 现今业界分...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"SpringCloud","slug":"SpringCloud","count":4,"path":"api/categories/SpringCloud.json"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","count":4,"path":"api/tags/SpringCloud.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"SpringCloud Hoxton","uid":"7782f77d73b91eb2c8a016712795b746","slug":"69-SpringCloud-Hoxton","date":"2021-09-13T15:45:32.000Z","updated":"2021-09-15T10:46:34.911Z","comments":true,"path":"api/articles/69-SpringCloud-Hoxton.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog7.jpg","text":"01、Eureka 基本内容 在微服务架构中，服务注册与发现是核心组件之一，手动指定每个服务是很低效的，Spring cloud提供了多种服务注册与发现的实现方式,例如: Eureka、Consu、 Zookeeper SringCloud支持得最好的是 Eureka,其次是 C...","link":"","photos":[],"count_time":{"symbolsCount":"48k","symbolsTime":"44 mins."},"categories":[{"name":"SpringCloud","slug":"SpringCloud","count":4,"path":"api/categories/SpringCloud.json"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","count":4,"path":"api/tags/SpringCloud.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}