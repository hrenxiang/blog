{"title":"IO流（下）","uid":"76d4babd3007758066655a1fc80352b9","slug":"14-IO流（下）","date":"2021-09-13T14:49:32.000Z","updated":"2021-09-15T10:16:21.465Z","comments":true,"path":"api/articles/14-IO流（下）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","content":"<h3 id=\"一、字符流\"><a href=\"#一、字符流\" class=\"headerlink\" title=\"一、字符流\"></a>一、字符流</h3><p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p>\n<p>字符流与字节流的区别：字符流虽然以字节流为基础创建的，但是字节流可以支持声音，视频，图片，文本等所有文件类型，而<strong>字符流只支持文本文件</strong>。</p>\n<h3 id=\"二、编码与乱码\"><a href=\"#二、编码与乱码\" class=\"headerlink\" title=\"二、编码与乱码\"></a>二、编码与乱码</h3><ul>\n<li><p>编码: 字符 (能看懂的) –&gt; 字节 (看不懂的)</p>\n</li>\n<li><p>解码: 字节 (看不懂的) –&gt; 字符 (能看懂的)</p>\n</li>\n<li><p>字符编码<code>Character Encoding</code> : 就是一套自然语言的字符与二进制数之间的对应规则。</p>\n</li>\n<li><p>编码表:生活中文字和计算机中二进制的对应规则。</p>\n</li>\n<li><p>字符集 <code>Charset</code>：也叫<strong>编码表</strong>。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</p>\n</li>\n<li><p>乱码：编码与解码不一致，导致的乱码问题，每一种编码格式都有自己独特的编码，如果编码与解码不一致，势必会导致乱码，例如用Unicode编码，用gbk解码，就会字符与码值不匹配，从而导致乱码。</p>\n</li>\n<li><p>ASCII字符集</p>\n<ul>\n<li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li>\n<li>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用<strong>8位（bits）表示一个字符</strong>，共256字符，方便支持欧洲常用字符。</li>\n</ul>\n</li>\n<li><p>ISO-8859-1字符集</p>\n<ul>\n<li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li>\n<li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li>\n</ul>\n</li>\n<li><p>GBxxx字符集</p>\n<ul>\n<li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li>\n<li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</li>\n<li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了<strong>双字节</strong>编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li>\n<li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li>\n</ul>\n</li>\n<li><p>Unicode字符集</p>\n<ul>\n<li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li>\n<li>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</li>\n<li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：<ol>\n<li>128个US-ASCII字符，只需一个字节编码。</li>\n<li>拉丁文等字符，需要二个字节编码。</li>\n<li><strong>大部分常用字（含中文），使用三个字节编码</strong>。</li>\n<li>其他极少使用的Unicode辅助字符，使用四字节编码。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三、字符输入流\"><a href=\"#三、字符输入流\" class=\"headerlink\" title=\"三、字符输入流\"></a>三、字符输入流</h3><h4 id=\"1、字符输入流，输出流\"><a href=\"#1、字符输入流，输出流\" class=\"headerlink\" title=\"1、字符输入流，输出流\"></a>1、字符输入流，输出流</h4><ul>\n<li><p><code>java.io.Reader</code>抽象类是表示用于<strong>读取字符流的所有类的超类</strong>，可以读取字符信息到内存中。它定义了字符输入流的基本<strong>共性</strong>功能方法。</p>\n<ul>\n<li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。</li>\n<li><code>public int read()</code>： 从输入流读取一个字符。</li>\n<li><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</li>\n</ul>\n</li>\n<li><p><code>java.io.Writer</code>抽象类是表示用于<strong>写入字符流的所有类的超类</strong>，将指定的字符信息写入到目的地。它定义了字节输出流的基本<strong>共性</strong>功能方法。</p>\n<ul>\n<li><code>void write(int c)</code> 写入单个字符。</li>\n<li><code>void write(char[] cbuf)</code>写入字符数组。</li>\n<li><code>abstract void write(char[] cbuf, int off, int len)</code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。</li>\n<li><code>void write(String str)</code>写入字符串。</li>\n<li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li>\n<li><code>void flush()</code>刷新该流的缓冲。</li>\n<li><code>void close()</code> <strong>关闭此流，但要先刷新它</strong>。</li>\n</ul>\n<p><strong>注意</strong>：close（）方法默认调用了flush（）方法，但是<strong>flush（）方法只刷新缓冲区</strong>，而close（）还会关闭IO流</p>\n</li>\n</ul>\n<h4 id=\"2、FileReader类\"><a href=\"#2、FileReader类\" class=\"headerlink\" title=\"2、FileReader类\"></a>2、FileReader类</h4><p><code>java.io.FileReader</code>类是读取字符文件的便利类。构造时<strong>使用系统默认的字符编码和默认字节缓冲区</strong>。</p>\n<ul>\n<li><code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象。</li>\n<li><code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。</li>\n</ul>\n<h4 id=\"3、FileWriter类\"><a href=\"#3、FileWriter类\" class=\"headerlink\" title=\"3、FileWriter类\"></a>3、FileWriter类</h4><ul>\n<li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。</li>\n<li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。</li>\n</ul>\n<h4 id=\"4、关闭和刷新\"><a href=\"#4、关闭和刷新\" class=\"headerlink\" title=\"4、关闭和刷新\"></a>4、关闭和刷新</h4><p>因为内置缓冲区的原因，如果不关闭输出流，无法写入字符到文件中。但是关闭的流对象，是无法继续写入数据的。如果我们既想写入数据，又想继续使用流，就需要<code>flush</code> 方法了。</p>\n<ul>\n<li><code>flush</code> ：刷新缓冲区，流对象可以继续使用。</li>\n<li><code>close</code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li>\n</ul>\n<h3 id=\"四、缓冲流\"><a href=\"#四、缓冲流\" class=\"headerlink\" title=\"四、缓冲流\"></a>四、缓冲流</h3><h4 id=\"1、概述\"><a href=\"#1、概述\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h4><p>高效读写的缓冲流，转换编码的转换流，持久化存储对象的序列化流等等，这些流的功能更为强大</p>\n<p>缓冲流,也叫高效流，是对4个基本的<code>FileXxx</code> 流的增强，所以也是4个流，按照数据类型分类：</p>\n<ul>\n<li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code></li>\n<li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li>\n</ul>\n<p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p>\n<h4 id=\"2、字节缓冲流\"><a href=\"#2、字节缓冲流\" class=\"headerlink\" title=\"2、字节缓冲流\"></a>2、字节缓冲流</h4><ul>\n<li><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的缓冲输入流。</li>\n<li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 创建字节缓冲输入流\nBufferedInputStream bis &#x3D; new BufferedInputStream(new FileInputStream(&quot;bis.txt&quot;));\n&#x2F;&#x2F; 创建字节缓冲输出流\nBufferedOutputStream bos &#x3D; new BufferedOutputStream(new FileOutputStream(&quot;bos.txt&quot;));</code></pre>\n\n<p>缓冲流读写方法与基本流是一致的，但是缓冲流的执行效率要比基本流高效。</p>\n<h4 id=\"3、字符缓冲流\"><a href=\"#3、字符缓冲流\" class=\"headerlink\" title=\"3、字符缓冲流\"></a>3、字符缓冲流</h4><p>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的<strong>特有方法</strong>。</p>\n<ul>\n<li>BufferedReader：<code>public String readLine()</code>: 读一行文字。</li>\n<li>BufferedWriter：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。</li>\n</ul>\n<h3 id=\"五、转换流\"><a href=\"#五、转换流\" class=\"headerlink\" title=\"五、转换流\"></a>五、转换流</h3><h4 id=\"1、概述-1\"><a href=\"#1、概述-1\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h4><p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从<strong>字节流到字符流</strong>的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>\n<h4 id=\"2、InputStreamReader\"><a href=\"#2、InputStreamReader\" class=\"headerlink\" title=\"2、InputStreamReader\"></a>2、InputStreamReader</h4><p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>\n<ul>\n<li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。</li>\n<li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>\n</ul>\n<h4 id=\"3、OutputStreamWriter\"><a href=\"#3、OutputStreamWriter\" class=\"headerlink\" title=\"3、OutputStreamWriter\"></a>3、OutputStreamWriter</h4><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>\n<ul>\n<li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。</li>\n<li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>\n</ul>\n<h4 id=\"4、解码需回到转换流\"><a href=\"#4、解码需回到转换流\" class=\"headerlink\" title=\"4、解码需回到转换流\"></a>4、解码需回到转换流</h4><ul>\n<li>FileReader和FileWriter是InputStreamReader和OutputStreamWriter的直接子类方便书写</li>\n<li>如果需要进行字符编码，解码问题，还需要回到InputStreamReader和OutputStreamWriter</li>\n</ul>\n<h3 id=\"六、序列化和反序列化\"><a href=\"#六、序列化和反序列化\" class=\"headerlink\" title=\"六、序列化和反序列化\"></a>六、序列化和反序列化</h3><h4 id=\"1、概述-2\"><a href=\"#1、概述-2\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h4><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。</p>\n<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。</p>\n<p><img src=\"https://gitee.com/xiuxiuai/picture/raw/master/img/%E5%BA%8F%E5%88%97%E5%8C%96.jpg\" alt=\"img\"></p>\n<p><strong>transient     关键字</strong>：被修饰的成员，在 不会被序列化。所以当我们用序列化流去存储后，在读取时，所得到的结果 和 我们读取未赋值的成员的结果一样，不能修饰方法。</p>\n<h4 id=\"2、ObjectOutputStream\"><a href=\"#2、ObjectOutputStream\" class=\"headerlink\" title=\"2、ObjectOutputStream\"></a>2、ObjectOutputStream</h4><p><code>java.io.ObjectOutputStream</code> 类，将Java对象的原始数据类型写入到文件,实现对象的持久存储。</p>\n<p><code>public ObjectOutputStream(OutputStream out)</code>： 创建一个指定OutputStream的ObjectOutputStream。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">FileOutputStream fileOut &#x3D; new FileOutputStream(&quot;employee.txt&quot;);\nObjectOutputStream out &#x3D; new ObjectOutputStream(fileOut);</code></pre>\n\n<h4 id=\"3、序列化实现\"><a href=\"#3、序列化实现\" class=\"headerlink\" title=\"3、序列化实现\"></a>3、序列化实现</h4><p>一个对象要想序列化，必须满足两个条件:</p>\n<ul>\n<li>该类必须实现<code>java.io.Serializable</code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</li>\n<li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li>\n</ul>\n<p>调用<code>writeObject</code>方法，序列化写入数据。</p>\n<h4 id=\"4、ObjectInputStream\"><a href=\"#4、ObjectInputStream\" class=\"headerlink\" title=\"4、ObjectInputStream\"></a>4、ObjectInputStream</h4><p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。</p>\n<ul>\n<li><code>public ObjectInputStream(InputStream in)</code>： 创建一个指定InputStream的ObjectInputStream。</li>\n<li><code>public final Object readObject ()</code> : 读取一个对象。</li>\n</ul>\n<h4 id=\"5、反序列化注意事项\"><a href=\"#5、反序列化注意事项\" class=\"headerlink\" title=\"5、反序列化注意事项\"></a>5、反序列化注意事项</h4><p>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。发生这个异常的原因如下：</p>\n<ul>\n<li>该类的序列版本号与从流中读取的类描述符的版本号不匹配</li>\n<li>该类包含未知数据类型</li>\n<li>该类没有可访问的无参数构造方法</li>\n</ul>\n<p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p>\n<h3 id=\"七、打印流\"><a href=\"#七、打印流\" class=\"headerlink\" title=\"七、打印流\"></a>七、打印流</h3><h4 id=\"1、概述-3\"><a href=\"#1、概述-3\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h4><p>平时我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，这两个方法都来自于<code>java.io.PrintStream</code>类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p>\n<p>打印流分为：字节流打印流 与 字符打印流</p>\n<p>通过这两个流，我们可以向所关联的文件 或 或控制台 打印数据</p>\n<p>打印流只有输出流，没有输入流</p>\n<h4 id=\"2、PrintStream（字节打印流）\"><a href=\"#2、PrintStream（字节打印流）\" class=\"headerlink\" title=\"2、PrintStream（字节打印流）\"></a>2、PrintStream（字节打印流）</h4><ul>\n<li><p>概述：</p>\n<ul>\n<li><p>PrintStream 为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。</p>\n<p>异常情况仅设置可通过 checkError 方法测试的内部标志。</p>\n<p>另外，为了自动刷新，可以创建一个 PrintStream；</p>\n</li>\n<li><p>这意味着可在写入 byte 数组之后自动调用 flush 方法，可调用其中一个 println 方法，或写入一个换行符或字节 (‘\\n’)。、</p>\n<p>PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。</p>\n</li>\n<li><p>在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。</p>\n</li>\n</ul>\n</li>\n<li><p>构造方法：</p>\n<ul>\n<li><p>PrintStream(String fileName)</p>\n<p>创建具有指定文件名称的新打印流</p>\n</li>\n<li><p>PrintStream(String fileName, String csn)</p>\n<p>创建具有指定文件名称和字符集的新打印流</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3、标准输入输出流\"><a href=\"#3、标准输入输出流\" class=\"headerlink\" title=\"3、标准输入输出流\"></a>3、标准输入输出流</h4><p>标准输入输出流：System类中的两个成员变量。</p>\n<p>标准输入流(public static final InputStream in)：通常，此流对应于键盘输入或者由主机环境或用户指定的另一个输入源。</p>\n<p>​          InputStream is = System.in;</p>\n<p>标准输出流(public static final PrintStream out)：通常，此流对应于显示器输出或者由主机环境或用户指定的另一个输出目标。</p>\n<p>​          PrintStream ps = System.out;</p>\n<p>System.out，本质是PrintStream类</p>\n<h4 id=\"4、PrintWriter类（字符打印流）\"><a href=\"#4、PrintWriter类（字符打印流）\" class=\"headerlink\" title=\"4、PrintWriter类（字符打印流）\"></a>4、PrintWriter类（字符打印流）</h4><ol>\n<li><p>概述：</p>\n<ul>\n<li>向文本输出流打印对象的格式化表示形式。</li>\n<li>此类实现在 PrintStream 中的所有 print 方法。</li>\n<li>它不包含用于写入原始字节的方法，对于这些字节，程序应该使用未编码的字节流进行写入。</li>\n<li>与 PrintStream 类不同，如果启用了自动刷新，则只有在调用 println、printf 或 format 的其中一个方法时才可能完成此操作，而不是每当正好输出换行符时才完成。</li>\n<li>这些方法使用平台自有的行分隔符概念，而不是换行符。</li>\n</ul>\n</li>\n<li><p>构造方法：</p>\n<ul>\n<li><p>PrintWriter(String fileName)</p>\n<p>创建具有指定文件名称且不带自动行刷新的新 PrintWriter</p>\n</li>\n<li><p>PrintWriter(String fileName, String csn)</p>\n<p>创建具有指定文件名称和字符集且不带自动行刷新的新 PrintWriter</p>\n</li>\n<li><p>PrintWriter(Writer out, boolean autoFlush)</p>\n<p>创建带自动行刷新的新 PrintWriter</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>虽然打印流没有输入流，但不意味着不能复制文件（借用BufferedReader）</p>\n<h3 id=\"八、属性集（Properties）\"><a href=\"#八、属性集（Properties）\" class=\"headerlink\" title=\"八、属性集（Properties）\"></a>八、属性集（Properties）</h3><h4 id=\"1、概述-4\"><a href=\"#1、概述-4\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h4><p><code>java.util.Properties</code> 继承于<code>Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，<code>System.getProperties</code> 方法就是返回一个<code>Properties</code>对象。</p>\n<h4 id=\"2、Properties类\"><a href=\"#2、Properties类\" class=\"headerlink\" title=\"2、Properties类\"></a>2、Properties类</h4><ul>\n<li><code>public Properties()</code> :创建一个空的属性列表。</li>\n<li><code>public void load(InputStream inStream)</code>： 从字节输入流中读取键值对。</li>\n<li><code>public Set&lt;String&gt; stringPropertyNames()</code> ：所有键的名称的集合。</li>\n<li>getProperty(String key)：用指定的键在此属性列表中搜索属性若搜索不到，则null</li>\n<li>void list(PrintStream out)：将属性列表输出到指定的输出流</li>\n<li>void list(PrintWriter out)：将属性列表输出到指定的输出流</li>\n</ul>\n<p>参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">filename&#x3D;a.txt\nlength&#x3D;209385038\nlocation&#x3D;D:\\a.txt</code></pre>\n\n<p>加载代码演示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ProDemo2 &#123;\n    public static void main(String[] args) throws FileNotFoundException &#123;\n        &#x2F;&#x2F; 创建属性集对象\n        Properties pro &#x3D; new Properties();\n        &#x2F;&#x2F; 加载文本中信息到属性集\n        pro.load(new FileInputStream(&quot;read.txt&quot;));\n        &#x2F;&#x2F; 遍历集合并打印\n        Set&lt;String&gt; strings &#x3D; pro.stringPropertyNames();\n        for (String key : strings ) &#123;\n              System.out.println(key+&quot; -- &quot;+pro.getProperty(key));\n        &#125;\n     &#125;\n&#125;\n输出结果：\nfilename -- a.txt\nlength -- 209385038\nlocation -- D:\\a.txt</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p></blockquote>\n","text":"一、字符流当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。 字符流与字节流的区别：字符流虽然以字节流为基础创建的，但是字...","link":"","photos":[],"count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/tags/JavaSE.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%AD%97%E7%AC%A6%E6%B5%81\"><span class=\"toc-text\">一、字符流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E7%BC%96%E7%A0%81%E4%B8%8E%E4%B9%B1%E7%A0%81\"><span class=\"toc-text\">二、编码与乱码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81\"><span class=\"toc-text\">三、字符输入流</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%8C%E8%BE%93%E5%87%BA%E6%B5%81\"><span class=\"toc-text\">1、字符输入流，输出流</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81FileReader%E7%B1%BB\"><span class=\"toc-text\">2、FileReader类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81FileWriter%E7%B1%BB\"><span class=\"toc-text\">3、FileWriter类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E5%85%B3%E9%97%AD%E5%92%8C%E5%88%B7%E6%96%B0\"><span class=\"toc-text\">4、关闭和刷新</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E7%BC%93%E5%86%B2%E6%B5%81\"><span class=\"toc-text\">四、缓冲流</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1、概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81\"><span class=\"toc-text\">2、字节缓冲流</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81\"><span class=\"toc-text\">3、字符缓冲流</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81\"><span class=\"toc-text\">五、转换流</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%A6%82%E8%BF%B0-1\"><span class=\"toc-text\">1、概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81InputStreamReader\"><span class=\"toc-text\">2、InputStreamReader</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81OutputStreamWriter\"><span class=\"toc-text\">3、OutputStreamWriter</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E8%A7%A3%E7%A0%81%E9%9C%80%E5%9B%9E%E5%88%B0%E8%BD%AC%E6%8D%A2%E6%B5%81\"><span class=\"toc-text\">4、解码需回到转换流</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96\"><span class=\"toc-text\">六、序列化和反序列化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%A6%82%E8%BF%B0-2\"><span class=\"toc-text\">1、概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81ObjectOutputStream\"><span class=\"toc-text\">2、ObjectOutputStream</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">3、序列化实现</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81ObjectInputStream\"><span class=\"toc-text\">4、ObjectInputStream</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">5、反序列化注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%83%E3%80%81%E6%89%93%E5%8D%B0%E6%B5%81\"><span class=\"toc-text\">七、打印流</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%A6%82%E8%BF%B0-3\"><span class=\"toc-text\">1、概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81PrintStream%EF%BC%88%E5%AD%97%E8%8A%82%E6%89%93%E5%8D%B0%E6%B5%81%EF%BC%89\"><span class=\"toc-text\">2、PrintStream（字节打印流）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81\"><span class=\"toc-text\">3、标准输入输出流</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81PrintWriter%E7%B1%BB%EF%BC%88%E5%AD%97%E7%AC%A6%E6%89%93%E5%8D%B0%E6%B5%81%EF%BC%89\"><span class=\"toc-text\">4、PrintWriter类（字符打印流）</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AB%E3%80%81%E5%B1%9E%E6%80%A7%E9%9B%86%EF%BC%88Properties%EF%BC%89\"><span class=\"toc-text\">八、属性集（Properties）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%A6%82%E8%BF%B0-4\"><span class=\"toc-text\">1、概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81Properties%E7%B1%BB\"><span class=\"toc-text\">2、Properties类</span></a></li></ol></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"多线程","uid":"ed728f6a9d3e4347d3410adc7305d745","slug":"15-多线程","date":"2021-09-13T14:50:32.000Z","updated":"2021-09-15T10:16:45.091Z","comments":true,"path":"api/articles/15-多线程.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"一、多任务我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？为什么操作系统上可以同时运行多个程序而用户感觉不出来？ 这是因为无论是单CPU还是多CPU，操作系统都营造出了可以同时运行多个程序的假象。实际的过程操作...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/tags/JavaSE.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"IO流（上）","uid":"4e865ee4768f3582deb20f72187b6c6b","slug":"13-IO流（上）","date":"2021-09-13T14:48:32.000Z","updated":"2021-09-15T10:16:02.083Z","comments":true,"path":"api/articles/13-IO流（上）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"一、File类1、概述 File类的一个对象，代表一个文件或一个文件目录(俗称：文件夹) File类声明在java.io包下 File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法， 并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须...","link":"","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/tags/JavaSE.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}