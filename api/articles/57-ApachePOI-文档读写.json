{"title":"ApachePOI 文档读写","uid":"fc61a710e2053b4421eaf30d8ac4fc38","slug":"57-ApachePOI-文档读写","date":"2021-09-13T15:34:32.000Z","updated":"2021-09-15T10:48:51.931Z","comments":true,"path":"api/articles/57-ApachePOI-文档读写.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog7.jpg","content":"<h4 id=\"whale-Apache-POI基础\"><a href=\"#whale-Apache-POI基础\" class=\"headerlink\" title=\":whale: Apache POI基础\"></a>:whale: Apache POI基础</h4><hr>\n<h4 id=\"①-Apache-POI简介\"><a href=\"#①-Apache-POI简介\" class=\"headerlink\" title=\"① Apache POI简介\"></a>① Apache POI简介</h4><p>Apache POI是一种流行的API，它允许程序员使用Java程序创建，修改和显示MS Office文件。这由Apache软件基金会开发使用Java分布式设计或修改Microsoft Office文件的开源库。它包含类和方法对用户输入数据或文件到MS Office文档进行解码。</p>\n<p>官方主页： <a href=\"http://poi.apache.org/index.html\">http://poi.apache.org/index.html</a></p>\n<p>API文档： <a href=\"http://poi.apache.org/apidocs/index.html\">http://poi.apache.org/apidocs/index.html</a></p>\n<h4 id=\"②-Apache-POI组件\"><a href=\"#②-Apache-POI组件\" class=\"headerlink\" title=\"② Apache POI组件\"></a>② Apache POI组件</h4><p>Apache POI包含类和方法，来将MS Office所有OLE 2文档复合。此API组件的列表如下。</p>\n<p>POIFS (较差混淆技术实现文件系统) : 此组件是所有其他POI元件的基本因素。它被用来明确地读取不同的文件。</p>\n<p><strong>HSSF</strong> (可怕的电子表格格式) : 它被用来读取和写入MS-Excel文件的xls格式。</p>\n<p><strong>XSSF</strong> (XML格式) : 它是用于MS-Excel中XLSX文件格式。</p>\n<p>HPSF (可怕的属性设置格式) : 它用来提取MS-Office文件属性设置。</p>\n<p>HWPF (可怕的字处理器格式) : 它是用来读取和写入MS-Word的文档扩展名的文件。</p>\n<p>XWPF (XML字处理器格式) : 它是用来读取和写入MS-Word的docx扩展名的文件。</p>\n<p>HSLF (可怕的幻灯片版式格式) : 它是用于读取，创建和编辑PowerPoint演示文稿。</p>\n<p>HDGF (可怕的图表格式) : 它包含类和方法为MS-Visio的二进制文件。</p>\n<p>HPBF (可怕的出版商格式**) :** 它被用来读取和写入MS-Publisher文件。</p>\n<h4 id=\"③-Excel包名称说明\"><a href=\"#③-Excel包名称说明\" class=\"headerlink\" title=\"③ Excel包名称说明\"></a>③ Excel包名称说明</h4><table>\n<thead>\n<tr>\n<th></th>\n<th>HSSF</th>\n<th>XSSF</th>\n<th>SXSSF</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>对应Excel版本</td>\n<td>2003及2003版本以前</td>\n<td>2007后版本</td>\n<td>2007后版本</td>\n</tr>\n<tr>\n<td>扩展名</td>\n<td>.xls</td>\n<td>.xlsx</td>\n<td>.xlsx</td>\n</tr>\n<tr>\n<td>区别</td>\n<td>最常用的方式，但是不能超过65535行，超出65536条就会报错，此方式因不足7万行所以一般不会内存溢出（OOM）</td>\n<td>突破HSSF 65535行的局限(1048576行，16384列)，不过就伴随着一个问题内存溢出，原因是你创建的是存在内存的并没有持久化</td>\n<td>POI 3.8 开始，提供基于XSSF低内存占用的SXSSF方式。它只会保存最新的excel rows在内存里供查看，在此之前的都会被写入到硬盘里。被写入硬盘的rows是不可见/不可访问的。只有内存里才可以访问到</td>\n</tr>\n</tbody></table>\n<h4 id=\"④-Maven坐标\"><a href=\"#④-Maven坐标\" class=\"headerlink\" title=\"④ Maven坐标\"></a>④ Maven坐标</h4><pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!--1.1 导入导出为.xls格式时，引入该依赖即可--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.poi&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;poi&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.14&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!--1.2 导入导出为.xlsx格式(07及以后版本)，引入该依赖即可--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.poi&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;poi-ooxml&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.14&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n\n\n<h4 id=\"⑤-简单的读取工具类（重要）\"><a href=\"#⑤-简单的读取工具类（重要）\" class=\"headerlink\" title=\"⑤ 简单的读取工具类（重要）\"></a>⑤ 简单的读取工具类（重要）</h4><p>==excle行和列的下标都是从0开始==</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.utils;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\nimport org.apache.poi.ss.usermodel.Cell;\nimport org.apache.poi.ss.usermodel.Row;\nimport org.apache.poi.ss.usermodel.Sheet;\nimport org.apache.poi.ss.usermodel.Workbook;\nimport org.apache.poi.xssf.usermodel.XSSFWorkbook;\nimport org.springframework.web.multipart.MultipartFile;\n\npublic class POIUtils &#123;\n    private final static String xls &#x3D; &quot;xls&quot;;\n    private final static String xlsx &#x3D; &quot;xlsx&quot;;\n    private final static String DATE_FORMAT &#x3D; &quot;yyyy&#x2F;MM&#x2F;dd&quot;;\n    &#x2F;**\n     * 读入excel文件，解析后返回\n     * @param file\n     * @throws IOException\n     *&#x2F;\n    public static List&lt;String[]&gt; readExcel(MultipartFile file) throws IOException &#123;\n        &#x2F;&#x2F;检查文件\n        checkFile(file);\n        &#x2F;&#x2F;获得Workbook工作薄对象\n        Workbook workbook &#x3D; getWorkBook(file);\n        &#x2F;&#x2F;创建返回对象，把每行中的值作为一个数组，所有行作为一个集合返回\n        List&lt;String[]&gt; list &#x3D; new ArrayList&lt;String[]&gt;();\n        if(workbook !&#x3D; null)&#123;\n            for(int sheetNum &#x3D; 0;sheetNum &lt; workbook.getNumberOfSheets();sheetNum++)&#123;\n                &#x2F;&#x2F;获得当前sheet工作表\n                Sheet sheet &#x3D; workbook.getSheetAt(sheetNum);\n                if(sheet &#x3D;&#x3D; null)&#123;\n                    continue;\n                &#125;\n                &#x2F;&#x2F;获得当前sheet的开始行\n                int firstRowNum  &#x3D; sheet.getFirstRowNum();\n                &#x2F;&#x2F;获得当前sheet的结束行\n                int lastRowNum &#x3D; sheet.getLastRowNum();\n                &#x2F;&#x2F;循环除了第一行的所有行\n                for(int rowNum &#x3D; firstRowNum+1;rowNum &lt;&#x3D; lastRowNum;rowNum++)&#123;\n                    &#x2F;&#x2F;获得当前行\n                    Row row &#x3D; sheet.getRow(rowNum);\n                    if(row &#x3D;&#x3D; null)&#123;\n                        continue;\n                    &#125;\n                    &#x2F;&#x2F;获得当前行的开始列\n                    int firstCellNum &#x3D; row.getFirstCellNum();\n                    &#x2F;&#x2F;获得当前行的列数\n                    int lastCellNum &#x3D; row.getPhysicalNumberOfCells();\n                    String[] cells &#x3D; new String[row.getPhysicalNumberOfCells()];\n                    &#x2F;&#x2F;循环当前行\n                    for(int cellNum &#x3D; firstCellNum; cellNum &lt; lastCellNum;cellNum++)&#123;\n                        Cell cell &#x3D; row.getCell(cellNum);\n                        cells[cellNum] &#x3D; getCellValue(cell);\n                    &#125;\n                    list.add(cells);\n                &#125;\n            &#125;\n            workbook.close();\n        &#125;\n        return list;\n    &#125;\n\n    &#x2F;&#x2F;校验文件是否合法\n    public static void checkFile(MultipartFile file) throws IOException&#123;\n        &#x2F;&#x2F;判断文件是否存在\n        if(null &#x3D;&#x3D; file)&#123;\n            throw new FileNotFoundException(&quot;文件不存在！&quot;);\n        &#125;\n        &#x2F;&#x2F;获得文件名\n        String fileName &#x3D; file.getOriginalFilename();\n        &#x2F;&#x2F;判断文件是否是excel文件\n        if(!fileName.endsWith(xls) &amp;&amp; !fileName.endsWith(xlsx))&#123;\n            throw new IOException(fileName + &quot;不是excel文件&quot;);\n        &#125;\n    &#125;\n    public static Workbook getWorkBook(MultipartFile file) &#123;\n        &#x2F;&#x2F;获得文件名\n        String fileName &#x3D; file.getOriginalFilename();\n        &#x2F;&#x2F;创建Workbook工作薄对象，表示整个excel\n        Workbook workbook &#x3D; null;\n        try &#123;\n            &#x2F;&#x2F;获取excel文件的io流\n            InputStream is &#x3D; file.getInputStream();\n            &#x2F;&#x2F;根据文件后缀名不同(xls和xlsx)获得不同的Workbook实现类对象\n            if(fileName.endsWith(xls))&#123;\n                &#x2F;&#x2F;2003\n                workbook &#x3D; new HSSFWorkbook(is);\n            &#125;else if(fileName.endsWith(xlsx))&#123;\n                &#x2F;&#x2F;2007\n                workbook &#x3D; new XSSFWorkbook(is);\n            &#125;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        return workbook;\n    &#125;\n    public static String getCellValue(Cell cell)&#123;\n        String cellValue &#x3D; &quot;&quot;;\n        if(cell &#x3D;&#x3D; null)&#123;\n            return cellValue;\n        &#125;\n        &#x2F;&#x2F;如果当前单元格内容为日期类型，需要特殊处理\n        String dataFormatString &#x3D; cell.getCellStyle().getDataFormatString();\n        if(dataFormatString.equals(&quot;m&#x2F;d&#x2F;yy&quot;))&#123;\n            cellValue &#x3D; new SimpleDateFormat(DATE_FORMAT).format(cell.getDateCellValue());\n            return cellValue;\n        &#125;\n        &#x2F;&#x2F;把数字当成String来读，避免出现1读成1.0的情况\n        if(cell.getCellType() &#x3D;&#x3D; Cell.CELL_TYPE_NUMERIC)&#123;\n            cell.setCellType(Cell.CELL_TYPE_STRING);\n        &#125;\n        &#x2F;&#x2F;判断数据的类型\n        switch (cell.getCellType())&#123;\n            case Cell.CELL_TYPE_NUMERIC: &#x2F;&#x2F;数字\n                cellValue &#x3D; String.valueOf(cell.getNumericCellValue());\n                break;\n            case Cell.CELL_TYPE_STRING: &#x2F;&#x2F;字符串\n                cellValue &#x3D; String.valueOf(cell.getStringCellValue());\n                break;\n            case Cell.CELL_TYPE_BOOLEAN: &#x2F;&#x2F;Boolean\n                cellValue &#x3D; String.valueOf(cell.getBooleanCellValue());\n                break;\n            case Cell.CELL_TYPE_FORMULA: &#x2F;&#x2F;公式\n                cellValue &#x3D; String.valueOf(cell.getCellFormula());\n                break;\n            case Cell.CELL_TYPE_BLANK: &#x2F;&#x2F;空值\n                cellValue &#x3D; &quot;&quot;;\n                break;\n            case Cell.CELL_TYPE_ERROR: &#x2F;&#x2F;故障\n                cellValue &#x3D; &quot;非法字符&quot;;\n                break;\n            default:\n                cellValue &#x3D; &quot;未知类型&quot;;\n                break;\n        &#125;\n        return cellValue;\n    &#125;\n&#125;\n</code></pre>\n\n\n\n<h4 id=\"⑥-读取工具类的使用\"><a href=\"#⑥-读取工具类的使用\" class=\"headerlink\" title=\"⑥ 读取工具类的使用\"></a>⑥ 读取工具类的使用</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.controller;\n\nimport com.alibaba.dubbo.config.annotation.Reference;\nimport com.atguigu.constant.MessageConstant;\nimport com.atguigu.entity.Result;\nimport com.atguigu.pojo.OrderSetting;\nimport com.atguigu.service.OrderSettingService;\nimport com.atguigu.util.POIUtils;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.IOException;\nimport java.util.Date;\nimport java.util.List;\n\n&#x2F;**\n * @author hrenxiang\n * @create 2021&#x2F;7&#x2F;30 15:50\n *&#x2F;\n@RestController\n@ResponseBody\n@RequestMapping(&quot;&#x2F;ordersetting&quot;)\npublic class OrderSettingController &#123;\n\n    @Reference\n    private OrderSettingService orderSettingService;\n\n    @RequestMapping(&quot;&#x2F;upload.do&quot;)\n    public Result upload(MultipartFile excelFile) throws IOException &#123;\n\n        &#x2F;&#x2F;使用POI工具类读取excel文件，得到每一条数据，封装到集合中\n        List&lt;String[]&gt; strings &#x3D; POIUtils.readExcel(excelFile);\n\n        &#x2F;&#x2F;遍历每一条数据的集合strings,将之封装为OrderSetting类型，进行逐条添加\n        for (String[] row : strings) &#123;\n            &#x2F;&#x2F;构建orderSetting实体类\n            OrderSetting orderSetting &#x3D; new OrderSetting();\n            &#x2F;&#x2F;将数据进行转换，给实体类赋值\n            orderSetting.setOrderDate(new Date(row[0]));\n            orderSetting.setNumber(Integer.parseInt(row[1]));\n            &#x2F;&#x2F;进行添加操作\n            orderSettingService.add(orderSetting);\n        &#125;\n\n        return new Result(true, MessageConstant.IMPORT_ORDERSETTING_SUCCESS);\n    &#125;\n\n&#125;\n</code></pre>\n\n\n\n<h4 id=\"whale-HSSF的使用（了解）\"><a href=\"#whale-HSSF的使用（了解）\" class=\"headerlink\" title=\":whale: HSSF的使用（了解）\"></a>:whale: HSSF的使用（了解）</h4><hr>\n<h4 id=\"①-HSSF概况\"><a href=\"#①-HSSF概况\" class=\"headerlink\" title=\"① HSSF概况\"></a>① HSSF概况</h4><pre><code>HSSF 是Horrible SpreadSheet Format的缩写，通过HSSF，你可以用纯Java代码来读取、写入、修改Excel文件。HSSF 为读取操作提供了两类API：usermodel和eventusermodel，即“用户模型”和“事件-用户模型”。\n</code></pre>\n<h4 id=\"②-POI-EXCEL文档结构类\"><a href=\"#②-POI-EXCEL文档结构类\" class=\"headerlink\" title=\"② POI EXCEL文档结构类\"></a>② POI EXCEL文档结构类</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">HSSFWorkbook excel文档对象\nHSSFSheet excel的sheet HSSFRow excel的行\nHSSFCell excel的单元格 HSSFFont excel字体\nHSSFName 名称 HSSFDataFormat 日期格式\nHSSFHeader sheet头\nHSSFFooter sheet尾\nHSSFCellStyle cell样式\nHSSFDateUtil 日期\nHSSFPrintSetup 打印</code></pre>\n\n\n\n<h4 id=\"③-EXCEL常用操作方法\"><a href=\"#③-EXCEL常用操作方法\" class=\"headerlink\" title=\"③ EXCEL常用操作方法\"></a>③ EXCEL常用操作方法</h4><p>1、 得到Excel常用对象             </p>\n<pre><code>POIFSFileSystem fs=newPOIFSFileSystem(new FileInputStream(&quot;d:/test.xls&quot;));   \n//得到Excel工作簿对象   \nHSSFWorkbook wb = new HSSFWorkbook(fs);  \n//得到Excel工作表对象   \nHSSFSheet sheet = wb.getSheetAt(0);   \n//得到Excel工作表的行   \nHSSFRow row = sheet.getRow(i);  \n//得到Excel工作表指定行的单元格   \nHSSFCell cell = row.getCell((short) j);  \ncellStyle = cell.getCellStyle();//得到单元格样式  \n</code></pre>\n<p>2、建立Excel常用对象</p>\n<pre><code>HSSFWorkbook wb = new HSSFWorkbook();//创建Excel工作簿对象  \nHSSFSheet sheet = wb.createSheet(&quot;new sheet&quot;);//创建Excel工作表对象    \nHSSFRow row = sheet.createRow((short)0); //创建Excel工作表的行  \ncellStyle = wb.createCellStyle();//创建单元格样式  \nrow.createCell((short)0).setCellStyle(cellStyle); //创建Excel工作表指定行的单元格  \nrow.createCell((short)0).setCellValue(1); //设置Excel工作表的值  \n</code></pre>\n<p>3、设置sheet名称和单元格内容</p>\n<pre><code>wb.setSheetName(1, &quot;第一张工作表&quot;,HSSFCell.ENCODING_UTF_16);          \ncell.setEncoding((short) 1);      \ncell.setCellValue(&quot;单元格内容&quot;); \n</code></pre>\n<p>4、取得sheet的数目 </p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">wb.getNumberOfSheets()   </code></pre>\n\n\n\n<p>5、  根据index取得sheet对象</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">HSSFSheet sheet &#x3D; wb.getSheetAt(0);  </code></pre>\n\n\n\n<p>6、取得有效的行数</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int rowcount &#x3D; sheet.getLastRowNum(); </code></pre>\n\n\n\n<p>7、取得一行的有效单元格个数</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">row.getLastCellNum();  </code></pre>\n\n\n\n<p>8、单元格值类型读写</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">cell.setCellType(HSSFCell.CELL_TYPE_STRING); &#x2F;&#x2F;设置单元格为STRING类型  \ncell.getNumericCellValue();&#x2F;&#x2F;读取为数值类型的单元格内容  </code></pre>\n\n\n\n<p>9、设置列宽、行高</p>\n<pre><code>sheet.setColumnWidth((short)column,(short)width);      \nrow.setHeight((short)height);    \n</code></pre>\n<p>10、添加区域，合并单元格</p>\n<pre><code>Region region = new Region((short)rowFrom,(short)columnFrom,(short)rowTo  \n,(short)columnTo);//合并从第rowFrom行columnFrom列  \nsheet.addMergedRegion(region);// 到rowTo行columnTo的区域     \n//得到所有区域      \nsheet.getNumMergedRegions()   \n</code></pre>\n<p>11、保存Excel文件</p>\n<pre><code>FileOutputStream fileOut = new FileOutputStream(path);   \nwb.write(fileOut);   \n</code></pre>\n<p>12、根据单元格不同属性返回字符串数值</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public String getCellStringValue(HSSFCell cell) &#123;      \n    String cellValue &#x3D; &quot;&quot;;      \n    switch (cell.getCellType()) &#123;      \n        case HSSFCell.CELL_TYPE_STRING:&#x2F;&#x2F;字符串类型  \n            cellValue &#x3D; cell.getStringCellValue();      \n            if(cellValue.trim().equals(&quot;&quot;)||cellValue.trim().length()&lt;&#x3D;0)      \n                cellValue&#x3D;&quot; &quot;;      \n            break;      \n        case HSSFCell.CELL_TYPE_NUMERIC: &#x2F;&#x2F;数值类型  \n            cellValue &#x3D; String.valueOf(cell.getNumericCellValue());      \n            break;      \n        case HSSFCell.CELL_TYPE_FORMULA: &#x2F;&#x2F;公式  \n            cell.setCellType(HSSFCell.CELL_TYPE_NUMERIC);      \n            cellValue &#x3D; String.valueOf(cell.getNumericCellValue());      \n            break;      \n        case HSSFCell.CELL_TYPE_BLANK:      \n            cellValue&#x3D;&quot; &quot;;      \n            break;      \n        case HSSFCell.CELL_TYPE_BOOLEAN:      \n            break;      \n        case HSSFCell.CELL_TYPE_ERROR:      \n            break;      \n        default:      \n            break;      \n    &#125;      \n    return cellValue;      \n&#125; </code></pre>\n\n\n\n<p>13、常用单元格边框格式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">HSSFCellStyle style &#x3D; wb.createCellStyle();      \nstyle.setBorderBottom(HSSFCellStyle.BORDER_DOTTED);&#x2F;&#x2F;下边框       \nstyle.setBorderLeft(HSSFCellStyle.BORDER_DOTTED);&#x2F;&#x2F;左边框       \nstyle.setBorderRight(HSSFCellStyle.BORDER_THIN);&#x2F;&#x2F;右边框       \nstyle.setBorderTop(HSSFCellStyle.BORDER_THIN);&#x2F;&#x2F;上边框 </code></pre>\n\n\n\n<p>14、设置字体和内容位置</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">HSSFFont f  &#x3D; wb.createFont();      \nf.setFontHeightInPoints((short) 11);&#x2F;&#x2F;字号      \nf.setBoldweight(HSSFFont.BOLDWEIGHT_NORMAL);&#x2F;&#x2F;加粗      \nstyle.setFont(f);      \nstyle.setAlignment(HSSFCellStyle.ALIGN_CENTER);&#x2F;&#x2F;左右居中      \nstyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);&#x2F;&#x2F;上下居中      \nstyle.setRotation(short rotation);&#x2F;&#x2F;单元格内容的旋转的角度      \nHSSFDataFormat df &#x3D; wb.createDataFormat();      \nstyle1.setDataFormat(df.getFormat(&quot;0.00%&quot;));&#x2F;&#x2F;设置单元格数据格式      \ncell.setCellFormula(string);&#x2F;&#x2F;给单元格设公式      \nstyle.setRotation(short rotation);&#x2F;&#x2F;单元格内容的旋转的角度   </code></pre>\n\n\n\n<p>15、插入图片</p>\n<pre><code>//先把读进来的图片放到一个ByteArrayOutputStream中，以便产生ByteArray      \n      ByteArrayOutputStream byteArrayOut = new ByteArrayOutputStream();      \n      BufferedImage bufferImg = ImageIO.read(new File(&quot;ok.jpg&quot;));      \n      ImageIO.write(bufferImg,&quot;jpg&quot;,byteArrayOut);      \n//读进一个excel模版      \nFileInputStream fos = new FileInputStream(filePathName+&quot;/stencil.xlt&quot;);       \nfs = new POIFSFileSystem(fos);      \n//创建一个工作薄      \nHSSFWorkbook wb = new HSSFWorkbook(fs);      \nHSSFSheet sheet = wb.getSheetAt(0);      \nHSSFPatriarch patriarch = sheet.createDrawingPatriarch();      \nHSSFClientAnchor anchor = new HSSFClientAnchor(0,0,1023,255,(short) 0,0,(short)10,10);           \npatriarch.createPicture(anchor , wb.addPicture(byteArrayOut.toByteArray(),HSSFWorkbook.PICTURE_TYPE_JPEG));    \n</code></pre>\n<p>16、调整工作表位置</p>\n<pre><code>HSSFWorkbook wb = new HSSFWorkbook();     \nHSSFSheet sheet = wb.createSheet(&quot;format sheet&quot;);     \nHSSFPrintSetup ps = sheet.getPrintSetup();     \nsheet.setAutobreaks(true);     \nps.setFitHeight((short)1);     \nps.setFitWidth((short)1);   \n</code></pre>\n<p>17、设置打印区域</p>\n<pre><code>HSSFSheet sheet = wb.createSheet(&quot;Sheet1&quot;);     \nwb.setPrintArea(0, &quot;$A$1:$C$2&quot;);    \n</code></pre>\n<p>18、标注脚注</p>\n<pre><code>HSSFSheet sheet = wb.createSheet(&quot;format sheet&quot;);     \nHSSFFooter footer = sheet.getFooter()     \nfooter.setRight( &quot;Page &quot; + HSSFFooter.page() + &quot; of &quot; + HSSFFooter.numPages() );   \n</code></pre>\n<p>19、在工作单中清空行数据，调整行位置</p>\n<pre><code>HSSFWorkbook wb = new HSSFWorkbook();     \nHSSFSheet sheet = wb.createSheet(&quot;row sheet&quot;);     \n// Create various cells and rows for spreadsheet.     \n// Shift rows 6 - 11 on the spreadsheet to the top (rows 0 - 5)     \nsheet.shiftRows(5, 10, -5);    \n</code></pre>\n<p>20、选中指定的工作表</p>\n<pre><code>HSSFSheet sheet = wb.createSheet(&quot;row sheet&quot;);     \nheet.setSelected(true);     \n</code></pre>\n<p>21、工作表的放大缩小</p>\n<pre><code>HSSFSheet sheet1 = wb.createSheet(&quot;new sheet&quot;);     \nsheet1.setZoom(1,2);   // 50 percent magnification    \n</code></pre>\n<p>22、头注和脚注</p>\n<pre><code>HSSFSheet sheet = wb.createSheet(&quot;new sheet&quot;);     \nHSSFHeader header = sheet.getHeader();     \nheader.setCenter(&quot;Center Header&quot;);     \nheader.setLeft(&quot;Left Header&quot;);     \nheader.setRight(HSSFHeader.font(&quot;Stencil-Normal&quot;, &quot;Italic&quot;) +     \nHSSFHeader.fontSize((short) 16) + &quot;Right w/ Stencil-Normal Italic font and size 16&quot;);  \n</code></pre>\n<p>23、自定义颜色  </p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">HSSFCellStyle style &#x3D; wb.createCellStyle();     \nstyle.setFillForegroundColor(HSSFColor.LIME.index);     \nstyle.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND);     \nHSSFFont font &#x3D; wb.createFont();     \nfont.setColor(HSSFColor.RED.index);     \nstyle.setFont(font);     \ncell.setCellStyle(style); </code></pre>\n\n<p>24、填充和颜色设置</p>\n<pre><code>HSSFCellStyle style = wb.createCellStyle();     \nstyle.setFillBackgroundColor(HSSFColor.AQUA.index);     \nstyle.setFillPattern(HSSFCellStyle.BIG_SPOTS);     \nHSSFCell cell = row.createCell((short) 1);     \ncell.setCellValue(&quot;X&quot;);     \nstyle = wb.createCellStyle();     \nstyle.setFillForegroundColor(HSSFColor.ORANGE.index);     \nstyle.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND);     \ncell.setCellStyle(style);   \n</code></pre>\n<p>25、强行刷新单元格公式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">HSSFFormulaEvaluator eval&#x3D;new HSSFFormulaEvaluator((HSSFWorkbook) wb);    \nprivate static void updateFormula(Workbook wb,Sheet s,int row)&#123;     \n    Row r&#x3D;s.getRow(row);     \n    Cell c&#x3D;null;     \n    FormulaEcaluator eval&#x3D;null;     \n    if(wb instanceof HSSFWorkbook)     \n        eval&#x3D;new HSSFFormulaEvaluator((HSSFWorkbook) wb);     \n    else if(wb instanceof XSSFWorkbook)     \n        eval&#x3D;new XSSFFormulaEvaluator((XSSFWorkbook) wb);     \n    for(int i&#x3D;r.getFirstCellNum();i&lt;r.getLastCellNum();i++)&#123;     \n        c&#x3D;r.getCell(i);     \n        if(c.getCellType()&#x3D;&#x3D;Cell.CELL_TYPE_FORMULA)     \n            eval.evaluateFormulaCell(c);     \n    &#125;     \n&#125;    </code></pre>\n<p>说明：FormulaEvaluator提供了evaluateFormulaCell(Cell cell)方法，计算公式保存结果，但不改变公式。而evaluateInCell(Cell cell) 方法是计算公式，并将原公式替换为计算结果，也就是说该单元格的类型不在是Cell.CELL_TYPE_FORMULA而是Cell.CELL_TYPE_NUMBERIC。HSSFFormulaEvaluator提供了静态方法evaluateAllFormu</p>\n<p>laCells(HSSFWorkbook wb) ，计算一个Excel文件的所有公式，用起来很方便。</p>\n<h4 id=\"whale-小结\"><a href=\"#whale-小结\" class=\"headerlink\" title=\":whale: 小结\"></a>:whale: 小结</h4><p>如果发现导出Excel有些复杂, 一般先把Excel制作一个模版. 把模版通过POI读取到内存里面. 获得数据, 动态的给模版里面填充数据, 再响应(Response)文件</p>\n","text":":whale: Apache POI基础 ① Apache POI简介Apache POI是一种流行的API，它允许程序员使用Java程序创建，修改和显示MS Office文件。这由Apache软件基金会开发使用Java分布式设计或修改Microsoft Office文件的开源库...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[{"name":"文档读写","slug":"文档读写","count":1,"path":"api/categories/文档读写.json"}],"tags":[{"name":"文档读写","slug":"文档读写","count":1,"path":"api/tags/文档读写.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#whale-Apache-POI%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">:whale: Apache POI基础</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A0-Apache-POI%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">① Apache POI简介</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A1-Apache-POI%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">② Apache POI组件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A2-Excel%E5%8C%85%E5%90%8D%E7%A7%B0%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">③ Excel包名称说明</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A3-Maven%E5%9D%90%E6%A0%87\"><span class=\"toc-text\">④ Maven坐标</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A4-%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%BB%E5%8F%96%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89\"><span class=\"toc-text\">⑤ 简单的读取工具类（重要）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A5-%E8%AF%BB%E5%8F%96%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">⑥ 读取工具类的使用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#whale-HSSF%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89\"><span class=\"toc-text\">:whale: HSSF的使用（了解）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A0-HSSF%E6%A6%82%E5%86%B5\"><span class=\"toc-text\">① HSSF概况</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A1-POI-EXCEL%E6%96%87%E6%A1%A3%E7%BB%93%E6%9E%84%E7%B1%BB\"><span class=\"toc-text\">② POI EXCEL文档结构类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A2-EXCEL%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">③ EXCEL常用操作方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#whale-%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">:whale: 小结</span></a></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"SpringSecurity 权限管理","uid":"57895ac4a5b71846b764434fcb138119","slug":"58-Spring Security-权限管理","date":"2021-09-13T15:35:32.000Z","updated":"2021-09-15T10:47:49.376Z","comments":true,"path":"api/articles/58-Spring Security-权限管理.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog6.jpg","text":":open_umbrella: 权限控制 1、认证和授权的概念前面我们已经完成了旅游后台管理系统的部分功能，例如自由行管理、跟团游管理、套餐管理、预约设置等。接下来我们需要思考2个问题： 问题1：在生产环境下我们如果不登录后台系统就可以完成这些功能操作吗？ 答案显然是否定的，要操...","link":"","photos":[],"count_time":{"symbolsCount":"41k","symbolsTime":"37 mins."},"categories":[{"name":"Spring","slug":"Spring","count":6,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":6,"path":"api/tags/Spring.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"Quartz 定时任务","uid":"4ce484ce04054bf7a1c2a1b718c83b71","slug":"56-Quartz-定时任务","date":"2021-09-13T15:33:32.000Z","updated":"2021-09-15T10:48:39.069Z","comments":true,"path":"api/articles/56-Quartz-定时任务.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog8.jpg","text":":articulated_lorry: Quartz 简介 ① Quartz是什么Quartz是Job scheduling（作业调度）领域的一个开源项目，Quartz既可以单独使用也可以跟spring框架整合使用，在实际开发中一般会使用后者。使用Quartz可以开发一个或者多个...","link":"","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"25 mins."},"categories":[{"name":"定时任务","slug":"定时任务","count":1,"path":"api/categories/定时任务.json"}],"tags":[{"name":"定时任务","slug":"定时任务","count":1,"path":"api/tags/定时任务.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}