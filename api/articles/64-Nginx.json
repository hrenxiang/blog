{"title":"Nginx","uid":"af6a277a1f79cc7652a602f9f57ed64f","slug":"64-Nginx","date":"2021-09-13T15:40:32.000Z","updated":"2021-09-15T10:39:17.590Z","comments":true,"path":"api/articles/64-Nginx.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","content":"<h4 id=\"01、Nginx-的介绍\"><a href=\"#01、Nginx-的介绍\" class=\"headerlink\" title=\"01、Nginx 的介绍\"></a>01、Nginx 的介绍</h4><p>Nginx 是开源、高性能、高可靠的 Web 和反向代理服务器</p>\n<p>Nginx 支持热部署，几乎能做到 7*24 小时不间断运行，即使运行几个月也不需要重启，还能在不间断服务的情况下对软件进行热更新。</p>\n<p>Nginx 最重要的考量是 性能 ，其占用内存少、并发能力强、能支持高达 5w 个并发连接数</p>\n<p>Nginx 是免费的并可以商业化，配置使用也比较简单。</p>\n<p>Nginx 的最重要的几个使用场景：</p>\n<ol>\n<li>静态资源服务，通过本地文件系统提供服务（就是作为静态页面的服务器）；</li>\n<li>反向代理服务，延伸出包括缓存、负载均衡等；</li>\n<li>API 服务，OpenResty ；</li>\n</ol>\n<h4 id=\"02、简单和非简单请求\"><a href=\"#02、简单和非简单请求\" class=\"headerlink\" title=\"02、简单和非简单请求\"></a>02、简单和非简单请求</h4><p>==如果同时满足下面两个条件，就属于简单请求，凡是不同时满足这两个条件的，都属于非简单请求==</p>\n<ol>\n<li>请求方法是 <code>HEAD</code>、<code>GET</code>、<code>POST</code> 三种之一；</li>\n<li>HTTP 头信息不超过右边这几个字段：<code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Last-Event-ID</code> 、<code>Content-Type</code> 只限于三个值 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>；</li>\n</ol>\n<p>浏览器处理简单请求和非简单请求的方式不一样</p>\n<ol>\n<li><p><strong>简单请求</strong></p>\n<p>对于简单请求，浏览器会在头信息中增加 <code>Origin</code> 字段后直接发出，<code>Origin</code> 字段用来说明，本次请求来自的哪个源（协议+域名+端口）。</p>\n<p>如果服务器发现 <code>Origin</code> 指定的源不在许可范围内，服务器会返回一个正常的 HTTP 回应，浏览器取到回应之后发现回应的头信息中没有包含 <code>Access-Control-Allow-Origin</code> 字段，就抛出一个错误给 XHR 的 <code>error</code> 事件；</p>\n<p>如果服务器发现 <code>Origin</code> 指定的域名在许可范围内，服务器返回的响应会多出几个 <code>Access-Control-</code> 开头的头信息字段。</p>\n</li>\n<li><p><strong>非简单请求</strong></p>\n<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 <code>PUT</code> 或 <code>DELETE</code>，或 <code>Content-Type</code> 值为 <code>application/json</code>。浏览器会在正式通信之前，发送一次 HTTP 预检 <code>OPTIONS</code> 请求，先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 请求方法和头信息字段。只有得到肯定答复，浏览器才会发出正式的 <code>XHR</code> 请求，否则报错。</p>\n</li>\n</ol>\n<h4 id=\"03、跨域\"><a href=\"#03、跨域\" class=\"headerlink\" title=\"03、跨域\"></a>03、跨域</h4><p>在浏览器上当前访问的网站向另一个网站发送请求获取数据的过程就是<strong>跨域请求</strong>。</p>\n<p>跨域是浏览器的<a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy\">同源策略</a>决定的，是一个重要的浏览器安全策略，用于限制一个 <a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Glossary/%E6%BA%90\">origin</a> 的文档或者它加载的脚本与另一个源的资源进行交互，它能够帮助阻隔恶意文档，减少可能被攻击的媒介，可以使用 <a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Glossary/CORS\">CORS</a> 配置解除这个限制。</p>\n<p>关于跨域网上已经有很多解释，这里就不啰嗦，也可以直接看 MDN 的 <a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy\">&lt;浏览器的同源策略&gt;</a> 文档进一步了解，这里就列举几个同源和不同元的例子，相信程序员都能看得懂。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 同源的例子\nhttp:&#x2F;&#x2F;example.com&#x2F;app1&#x2F;index.html  # 只是路径不同\nhttp:&#x2F;&#x2F;example.com&#x2F;app2&#x2F;index.html\n\nhttp:&#x2F;&#x2F;Example.com:80  # 只是大小写差异\nhttp:&#x2F;&#x2F;example.com\n\n# 不同源的例子\nhttp:&#x2F;&#x2F;example.com&#x2F;app1   # 协议不同\nhttps:&#x2F;&#x2F;example.com&#x2F;app2\n\nhttp:&#x2F;&#x2F;example.com        # host 不同\nhttp:&#x2F;&#x2F;www.example.com\nhttp:&#x2F;&#x2F;myapp.example.com\n\nhttp:&#x2F;&#x2F;example.com        # 端口不同\nhttp:&#x2F;&#x2F;example.com:8080</code></pre>\n\n\n\n<h4 id=\"04、正向代理和反向代理\"><a href=\"#04、正向代理和反向代理\" class=\"headerlink\" title=\"04、正向代理和反向代理\"></a>04、正向代理和反向代理</h4><p>反向代理（Reverse Proxy）对应的是正向代理（Forward Proxy），他们的区别：</p>\n<p><strong>正向代理：</strong> 一般的访问流程是客户端直接向目标服务器发送请求并获取内容，使用正向代理后，客户端改为向代理服务器发送请求，并指定目标服务器（原始服务器），然后由代理服务器和原始服务器通信，转交请求并获得的内容，再返回给客户端。正向代理隐藏了真实的客户端，为客户端收发请求，使真实客户端对服务器不可见；</p>\n<p>举个具体的例子 🌰，你的浏览器无法直接访问谷哥，这时候可以通过一个代理服务器来帮助你访问谷哥，那么这个服务器就叫正向代理。</p>\n<p><strong>反向代理：</strong> 与一般访问流程相比，使用反向代理后，直接收到请求的服务器是代理服务器，然后将请求转发给内部网络上真正进行处理的服务器，得到的结果返回给客户端。反向代理隐藏了真实的服务器，为服务器收发请求，使真实服务器对客户端不可见。一般在处理跨域请求的时候比较常用。现在基本上所有的大型网站都设置了反向代理。</p>\n<p>举个具体的例子 🌰，去饭店吃饭，可以点川菜、粤菜、江浙菜，饭店也分别有三个菜系的厨师 👨‍🍳，但是你作为顾客不用管哪个厨师给你做的菜，只用点菜即可，小二将你菜单中的菜分配给不同的厨师来具体处理，那么这个小二就是反向代理服务器。</p>\n<p>简单的说，一般给客户端做代理的都是正向代理，给服务器做代理的就是反向代理。</p>\n<p>正向代理和反向代理主要的原理区别可以参见下图：</p>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/nginx-forward-proxy.png\" alt=\"image-20210809183543625\" style=\"zoom:43%;\" />\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/nginx-reverse-proxy.png\" alt=\"image-20210809183635016\" style=\"zoom:43%;\" />\n</div>\n\n\n\n<h4 id=\"05、负载均衡\"><a href=\"#05、负载均衡\" class=\"headerlink\" title=\"05、负载均衡\"></a>05、负载均衡</h4><p>一般情况下，客户端发送多个请求到服务器，服务器处理请求，其中一部分可能要操作一些资源比如数据库、静态资源等，服务器处理完毕后，再将结果返回给客户端。</p>\n<p>这种模式对于早期的系统来说，功能要求不复杂，且并发请求相对较少的情况下还能胜任，成本也低。随着信息数量不断增长，访问量和数据量飞速增长，以及系统业务复杂度持续增加，这种做法已无法满足要求，并发量特别大时，服务器容易崩。</p>\n<p>很明显这是由于服务器性能的瓶颈造成的问题，除了堆机器之外，最重要的做法就是负载均衡。</p>\n<p>请求爆发式增长的情况下​，单个机器性能再强劲也无法满足要求了，这个时候集群的概念产生了，单个服务器解决不了的问题，可以使用多个服务器，然后==将请求分发到各个服务器上，将负载分发到不同的服务器==，这就是<strong>负载均衡</strong>，核心是「分摊压力」。</p>\n<p>:star: ​Nginx 实现负载均衡，一般来说指的是将请求转发给服务器集群。</p>\n<p>:chestnut: 举个具体的例子，晚高峰乘坐地铁的时候，入站口经常会有地铁工作人员大喇叭“请走 B 口，B 口人少车空….”，这个工作人员的作用就是负载均衡。</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/nginx-balance.png\" alt=\"负载均衡\"></p>\n<h4 id=\"06、动静分离\"><a href=\"#06、动静分离\" class=\"headerlink\" title=\"06、动静分离\"></a>06、动静分离</h4><p>为了加快网站的解析速度，可以==把动态页面和静态页面由不同的服务器来解析，加快解析速度，降低原来单个服务器的压力==。</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/nginx-sport-static.png\" alt=\"动静分离\"></p>\n<p>一般来说，都需要将动态资源和静态资源分开，由于 ==Nginx 的高并发和静态资源缓存等特性==，经常将静态资源部署在 Nginx 上。<strong>如果请求的是静态资源，直接到静态资源目录获取资源，如果是动态资源的请求，则利用反向代理的原理</strong>，把请求转发给对应后台应用去处理，从而实现动静分离。</p>\n<p>使用前后端分离后，可以很大程度提升静态资源的访问速度，即使动态服务不可用，静态资源的访问也不会受到影响。</p>\n<h4 id=\"07、Nginx-的安装\"><a href=\"#07、Nginx-的安装\" class=\"headerlink\" title=\"07、Nginx 的安装\"></a>07、Nginx 的安装</h4><p>1、到官网下载安装包：<a href=\"http://nginx.org/\">http://nginx.org/</a>   nginx-1.12.2.tar.gz  （centos8 安装1.12版本并不可以，可以试试更高版本，比如1.17.6）</p>\n<p>2、下载所需依赖包：pcre-8.37.tar.gz        openssl-1.0.1t.tar.gz        zlib-1.2.8.tar.gz</p>\n<p>3、离线安装 nginx：</p>\n<ul>\n<li><p>解压缩 pcre-xx.tar.gz 包</p>\n<p>进入解压缩目录，执行 ./configure</p>\n<p>注意：如果提示错误，需要提前安装 gcc++：<code>yum install -y gcc-c++</code></p>\n<p>./configure 完成后，回到pcre目录下执行make，再执行make install</p>\n</li>\n<li><p>解压缩 openssl-xx.tar.gz 包</p>\n<p>进入解压缩目录，执行 ./config </p>\n<p>make &amp;&amp; make install</p>\n</li>\n<li><p>解压缩 zlib-xx.tar.gz 包</p>\n<p>进入解压缩目录，执行./configure</p>\n<p>make &amp;&amp; make install</p>\n</li>\n<li><p>解压缩 nginx-xx.tar.gz 包 </p>\n<p>进入解压缩目录，执行 ./configure </p>\n<p>make &amp;&amp; make install</p>\n</li>\n</ul>\n<p>4、关闭防火墙，访问nginx</p>\n<ul>\n<li><p>在windows系统中访问linux中nginx，默认不能访问的，因为防火墙问题</p>\n</li>\n<li><p>关闭防火墙-开放访问的端口号，<strong>80</strong>端口</p>\n</li>\n<li><p>查看开放的端口号</p>\n<p><code>firewall-cmd --list-all</code></p>\n</li>\n<li><p>开启防火墙</p>\n<p><code>systemctl start firewalld</code></p>\n</li>\n<li><p>关闭防火墙</p>\n<p><code>systemctl stop firewalld</code></p>\n</li>\n<li><p>设置开放的服务或端口号</p>\n<p><code>firewall-cmd --add-service=http --permanent</code></p>\n<p><code>firewall-cmd --add-port=80/tcp --permanent</code></p>\n</li>\n<li><p>重启防火墙：<code>firewall-cmd --reload</code></p>\n</li>\n</ul>\n<p>5、扩展：在线安装</p>\n<ul>\n<li>第 1.0 步 安装openssl、zlib、gcc 依赖 <code>yum -y install make zlib zlib-devel gcc-c++ libtool  openssl openssl-devel</code></li>\n<li>第 2.1 步 联网下载pcre<br><code>wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz</code></li>\n<li>第 2.2 步 解压压缩文件 <code>tar -zxvf pcre-8.37.tar.gz</code></li>\n<li>第 2.3 步 <code>./configure</code> 完成后，回到pcre目录下执行 <code>make</code>，最后执行 <code>make install</code></li>\n<li>第 2.4 步 <code>pcre-config --version</code>  检查版本</li>\n<li>第 3.0 步，安装nginx，使用命令解压 然后进入解压缩目录，执行 <code>./configure</code> 然后 <code>make</code> &amp;&amp; <code>make install</code></li>\n<li>进入目录 <code>/usr/local/nginx/sbin</code>  执行 <code>./nginx</code> 启动服务</li>\n<li>第 4.0 步，关闭防火墙，访问nginx</li>\n</ul>\n<h4 id=\"08、Nginx-相关命令\"><a href=\"#08、Nginx-相关命令\" class=\"headerlink\" title=\"08、Nginx 相关命令\"></a>08、Nginx 相关命令</h4><p>我们需要去相关目录下执行命令，下面我们一个命令直接到了相应目录并执行 nginx 相关操作</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># nginx版本检查\nnginx -v\n\n# nginx编译参数\nnginx -V\n\n# 启停方式\n- 启动\n\t[root@zls ~]# &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx\n\t[root@zls ~]# systemctl start nginx\n- 停止\n\t[root@zls ~]# &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s stop\n\t[root@zls ~]# systemctl stop nginx\n- 重启\n\t[root@zls ~]# systemctl restart nginx\n- 重载\n\t[root@zls ~]# &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload\n\t[root@zls ~]# systemctl reload nginx</code></pre>\n\n<p>==上述 — 使用 systemctl start nginx 来启动 nginx 是需要配置的，下面我们来创建并配置 nginx.service 文件==</p>\n<p>Systemd服务文件以.service结尾，比如现在要建立nginx为开机启动，如果用yum install命令安装的，yum命令会自动创建nginx.service文件，可以直接使用systemctl相关命令。而用源码编译安装的，则需要手动创建nginx.service服务文件。</p>\n<p>配置nginx.service文件</p>\n<p>vim /usr/lib/systemd/system/nginx.service</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#配置文件内容\n[Unit]                                          \nDescription&#x3D;nginx \nAfter&#x3D;network.target \n\n[Service] \nType&#x3D;forking \nExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx \nExecReload&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload \nExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s quit\nPrivateTmp&#x3D;true \n\n[Install] \nWantedBy&#x3D;multi-user.target\n\n#[Unit]:服务的说明\n#Description:描述服务\n#After:描述服务类别\n#[Service]服务运行参数的设置\n#Type&#x3D;forking是后台运行的形式\n#ExecStart为服务的具体运行命令\n#ExecReload为重启命令\n#ExecStop为停止命令\n#PrivateTmp&#x3D;True表示给服务分配独立的临时空间\n#注意：[Service]的启动、重启、停止命令全部要求使用绝对路径\n#[Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3</code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#查看nginx服务状态\nsystemctl status nginx.service\n#启动nginx服务\nsystemctl start nginx.service\n#停止nginx服务\nsystemctl stop nginx.service\n#重启nginx服务\nsystemctl restart nginx.service\n#重新读取nginx配置(这个最常用, 不用停止nginx服务就能使修改的配置生效)\nsystemctl reload nginx.service</code></pre>\n\n\n\n<h4 id=\"09、Nginx-配置语法\"><a href=\"#09、Nginx-配置语法\" class=\"headerlink\" title=\"09、Nginx 配置语法\"></a>09、Nginx 配置语法</h4><p>Nginx 的主配置文件是 <code>/usr/local/nginx/conf/nginx.conf</code>，可以使用 <code>vim /usr/local/nginx/conf/nginx.conf</code> 来查看配置。</p>\n<p><code>nginx.conf</code> 结构图可以这样概括：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">main        # 全局配置，对全局生效\n├── events  # 配置影响 Nginx 服务器或与用户的网络连接\n├── http    # 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置\n│   ├── upstream # 配置后端服务器具体地址，负载均衡配置不可或缺的部分\n│   ├── server   # 配置虚拟主机的相关参数，一个 http 块中可以有多个 server 块\n│   ├── server\n│   │   ├── location  # server 块可以包含多个 location 块，location 指令用于匹配 uri\n│   │   ├── location\n│   │   └── ...\n│   └── ...\n└── ...</code></pre>\n\n<p>一个 Nginx 配置文件的结构就像 <code>nginx.conf</code> 显示的那样，配置文件的语法规则：</p>\n<ol>\n<li>配置文件由指令与指令块构成；</li>\n<li>每条指令以 <code>;</code> 分号结尾，指令与参数间以空格符号分隔；</li>\n<li>指令块以 <code>&#123;&#125;</code> 大括号将多条指令组织在一起；</li>\n<li><code>include</code> 语句允许组合多个配置文件以提升可维护性；</li>\n<li>使用 <code>#</code> 符号添加注释，提高可读性；</li>\n<li>使用 <code>$</code> 符号使用变量；</li>\n<li>部分指令的参数支持正则表达式；</li>\n</ol>\n<ul>\n<li><p>全局块</p>\n<p>从配置文件开始到 events 块之间的内容，主要会设置一些影响nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。</p>\n<p>worker_processes  1; 这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约。</p>\n</li>\n<li><p>events 块</p>\n<p>events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 work process 可以同时支持的最大连接数等</p>\n<p>上述例子就表示每个 work process 支持的最大连接数为 1024.</p>\n<p>这部分的配置<strong>对 Nginx 的性能影响较大</strong>，在实际中应该灵活配置。</p>\n</li>\n<li><p>http 块</p>\n<p>这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。</p>\n<p>需要注意的是：http 块也可以包括 <strong>http全局块</strong>、<strong>server 块</strong>。</p>\n<p>①、http 全局块</p>\n<p>　　http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</p>\n<p>​        最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置。</p>\n<p>②、server 块</p>\n<p>　　这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。</p>\n<p>　　:star: 每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。</p>\n<p>　　:star: 每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。</p>\n<p>③、location 块</p>\n<p>　　一个 server 块可以配置多个 location 块。</p>\n<p>​       这块的主要作用是基于 Nginx 服务器接收到的请求字符串</p>\n<p>​       :chestnut: 例如 server_name/uri-string ，对虚拟主机名称（也可以是IP别名）之外的字符串</p>\n<p>​      ​ :chestnut: 例如 前面的 /uri-string 进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的                     配置也在这里进行。</p>\n</li>\n</ul>\n<p>location 指令用于匹配 uri，语法：</p>\n<pre class=\"line-numbers language-nginx\" data-language=\"nginx\"><code class=\"language-nginx\">location [ &#x3D; | ~ | ~* | ^~] uri &#123;\n\t...\n&#125;</code></pre>\n\n<p>指令后面：</p>\n<ol>\n<li><code>=</code> 精确匹配路径，用于不含正则表达式的 uri 前，如果匹配成功，不再进行后续的查找；</li>\n<li><code>^~</code> 用于不含正则表达式的 uri； 前，表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找；</li>\n<li><code>~</code> 表示用该符号后面的正则去匹配路径，区分大小写；</li>\n<li><code>~*</code> 表示用该符号后面的正则去匹配路径，不区分大小写。跟 <code>~</code> 优先级都比较低，如有多个location的正则能匹配的话，则使用正则表达式最长的那个；</li>\n</ol>\n<p>如果 uri 包含正则表达式，则必须要有 <code>~</code> 或 <code>~*</code> 标志。</p>\n<h4 id=\"10、典型配置\"><a href=\"#10、典型配置\" class=\"headerlink\" title=\"10、典型配置\"></a>10、典型配置</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#user  nobody;  # 运行用户，默认即是nginx，可以不进行设置\nworker_processes  1;  # Nginx 进程数，一般设置为和 CPU 核数一样\n\n#error_log  logs&#x2F;error.log;  # Nginx 的错误日志存放目录\n#error_log  logs&#x2F;error.log  notice;\n#error_log  logs&#x2F;error.log  info;\n\n#pid        logs&#x2F;nginx.pid;  # Nginx 服务启动时的 pid 存放位置\n\n\nevents &#123;\n    use epoll;     # 使用epoll的I&#x2F;O模型(如果你不知道Nginx该使用哪种轮询方法，会自动选择一个最适合你操作系统的)\n    worker_connections  1024;  # 每个进程允许最大并发数\n&#125;\n\n# 配置使用最频繁的部分，代理、缓存、日志定义等绝大多数功能和第三方模块的配置都在这里设置\nhttp &#123;\n    include       mime.types;  # 文件扩展名与类型映射表\n    default_type  application&#x2F;octet-stream;  # 默认文件类型\n\n\t# 设置日志模式\n    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;\n    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;\n    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;\n\n    #access_log  logs&#x2F;access.log  main;  # Nginx访问日志存放位置\n  \n    sendfile        on;   # 开启高效传输模式\n    #tcp_nopush     on;  # 减少网络报文段的数量\n\n    #keepalive_timeout  0;\n    keepalive_timeout  65; # 保持连接的时间，也叫超时时间，单位秒\n\n\t#gzip  on;\n\n    # 这是负载均衡的配置，让两个服务器进行轮循，可以设置轮询的具体效果\n    upstream myserver &#123;\n        server 192.168.96.66:8080;\n        server 192.168.96.66:8081;\n    &#125;\n\n    server &#123;\n        listen       80;\n        server_name  192.168.96.66;\n\n        #charset koi8-r;\n\n        #access_log  logs&#x2F;host.access.log  main;\n\n        location &#x2F; &#123;\n            root   html;\n            #proxy_pass http:&#x2F;&#x2F;192.168.96.66:8080;\n            proxy_pass http:&#x2F;&#x2F;myserver;\n            index  index.html index.htm;\n        &#125;\n\n        #error_page  404              &#x2F;404.html;\n\n        # redirect server error pages to the static page &#x2F;50x.html\n        #\n        error_page   500 502 503 504  &#x2F;50x.html;\n        location &#x3D; &#x2F;50x.html &#123;\n            root   html;\n        &#125;\n\n        # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n        #\n        #location ~ \\.php$ &#123;\n        #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;\n        #&#125;\n\n        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n        #\n        #location ~ \\.php$ &#123;\n        #    root           html;\n        #    fastcgi_pass   127.0.0.1:9000;\n        #    fastcgi_index  index.php;\n        #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;\n        #    include        fastcgi_params;\n        #&#125;\n\n        # deny access to .htaccess files, if Apache&#39;s document root\n        # concurs with nginx&#39;s one\n        #\n        #location ~ &#x2F;\\.ht &#123;\n        #    deny  all;\n        #&#125;\n    &#125;\n\n    # another virtual host using mix of IP-, name-, and port-based configuration\n    #\n    #server &#123;\n    #    listen       8000;\n    #    listen       somename:8080;\n    #    server_name  somename  alias  another.alias;\n\n    #    location &#x2F; &#123;\n    #        root   html;\n    #        index  index.html index.htm;\n    #    &#125;\n    #&#125;\n\n\n    # HTTPS server\n    #\n    #server &#123;\n    #    listen       443 ssl;\n    #    server_name  localhost;\n\n    #    ssl_certificate      cert.pem;\n    #    ssl_certificate_key  cert.key;\n\n    #    ssl_session_cache    shared:SSL:1m;\n    #    ssl_session_timeout  5m;\n\n    #    ssl_ciphers  HIGH:!aNULL:!MD5;\n    #    ssl_prefer_server_ciphers  on;\n\n    #    location &#x2F; &#123;\n    #        root   html;\n    #        index  index.html index.htm;\n    #    &#125;\n    #&#125;       \n&#125; </code></pre>\n\n\n\n<h4 id=\"11、反向代理\"><a href=\"#11、反向代理\" class=\"headerlink\" title=\"11、反向代理\"></a>11、反向代理</h4><p>实例一：实现效果，使用nginx反向代理，根据访问的路径跳转到不同端口的服务中</p>\n<p>nginx监听端口为9000，</p>\n<p>访问 <a href=\"http://127.0.0.1:9000/edu/\">http://127.0.0.1:9000/edu/</a> 直接跳转到127.0.0.1:8080</p>\n<p>访问 <a href=\"http://127.0.0.1:9000/vod/\">http://127.0.0.1:9000/vod/</a> 直接跳转到127.0.0.1:8081</p>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/nginx-1.png\" alt=\"image-20210809200139493\" style=\"zoom: 75%;\" />\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/nginx-2.png\" alt=\"image-20210809200217911\" style=\"zoom:75%;\" />\n</div>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 在 nginx.conf 中配置如下信息\n   server &#123; \n       listen 9000; \n       server_name 192.168.96.66; \n       location ~ &#x2F;edu&#x2F; &#123; \n               proxy_pass http:&#x2F;&#x2F;192.168.96.66:8080; \n               &#125; \n       location ~ &#x2F;vod&#x2F; &#123; \n               proxy_pass http:&#x2F;&#x2F;192.168.96.66:8081; \n               &#125; \n       &#125; </code></pre>\n\n\n\n<h4 id=\"12、负载均衡\"><a href=\"#12、负载均衡\" class=\"headerlink\" title=\"12、负载均衡\"></a>12、负载均衡</h4><p>实现效果：浏览器地址栏输入地址 <a href=\"http://192.168.137.129/edu/a.html%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%95%88%E6%9E%9C%EF%BC%8C%E5%B0%86%E8%AF%B7%E6%B1%82%E5%B9%B3%E5%9D%87%E5%88%86%E9%85%8D%E5%88%B08080%E5%92%8C8081%E4%B8%A4%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E3%80%82\">http://192.168.137.129/edu/a.html，负载均衡效果，将请求平均分配到8080和8081两台服务器上。</a></p>\n<ul>\n<li>准备两台tomcat服务器，一台8080，一台8081</li>\n<li>在两台tomcat里面webapps目录中，创建名称是edu文件夹，在edu文件夹中创建页面a.html(让a.html内容不一样，查看效果)，用于测试</li>\n</ul>\n<p>在配置文件中进行负载均衡配置：</p>\n<p>upstream称为上游服务器，即真实处理请求的业务服务器。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 这是负载均衡的配置，让两个服务器进行轮循\n    upstream myserver &#123;\n        server 192.168.96.66:8080;\n        server 192.168.96.66:8081;\n        # server 192.168.96.66:8081 weight&#x3D;10;  # weight 方式，不写默认为 1 ,1 表示一个服务器一次依次循环\n    &#125;</code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">server &#123;\n\tlisten       80;\n\tserver_name  192.168.96.66;\n\t\n\tlocation &#x2F; &#123;\n\t\troot   html;\n\t\t# proxy_pass http:&#x2F;&#x2F;192.168.96.66:8080;\n\t\t# 使用上游服务器进行分配，给真正的业务服务器\n\t\tproxy_pass http:&#x2F;&#x2F;myserver;\n\t\tindex  index.html index.htm;\n&#125;</code></pre>\n\n<p>Nginx 提供了好几种分配方式，默认为<strong>轮询</strong>，就是轮流来。有以下几种分配方式：</p>\n<ol>\n<li><p><strong>轮询</strong>，默认方式，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务挂了，能自动剔除；</p>\n</li>\n<li><p><strong>weight</strong>，权重分配，指定轮询几率，权重越高，在被访问的概率越大，用于后端服务器性能不均的情况；</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># weight代表权,重默认为1,权重越高被分配的客户端越多\n\n# 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如：\n\nupstream server_pool&#123;  \n\n\tserver 192.168.5.21 weight&#x3D;1;  \n\n\tserver 192.168.5.22 weight&#x3D;2; \n\n\tserver 192.168.5.23 weight&#x3D;3;  \n\n&#125;</code></pre>\n\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/nginx-4.png\" alt=\"image-20210809201358537\"></p>\n</li>\n<li><p><strong>ip_hash</strong>，每个请求按访问 IP 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决动态网页 session 共享问题。负载均衡每次请求都会重新定位到服务器集群中的某一个，那么已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的；</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 例如：\n\nupstream server_pool&#123;  \n\n\tip_hash;   \n\n\tserver 192.168.5.21:80;  \n\n\tserver 192.168.5.22:80;  \n\n&#125;</code></pre>\n\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/nginx-5.png\" alt=\"image-20210809201601602\"></p>\n</li>\n<li><p><strong>fair</strong>（第三方），按后端服务器的响应时间分配，响应时间短的优先分配，依赖第三方插件 nginx-upstream-fair，需要先安装；</p>\n</li>\n</ol>\n<h4 id=\"13、Nginx-动静分离\"><a href=\"#13、Nginx-动静分离\" class=\"headerlink\" title=\"13、Nginx 动静分离\"></a>13、Nginx 动静分离</h4><p>动静分离在之前也介绍过了，就是把动态和静态的请求分开。方式主要有两种，一种 是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案。另外一种方法就是动态跟静态文件混合在一起发布， 通过 Nginx 配置来分开。</p>\n<p>通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用 expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个URL，发送一个请求，比对服务器该文件最后更新时间没有变化。则不会从服务器抓取，返回状态码 304，如果有修改，则直接从服务器重新下载，返回状态码 200。</p>\n<p>项目静态资源准备：在任意一个tomcat的webapps中，新建data/www/a.html   与    data/img/2.jpg</p>\n<p>nginx.conf 配置</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">location &#x2F;img&#x2F; &#123;\n\troot &#x2F;data&#x2F;;\n\tautoindex on;\n&#125;\n\nlocation &#x2F;www&#x2F; &#123;\n\troot &#x2F;data&#x2F;;\n\tautoindex on;\n\tindex index.html index.htm;\n&#125;</code></pre>\n\n\n\n<h4 id=\"14、Nginx-原理与优化参数配置\"><a href=\"#14、Nginx-原理与优化参数配置\" class=\"headerlink\" title=\"14、Nginx 原理与优化参数配置\"></a>14、Nginx 原理与优化参数配置</h4><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/nginx-%E5%8E%9F%E7%90%86.png\" alt=\"image-20210809203754873\"></p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/nginx-%E5%8E%9F%E7%90%862.png\" alt=\"image-20210809203817508\"></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># master-workers的机制的好处\n\n首先，对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。\n\n其次，采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master进程则很快启动新的worker进程。\n\n当然，worker进程的异常退出，肯定是程序有bug了，异常退出，会导致当前worker上的所有请求失败，不过不会影响到所有请求，所以降低了风险。</code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 需要设置多少个worker\nNginx 同redis类似都采用了io多路复用机制，每个worker都是一个独立的进程，但每个进程里只有一个主线程，通过异步非阻塞的方式来处理请求， 即使是千上万个请求也不在话下。每个worker的线程可以把一个cpu的性能发挥到极致。\n所以worker数和服务器的cpu数相等是最为适宜的。设少了会浪费cpu，设多了会造成cpu频繁切换上下文带来的损耗。\n\n#设置worker数量\nworker_processes 4\n\n#work绑定cpu(4 work绑定4cpu)。\nworker_cpu_affinity 0001 0010 0100 1000\n\n#work绑定cpu (4 work绑定8cpu中的4个) 。\nworker_cpu_affinity 00000001 00000010 00000100 00001000  00010000  00100000 01000000  10000000</code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#连接数\nworker_connections 1024\n\n这个值是表示每个worker进程所能建立连接的最大值，所以，一个nginx能建立的最大连接数，应该是worker_connections * worker_processes。当然，这里说的是最大连接数，对于HTTP请求本地资源来说，能够支持的最大并发数量是worker_connections * worker_processes，如果是支持http1.1的浏览器每次访问要占两个连接，所以普通的静态访问最大并发数是： worker_connections * worker_processes &#x2F;2，而如果是HTTP作为反向代理来说，最大并发数量应该是worker_connections * worker_processes&#x2F;4。\n因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。</code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#面试题：\n第一个：发送请求，占用了woker的几个连接数？\n第二个：nginx有一个master，有四个woker，每个woker支持最大的连接数1024，支持的最大并发数是多少？</code></pre>\n\n\n\n<h4 id=\"14-1-nginx-conf-配置详解\"><a href=\"#14-1-nginx-conf-配置详解\" class=\"headerlink\" title=\"14.1 nginx.conf 配置详解\"></a>14.1 nginx.conf 配置详解</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#安全问题，建议用nobody,不要用root.\n#user  nobody;\n \n#worker数和服务器的cpu数相等是最为适宜\nworker_processes  2;\n \n#work绑定cpu(4 work绑定4cpu)\nworker_cpu_affinity 0001 0010 0100 1000\n \n#work绑定cpu (4 work绑定8cpu中的4个) 。\nworker_cpu_affinity 0000001 00000010 00000100 00001000  \n \n#error_log path(存放路径) level(日志等级) path表示日志路径，level表示日志等级，\n#具体如下：[ debug | info | notice | warn | error | crit ]\n#从左至右，日志详细程度逐级递减，即debug最详细，crit最少，默认为crit。 \n \n#error_log  logs&#x2F;error.log;\n#error_log  logs&#x2F;error.log  notice;\n#error_log  logs&#x2F;error.log  info;\n#pid        logs&#x2F;nginx.pid;\n \nevents &#123;\n    #这个值是表示每个worker进程所能建立连接的最大值，所以，一个nginx能建立的最大连接数，应该是worker_connections * worker_processes。\n    #当然，这里说的是最大连接数，对于HTTP请求本地资源来说，能够支持的最大并发数量是worker_connections * worker_processes，\n    #如果是支持http1.1的浏览器每次访问要占两个连接，\n    #所以普通的静态访问最大并发数是： worker_connections * worker_processes &#x2F;2，\n    #而如果是HTTP作为反向代理来说，最大并发数量应该是worker_connections * worker_processes&#x2F;4。\n    #因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。\n \n    worker_connections  1024;  \n \n    #这个值是表示nginx要支持哪种多路io复用。\n    #一般的Linux选择epoll, 如果是(*BSD)系列的Linux使用kquene。\n    #windows版本的nginx不支持多路IO复用，这个值不用配。\n    use epoll;\n \n    # 当一个worker抢占到一个链接时，是否尽可能的让其获得更多的连接,默认是off 。\n    multi_accept on; &#x2F;&#x2F;并发量大时缓解客户端等待时间。\n    # 默认是on ,开启nginx的抢占锁机制。\n    accept_mutex  on; &#x2F;&#x2F;master指派worker抢占锁\n&#125;\nhttp &#123;\n    #当web服务器收到静态的资源文件请求时，依据请求文件的后缀名在服务器的MIME配置文件中找到对应的MIME Type，再根据MIME Type设置HTTP Response的Content-Type，然后浏览器根据Content-Type的值处理文件。\n \n    include       mime.types;  #&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;mime.types\n \n    #如果 不能从mime.types找到映射的话，用以下作为默认值-二进制\n    default_type  application&#x2F;octet-stream;\n \n     #日志位置\n     access_log  logs&#x2F;host.access.log  main;\n \n     #一条典型的accesslog：\n     #101.226.166.254 - - [21&#x2F;Oct&#x2F;2013:20:34:28 +0800] &quot;GET &#x2F;movie_cat.php?year&#x3D;2013 HTTP&#x2F;1.1&quot; 200 5209 &quot;http:&#x2F;&#x2F;www.baidu.com&quot; &quot;Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident&#x2F;4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; MDDR; .NET4.0C; .NET4.0E; .NET CLR 1.1.4322; Tablet PC 2.0); 360Spider&quot;\n \n     #1）101.226.166.254:(用户IP)\n     #2）[21&#x2F;Oct&#x2F;2013:20:34:28 +0800]：(访问时间) \n     #3）GET：http请求方式，有GET和POST两种\n     #4）&#x2F;movie_cat.php?year&#x3D;2013：当前访问的网页是动态网页，movie_cat.php即请求的后台接口，year&#x3D;2013为具体接口的参数\n     #5）200：服务状态，200表示正常，常见的还有，301永久重定向、4XX表示请求出错、5XX服务器内部错误\n     #6）5209：传送字节数为5209，单位为byte\n     #7）&quot;http:&#x2F;&#x2F;www.baidu.com&quot;：refer:即当前页面的上一个网页\n     #8）&quot;Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident&#x2F;4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; #.NET CLR 3.0.30729; Media Center PC 6.0; MDDR; .NET4.0C; .NET4.0E; .NET CLR 1.1.4322; Tablet PC 2.0); 360Spider&quot;： agent字段：通常用来记录操作系统、浏览器版本、浏览器内核等信息\n \n    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;\n                       &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;\n                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;\n \n    #开启从磁盘直接到网络的文件传输，适用于有大文件上传下载的情况，提高IO效率。\n    sendfile        on; &#x2F;&#x2F;大文件传递优化，提高效率\n   \n    #一个请求完成之后还要保持连接多久, 默认为0，表示完成请求后直接关闭连接。\n    #keepalive_timeout  0;\n    keepalive_timeout  65; \n \n    #开启或者关闭gzip模块\n    #gzip  on ; &#x2F;&#x2F;文件压缩，再传输，提高效率\n \n    #设置允许压缩的页面最小字节数，页面字节数从header头中的Content-Length中进行获取。\n    #gzip_min_lenth 1k;&#x2F;&#x2F;超过该大小开始压缩，否则不用压缩\n \n    # gzip压缩比，1 压缩比最小处理速度最快，9 压缩比最大但处理最慢（传输快但比较消耗cpu）\n    #gzip_comp_level 4;\n \n    #匹配MIME类型进行压缩，（无论是否指定）&quot;text&#x2F;html&quot;类型总是会被压缩的。\n    #gzip_types types text&#x2F;plain text&#x2F;css application&#x2F;json  application&#x2F;x-javascript text&#x2F;xml   \n \n    #动静分离\n    #服务器端静态资源缓存，最大缓存到内存中的文件，不活跃期限\n    open_file_cache max&#x3D;655350 inactive&#x3D;20s;   \n   \n    #活跃期限内最少使用的次数，否则视为不活跃。\n    open_file_cache_min_uses 2;\n \n    #验证缓存是否活跃的时间间隔 \n    open_file_cache_valid 30s;\n    \nupstream  myserver&#123;\n    # 1、轮询（默认）\n    # 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\n    # 2、指定权重\n    # 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\n    #3、IP绑定 ip_hash\n    # 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\n    #4、备机方式 backup\n    # 正常情况不访问设定为backup的备机，只有当所有非备机全都宕机的情况下，服务才会进备机。当非备机启动后，自动切换到非备机\n# ip_hash;\nserver 192.168.161.132:8080 weight&#x3D;1;\nserver 192.168.161.132:8081 weight&#x3D;1 backup;\n    #5、fair（第三方）公平，需要安装插件才能用\n    #按后端服务器的响应时间来分配请求，响应时间短的优先分配。   \n    #6、url_hash（第三方）\n    #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。\n \n      # ip_hash;\n             server 192.168.161.132:8080 weight&#x3D;1;\n             server 192.168.161.132:8081 weight&#x3D;1;\n      \n      #fair\n \n      #hash $request_uri\n      #hash_method crc32\n      \n&#125;\n \n    server &#123;\n        #监听端口号\n        listen       80;\n \n        #服务名\n        server_name  192.168.161.130;\n \n        #字符集\n        #charset utf-8;\n \n#location [&#x3D;|~|~*|^~] &#x2F;uri&#x2F; &#123; … &#125;   \n# &#x3D; 精确匹配\n# ~ 正则匹配，区分大小写\n# ~* 正则匹配，不区分大小写\n# ^~  关闭正则匹配\n \n#匹配原则：\n \n# 1、所有匹配分两个阶段，第一个叫普通匹配，第二个叫正则匹配。\n# 2、普通匹配，首先通过“&#x3D;”来匹配完全精确的location\n        #   2.1、 如果没有精确匹配到， 那么按照最大前缀匹配的原则，来匹配location\n        #   2.2、 如果匹配到的location有^~,则以此location为匹配最终结果，如果没有那么会把匹配的结果暂存，继续进行正则匹配。\n        # 3、正则匹配，依次从上到下匹配前缀是~或~*的location, 一旦匹配成功一次，则立刻以此location为准，不再向下继续进行正则匹配。\n        # 4、如果正则匹配都不成功，则继续使用之前暂存的普通匹配成功的location.\n          #不是以波浪线开头的都是普通匹配。\n        location &#x2F; &#123;   # 匹配任何查询，因为所有请求都以 &#x2F; 开头。但是正则表达式规则和长的块规则将被优先和查询匹配。\n   \n    #定义服务器的默认网站根目录位置\n            root   html;&#x2F;&#x2F;相对路径，省略了.&#x2F;         &#x2F;user&#x2F;local&#x2F;nginx&#x2F;html  路径\n            \n    #默认访问首页索引文件的名称\n    index  index.html index.htm;\n \n    #反向代理路径\n            proxy_pass http:&#x2F;&#x2F;myserver;\n \n    #反向代理的超时时间\n            proxy_connect_timeout 10;\n \n            proxy_redirect default;\n         &#125;\n          #普通匹配\nlocation  &#x2F;images&#x2F; &#123;    \n    root images ;\n &#125;\n           # 反正则匹配\nlocation ^~ &#x2F;images&#x2F;jpg&#x2F; &#123;  # 匹配任何以 &#x2F;images&#x2F;jpg&#x2F; 开头的任何查询并且停止搜索。任何正则表达式将不会被测试。 \n    root images&#x2F;jpg&#x2F; ;\n&#125;\n#正则匹配\nlocation ~*.(gif|jpg|jpeg)$ &#123;       \n      #所有静态文件直接读取硬盘\n              root pic ;\n      \n      #expires定义用户浏览器缓存的时间为3天，如果静态页面不常更新，可以设置更长，这样可以节省带宽和缓解服务器的压力\n              expires 3d; #缓存3天\n         &#125;\n \n        #error_page  404              &#x2F;404.html;\n \n        # redirect server error pages to the static page &#x2F;50x.html\n        #\n        error_page   500 502 503 504  &#x2F;50x.html;\n        location &#x3D; &#x2F;50x.html &#123;\n            root   html;\n        &#125; \n    &#125;\n&#125;</code></pre>\n\n\n\n<h4 id=\"15、常用技巧\"><a href=\"#15、常用技巧\" class=\"headerlink\" title=\"15、常用技巧\"></a>15、常用技巧</h4><p>1、静态服务</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">server &#123;\n  listen       80;\n  server_name  static.sherlocked93.club;\n  charset utf-8;    # 防止中文文件名乱码\n\n  location &#x2F;download &#123;\n    alias\t          &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;static;  # 静态资源目录\n    \n    autoindex               on;    # 开启静态资源列目录\n    autoindex_exact_size    off;   # on(默认)显示文件的确切大小，单位是byte；off显示文件大概大小，单位KB、MB、GB\n    autoindex_localtime     off;   # off(默认)时显示的文件时间为GMT时间；on显示的文件时间为服务器时间\n  &#125;\n&#125;</code></pre>\n\n<p>2、图片防盗链</p>\n<p>最好将百度和 google 设置为白名单，利于 SEO</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">server &#123;\n  listen       80;        \n  server_name  *.sherlocked93.club;\n  \n  # 图片防盗链\n  location ~* \\.(gif|jpg|jpeg|png|bmp|swf)$ &#123;\n    valid_referers none blocked server_names ~\\.google\\. ~\\.baidu\\. *.qq.com;  # 只允许本机 IP 外链引用，将百度和谷歌也加入白名单\n    if ($invalid_referer)&#123;\n      return 403;\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<p>3、请求过滤</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># 非指定请求全返回 403\nif ( $request_method !~ ^(GET|POST|HEAD)$ ) &#123;\n  return 403;\n&#125;\n\nlocation &#x2F; &#123;\n  # IP访问限制（只允许IP是 192.168.0.2 机器访问）\n  allow 192.168.0.2;\n  deny all;\n  \n  root   html;\n  index  index.html index.htm;\n&#125;</code></pre>\n\n<p>4、配置图片字体等静态资源缓存</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">由于图片、字体、音频、视频等静态文件在打包的时候通常会增加了 hash，所以缓存可以设置的长一点，先设置强制缓存，再设置协商缓存；如果存在没有 hash 值的静态文件，建议不设置强制缓存，仅通过协商缓存判断是否需要使用缓存。\n# 图片缓存时间设置\nlocation ~ .*\\.(css|js|jpg|png|gif|swf|woff|woff2|eot|svg|ttf|otf|mp3|m4a|aac|txt)$ &#123;\n\texpires 10d;\n&#125;\n\n# 如果不希望缓存\nexpires -1;</code></pre>\n\n<p>5、HTTP 请求转发到 HTTPS</p>\n<p>配置完 HTTPS 后，浏览器还是可以访问 HTTP 的地址 <code>http://sherlocked93.club/</code> 的，可以做一个 301 跳转，把对应域名的 HTTP 请求重定向到 HTTPS 上</p>\n<pre class=\"line-numbers language-nginx\" data-language=\"nginx\"><code class=\"language-nginx\">server &#123;\n    listen      80;\n    server_name www.sherlocked93.club;\n\n    # 单域名重定向\n    if ($host &#x3D; &#39;www.sherlocked93.club&#39;)&#123;\n        return 301 https:&#x2F;&#x2F;www.sherlocked93.club$request_uri;\n    &#125;\n    # 全局非 https 协议时重定向\n    if ($scheme !&#x3D; &#39;https&#39;) &#123;\n        return 301 https:&#x2F;&#x2F;$server_name$request_uri;\n    &#125;\n\n    # 或者全部重定向\n    return 301 https:&#x2F;&#x2F;$server_name$request_uri;\n\n    # 以上配置选择自己需要的即可，不用全部加\n&#125;</code></pre>\n\n\n\n<h4 id=\"16、总结\"><a href=\"#16、总结\" class=\"headerlink\" title=\"16、总结\"></a>16、总结</h4><ul>\n<li><p>为了使 Nginx 配置更易于维护，建议为每个服务创建一个单独的配置文件，存储在 <code>/etc/nginx/conf.d</code> 目录，根据需求可以创建任意多个独立的配置文件。</p>\n</li>\n<li><p>独立的配置文件，建议遵循以下命名约定 <code>&lt;服务&gt;.conf</code>，比如域名是 <code>sherlocked93.club</code>，那么你的配置文件的应该是这样的 <code>/etc/nginx/conf.d/sherlocked93.club.conf</code>，如果部署多个服务，也可以在文件名中加上 Nginx 转发的端口号，比如 <code>sherlocked93.club.8080.conf</code>，如果是二级域名，建议也都加上 <code>fe.sherlocked93.club.conf</code>。</p>\n</li>\n<li><p>常用的、复用频率比较高的配置可以放到 <code>/etc/nginx/snippets</code> 文件夹，在 Nginx 的配置文件中需要用到的位置 include 进去，以功能来命名，并在每个 snippet 配置文件的开头注释标明主要功能和引入位置，方便管理。比如之前的 <code>gzip</code>、<code>cors</code> 等常用配置，我都设置了 snippet。</p>\n</li>\n<li><p>Nginx 日志相关目录，内以 <code>域名.type.log</code> 命名（比如 <code>be.sherlocked93.club.access.log</code> 和 <code>be.sherlocked93.club.error.log</code> ）位于 <code>/var/log/nginx/</code> 目录中，为每个独立的服务配置不同的访问权限和错误日志文件，这样查找错误时，会更加方便快捷。</p>\n</li>\n</ul>\n","text":"01、Nginx 的介绍Nginx 是开源、高性能、高可靠的 Web 和反向代理服务器 Nginx 支持热部署，几乎能做到 7*24 小时不间断运行，即使运行几个月也不需要重启，还能在不间断服务的情况下对软件进行热更新。 Nginx 最重要的考量是 性能 ，其占用内存少、并发能力...","link":"","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"23 mins."},"categories":[{"name":"Nginx","slug":"Nginx","count":1,"path":"api/categories/Nginx.json"}],"tags":[{"name":"Nginx","slug":"Nginx","count":1,"path":"api/tags/Nginx.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#01%E3%80%81Nginx-%E7%9A%84%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">01、Nginx 的介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#02%E3%80%81%E7%AE%80%E5%8D%95%E5%92%8C%E9%9D%9E%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">02、简单和非简单请求</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#03%E3%80%81%E8%B7%A8%E5%9F%9F\"><span class=\"toc-text\">03、跨域</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#04%E3%80%81%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">04、正向代理和反向代理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#05%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\"><span class=\"toc-text\">05、负载均衡</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#06%E3%80%81%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB\"><span class=\"toc-text\">06、动静分离</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#07%E3%80%81Nginx-%E7%9A%84%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">07、Nginx 的安装</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#08%E3%80%81Nginx-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">08、Nginx 相关命令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#09%E3%80%81Nginx-%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">09、Nginx 配置语法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10%E3%80%81%E5%85%B8%E5%9E%8B%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">10、典型配置</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#11%E3%80%81%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">11、反向代理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#12%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\"><span class=\"toc-text\">12、负载均衡</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#13%E3%80%81Nginx-%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB\"><span class=\"toc-text\">13、Nginx 动静分离</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#14%E3%80%81Nginx-%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">14、Nginx 原理与优化参数配置</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#14-1-nginx-conf-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">14.1 nginx.conf 配置详解</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#15%E3%80%81%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7\"><span class=\"toc-text\">15、常用技巧</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#16%E3%80%81%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">16、总结</span></a></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"SpringBoot 基础内容","uid":"1622936a4b6ba96f2723411bb290759b","slug":"65-SpringBoot-基础内容","date":"2021-09-13T15:41:32.000Z","updated":"2021-09-15T10:46:54.437Z","comments":true,"path":"api/articles/65-SpringBoot-基础内容.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog11.jpg","text":"1、Spirng Boot 概念① Spring 框架 最核心的特性就是依赖注入DI（Dependency Injecttion）和控制反转IOC（Inversion Of Control）。如果你能够合理的使用DI和IOC，可以开发出松耦合、扩展性好的的应用程序。 ② Spri...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"SpringBoot","slug":"SpringBoot","count":1,"path":"api/categories/SpringBoot.json"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","count":1,"path":"api/tags/SpringBoot.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"SVN","uid":"f2c49803fec94cd24a1c1407e5e84879","slug":"63-Svn","date":"2021-09-13T15:39:32.000Z","updated":"2021-09-15T10:47:00.975Z","comments":true,"path":"api/articles/63-Svn.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog1.jpg","text":"1. SVN是什么SVN的全称是subVersion，Svn版本控制软件可以解决协助开发，远程开发，和版本回退三个问题。 特点：操作简单，入门简单，跨平台操作。 SVN是输入 C/S服务类软件，有客户端和服务端。 2. SVN服务端 重要 创建服务器项目仓库，复制仓库地址，在本机...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"Project Manager","slug":"Project-Manager","count":3,"path":"api/categories/Project-Manager.json"}],"tags":[{"name":"Project Manager","slug":"Project-Manager","count":3,"path":"api/tags/Project-Manager.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}