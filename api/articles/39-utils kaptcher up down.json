{"title":"工具类，上传下载，验证码","uid":"cfe3c6b5bac26dbfd06dd74550839a48","slug":"39-utils kaptcher up down","date":"2021-09-13T15:15:32.000Z","updated":"2021-09-15T10:29:16.262Z","comments":true,"path":"api/articles/39-utils kaptcher up down.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","content":"<h3 id=\"1-BeanUtils使用及方法分析\"><a href=\"#1-BeanUtils使用及方法分析\" class=\"headerlink\" title=\"1. BeanUtils使用及方法分析\"></a>1. BeanUtils使用及方法分析</h3><h4 id=\"1-1-概论\"><a href=\"#1-1-概论\" class=\"headerlink\" title=\"1.1 概论\"></a>1.1 概论</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">1. BeanUtils被广泛的使用与三大框架。\n在整个J2EE的编程过程中，我们经常会从各种配置文件中读取相应的数据，需要明白的一点是从配置文件中读取到的数据都是String，但是很显然我们的应用程序中不仅仅有String一种数据类型，比如：基本数据类型（int、double、char、float等），还有自定义数据类型（引用数据类型），那么我们必须面临的一个问题就是讲字符串类型转换为各种具体的数据类型\n\n2. 主要解决的问题是：\n把对象的属性数据封装到对象中。该工具提供字符式操作为对象属性提供封装。BeanUtils&lt;kbd&gt;底层使用反射机制&lt;&#x2F;kbd&gt;实现数据访问及封装\n\n3. 使用前导入jar包：\n   commons-beanutils-1.9.3中的commons-beanutils-1.9.3.jar\n   commons-logging-1.2中的commons-logging-1.2.jar</code></pre>\n\n<h4 id=\"1-2-主要方法\"><a href=\"#1-2-主要方法\" class=\"headerlink\" title=\"1.2 主要方法\"></a>1.2 主要方法</h4><table>\n<thead>\n<tr>\n<th>方法参数</th>\n<th>使用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>static void copyProperty (Object bean, String name, Object value)</td>\n<td>将指定的属性值复制到指定的目标bean，执行所需的任何类型转换。</td>\n</tr>\n<tr>\n<td>static void setProperty (Object bean, String name, Object value)</td>\n<td>和上一个方法使用</td>\n</tr>\n<tr>\n<td><kbd>static void populate (Object bean, Map < String,? extends Object> properties)</kbd></td>\n<td>将指定的<strong>map</strong>集合内的元素<strong>赋值到目标bean</strong></td>\n</tr>\n<tr>\n<td>static void copyProperties (Object dest, Object orig)</td>\n<td>在属性名相同的所有情况下，将属性值从原始bean复制到目标bean。（底层进行深克隆）</td>\n</tr>\n</tbody></table>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * BeanUtils工具的使用\n * 功能：BeanUtils主要是用于将对象的属性封装到对象中\n * BeanUtils的好处：\n * BeanUtils设置属性值的时候，如果属性是基本数据类型，那么BeanUtils会自动帮我们进行数据类型的转换，并且\n * BeanUtils设置属性的时候也是依赖于底层的getter和setter方法\n * \n *方法内部参数使用 Map类型 和 泛型T 可以降低耦合度，提高扩展性，简化代码书写\n * dao层\n * service层\n * web层（servlet）\n * 使用HttpServletRequest request，只能应用在web层，并且最后传入的参数类型是 Map集合\n * 而直接使用 Map类型作为参数的话，在三层中都能使用，降低了代码的耦合性，提高了扩张性\n *\n * 如果设置的属性值是其他的引用数据类型，此时必须要注册一个类型转换器才能实现自动的转换\n * *&#x2F;\n\npublic class beanUtil &#123;\n\n    public static &lt;T&gt; T copyParaToBean(Map map, T been)&#123;\n\n        try &#123;\n            System.out.println(&quot;注入前：&quot;+been);\n            BeanUtils.populate(been,map);\n            System.out.println(&quot;注入后：&quot;+been);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        return been;\n\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"1-3-BeanUtils结论\"><a href=\"#1-3-BeanUtils结论\" class=\"headerlink\" title=\"1.3 BeanUtils结论\"></a>1.3 BeanUtils结论</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">1. 方法进行数据封装\n   \n2. 一般其实不需要自定义转换器，只有在特殊情况下才会**自定义转换器**\n   1、如果form参数是String类型，javabean属性String类型 — 调用BeanUtils.populate 将form数据封装 javabean\n   2、如果JavaBean属性类型不是String — 将form数据封装javabean 需要转换器 —– 在BeanUtils API 提供很多默认转换器（完成常见转换）\n   3、如果需要转换类型非常特殊，可以通过自定义转换器完成 定义类实现Converter接口，实现convert方法 ，在populate调用之前通过ConvertUtils.register注册转换器   \n\n3. 最通俗的说法，JavaBean就是一个存数据的地方，要么\n   （1）通过JSP页面中的标签去存储form表单中的数据（action跳转到JSP页面，之后“useBean”，“setProperty”进行数据存储），再在JSP界面中通过“getProperty”显示数据。\n   （2）在JSP页面中通过action跳转到Servlet程序的url，在Servlet程序中通过BeanUtils工具类的相关方法对JSP页面中的表单信息进行存储。</code></pre>\n\n<h3 id=\"2-Threadlocal\"><a href=\"#2-Threadlocal\" class=\"headerlink\" title=\"2. Threadlocal\"></a>2. Threadlocal</h3><h4 id=\"2-1-为什么会导致业务逻辑出错\"><a href=\"#2-1-为什么会导致业务逻辑出错\" class=\"headerlink\" title=\"2.1 为什么会导致业务逻辑出错\"></a>2.1 为什么会导致业务逻辑出错</h4><p>==ThreadLocal不调用remove方法会导致业务逻辑错误==</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">当ThreadLocal用于线程池、web应用或者线程被多次重复使用的时候，特别要注意，以web应用为例：\n\n我们都知道web应用很多类都是单例模式，如spring默认注入方式所创建的类就是一个单例，当不同的http请求到达服务器的时候，实际上都是使用了同一个实例，假如该实例使用了全局变量，当请求A修改了这个变量，后面到来的其它请求（此时不管A请求是否结束），如请求B再使用该变量的时候，实际上是被请求A修改过的，这会导致业务逻辑出错，而且很难被发现，这种情况，通常是使用ThreadLocal来解决，因为不同的请求虽然使用了同一个实例，但所使用的线程却不同，但有一点需要特别注意，那就是web容器的线程是重复使用的，web容器使用了线程池，当一个请求使用完某个线程，该线程会放回线程池被其它请求使用，这就导致一个问题，不同的请求还是有可能会使用到同一个线程（只要请求数量大于线程数量），而ThreadLocal是属于线程的，如果我们使用完ThreadLocal对象而没有手动删掉，那么后面的请求就有机会使用到被使用过的ThreadLocal对象，如果一个请求在使用ThreadLocal的时候，是先get()来判断然后再set()，那就会有问题，因为get到的是别的请求set的内容，如果一个请求每次使用ThreadLocal，都是先set再get，那就不会有问题，因为一个线程同一时刻只被一个请求使用，只要我们每次使用之前，都设置成自己想要的内容，那就不会在使用的过程中被覆盖。使用ThreadLocal最好是每次使用完就调用remove方法，将其删掉，避免先get后set的情况导致业务的错误。</code></pre>\n\n<h4 id=\"2-2-ThreadLocal-的使用\"><a href=\"#2-2-ThreadLocal-的使用\" class=\"headerlink\" title=\"2.2 ThreadLocal 的使用\"></a>2.2 ThreadLocal 的使用</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">1. ThreadLocal 的作用，它可以解决多线程的数据安全问题。 \n\n   ThreadLocal 它可以给当前线程关联一个数据（可以是普通变量，可以是对象，也可以是数组，集合） \n\n2. ThreadLocal 的特点： \n\n   * 1、ThreadLocal 可以为当前线程  &#x3D;&#x3D; 关联一个数据 &#x3D;&#x3D;。（它可以像 Map 一样存取数据，key 为当前线程） \n   * 每一个 ThreadLocal 对象，只能为当前线程关联一个数据，如果要为当前线程关联多个数据，就需要使用多个 ThreadLocal 对象实例。 \n   * 每个 ThreadLocal 对象实例定义的时候，&#x3D;&#x3D; 一般都是 static 类型 &#x3D;&#x3D;\n   * ThreadLocal 中保存数据，在线程销毁后。会由 JVM 虚拟自动释放。</code></pre>\n\n<h4 id=\"2-3-Filter-和-ThreadLocal-组合管理事务\"><a href=\"#2-3-Filter-和-ThreadLocal-组合管理事务\" class=\"headerlink\" title=\"2.3 Filter 和 ThreadLocal 组合管理事务\"></a>2.3 Filter 和 ThreadLocal 组合管理事务</h4><p><strong>使用 ThreadLocal 来确保所有 dao 操作都在同一个 Connection 连接对象中完 成</strong></p>\n<p><strong>先修改工具类的获取，提交，回滚方法</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static Connection getConnection() &#123;\n     Connection conn &#x3D; conns.get();\n\n     try &#123;\n         if (conn &#x3D;&#x3D; null) &#123;\n             conn &#x3D; ds.getConnection();\n             conns.set(conn);\n             conn.setAutoCommit(false);\n         &#125;\n     &#125; catch (Exception e) &#123;\n         e.printStackTrace();\n     &#125;\n     return conn;\n &#125;\n\n public static void commitAndClose() &#123;\n\n     Connection connection &#x3D; conns.get();\n     if (connection !&#x3D; null) &#123;\n         try &#123;\n             connection.commit();\n         &#125; catch (SQLException e) &#123;\n             e.printStackTrace();\n         &#125; finally &#123;\n             try &#123;\n                 connection.close();\n             &#125; catch (SQLException e) &#123;\n                 e.printStackTrace();\n             &#125;\n         &#125;\n     &#125;\n     &#x2F;&#x2F; 一定要执行remove操作，否则就会出错。（因为Tomcat服务器底层使用了线程池技术）\n     conns.remove();\n\n &#125;\n\n public static void rollbackAndClose() &#123;\n\n     Connection connection &#x3D; conns.get();\n\n     if (connection !&#x3D; null) &#123;\n         try &#123;\n             connection.rollback();\n         &#125; catch (SQLException e) &#123;\n             e.printStackTrace();\n         &#125; finally &#123;\n             try &#123;\n                 connection.close();\n             &#125; catch (SQLException e) &#123;\n                 e.printStackTrace();\n             &#125;\n         &#125;\n     &#125;\n     &#x2F;&#x2F; 一定要执行remove操作，否则就会出错。（因为Tomcat服务器底层使用了线程池技术）\n     conns.remove();\n &#125;</code></pre>\n\n<p>再修改baseDao中的方法，因为要使用 ThreadLocal 来确保所有 dao 操作都在同一个 Connection 连接对象中完 成，所以不能使用完其中一个个方法就将其关闭，我们应该在提交或者回滚的时候关闭，并且无论哪个方法出现错误，都应该抛出来，让transactionFilter来接收处理</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;使用DBUtils操作数据库对象\nprivate final QueryRunner queryRunner &#x3D; new QueryRunner();\n\n&#x2F;**\n * 进行增删改的操作\n * @param sql   数据库操作语句\n * @param args  sql语句的参数\n * @return  返回-1表示操作失败，其他值表示成功，值为影响的数据条数\n *&#x2F;\npublic int update(String sql,Object...args)&#123;\n    Connection conn &#x3D; jdbcUtil.getConnection();\n    try &#123;\n        return queryRunner.update(conn,sql,args);\n    &#125; catch (SQLException e) &#123;\n        e.printStackTrace();\n        throw new RuntimeException(e);\n    &#125;\n&#125;\n\n&#x2F;**\n * 查询返回一个javaBean的sql语句\n * @param sql 查询单个的查询语句\n * @param type  返回的对象类型\n * @param args  sql语句的参数\n * @param &lt;T&gt;   返回的数据类型的泛型\n * @return  返回null，说明数据库中，无此查询数据\n *&#x2F;\npublic &lt;T&gt; T queryOne(String sql,Class&lt;T&gt; type,Object...args)&#123;\n    Connection conn &#x3D; jdbcUtil.getConnection();\n    try &#123;\n        return queryRunner.query(conn,sql,new BeanHandler&lt;T&gt;(type),args);\n    &#125; catch (SQLException e) &#123;\n        e.printStackTrace();\n        throw new RuntimeException(e);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>使用 Filter 过滤器统一给所有的 Service 方法都加上 try-catch。来进行实现的 管理。</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@WebFilter(filterName &#x3D; &quot;TransactonFilter&quot;,urlPatterns &#x3D; &quot;&#x2F;*&quot;)\npublic class TransactonFilter implements Filter &#123;\n    public void destroy() &#123;\n    &#125;\n\n    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;\n\n        try &#123;\n            chain.doFilter(req, resp);\n            jdbcUtil.commitAndClose();\n        &#125; catch (Exception e) &#123;\n            jdbcUtil.rollbackAndClose();\n            e.printStackTrace();\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n\n    public void init(FilterConfig config) throws ServletException &#123;\n\n    &#125;\n\n&#125;</code></pre>\n\n<p>需要修改baseServlet中的异常捕获，使他抛出，利于transactionFilter 接收并做出相应处理</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n\n    request.setCharacterEncoding(&quot;utf8&quot;);\n    response.setContentType(&quot;text&#x2F;html;charset&#x3D;utf8&quot;);\n\n    String action &#x3D; request.getParameter(&quot;action&quot;);\n\n    try &#123;\n        &#x2F;&#x2F; 获取 action 业务鉴别字符串，获取相应的业务 方法反射对象\n        &#x2F;&#x2F;System.out.println(this);&#x2F;&#x2F;servlet.UserServlet@20e68ff8\n        &#x2F;&#x2F;System.out.println(this.getClass());&#x2F;&#x2F;class servlet.UserServlet\n        Method method &#x3D; this.getClass().getDeclaredMethod(action, HttpServletRequest.class, HttpServletResponse.class);\n        &#x2F;&#x2F;System.out.println(method);&#x2F;&#x2F;protected void servlet.UserServlet.login(javax.servlet.http.HttpServletRequest,\n        &#x2F;&#x2F; +javax.servlet.http.HttpServletResponse)throws javax.servlet.ServletException,java.io.IOException\n\n        &#x2F;&#x2F; 调用目标业务 方法\n        method.invoke(this,request,response);\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n        throw new RuntimeException(e);\n    &#125;\n\n&#125;</code></pre>\n\n<p>将所有异常都统一交给 Tomcat，让 Tomcat 展示友好的错误信息页面</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;error-page&gt;\n    &lt;error-code&gt;500&lt;&#x2F;error-code&gt;\n    &lt;location&gt;&#x2F;pages&#x2F;error&#x2F;error500.jsp&lt;&#x2F;location&gt;\n&lt;&#x2F;error-page&gt;</code></pre>\n\n<h3 id=\"3-谷歌验证码-kaptch\"><a href=\"#3-谷歌验证码-kaptch\" class=\"headerlink\" title=\"3. 谷歌验证码 - kaptch\"></a>3. 谷歌验证码 - kaptch</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">谷歌验证码 kaptcha 使用步骤如下：\n1、导入谷歌验证码的 jar 包\n   kaptcha-2.3.2.jar\n\t\n2、在 web.xml 中去配置用于生成验证码的 Servlet 程序\n   &lt;servlet&gt;\n\t\t&lt;servlet-name&gt;KaptchaServlet&lt;&#x2F;servlet-name&gt;\n\t\t&lt;servlet-class&gt;com.google.code.kaptcha.servlet.KaptchaServlet&lt;&#x2F;servlet-class&gt;\n   &lt;&#x2F;servlet&gt;\n   &lt;servlet-mapping&gt;\n\t\t&lt;servlet-name&gt;KaptchaServlet&lt;&#x2F;servlet-name&gt;\n\t\t&lt;url-pattern&gt;&#x2F;kaptcha.jpg&lt;&#x2F;url-pattern&gt;\n   &lt;&#x2F;servlet-mapping&gt;\n   \n3、在表单中使用 img 标签去显示验证码图片并使用它\n   &lt;form action&#x3D;&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;tmp&#x2F;registServlet&quot; method&#x3D;&quot;get&quot;&gt;\n   \t\t用户名：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; &gt; &lt;br&gt;\n   \t\t验证码：&lt;input type&#x3D;&quot;text&quot; style&#x3D;&quot;width: 80px;&quot; name&#x3D;&quot;code&quot;&gt;\n   \t\t&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;tmp&#x2F;kaptcha.jpg&quot; alt&#x3D;&quot;&quot; style&#x3D;&quot;width: 100px; height: 28px;&quot;&gt; &lt;br&gt;\n   \t\t&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;登录&quot;&gt;\n   &lt;&#x2F;form&gt;\n   \n4、在服务器获取谷歌生成的验证码和客户端发送过来的验证码比较使用。\n   protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException,\n   IOException &#123;\n\t\t&#x2F;&#x2F; 获取 Session 中的验证码\n\t\tString token &#x3D; (String) req.getSession().getAttribute(KAPTCHA_SESSION_KEY);\n\t\t&#x2F;&#x2F; 删除 Session 中的验证码\n\t\treq.getSession().removeAttribute(KAPTCHA_SESSION_KEY);\n\t\tString code &#x3D; req.getParameter(&quot;code&quot;);\n\t\t\t\t\n\t\t&#x2F;&#x2F; 获取用户名\n\t\tString username &#x3D; req.getParameter(&quot;username&quot;);\n\t\tif (token !&#x3D; null &amp;&amp; token.equalsIgnoreCase(code)) &#123;\n\t\t\tSystem.out.println(&quot;保存到数据库：&quot; + username);\n\t\t\tresp.sendRedirect(req.getContextPath() + &quot;&#x2F;ok.jsp&quot;);\n\t\t&#125; else &#123;\n\t\t\tSystem.out.println(&quot;请不要重复提交表单&quot;);\n\t\t\t&#125;\n\t\t&#125;\n\t\t\n5、点击切换验证码：\n\t&#x2F;&#x2F; 给验证码的图片，绑定单击事件\n\t$(&quot;#code_img&quot;).click(function () &#123;\n\t&#x2F;&#x2F; 在事件响应的 function 函数中有一个 this 对象。这个 this 对象，是当前正在响应事件的 dom 对象\n\t&#x2F;&#x2F; src 属性表示验证码 img 标签的 图片路径。它可读，可写\n\t&#x2F;&#x2F; alert(this.src);\n\tthis.src &#x3D; &quot;$&#123;basePath&#125;kaptcha.jpg?d&#x3D;&quot; + new Date();\n\t&#125;);</code></pre>\n\n\n\n<h3 id=\"4-文件上传\"><a href=\"#4-文件上传\" class=\"headerlink\" title=\"4. 文件上传\"></a>4. 文件上传</h3><h4 id=\"4-1-概述\"><a href=\"#4-1-概述\" class=\"headerlink\" title=\"4.1 概述\"></a>4.1 概述</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">1. 要有一个 form 标签，method&#x3D;post 请求 \n2. form 标签的 encType 属性值必须为 multipart&#x2F;form-data 值 \n3. 在 form 标签中使用 input type&#x3D;file 添加上传的文件 \n4. 编写服务器代码（Servlet 程序）接收，处理上传的数据。 \n5. encType&#x3D;multipart&#x2F;form-data 表示提交的数据，以多段（每一个表单项一个数据段）的形式进行拼 接，然后以二进制流的形式发送给服务器</code></pre>\n\n<h4 id=\"4-2-文件上传，HTTP-协议的说明\"><a href=\"#4-2-文件上传，HTTP-协议的说明\" class=\"headerlink\" title=\"4.2 文件上传，HTTP 协议的说明\"></a>4.2 文件上传，HTTP 协议的说明</h4><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8F%91%E9%80%81%E7%9A%84HTTP%E5%8D%8F%E8%AE%AE.png\" alt=\"文件上传发送的HTTP协议\"></p>\n<h4 id=\"4-3-commons-fileupload常用-API\"><a href=\"#4-3-commons-fileupload常用-API\" class=\"headerlink\" title=\"4.3 commons-fileupload常用 API\"></a>4.3 commons-fileupload常用 API</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">1. 第一步，就是需要导入两个 jar 包： commons-fileupload-1.2.1.jar \tcommons-io-1.4.jar\n\n2. commons-fileupload.jar 和 commons-io.jar 包中常用的类\n\n   * ServletFileUpload 类，用于解析上传的数据。 \n\n   * FileItem 类，表示每一个表单项。\n\n3. 常用API\n\n   * boolean  ServletFileUpload  isMultipartContent(HttpServletRequest request) 判断当前上传的数据格式是否是多段的格式。 \n\n   * public \tList \tparseRequest(HttpServletRequest request) \t解析上传的数据 \n\n   * boolean \tFileItem\tisFormField() \t判断当前这个表单项，是否是普通的表单项。还是上传的文件类型。 \n\n     true 表示普通类型的表单项\t false 表示上传的文件类型 \n\n   * String     FileItem    getFieldName()     获取表单项的 name 属性值 \n\n   * String     FileItem    getString() \t获取当前表单项的值。 \n\n   * String     FileItem    getName()\t 获取上传的文件名 \n\n   * void       FileItem    write( file )\t将上传的文件写到 参数 file 所指向抽硬盘位置 。</code></pre>\n\n<h4 id=\"4-4-示例\"><a href=\"#4-4-示例\" class=\"headerlink\" title=\"4.4 示例\"></a>4.4 示例</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">HTML中代码：\n    &lt;form action&#x3D;&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;EL&#x2F;upload&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;\n        用户名:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&#x2F;&gt;\n        密码:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;password&quot;&#x2F;&gt;\n        文件上传:&lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;photo&quot;&#x2F;&gt;\n        &lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot;&#x2F;&gt;\n    &lt;&#x2F;form&gt;\n\n\n\n\t\trequest.setCharacterEncoding(&quot;utf8&quot;);\n        &#x2F;&#x2F;System.out.println(request.getCharacterEncoding());\n        &#x2F;&#x2F;1.判断是否是多段数据\n        if (ServletFileUpload.isMultipartContent(request)) &#123;\n            &#x2F;&#x2F;2.创建用于解析上传数据的工具类 ServletFileUpload 类\n            &#x2F;&#x2F; 创建 FileItemFactory 工厂实现类\n            FileItemFactory fileItemFactory &#x3D; new DiskFileItemFactory();\n            ServletFileUpload servletFileUpload &#x3D; new ServletFileUpload(fileItemFactory);\n\n            &#x2F;&#x2F;4.解析上传的数据，得到每一个表单项 FileItem\n            try &#123;\n                List&lt;FileItem&gt; list &#x3D; servletFileUpload.parseRequest(request);\n                for (FileItem fileItem : list) &#123;\n                    &#x2F;&#x2F;5.判断是否为普通表单项\n                    if (fileItem.isFormField()) &#123;\n                        &#x2F;&#x2F;是普通表单项\n                        System.out.println(&quot;name属性值：&quot; + fileItem.getFieldName());\n                        System.out.println(&quot;传入的数据：&quot; + fileItem.getString(&quot;utf-8&quot;));\n                    &#125; else &#123;\n                        &#x2F;&#x2F;是文件fileName &#x3D; URLDecoder.decode(fileDetail.getFileName(), &quot;UTF-8&quot;);\n                        System.out.println(&quot;文件上传项name属性值：&quot; + fileItem.getFieldName());\n                        System.out.println(&quot;上传的文件名：&quot; + fileItem.getName());\n\n                        &#x2F;&#x2F;6.把文件保存到要保存的位置StandardCharsets.UTF_8 can be used instead\n                        fileItem.write(new File(&quot;e:&#x2F;&#x2F;&quot; + fileItem.getName()));\n                    &#125;\n                &#125;\n            &#125; catch (Exception e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;</code></pre>\n\n<h3 id=\"5-文件下载\"><a href=\"#5-文件下载\" class=\"headerlink\" title=\"5. 文件下载\"></a>5. 文件下载</h3><h4 id=\"5-1-示例\"><a href=\"#5-1-示例\" class=\"headerlink\" title=\"5.1 示例\"></a>5.1 示例</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;1.获取要下载的文件名\nString downloadfilename&#x3D;&quot;按钮.jpg&quot;;\n\n&#x2F;&#x2F;2.读取要下载的文件内容(通过servletContext对象获取)\n&#x2F;&#x2F;ServletContext servletContext &#x3D; getServletContext();\nServletContext servletContext &#x3D; getServletConfig().getServletContext();\n&#x2F;&#x2F;以流的方式获取文件内容\nInputStream resourceAsStream &#x3D; servletContext.getResourceAsStream(&quot;&#x2F;img&#x2F;&quot; + downloadfilename);\n\n&#x2F;&#x2F;3.再回传前，通过响应头告诉客户端返回的数据类型\nString mimeType &#x3D; servletContext.getMimeType(&quot;&#x2F;img&#x2F;&quot; + downloadfilename);\n&#x2F;&#x2F;System.out.println(mimeType);\nresponse.setContentType(mimeType);\n\n&#x2F;&#x2F;4.还要告诉客户端收到的数据是用于下载使用（通过响应头设置）\nresponse.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; fileName&#x3D;&quot;+ URLEncoder.encode(&quot;按钮.jpg&quot;,&quot;utf8&quot;));\n\n&#x2F;&#x2F;5.把要下载的文件回传给客户端(通过输出流进行输出)\nServletOutputStream outputStream &#x3D; response.getOutputStream();\n&#x2F;&#x2F;用commons-io-1.4.jar包中封装好的工具类进行复制输出\nIOUtils.copy(resourceAsStream, outputStream);</code></pre>\n\n<h4 id=\"5-2-常用API\"><a href=\"#5-2-常用API\" class=\"headerlink\" title=\"5.2 常用API\"></a>5.2 常用API</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">1. response.getOutputStream(); \n\n2. servletContext.getResourceAsStream(); \n\n   以流的方式获取文件内容\n\n3. servletContext.getMimeType(); \n\n   获得文件的数据类型\n\n4. response.setContentType();\n\n   再回传前，通过响应头告诉客户端返回的数据类型\n\n5. response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; fileName&#x3D;1.jpg&quot;);\n\n   这个响应头告诉浏览器。这是需要下载的。而 attachment 表示附件，也就是下载的一个文件。fileName&#x3D;后面， 表示下载的文件名。\n\n6. URLEncoder.encode(&quot;按钮.jpg&quot;,&quot;utf8&quot;)\n\n   以中文方式进行编码</code></pre>\n\n","text":"1. BeanUtils使用及方法分析1.1 概论1. BeanUtils被广泛的使用与三大框架。 在整个J2EE的编程过程中，我们经常会从各种配置文件中读取相应的数据，需要明白的一点是从配置文件中读取到的数据都是String，但是很显然我们的应用程序中不仅仅有String一种数...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/categories/JavaWeb.json"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/tags/JavaWeb.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-BeanUtils%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90\"><span class=\"toc-text\">1. BeanUtils使用及方法分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-%E6%A6%82%E8%AE%BA\"><span class=\"toc-text\">1.1 概论</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1.2 主要方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-BeanUtils%E7%BB%93%E8%AE%BA\"><span class=\"toc-text\">1.3 BeanUtils结论</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Threadlocal\"><span class=\"toc-text\">2. Threadlocal</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%87%BA%E9%94%99\"><span class=\"toc-text\">2.1 为什么会导致业务逻辑出错</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-ThreadLocal-%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">2.2 ThreadLocal 的使用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-Filter-%E5%92%8C-ThreadLocal-%E7%BB%84%E5%90%88%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1\"><span class=\"toc-text\">2.3 Filter 和 ThreadLocal 组合管理事务</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E8%B0%B7%E6%AD%8C%E9%AA%8C%E8%AF%81%E7%A0%81-kaptch\"><span class=\"toc-text\">3. 谷歌验证码 - kaptch</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0\"><span class=\"toc-text\">4. 文件上传</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">4.1 概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-2-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%EF%BC%8CHTTP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">4.2 文件上传，HTTP 协议的说明</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-3-commons-fileupload%E5%B8%B8%E7%94%A8-API\"><span class=\"toc-text\">4.3 commons-fileupload常用 API</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-4-%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">4.4 示例</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD\"><span class=\"toc-text\">5. 文件下载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">5.1 示例</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-2-%E5%B8%B8%E7%94%A8API\"><span class=\"toc-text\">5.2 常用API</span></a></li></ol></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"Maven","uid":"6f4f974e39a23a6637b9ccfa82544a76","slug":"40_Maven","date":"2021-09-13T15:16:32.000Z","updated":"2021-09-15T10:53:25.585Z","comments":true,"path":"api/articles/40_Maven.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog9.jpg","text":"1. Maven简介1.1 完成一个java项目1. 分析项目要做什么，知道项目有哪些组成部分 2. 设计项目（步骤，技术，多少人，多长时间） 3. 组建团队，招人，购置设备，服务器，软件，笔记本 4. 开发人员写代码，测试代码，重复多次工作 5. 测试人员，测试项目功能 ---...","link":"","photos":[],"count_time":{"symbolsCount":"8.7k","symbolsTime":"8 mins."},"categories":[{"name":"Project Manager","slug":"Project-Manager","count":3,"path":"api/categories/Project-Manager.json"}],"tags":[{"name":"Project Manager","slug":"Project-Manager","count":3,"path":"api/tags/Project-Manager.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"Json Ajax","uid":"cf8cafd4cf1868b0ac65896e606a4625","slug":"38-Json Ajax","date":"2021-09-13T15:14:32.000Z","updated":"2021-09-15T10:28:40.121Z","comments":true,"path":"api/articles/38-Json Ajax.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":":beginner: ​Json① json 的定义1. json 是由键值对组成，并且由 花括号（大括号）包围。 2. 每个键由引号引起来，键和值之间使用 冒号进行分隔， 多组键值对之间进行 逗号进行分隔。 例子♥: &#123; &quot;name&quot;:&quot;...","link":"","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"23 mins."},"categories":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/categories/JavaWeb.json"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/tags/JavaWeb.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}