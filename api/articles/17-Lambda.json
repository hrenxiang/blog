{"title":"Lambda 表达式","uid":"c7c150790ff577b4efb11f92f9e10f6d","slug":"17-Lambda","date":"2021-09-13T14:52:32.000Z","updated":"2021-09-15T10:17:28.153Z","comments":true,"path":"api/articles/17-Lambda.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","content":"<h3 id=\"一、函数式编程思想\"><a href=\"#一、函数式编程思想\" class=\"headerlink\" title=\"一、函数式编程思想\"></a>一、函数式编程思想</h3><p>在数学中，<strong>函数</strong>就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。编程中的函数，也有类似的概念，你调用我的时候，给我实参为形参赋值，然后通过运行方法体，给你返回一个结果。对于调用者来做，关注这个方法具备什么样的功能。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong>。</p>\n<ul>\n<li><p>面向对象的思想:</p>\n<ul>\n<li>做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</li>\n</ul>\n</li>\n<li><p>函数式编程思想:</p>\n<ul>\n<li>只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</li>\n</ul>\n</li>\n</ul>\n<p>Java8引入了Lambda表达式之后，Java也开始支持函数式编程。</p>\n<p>Lambda表达式不是Java最早使用的，很多语言就支持Lambda表达式，例如：C++，C#，Python，Scala等。如果有Python或者Javascript的语言基础，对理解Lambda表达式有很大帮助，可以这么说lambda表达式其实就是实现SAM接口的语法糖，使得Java也算是支持函数式编程的语言。Lambda<strong>写的好</strong>可以极大的减少代码冗余，同时可读性也好过冗长的匿名内部类。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实<br>底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部<br>类的“语法糖”，但是二者在原理上是不同的。</p></blockquote>\n<h3 id=\"二、函数式接口\"><a href=\"#二、函数式接口\" class=\"headerlink\" title=\"二、函数式接口\"></a>二、函数式接口</h3><p>lambda表达式其实就是实现SAM接口的语法糖，所谓<strong>SAM接口就是Single Abstract Method</strong>，即<u>该接口中只有一个抽象方法需要实现</u>，当然该接口可以包含其他非抽象方法。</p>\n<p>其实只要满足“SAM”特征的接口都可以称为函数式接口，都可以使用Lambda表达式，但是如果要更明确一点，最好在声明接口时，加上@FunctionalInterface。一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。</p>\n<p>之前学过的SAM接口中，标记了@FunctionalInterface的函数式接口的有：Runnable，Comparator，FileFilter。</p>\n<p>Java8在java.util.function新增了很多函数式接口：<strong>主要分为四大类，消费型、供给型、判断型、功能型</strong>。基本可以满足我们的开发需求。当然你也可以定义自己的函数式接口。</p>\n<h4 id=\"1、自定义函数式接口\"><a href=\"#1、自定义函数式接口\" class=\"headerlink\" title=\"1、自定义函数式接口\"></a>1、自定义函数式接口</h4><p>只要确保接口中有且仅有一个抽象方法即可：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">修饰符 interface 接口名称 &#123;\n    public abstract 返回值类型 方法名称(可选参数信息);\n    &#x2F;&#x2F; 其他非抽象方法内容\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>接口当中抽象方法的 public abstract 是可以省略的</p></blockquote>\n<h4 id=\"2、消费型接口\"><a href=\"#2、消费型接口\" class=\"headerlink\" title=\"2、消费型接口\"></a><strong>2、消费型接口</strong></h4><p>消费型接口的抽象方法特点：有形参，但是返回值类型是void</p>\n<table>\n<thead>\n<tr>\n<th>接口名</th>\n<th>抽象方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Consumer<T></td>\n<td>void accept(T t)</td>\n<td>接收一个对象用于完成功能</td>\n</tr>\n<tr>\n<td>BiConsumer&lt;T,U&gt;</td>\n<td>void accept(T t, U u)</td>\n<td>接收两个对象用于完成功能</td>\n</tr>\n<tr>\n<td>DoubleConsumer</td>\n<td>void accept(double value)</td>\n<td>接收一个double值</td>\n</tr>\n<tr>\n<td>IntConsumer</td>\n<td>void accept(int value)</td>\n<td>接收一个int值</td>\n</tr>\n<tr>\n<td>LongConsumer</td>\n<td>void accept(long value)</td>\n<td>接收一个long值</td>\n</tr>\n<tr>\n<td>ObjDoubleConsumer<T></td>\n<td>void accept(T t, double value)</td>\n<td>接收一个对象和一个double值</td>\n</tr>\n<tr>\n<td>ObjIntConsumer<T></td>\n<td>void accept(T t, int value)</td>\n<td>接收一个对象和一个int值</td>\n</tr>\n<tr>\n<td>ObjLongConsumer<T></td>\n<td>void accept(T t, long value)</td>\n<td>接收一个对象和一个long值</td>\n</tr>\n</tbody></table>\n<h4 id=\"3、供给型接口\"><a href=\"#3、供给型接口\" class=\"headerlink\" title=\"3、供给型接口\"></a><strong>3、供给型接口</strong></h4><p>这类接口的抽象方法特点：无参，但是无返回值</p>\n<table>\n<thead>\n<tr>\n<th>接口名</th>\n<th>抽象方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Supplier<T></td>\n<td>T get()</td>\n<td>返回一个对象</td>\n</tr>\n<tr>\n<td>BooleanSupplier</td>\n<td>boolean getAsBoolean()</td>\n<td>返回一个boolean值</td>\n</tr>\n<tr>\n<td>DoubleSupplier</td>\n<td>double getAsDouble()</td>\n<td>返回一个double值</td>\n</tr>\n<tr>\n<td>IntSupplier</td>\n<td>int getAsInt()</td>\n<td>返回一个int值</td>\n</tr>\n<tr>\n<td>LongSupplier</td>\n<td>long getAsLong()</td>\n<td>返回一个long值</td>\n</tr>\n</tbody></table>\n<h4 id=\"4、判断型接口\"><a href=\"#4、判断型接口\" class=\"headerlink\" title=\"4、判断型接口\"></a><strong>4、判断型接口</strong></h4><p>这里接口的抽象方法特点：有参，但是返回值类型是boolean结果。</p>\n<table>\n<thead>\n<tr>\n<th>接口名</th>\n<th>抽象方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Predicate<T></td>\n<td>boolean test(T t)</td>\n<td>接收一个对象</td>\n</tr>\n<tr>\n<td>BiPredicate&lt;T,U&gt;</td>\n<td>boolean test(T t, U u)</td>\n<td>接收两个对象</td>\n</tr>\n<tr>\n<td>DoublePredicate</td>\n<td>boolean test(double value)</td>\n<td>接收一个double值</td>\n</tr>\n<tr>\n<td>IntPredicate</td>\n<td>boolean test(int value)</td>\n<td>接收一个int值</td>\n</tr>\n<tr>\n<td>LongPredicate</td>\n<td>boolean test(long value)</td>\n<td>接收一个long值</td>\n</tr>\n</tbody></table>\n<h4 id=\"5、功能型接口\"><a href=\"#5、功能型接口\" class=\"headerlink\" title=\"5、功能型接口\"></a><strong>5、功能型接口</strong></h4><p>这类接口的抽象方法特点：既有参数又有返回值</p>\n<table>\n<thead>\n<tr>\n<th>接口名</th>\n<th>抽象方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Function&lt;T,R&gt;</td>\n<td>R apply(T t)</td>\n<td>接收一个T类型对象，返回一个R类型对象结果</td>\n</tr>\n<tr>\n<td>UnaryOperator<T></td>\n<td>T apply(T t)</td>\n<td>接收一个T类型对象，返回一个T类型对象结果</td>\n</tr>\n<tr>\n<td>DoubleFunction<R></td>\n<td>R apply(double value)</td>\n<td>接收一个double值，返回一个R类型对象</td>\n</tr>\n<tr>\n<td>IntFunction<R></td>\n<td>R apply(int value)</td>\n<td>接收一个int值，返回一个R类型对象</td>\n</tr>\n<tr>\n<td>LongFunction<R></td>\n<td>R apply(long value)</td>\n<td>接收一个long值，返回一个R类型对象</td>\n</tr>\n<tr>\n<td>ToDoubleFunction<T></td>\n<td>double applyAsDouble(T value)</td>\n<td>接收一个T类型对象，返回一个double</td>\n</tr>\n<tr>\n<td>ToIntFunction<T></td>\n<td>int applyAsInt(T value)</td>\n<td>接收一个T类型对象，返回一个int</td>\n</tr>\n<tr>\n<td>ToLongFunction<T></td>\n<td>long applyAsLong(T value)</td>\n<td>接收一个T类型对象，返回一个long</td>\n</tr>\n<tr>\n<td>DoubleToIntFunction</td>\n<td>int applyAsInt(double value)</td>\n<td>接收一个double值，返回一个int结果</td>\n</tr>\n<tr>\n<td>DoubleToLongFunction</td>\n<td>long applyAsLong(double value)</td>\n<td>接收一个double值，返回一个long结果</td>\n</tr>\n<tr>\n<td>IntToDoubleFunction</td>\n<td>double applyAsDouble(int value)</td>\n<td>接收一个int值，返回一个double结果</td>\n</tr>\n<tr>\n<td>IntToLongFunction</td>\n<td>long applyAsLong(int value)</td>\n<td>接收一个int值，返回一个long结果</td>\n</tr>\n<tr>\n<td>LongToDoubleFunction</td>\n<td>double applyAsDouble(long value)</td>\n<td>接收一个long值，返回一个double结果</td>\n</tr>\n<tr>\n<td>LongToIntFunction</td>\n<td>int applyAsInt(long value)</td>\n<td>接收一个long值，返回一个int结果</td>\n</tr>\n<tr>\n<td>DoubleUnaryOperator</td>\n<td>double applyAsDouble(double operand)</td>\n<td>接收一个double值，返回一个double</td>\n</tr>\n<tr>\n<td>IntUnaryOperator</td>\n<td>int applyAsInt(int operand)</td>\n<td>接收一个int值，返回一个int结果</td>\n</tr>\n<tr>\n<td>LongUnaryOperator</td>\n<td>long applyAsLong(long operand)</td>\n<td>接收一个long值，返回一个long结果</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>BiFunction&lt;T,U,R&gt;</td>\n<td>R apply(T t, U u)</td>\n<td>接收一个T类型和一个U类型对象，返回一个R类型对象结果</td>\n</tr>\n<tr>\n<td>BinaryOperator<T></td>\n<td>T apply(T t, T u)</td>\n<td>接收两个T类型对象，返回一个T类型对象结果</td>\n</tr>\n<tr>\n<td>ToDoubleBiFunction&lt;T,U&gt;</td>\n<td>double applyAsDouble(T t, U u)</td>\n<td>接收一个T类型和一个U类型对象，返回一个double</td>\n</tr>\n<tr>\n<td>ToIntBiFunction&lt;T,U&gt;</td>\n<td>int applyAsInt(T t, U u)</td>\n<td>接收一个T类型和一个U类型对象，返回一个int</td>\n</tr>\n<tr>\n<td>ToLongBiFunction&lt;T,U&gt;</td>\n<td>long applyAsLong(T t, U u)</td>\n<td>接收一个T类型和一个U类型对象，返回一个long</td>\n</tr>\n<tr>\n<td>DoubleBinaryOperator</td>\n<td>double applyAsDouble(double left, double right)</td>\n<td>接收两个double值，返回一个double结果</td>\n</tr>\n<tr>\n<td>IntBinaryOperator</td>\n<td>int applyAsInt(int left, int right)</td>\n<td>接收两个int值，返回一个int结果</td>\n</tr>\n<tr>\n<td>LongBinaryOperator</td>\n<td>long applyAsLong(long left, long right)</td>\n<td>接收两个long值，返回一个long结果</td>\n</tr>\n</tbody></table>\n<h3 id=\"三、Lambda表达式语法\"><a href=\"#三、Lambda表达式语法\" class=\"headerlink\" title=\"三、Lambda表达式语法\"></a>三、Lambda表达式语法</h3><p>Lambda表达式是用来给 <code>函数式接口</code> 的变量或形参赋值用的。</p>\n<p>其实本质上，Lambda表达式是用于实现【函数式接口】的“抽象方法”</p>\n<p>Lambda表达式语法格式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">(形参列表) -&gt; &#123;Lambda体&#125;</code></pre>\n\n<p>说明：</p>\n<ul>\n<li>(形参列表)它就是你要赋值的函数式接口的抽象方法的(形参列表)，照抄</li>\n<li>{Lambda体}就是实现这个抽象方法的方法体</li>\n<li>-&gt;称为Lambda操作符（减号和大于号中间不能有空格，而且必须是英文状态下半角输入方式）</li>\n</ul>\n<p>优化：Lambda表达式可以精简</p>\n<ul>\n<li>当{Lambda体}中只有一句语句时，可以省略{}和{;}</li>\n<li>当{Lambda体}中只有一句语句时，并且这个语句还是一个return语句，那么return也可以省略，但是如果{;}没有省略的话，return是不能省略的</li>\n<li>(形参列表)的类型可以省略</li>\n<li>当(形参列表)的形参个数只有一个，那么可以把数据类型和()一起省略，但是形参名不能省略</li>\n<li>当(形参列表)是空参时，()不能省略</li>\n</ul>\n<h3 id=\"四、方法引用与构造器引用\"><a href=\"#四、方法引用与构造器引用\" class=\"headerlink\" title=\"四、方法引用与构造器引用\"></a>四、方法引用与构造器引用</h3><p>Lambda表达式是可以简化函数式接口的变量与形参赋值的语法。而方法引用和构造器引用是为了简化Lambda表达式的。当Lambda表达式满足一些特殊的情况时，还可以再简化：</p>\n<p>（1）Lambda体只有一句语句，并且是通过调用一个对象的/类现有的方法来完成的</p>\n<p>例如：System.out对象，调用println()方法来完成Lambda体；Math类，调用random()静态方法来完成Lambda体</p>\n<p>（2）并且Lambda表达式的形参正好是给该方法的实参</p>\n<p>例如：t-&gt;System.out.println(t)； () -&gt; Math.random() 都是无参</p>\n<h4 id=\"1、方法引用\"><a href=\"#1、方法引用\" class=\"headerlink\" title=\"1、方法引用\"></a>1、方法引用</h4><p>方法引用的语法格式：</p>\n<p>（1）实例对象名::实例方法        </p>\n<p>（2）类名::静态方法</p>\n<p>（3）类名::实例方法</p>\n<p>说明：</p>\n<ul>\n<li>::  称为方法引用操作符（两个 : 中间不能有空格，而且必须英文状态下半角输入）</li>\n<li>Lambda表达式的形参列表，全部在Lambda体中使用上了，要么是作为调用方法的对象，要么是作为方法的实参。</li>\n<li>在整个Lambda体中没有额外的数据。</li>\n</ul>\n<h4 id=\"2、构造器引用\"><a href=\"#2、构造器引用\" class=\"headerlink\" title=\"2、构造器引用\"></a>2、构造器引用</h4><p>（1）当Lambda表达式是创建一个对象，并且满足Lambda表达式形参，正好是给创建这个对象的构造器的实参列表。</p>\n<p>（2）  当Lambda表达式是创建一个数组对象，并且满足Lambda表达式形参，正好是给创建这个数组对象的长度</p>\n<p>构造器引用的语法格式：</p>\n<ul>\n<li>类名::new</li>\n<li>数组类型名::new</li>\n</ul>\n<h3 id=\"五、StreamAPI\"><a href=\"#五、StreamAPI\" class=\"headerlink\" title=\"五、StreamAPI\"></a>五、StreamAPI</h3><p>Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 Stream API。</p>\n<p>Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p>\n<p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p>\n<p>Stream是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。“集合讲的是数据，负责存储数据，Stream流讲的是计算，负责处理数据！”</p>\n<h4 id=\"1、注意\"><a href=\"#1、注意\" class=\"headerlink\" title=\"1、注意\"></a>1、注意</h4><p>①Stream 自己不会存储元素。</p>\n<p>②Stream 不会改变源对象。每次处理都会返回一个持有结果的新Stream。</p>\n<p>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</p>\n<h4 id=\"2、Stream-的操作三个步骤\"><a href=\"#2、Stream-的操作三个步骤\" class=\"headerlink\" title=\"2、Stream 的操作三个步骤\"></a>2、Stream 的操作三个步骤</h4><p>1- 创建 Stream：通过一个数据源（如：集合、数组），获取一个流</p>\n<p>2- 中间操作：中间操作是个操作链，对数据源的数据进行n次处理，但是在终结操作前，并不会真正执行。</p>\n<p>3- 终止操作：一旦执行终止操作，就执行中间操作链，最终产生结果并结束Stream。</p>\n<p><img src=\"https://gitee.com/xiuxiuai/picture/raw/master/img/StreamAPI.png\" alt=\"1560769396655\"></p>\n<h4 id=\"3、创建Stream\"><a href=\"#3、创建Stream\" class=\"headerlink\" title=\"3、创建Stream\"></a>3、创建Stream</h4><h5 id=\"1、创建-Stream方式一：通过集合\"><a href=\"#1、创建-Stream方式一：通过集合\" class=\"headerlink\" title=\"1、创建 Stream方式一：通过集合\"></a>1、创建 Stream方式一：通过集合</h5><p>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：</p>\n<ul>\n<li><p>public default Stream<E> stream() : 返回一个顺序流</p>\n</li>\n<li><p>public default Stream<E> parallelStream() : 返回一个并行流</p>\n</li>\n</ul>\n<h5 id=\"2、创建-Stream方式二：通过数组\"><a href=\"#2、创建-Stream方式二：通过数组\" class=\"headerlink\" title=\"2、创建 Stream方式二：通过数组\"></a>2、创建 Stream方式二：通过数组</h5><p>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：</p>\n<ul>\n<li>public static <T> Stream<T> stream(T[] array): 返回一个流</li>\n</ul>\n<p>重载形式，能够处理对应基本类型的数组：</p>\n<ul>\n<li>public static IntStream stream(int[] array)：返回一个整型数据流</li>\n<li>public static LongStream stream(long[] array)：返回一个长整型数据流</li>\n<li>public static DoubleStream stream(double[] array)：返回一个浮点型数据流</li>\n</ul>\n<h5 id=\"3、创建-Stream方式三：通过Stream的of\"><a href=\"#3、创建-Stream方式三：通过Stream的of\" class=\"headerlink\" title=\"3、创建 Stream方式三：通过Stream的of()\"></a>3、创建 Stream方式三：通过Stream的of()</h5><p>可以调用Stream类静态方法 of(), 通过显示值创建一个流。它可以接收任意数量的参数。</p>\n<ul>\n<li>public static<T> Stream<T> of(T… values) : 返回一个顺序流</li>\n</ul>\n<h5 id=\"4、创建-Stream方式四：创建无限流\"><a href=\"#4、创建-Stream方式四：创建无限流\" class=\"headerlink\" title=\"4、创建 Stream方式四：创建无限流\"></a>4、创建 Stream方式四：创建无限流</h5><p>可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。</p>\n<ul>\n<li>public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f):返回一个无限流</li>\n<li>public static<T> Stream<T> generate(Supplier<T> s) ：返回一个无限流</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.test06;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.junit.Test;\n\npublic class Test07StreamCreate &#123;\n\t@Test\n\tpublic void test06()&#123;\n\t\t&#x2F;*\n\t\t * Stream&lt;T&gt; iterate(T seed, UnaryOperator&lt;T&gt; f)  \n\t\t * UnaryOperator接口，SAM接口，抽象方法：\n\t\t * \n\t\t * UnaryOperator&lt;T&gt; extends Function&lt;T,T&gt;\n\t\t * \t\tT apply(T t)\n\t\t *&#x2F;\n\t\tStream&lt;Integer&gt; stream &#x3D; Stream.iterate(1, num -&gt; num+&#x3D;2);\n&#x2F;&#x2F;\t\tstream &#x3D; stream.limit(10);\n\t\tstream.forEach(System.out::println);\n\t&#125;\n\t\n\t@Test\n\tpublic void test05()&#123;\n\t\tStream&lt;Double&gt; stream &#x3D; Stream.generate(Math::random);\n\t\tstream.forEach(System.out::println);\n\t&#125;\n\t\n\t@Test\n\tpublic void test04()&#123;\n\t\tStream&lt;Integer&gt; stream &#x3D; Stream.of(1,2,3,4,5);\n\t\tstream.forEach(System.out::println);\n\t&#125;\n\t\n\t@Test\n\tpublic void test03()&#123;\n\t\tString[] arr &#x3D; &#123;&quot;hello&quot;,&quot;world&quot;&#125;;\n\t\tStream&lt;String&gt; stream &#x3D; Arrays.stream(arr);\n\t&#125;\n\t\n\t@Test\n\tpublic void test02()&#123;\n\t\tint[] arr &#x3D; &#123;1,2,3,4,5&#125;;\n\t\tIntStream stream &#x3D; Arrays.stream(arr);\n\t&#125;\n\t\n\t@Test\n\tpublic void test01()&#123;\n\t\tList&lt;Integer&gt; list &#x3D; Arrays.asList(1,2,3,4,5);\n\t\t\n\t\t&#x2F;&#x2F;JDK1.8中，Collection系列集合增加了方法\n\t\tStream&lt;Integer&gt; stream &#x3D; list.stream();\n\t&#125;\n&#125;</code></pre>\n\n<h4 id=\"4、中间操作\"><a href=\"#4、中间操作\" class=\"headerlink\" title=\"4、中间操作\"></a>4、中间操作</h4><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。</p>\n<table>\n<thead>\n<tr>\n<th><strong>方  法</strong></th>\n<th><strong>描  述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>filter(Predicate p)</strong></td>\n<td>接收 Lambda ， 从流中排除某些元素</td>\n</tr>\n<tr>\n<td><strong>distinct()</strong></td>\n<td>筛选，通过流所生成元素的equals() 去除重复元素</td>\n</tr>\n<tr>\n<td><strong>limit(long maxSize)</strong></td>\n<td>截断流，使其元素不超过给定数量</td>\n</tr>\n<tr>\n<td><strong>skip(long n)</strong></td>\n<td>跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</td>\n</tr>\n<tr>\n<td><strong>peek(Consumer</strong> <strong>action)</strong></td>\n<td>接收Lambda，对流中的每个数据执行Lambda体操作</td>\n</tr>\n<tr>\n<td><strong>sorted()</strong></td>\n<td>产生一个新流，其中按自然顺序排序</td>\n</tr>\n<tr>\n<td><strong>sorted(Comparator com)</strong></td>\n<td>产生一个新流，其中按比较器顺序排序</td>\n</tr>\n<tr>\n<td><strong>map(Function f)</strong></td>\n<td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</td>\n</tr>\n<tr>\n<td><strong>mapToDouble(ToDoubleFunction f)</strong></td>\n<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。</td>\n</tr>\n<tr>\n<td><strong>mapToInt(ToIntFunction f)</strong></td>\n<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。</td>\n</tr>\n<tr>\n<td><strong>mapToLong(ToLongFunction f)</strong></td>\n<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。</td>\n</tr>\n<tr>\n<td><strong>flatMap(Function f)</strong></td>\n<td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td>\n</tr>\n</tbody></table>\n<h4 id=\"5、终结操作\"><a href=\"#5、终结操作\" class=\"headerlink\" title=\"5、终结操作\"></a>5、终结操作</h4><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void。流进行了终止操作后，不能再次使用。</p>\n<table>\n<thead>\n<tr>\n<th><strong>方法</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>boolean</strong> <strong>allMatch(Predicate p)</strong></td>\n<td>检查是否匹配所有元素</td>\n</tr>\n<tr>\n<td><strong>boolean</strong> <strong>anyMatch</strong>(<strong>Predicate p</strong>)</td>\n<td>检查是否至少匹配一个元素</td>\n</tr>\n<tr>\n<td><strong>boolean</strong> <strong>noneMatch(Predicate  p)</strong></td>\n<td>检查是否没有匹配所有元素</td>\n</tr>\n<tr>\n<td><strong>Optional<T></strong> <strong>findFirst()</strong></td>\n<td>返回第一个元素</td>\n</tr>\n<tr>\n<td><strong>Optional<T></strong> <strong>findAny()</strong></td>\n<td>返回当前流中的任意元素</td>\n</tr>\n<tr>\n<td><strong>long</strong> <strong>count()</strong></td>\n<td>返回流中元素总数</td>\n</tr>\n<tr>\n<td><strong>Optional<T></strong> <strong>max(Comparator c)</strong></td>\n<td>返回流中最大值</td>\n</tr>\n<tr>\n<td><strong>Optional<T></strong> <strong>min(Comparator c)</strong></td>\n<td>返回流中最小值</td>\n</tr>\n<tr>\n<td><strong>void</strong> <strong>forEach(Consumer c)</strong></td>\n<td>迭代</td>\n</tr>\n<tr>\n<td><strong>T</strong> <strong>reduce(T iden, BinaryOperator b)</strong></td>\n<td>可以将流中元素反复结合起来，得到一个值。返回 T</td>\n</tr>\n<tr>\n<td><strong>U</strong> <strong>reduce(BinaryOperator b)</strong></td>\n<td>可以将流中元素反复结合起来，得到一个值。返回 Optional<T></td>\n</tr>\n<tr>\n<td><strong>R</strong> <strong>collect(Collector c)</strong></td>\n<td>将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法</td>\n</tr>\n</tbody></table>\n<p>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例。</p>\n","text":"一、函数式编程思想在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。编程中的函数，也有类似的概念，你调用我的时候，给我实参为形参赋值，然后通过运行方法体，给你返回一个结果。对于调用者来做，关注这个方法具备什么样的功能。相对而言，面向对象过分强调“必...","link":"","photos":[],"count_time":{"symbolsCount":"9.6k","symbolsTime":"9 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/tags/JavaSE.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">一、函数式编程思想</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">二、函数式接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">1、自定义函数式接口</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%B6%88%E8%B4%B9%E5%9E%8B%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">2、消费型接口</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E4%BE%9B%E7%BB%99%E5%9E%8B%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">3、供给型接口</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E5%88%A4%E6%96%AD%E5%9E%8B%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">4、判断型接口</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%E3%80%81%E5%8A%9F%E8%83%BD%E5%9E%8B%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">5、功能型接口</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">三、Lambda表达式语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">四、方法引用与构造器引用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">1、方法引用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">2、构造器引用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81StreamAPI\"><span class=\"toc-text\">五、StreamAPI</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%B3%A8%E6%84%8F\"><span class=\"toc-text\">1、注意</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81Stream-%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">2、Stream 的操作三个步骤</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%88%9B%E5%BB%BAStream\"><span class=\"toc-text\">3、创建Stream</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%88%9B%E5%BB%BA-Stream%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E9%80%9A%E8%BF%87%E9%9B%86%E5%90%88\"><span class=\"toc-text\">1、创建 Stream方式一：通过集合</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%88%9B%E5%BB%BA-Stream%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E9%80%9A%E8%BF%87%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">2、创建 Stream方式二：通过数组</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%88%9B%E5%BB%BA-Stream%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E9%80%9A%E8%BF%87Stream%E7%9A%84of\"><span class=\"toc-text\">3、创建 Stream方式三：通过Stream的of()</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4%E3%80%81%E5%88%9B%E5%BB%BA-Stream%E6%96%B9%E5%BC%8F%E5%9B%9B%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%97%A0%E9%99%90%E6%B5%81\"><span class=\"toc-text\">4、创建 Stream方式四：创建无限流</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">4、中间操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%E3%80%81%E7%BB%88%E7%BB%93%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">5、终结操作</span></a></li></ol></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"反射","uid":"89dcc30b71db0004bd54ff025b96bee1","slug":"18-反射","date":"2021-09-13T14:53:32.000Z","updated":"2021-09-15T10:17:53.511Z","comments":true,"path":"api/articles/18-反射.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"一、类加载– 概述：类在内存中的生命周期：加载–&gt;使用–&gt;卸载 1、类的加载过程当程序主动使用某个类时，如果该类还未被加载到内存中，系统会通过加载、连接、初始化三个步骤来对该类进行初始化，如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载。...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/tags/JavaSE.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"网络编程","uid":"b85a5ed5aa29024c7191b1325f9b4bb8","slug":"16-网络编程","date":"2021-09-13T14:51:32.000Z","updated":"2021-09-15T10:16:58.700Z","comments":true,"path":"api/articles/16-网络编程.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"一、实现通信需解决的两个问题 1.如何准确地定位网络上一台或多台主机；定位主机上的特定的应用 2.找到主机后如何可靠高效地进行数据传输 二、网络通信的两个要素 对应问题一：IP和端口号 对应问题二：提供网络通信协议：TCP/IP参考模型（应用层、传输层、网络层、物理+数据链路层）...","link":"","photos":[],"count_time":{"symbolsCount":"8.5k","symbolsTime":"8 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/tags/JavaSE.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}