{"title":"listener，filter，cookie，session","uid":"5e2a4e0d14846d085ea5bb260a2f8b57","slug":"37-listener filter cookie session","date":"2021-09-13T15:13:32.000Z","updated":"2021-09-15T10:28:17.089Z","comments":true,"path":"api/articles/37-listener filter cookie session.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","content":"<h3 id=\"1-Listener监听器\"><a href=\"#1-Listener监听器\" class=\"headerlink\" title=\"1. Listener监听器\"></a>1. Listener监听器</h3><h4 id=\"1-1-Listener是什么？\"><a href=\"#1-1-Listener是什么？\" class=\"headerlink\" title=\"1.1 Listener是什么？\"></a>1.1 Listener是什么？</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">* Listener 监听器是 JavaWeb 的三大组件之一。\n* JavaWeb 的三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监 听器。\n\n* Listener 它是 JavaEE 的规范，就是接口 \n\n* 监听器的作用是，监听某种事物的变化。然后通过回调函数，反馈给客户（程序）去做一些相应的处理。\n\n* 有八个Listener监听器，但是随着技术的发展，现在就ServletContextListener 监听器还经常被使用</code></pre>\n\n<h4 id=\"1-2-ServletContextListener\"><a href=\"#1-2-ServletContextListener\" class=\"headerlink\" title=\"1.2 ServletContextListener\"></a>1.2 ServletContextListener</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">* ServletContextListener 它可以监听 ServletContext 对象的创建和销毁。 \n\n* ServletContext 对象在 web 工程启动的时候创建，在 web 工程停止的时候销毁。\n\n&#x3D;&#x3D; 监听到创建和销毁之后都会分别调用 ServletContextListener 监听器的方法反馈 &#x3D;&#x3D;</code></pre>\n\n<p> <strong>两个方法分别是</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface ServletContextListener extends EventListener &#123;\n&#x2F;**\n* 在 ServletContext 对象创建之后马上调用，做初始化\n*&#x2F;\npublic void contextInitialized(ServletContextEvent sce);\n&#x2F;**\n* 在 ServletContext 对象销毁之后调用\n*&#x2F;\npublic void contextDestroyed(ServletContextEvent sce);\n&#125;</code></pre>\n\n<p><strong>使用 ServletContextListener 监听器监听 ServletContext 对象</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">使用步骤如下： \n1. 编写一个类去实现 ServletContextListener \n2. 实现其两个回调方法 \n3. 到 web.xml 中去配置监听器</code></pre>\n\n<p><strong>监听器实现类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyServletContextListenerImpl implements ServletContextListener &#123;\n\t@Override\n\tpublic void contextInitialized(ServletContextEvent sce) &#123;\n\t\tSystem.out.println(&quot;ServletContext 对象被创建了&quot;);\n\t&#125;\n\t@Override\n\tpublic void contextDestroyed(ServletContextEvent sce) &#123;\n\t\tSystem.out.println(&quot;ServletContext 对象被销毁了&quot;);\n\t&#125;\n&#125;</code></pre>\n\n<p><strong>web.xml的配置</strong></p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!--配置监听器--&gt;\n&lt;listener&gt;\n&lt;listener-class&gt;com.atguigu.listener.MyServletContextListenerImpl&lt;&#x2F;listener-class&gt;\n&lt;&#x2F;listener&gt;</code></pre>\n\n\n<h3 id=\"2-Filter过滤器\"><a href=\"#2-Filter过滤器\" class=\"headerlink\" title=\"2. Filter过滤器\"></a>2. Filter过滤器</h3><h4 id=\"2-1-Filter-是什么？\"><a href=\"#2-1-Filter-是什么？\" class=\"headerlink\" title=\"2.1 Filter 是什么？\"></a>2.1 Filter 是什么？</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">1、Filter 过滤器它是 JavaWeb 的三大组件之一。三大组件分别是：servlet程序，listener监听器，Filter过滤器\n\n2、Filter 过滤器它是 JavaEE 的规范。也就是 接口\n\n3、Filter 过滤器它的作用是：&#x3D;&#x3D; 拦截请求，过滤响应 &#x3D;&#x3D;\n\n​  拦截请求常见的应用场景有： &#x3D;&#x3D; 1、权限检查 2、日记操作 3、事务管理 ……等等 &#x3D;&#x3D;</code></pre>\n\n<h4 id=\"2-2-Filter-初体验\"><a href=\"#2-2-Filter-初体验\" class=\"headerlink\" title=\"2.2 Filter 初体验\"></a>2.2 Filter 初体验</h4><h5 id=\"2-2-1-示例\"><a href=\"#2-2-1-示例\" class=\"headerlink\" title=\"2.2.1 示例\"></a>2.2.1 示例</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">\t\t要求：在你的 web 工程下，有一个 admin 目录。这个 admin 目录下的所有资源（html 页面、jpg 图片jsp 文件、等等）都必须是用户登录之后才允许访问。\n\n​\t\t思考：根据之前我们学过内容。我们知道，用户登录之后都会把用户登录的信息保存到 Session 域中。所以要检查用户是否登录，可以判断 Session 中否包含有用户登录的信息即可！！！</code></pre>\n\n<h5 id=\"2-2-2-工作流程图\"><a href=\"#2-2-2-工作流程图\" class=\"headerlink\" title=\"2.2.2 工作流程图\"></a>2.2.2 工作流程图</h5><p><img src=\"F:\\Picture\\博客图片\\filter工作流程图.PNG\" alt=\"filter工作流程图\"></p>\n<h5 id=\"2-2-3-使用步骤\"><a href=\"#2-2-3-使用步骤\" class=\"headerlink\" title=\"2.2.3 使用步骤\"></a>2.2.3 使用步骤</h5><p><strong>编写一个类去实现 Filter 接口</strong>      <strong>实现过滤方法 doFilter()</strong>      <strong>到 web.xml 中去配置 Filter 的拦截路径</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@WebFilter(filterName &#x3D; &quot;Filter1&quot;,urlPatterns &#x3D; &quot;&#x2F;a.jsp&quot;)\npublic class Filter1 implements Filter &#123;\n    public void destroy() &#123;\n    &#125;\n\n    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;\n        System.out.println(&quot;filter1前置&quot;);\n        chain.doFilter(req, resp);\n        System.out.println(&quot;filter1后置&quot;);\n\n    &#125;\n\n    public void init(FilterConfig config) throws ServletException &#123;\n\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"2-3-Filter-生命周期\"><a href=\"#2-3-Filter-生命周期\" class=\"headerlink\" title=\"2.3 Filter 生命周期\"></a>2.3 Filter 生命周期</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">Filter 的生命周期包含几个方法 \n 1. 构造器方法\t\n 2. init 初始化方法        第 1，2 步，在 web 工程启动的时候执行（Filter 已经创建） \n 3. doFilter 过滤方法      第 3 步，每次拦截到请求，就会执行 \n 4. destroy 销毁          第 4 步，停止 web 工程的时候，就会执行（停止 web 工程，也会销毁 Filter 过滤器）</code></pre>\n\n<h4 id=\"2-5-FilterConfig-类\"><a href=\"#2-5-FilterConfig-类\" class=\"headerlink\" title=\"2.5 FilterConfig 类\"></a>2.5 FilterConfig 类</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">* FilterConfig 类见名知义，它是 Filter 过滤器的配置文件类。 \n* Tomcat 每次创建 Filter 的时候，也会同时创建一个 FilterConfig 类，这里包含了 Filter 配置文件的配置信息。 \n* FilterConfig 类的作用是获取 filter 过滤器的配置内容 \n  1. 获取 Filter 的名称 filter-name 的内容 \n  2. 获取在 Filter 中配置的 init-param 初始化参数 \n  3. 获取 ServletContext 对象</code></pre>\n\n<h4 id=\"2-6-FilterChain-过滤器链\"><a href=\"#2-6-FilterChain-过滤器链\" class=\"headerlink\" title=\"2.6 FilterChain 过滤器链\"></a>2.6 FilterChain 过滤器链</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">* Filter 过滤器 \n* Chain 链\n* 链条 FilterChain 就是过滤器链（多个过滤器如何一起工作）</code></pre>\n\n<p><strong>工作流程图</strong></p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/filterChain%E8%BF%87%E6%BB%A4%E9%93%BE.png\" alt=\"image-20200720214251480\"></p>\n<h4 id=\"2-7-Filter-的拦截路径\"><a href=\"#2-7-Filter-的拦截路径\" class=\"headerlink\" title=\"2.7 Filter 的拦截路径\"></a>2.7 Filter 的拦截路径</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\"> 精确匹配 \n\n  &lt;url-pattern&gt; &#x2F;target.jsp  &lt;&#x2F;url-pattern&gt;\n\n  以上配置的路径，表示请求地址必须为：http:&#x2F;&#x2F;ip:port&#x2F;工程路径&#x2F;target.jsp \n\n​ 目录匹配 \n\n  &lt;url-pattern&gt; &#x2F;admin&#x2F;* &lt;&#x2F;url-pattern&gt;\n\n  以上配置的路径，表示请求地址必须为：http:&#x2F;&#x2F;ip:port&#x2F;工程路径&#x2F;admin&#x2F;* \n\n​ 后缀名匹配 \n\n  &lt;url-pattern&gt;*.html &lt;&#x2F;url-pattern&gt;\n\n  以上配置的路径，表示请求地址必须以.html 结尾才会拦截到     \n\n  &lt;url-pattern&gt;*.do &lt;&#x2F;url-pattern&gt;\n\n  以上配置的路径，表示请求地址必须以.do 结尾才会拦截到      \n\n  &lt;url-pattern&gt;*.action &lt;&#x2F;url-pattern&gt;\n\n  以上配置的路径，表示请求地址必须以.action 结尾才会拦截到 \n\n\n​ Filter 过滤器它只关心请求的地址是否匹配，不关心请求的资源是否存在！！！</code></pre>\n\n<h3 id=\"3-cookie\"><a href=\"#3-cookie\" class=\"headerlink\" title=\"3. cookie\"></a>3. cookie</h3><h4 id=\"3-1-什么是cookie？\"><a href=\"#3-1-什么是cookie？\" class=\"headerlink\" title=\"3.1 什么是cookie？\"></a>3.1 什么是cookie？</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\"> 1、Cookie 翻译过来是饼干的意思。\n\n​ 2、Cookie 是服务器&lt;kbd&gt;通知客户端保存键值对&lt;&#x2F;kbd&gt;的一种技术。 \n\n​ 3、创建一个 cookie，cookie 是 servlet 发送到 Web 浏览器的少量信息，这些信息由浏览器保存，然后发送回服务器\n\n​ 4、客户端有了 Cookie 后，&lt;kbd&gt;每次请求都发送给服务器&lt;&#x2F;kbd&gt;。 \n\n​ 5、每个 Cookie 的大小不能超过 4kb\n\n​ 6、cookie  的值&lt;kbd&gt;可以唯一地标识客户端&lt;&#x2F;kbd&gt;，因此 cookie 常用于会话管理</code></pre>\n\n<h4 id=\"3-2-如何创建cookie？\"><a href=\"#3-2-如何创建cookie？\" class=\"headerlink\" title=\"3.2 如何创建cookie？\"></a>3.2 如何创建cookie？</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\"> 1. 通过new的方式，创建cookie对象\n\n\t Cookie cookie &#x3D; new Cookie(&quot;hh1&quot;,&quot;ww1&quot;);\n\n\t 服务器创建cookie对象后，一定要使用&lt;kbd&gt;response.addCookie()&lt;&#x2F;kbd&gt; ，通知客户端保存cookie（通过响应头的方式）\n\n\t response.addCookie(cookie);\n\n​ 2、也可以创建多个cookie对象，再依次添加多个cookie对象</code></pre>\n\n<h4 id=\"3-3-服务器如何获取cookie\"><a href=\"#3-3-服务器如何获取cookie\" class=\"headerlink\" title=\"3.3 服务器如何获取cookie\"></a>3.3 服务器如何获取cookie</h4><p><strong>getCookies()，返回的是所有cookie的map集合</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Cookie[] cookies &#x3D; request.getCookies();\nfor (Cookie cookie : cookies) &#123;\n     response.getWriter().write(cookie.getName()+&quot;&#x3D;&quot;+cookie.getValue()+&quot;&lt;br&gt;&quot;);\n&#125;</code></pre>\n\n<p><strong>获取单个cookie</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;获取相应的cookie对象，需要先得到所有cookie的集合（因为cookie没有单独获取一个cookie的方法），然后遍历cookie集合，\n&#x2F;&#x2F;在遍历的时候判断是否有与已知key值相等的cookie，如果有，则进行输出\nCookie cookie &#x3D; CookieUtil.findCookie(&quot;hh&quot;, cookies);\n  if (cookie!&#x3D;null)&#123;\n        response.getWriter().write(cookie.getName()+&quot;&#x3D;&quot;+cookie.getValue());\n  &#125;\n\n\npublic static Cookie findCookie(String name,Cookie[] cookies)&#123;\n     if (name&#x3D;&#x3D;null || cookies&#x3D;&#x3D;null || cookies.length&#x3D;&#x3D;0)&#123;\n         return null;\n     &#125;\n\n     for (Cookie cookie : cookies)&#123;\n            if (name.equals(cookie.getName()))&#123;\n                return cookie;\n         &#125;\n     &#125;\n     return null;\n&#125;</code></pre>\n\n<h4 id=\"3-4-修改cookie值\"><a href=\"#3-4-修改cookie值\" class=\"headerlink\" title=\"3.4 修改cookie值\"></a>3.4 修改cookie值</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\"> 方案一： \n\n\t  1、先创建一个要修改的同名（指的就是 key）的 Cookie 对象 \n\n\t  2、在构造器，同时赋于新的 Cookie 值。 \n\n\t  3、调用 response.addCookie( Cookie );\n\n​ 方案二： \n\n\t  1、先查找到需要修改的 Cookie 对象 \n\n\t  2、调用 setValue()方法赋于新的 Cookie 值。 \n\n\t  3、调用 response.addCookie()通知客户端保存修改</code></pre>\n\n<h4 id=\"3-5-cookie的生命控制\"><a href=\"#3-5-cookie的生命控制\" class=\"headerlink\" title=\"3.5 cookie的生命控制\"></a>3.5 cookie的生命控制</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\"> Cookie 的生命控制指的是如何管理 Cookie ​ 什么时候被销毁（删除）\n\n​ setMaxAge(int expiry)  expiry(到期，满期)为到期时间，1代表一秒\n\n\t  &#x3D;&#x3D;正数&#x3D;&#x3D;，表示在指定的秒数后过期 \n\n\t  &#x3D;&#x3D;负数&#x3D;&#x3D;，表示浏览器一关，Cookie 就会被删除（默认值是-1） \n\n\t  &#x3D;&#x3D;零&#x3D;&#x3D;，表示马上删除 Cookie</code></pre>\n\n<h4 id=\"3-6-cookie有效路径-path-设置\"><a href=\"#3-6-cookie有效路径-path-设置\" class=\"headerlink\" title=\"3.6 cookie有效路径 path 设置\"></a>3.6 cookie有效路径 path 设置</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\"> 1、Cookie 的 path 属性可以有效的过滤哪些 Cookie 可以发送给服务器，哪些不发。 \n\n​ 2、cookie的 path设置方法\t&lt;kbd&gt;cookie.setPath( url );&lt;&#x2F;kbd&gt; 设置完路径一定要调用addcookie() 方法\n\n​ 3、path 属性是&lt;kbd&gt;通过请求的地址&lt;&#x2F;kbd&gt;来进行有效的过滤。例子如下：\n\n\t  CookieA path&#x3D;&#x2F;工程路径 \tCookieB path&#x3D;&#x2F;工程路径&#x2F;abc \n\n\t  请求地址如下:  http:&#x2F;&#x2F;ip:port&#x2F;工程路径&#x2F;a.html \t\t\tCookieA 发送 \tCookieB 不发送 \n\n                   http:&#x2F;&#x2F;ip:port&#x2F;工程路径&#x2F;abc&#x2F;a.html \t CookieA 发送 \tCookieB 发送</code></pre>\n\n<h3 id=\"4-session\"><a href=\"#4-session\" class=\"headerlink\" title=\"4. session\"></a>4. session</h3><h4 id=\"4-1-session是什么？\"><a href=\"#4-1-session是什么？\" class=\"headerlink\" title=\"4.1 session是什么？\"></a>4.1 session是什么？</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\"> 1、Session 就一个接口（HttpSession）\n\n​ 2、Session 就是会话。它是用来维护一个客户端和服务器之间关联的一种技术\n\n​ 3、每个客户端都有自己的一个 Session 会话\n\n​ 4、Session 会话中，我们经常用来保存 用户登录之后的信息</code></pre>\n\n<h4 id=\"4-2-创建-获取-ID值\"><a href=\"#4-2-创建-获取-ID值\" class=\"headerlink\" title=\"4.2 创建 获取 ID值\"></a>4.2 创建 获取 ID值</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\"> 如何创建和获取 Session。它们的 API 是一样的。 \n\n​ request.getSession()  第一次调用是：创建 Session 会话 \t之后调用都是：获取前面创建好的 Session 会话对象\n\n​ isNew(); 判断到底是不是刚创建出来的（新的） true 表示刚创建     false 表示获取之前创建 \n\n​ 每个会话都有一个身份证号。也就是 ID 值。而且这个 ID 唯一   getId() 得到 Session 的会话 id 值。</code></pre>\n\n<h4 id=\"4-3-Session-生命周期控制\"><a href=\"#4-3-Session-生命周期控制\" class=\"headerlink\" title=\"4.3 Session 生命周期控制\"></a>4.3 Session 生命周期控制</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">  1、public void setMaxInactiveInterval(int interval) \t\n  [ 最大非活动时间间隔 ] 设置 Session 的超时时间（以秒为单位），超过,Session 就会被销毁。 \n  值为正数的时候，设定 Session的超时时长。 负数表示永不超时（极少使用） \n  \n​  2、public int getMaxInactiveInterval()\t获取 Session 的超时时间\n\n​  3、public void invalidate() \t让当前 Session 会话马上超时无效。 \n\n​  4、Session 默认的超时时间长为 30 分钟。 \n   因为 Tomcat 服务器的配置文件 web.xml中默认配置，表示配置了当前 Tomcat 下所有的 Session 超时配置默认时长为 30 分钟。</code></pre>\n\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">如果说。你希望你的 web 工程，默认的 Session 的超时时长为其他时长。\n你可以在你自己的 web.xml 配置文件中做以上相同的配置。就可以修改你的 web 工程所有 Seession 的默认超时时长。\n\n&lt;!--表示当前 web 工程。创建出来 的所有 Session 默认是 20 分钟 超时时长--&gt;\n&lt;session-config&gt;\n&lt;session-timeout&gt;20&lt;&#x2F;session-timeout&gt;\n&lt;&#x2F;session-config&gt;\n</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\t  5、如果你想只修改\t个别 Session 的超时时长。就可以使用上面的 API，setMaxInactiveInterval(int interval)来进行单独的设置\n\n​\t  6、Session 超时的概念介绍：session设置的超时时长，指的是 两次非活动时间间隔，例子如下\n\n\t     新建一个按钮，用来得到Session会话对象，设置3秒超时，如果在3秒内不断点击得到按钮，则session对象并不会超时；\n\t     但是，间隔3秒 不按按钮的话，session对象就会被销毁</code></pre>\n\n<h4 id=\"4-4-session-浏览器间关联的技术内幕\"><a href=\"#4-4-session-浏览器间关联的技术内幕\" class=\"headerlink\" title=\"4.4 session 浏览器间关联的技术内幕\"></a>4.4 session 浏览器间关联的技术内幕</h4><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/session%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8.png\" alt=\"image-20200715151530572\"></p>\n<h3 id=\"5-表单重复提交的三种情况\"><a href=\"#5-表单重复提交的三种情况\" class=\"headerlink\" title=\"5. 表单重复提交的三种情况\"></a>5. 表单重复提交的三种情况</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">一：提交完表单。服务器使用请求转发进行页面跳转。这个时候，用户按下功能键 F5，就会发起最后一次的请求。 造成表单重复提交问题。\n   （解决方法：使用重定向来进行跳转）\n   \n二：用户正常提交服务器，但是由于网络延迟等原因，迟迟未收到服务器的响应，这个时候，用户以为提交失败， 就会着急，然后多点了几次提交操作，也会造成表单重复提交。（解决方法，验证码）\n\n三：用户正常提交服务器。服务器也没有延迟，但是提交完成后，用户回退浏览器。重新提交。也会造成表单重复 提交。（解决方法，验证码）</code></pre>\n\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/%E8%A7%A3%E5%86%B3%E8%A1%A8%E5%8D%95%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.PNG\" alt=\"解决表单重复提交的底层原理\"></p>\n","text":"1. Listener监听器1.1 Listener是什么？* Listener 监听器是 JavaWeb 的三大组件之一。 * JavaWeb 的三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监 听器。 * Listener 它是 JavaEE ...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/categories/JavaWeb.json"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/tags/JavaWeb.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Listener%E7%9B%91%E5%90%AC%E5%99%A8\"><span class=\"toc-text\">1. Listener监听器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-Listener%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">1.1 Listener是什么？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-ServletContextListener\"><span class=\"toc-text\">1.2 ServletContextListener</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Filter%E8%BF%87%E6%BB%A4%E5%99%A8\"><span class=\"toc-text\">2. Filter过滤器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-Filter-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">2.1 Filter 是什么？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-Filter-%E5%88%9D%E4%BD%93%E9%AA%8C\"><span class=\"toc-text\">2.2 Filter 初体验</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-1-%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">2.2.1 示例</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-2-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE\"><span class=\"toc-text\">2.2.2 工作流程图</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-3-%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">2.2.3 使用步骤</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-Filter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">2.3 Filter 生命周期</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-5-FilterConfig-%E7%B1%BB\"><span class=\"toc-text\">2.5 FilterConfig 类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-6-FilterChain-%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE\"><span class=\"toc-text\">2.6 FilterChain 过滤器链</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-7-Filter-%E7%9A%84%E6%8B%A6%E6%88%AA%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">2.7 Filter 的拦截路径</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-cookie\"><span class=\"toc-text\">3. cookie</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-%E4%BB%80%E4%B9%88%E6%98%AFcookie%EF%BC%9F\"><span class=\"toc-text\">3.1 什么是cookie？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAcookie%EF%BC%9F\"><span class=\"toc-text\">3.2 如何创建cookie？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-3-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96cookie\"><span class=\"toc-text\">3.3 服务器如何获取cookie</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-4-%E4%BF%AE%E6%94%B9cookie%E5%80%BC\"><span class=\"toc-text\">3.4 修改cookie值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-5-cookie%E7%9A%84%E7%94%9F%E5%91%BD%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">3.5 cookie的生命控制</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-6-cookie%E6%9C%89%E6%95%88%E8%B7%AF%E5%BE%84-path-%E8%AE%BE%E7%BD%AE\"><span class=\"toc-text\">3.6 cookie有效路径 path 设置</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-session\"><span class=\"toc-text\">4. session</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-1-session%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">4.1 session是什么？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-2-%E5%88%9B%E5%BB%BA-%E8%8E%B7%E5%8F%96-ID%E5%80%BC\"><span class=\"toc-text\">4.2 创建 获取 ID值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-3-Session-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">4.3 Session 生命周期控制</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-4-session-%E6%B5%8F%E8%A7%88%E5%99%A8%E9%97%B4%E5%85%B3%E8%81%94%E7%9A%84%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95\"><span class=\"toc-text\">4.4 session 浏览器间关联的技术内幕</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E8%A1%A8%E5%8D%95%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E7%9A%84%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5\"><span class=\"toc-text\">5. 表单重复提交的三种情况</span></a></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"Json Ajax","uid":"cf8cafd4cf1868b0ac65896e606a4625","slug":"38-Json Ajax","date":"2021-09-13T15:14:32.000Z","updated":"2021-09-15T10:28:40.121Z","comments":true,"path":"api/articles/38-Json Ajax.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":":beginner: ​Json① json 的定义1. json 是由键值对组成，并且由 花括号（大括号）包围。 2. 每个键由引号引起来，键和值之间使用 冒号进行分隔， 多组键值对之间进行 逗号进行分隔。 例子♥: &#123; &quot;name&quot;:&quot;...","link":"","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"23 mins."},"categories":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/categories/JavaWeb.json"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/tags/JavaWeb.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"Servlet（下）","uid":"5be9ff575c28645ffc905ea202238d73","slug":"36-Servlet（下）","date":"2021-09-13T15:12:32.000Z","updated":"2021-09-15T10:27:25.523Z","comments":true,"path":"api/articles/36-Servlet（下）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"1. HttpServletRequest类1.1 作用每次只要有请求进入 Tomcat 服务器，Tomcat 服务器就会把请求过来的 HTTP 协议信息**解析好封装**到 Request 对象中。 然后传递到 service 方法（doGet 和 doPost）中给我们使用。...","link":"","photos":[],"count_time":{"symbolsCount":"9.5k","symbolsTime":"9 mins."},"categories":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/categories/JavaWeb.json"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/tags/JavaWeb.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}