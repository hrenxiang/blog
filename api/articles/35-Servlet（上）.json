{"title":"Servlet（上）","uid":"e273b80f255b91b744fcbcd9e45a6bf0","slug":"35-Servlet（上）","date":"2021-09-13T15:11:32.000Z","updated":"2021-09-15T10:27:04.368Z","comments":true,"path":"api/articles/35-Servlet（上）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","content":"<h3 id=\"1-JavaEE概述\"><a href=\"#1-JavaEE概述\" class=\"headerlink\" title=\"1. JavaEE概述\"></a>1. JavaEE概述</h3><h4 id=\"1-1-什么是API？-包括什么？\"><a href=\"#1-1-什么是API？-包括什么？\" class=\"headerlink\" title=\"1.1 什么是API？ 包括什么？\"></a>1.1 什么是API？ 包括什么？</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">* API：应用程序编程接口（这里所描述的接口不是interface）\n\n* API包括：源码，字节码，帮助文档（使用的时候要注意版本一致）</code></pre>\n\n\n<h4 id=\"1-2-什么是JavaSE？\"><a href=\"#1-2-什么是JavaSE？\" class=\"headerlink\" title=\"1.2 什么是JavaSE？\"></a>1.2 什么是JavaSE？</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">* Java 标准版本\n* SUN公司为程序员提供的一套基础类库\n* 这套类库包括：基础语法，面向对象，异常，IO，集合，反射，线程......\n* JavaSE版本：目前JavaSE由Oracle维护，最高版本16</code></pre>\n\n<h4 id=\"1-3-什么是JavaEE？\"><a href=\"#1-3-什么是JavaEE？\" class=\"headerlink\" title=\"1.3 什么是JavaEE？\"></a>1.3 什么是JavaEE？</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">* Java 企业版\n* SUN 公司为程序员提供的另外一套庞大的类库，帮助程序员完成企业级项目开发\n* JavaEE规范是一个比较较大的规范，包含了13个子规范（子规范下还有其他子规范）</code></pre>\n\n<h3 id=\"2-Servlet简介\"><a href=\"#2-Servlet简介\" class=\"headerlink\" title=\"2. Servlet简介\"></a>2. Servlet简介</h3><h4 id=\"2-1-什么是servlet？\"><a href=\"#2-1-什么是servlet？\" class=\"headerlink\" title=\"2.1 什么是servlet？\"></a>2.1 什么是servlet？</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">* servlet 是JavaEE规范之一。 规范就是接口\n\n* servlet 是JavaWeb  &#x3D;&#x3D; 三大组件之一 &#x3D;&#x3D;，三大组件分别是：servlet程序，Fiiter过滤器，Listener监听器\n\n* servlet 是运行在服务器上的一个java小程序，他可以接收客户端发送的请求，并响应数据给客户端\n\n* 但servlet的实质就是java代码，通过java的API 动态的向客户端输出内容</code></pre>\n\n<h4 id=\"2-2-Servlet-API-生命周期\"><a href=\"#2-2-Servlet-API-生命周期\" class=\"headerlink\" title=\"2.2 Servlet API (生命周期)\"></a>2.2 Servlet API (生命周期)</h4><p><strong>Servlet 接口中的方法</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1. 执行 Servlet 构造器方法\n2. init(ServletConfig config)：  \n   * 何时执行：servlet对象创建的时候执行        \n   * ServletConfig ： 代表的是该servlet对象的配置信息\n3. service（ServletRequest request,ServletResponse response）\n\n   * 何时执行：每次请求都会执行\n   * ServletRequest ：代表请求 认为ServletRequest 内部封装的是 http请求的信息\n   * ServletResponse ：代表响应 认为要封装的是响应的信息\n4. destroy()\n\n   * 何时执行：servlet销毁的时候执行</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">* 第一、二步，是在第一次访问，的时候创建 Servlet 程序会调用\n* 第三步，每次访问都会调用。\n* 第四步，在 web 工程停止的时候调用。</code></pre>\n\n<h4 id=\"2-3-HttpServlet类的方法\"><a href=\"#2-3-HttpServlet类的方法\" class=\"headerlink\" title=\"2.3 HttpServlet类的方法\"></a>2.3 HttpServlet类的方法</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">* init()\n\n* doGet(HttpServletRequest request,HttpServletResponse response)\n\n* doPost(HttpServletRequest request,HttpServletResponse response)\n\n* destroy()</code></pre>\n\n<h3 id=\"3-创建Servlet的两种方式\"><a href=\"#3-创建Servlet的两种方式\" class=\"headerlink\" title=\"3. 创建Servlet的两种方式\"></a>3. 创建Servlet的两种方式</h3><h4 id=\"3-1-实现-Servlet-接口\"><a href=\"#3-1-实现-Servlet-接口\" class=\"headerlink\" title=\"3.1 实现 Servlet 接口\"></a>3.1 实现 Servlet 接口</h4><p><span style=\"color:red;\">【此方法不常用】</span>实现步骤：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1）创建类实现Servlet接口\n\n2）覆盖尚未实现的方法---service方法，处理请求并响应数据\n\n3）在web.xml进行servlet的配置（可以使用注解）</code></pre>\n\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/servlet%E5%AE%9E%E7%8E%B01.png\" alt=\"image-20210512193723480\"></p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/servlet%E9%85%8D%E7%BD%AE1.png\" alt=\"image-20210512193811238\"></p>\n<h4 id=\"3-2-创建类继承HttpServlet\"><a href=\"#3-2-创建类继承HttpServlet\" class=\"headerlink\" title=\"3.2 创建类继承HttpServlet\"></a>3.2 创建类继承HttpServlet</h4><p>实际开发中，我们不会直接去实现Servlet接口，因为需要覆盖的方法太多， 我们一般创建类继承HttpServlet</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">实现步骤：\n\n1）创建类继承HttpServlet类\n\n2）根据新需要覆盖doGet和doPost\n\n3）在web.xml中进行servlet的配置</code></pre>\n\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/servlet%E5%AE%9E%E7%8E%B02.png\" alt=\"image-20210512193919067\"></p>\n<h3 id=\"4-如何访问Servlet，路径配置\"><a href=\"#4-如何访问Servlet，路径配置\" class=\"headerlink\" title=\"4. 如何访问Servlet，路径配置\"></a>4. 如何访问Servlet，路径配置</h3><h4 id=\"4-1-url-地址到-Servlet的访问\"><a href=\"#4-1-url-地址到-Servlet的访问\" class=\"headerlink\" title=\"4.1 url 地址到 Servlet的访问\"></a>4.1 url 地址到 Servlet的访问</h4><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/url%E8%AE%BF%E9%97%AEservlet%E8%B7%AF%E5%BE%84.png\" alt=\"image-20200626095916775\"></p>\n<h4 id=\"4-2-Servlet的三种映射路径的配置\"><a href=\"#4-2-Servlet的三种映射路径的配置\" class=\"headerlink\" title=\"4.2 Servlet的三种映射路径的配置\"></a>4.2 Servlet的三种映射路径的配置</h4><h5 id=\"4-2-1-映射路径的作用\"><a href=\"#4-2-1-映射路径的作用\" class=\"headerlink\" title=\"4.2.1 映射路径的作用\"></a>4.2.1 映射路径的作用</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">Servlet的映射路径是提供一个让别人能够访问该Servlet的路径，例如Servlet的映射路径是&quot;&#x2F;hello&quot;,那么在浏览器上访问该Servlet的路径是&#96;http:&#x2F;&#x2F;localhost:8080&#x2F;项目部署名&#x2F;hello&#96;\n\n</code></pre>\n\n<p><strong>注意:一个Servlet可以配置多个映射路径，但是多个Servlet不能配置相同的映射路径</strong></p>\n<h5 id=\"4-2-2-映射路径的分类\"><a href=\"#4-2-2-映射路径的分类\" class=\"headerlink\" title=\"4.2.2 映射路径的分类\"></a>4.2.2 映射路径的分类</h5><h6 id=\"4-2-2-1-完全路径匹配\"><a href=\"#4-2-2-1-完全路径匹配\" class=\"headerlink\" title=\"4.2.2.1 完全路径匹配\"></a>4.2.2.1 完全路径匹配</h6><pre class=\"line-numbers language-none\"><code class=\"language-none\">访问当前Servlet的路径需要和配置的映射路径完全一致，例如Servlet的配置是&#96;&#x2F;demo01&#96;，那么访问该Servlet的时候的路径也必须是&#96;http:&#x2F;&#x2F;localhost:8080&#x2F;项目部署名&#x2F;demo01&#96;才可以访问到</code></pre>\n\n<h6 id=\"4-2-2-2-目录匹配\"><a href=\"#4-2-2-2-目录匹配\" class=\"headerlink\" title=\"4.2.2.2 目录匹配\"></a>4.2.2.2 目录匹配</h6><p>以 <code>/</code> 开始需要以 <code>*</code> 结束，<strong>注</strong>: Servlet里面用的不多, 但是过滤器里面通常就使用目录匹配</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">例如:  配置&#x2F;* 访问的路径可写成&#x2F;任意字符串,比方: &#x2F;aa, &#x2F;aaa; 配置 &#x2F;aa&#x2F;*  访问的路径可写成&#x2F;aa&#x2F;任意字符串,比方: &#x2F;aa&#x2F;b , &#x2F;aa&#x2F;cc</code></pre>\n\n<h6 id=\"4-2-2-3-扩展名匹配\"><a href=\"#4-2-2-3-扩展名匹配\" class=\"headerlink\" title=\"4.2.2.3 扩展名匹配\"></a>4.2.2.3 扩展名匹配</h6><p>以<code>*</code>开头，以<code>.扩展名</code>结束，能够匹配所有以<code>.相同扩展名</code>结尾的请求路径</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">例如:  *.action;  访问路径可以是 任意字符串.action,比方: aa.action, bb.action, c.action;</code></pre>\n\n<h3 id=\"5-GET-POST的分发处理-三种\"><a href=\"#5-GET-POST的分发处理-三种\" class=\"headerlink\" title=\"5. GET POST的分发处理(三种)\"></a>5. GET POST的分发处理(三种)</h3><h4 id=\"5-1-实现servlet接口处理\"><a href=\"#5-1-实现servlet接口处理\" class=\"headerlink\" title=\"5.1 实现servlet接口处理\"></a>5.1 实现servlet接口处理</h4><p><span style=\"color:red;\">【此方法不常用】</span></p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F1.png\" alt=\"image-20210512194206356\"></p>\n<h4 id=\"5-2-继承HttpServlet处理\"><a href=\"#5-2-继承HttpServlet处理\" class=\"headerlink\" title=\"5.2 继承HttpServlet处理\"></a>5.2 继承HttpServlet处理</h4><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%862.png\" alt=\"image-20210512194311006\"></p>\n<h3 id=\"6-Servlet-配置-继承体系\"><a href=\"#6-Servlet-配置-继承体系\" class=\"headerlink\" title=\"6. Servlet 配置 继承体系\"></a>6. Servlet 配置 继承体系</h3><h4 id=\"6-1-一个Web-xml能写多个servlet程序配置\"><a href=\"#6-1-一个Web-xml能写多个servlet程序配置\" class=\"headerlink\" title=\"6.1 一个Web.xml能写多个servlet程序配置\"></a>6.1 一个Web.xml能写多个servlet程序配置</h4><pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;servlet&gt;\n    &lt;servlet-name&gt;HellowServlet&lt;&#x2F;servlet-name&gt;\n    &lt;servlet-class&gt;com.servlet.HellowServlet&lt;&#x2F;servlet-class&gt;\n&lt;&#x2F;servlet&gt;\n\n&lt;servlet&gt;\n    &lt;servlet-name&gt;HellowServlet_02&lt;&#x2F;servlet-name&gt;\n    &lt;servlet-class&gt;com.servlet.HellowServlet_02&lt;&#x2F;servlet-class&gt;\n&lt;&#x2F;servlet&gt;\n\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;HellowServlet&lt;&#x2F;servlet-name&gt;\n    &lt;url-pattern&gt;&#x2F;HS1&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;servlet-mapping&gt;\n\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;HellowServlet_02&lt;&#x2F;servlet-name&gt;\n    &lt;url-pattern&gt;&#x2F;HS2&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;servlet-mapping&gt;</code></pre>\n\n<h4 id=\"6-2-Servlet-继承体系（源码解读）\"><a href=\"#6-2-Servlet-继承体系（源码解读）\" class=\"headerlink\" title=\"6.2 Servlet 继承体系（源码解读）\"></a>6.2 Servlet 继承体系（源码解读）</h4><p><span style=\"color:red;\">只需要根据自己的业务重写 doGet 或 doPost 方法即可，其他的事情（例如抛错误等）已经被实现，不需要我们管</span></p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/Servlet%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB.png\" alt=\"Servlet继承体系\"></p>\n<h3 id=\"7-ServletConfig类\"><a href=\"#7-ServletConfig类\" class=\"headerlink\" title=\"7. ServletConfig类\"></a>7. ServletConfig类</h3><h4 id=\"7-1-ServletConfig概述\"><a href=\"#7-1-ServletConfig概述\" class=\"headerlink\" title=\"7.1 ServletConfig概述\"></a>7.1 ServletConfig概述</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">* ServletConfig 类从类名上来看，就是 Servlet 程序的配置信息类\n* Servlet 程序和 ServletConfig 对象都是由 Tomcat 负责创建，我们负责使用\n* Servlet 程序默认是第一次访问的时候创建，ServletConfig 是每个 Servlet 程序创建时，就创建一个对应的 ServletConfig 对 象。</code></pre>\n\n<h4 id=\"7-2-ServletConfig-三大作用\"><a href=\"#7-2-ServletConfig-三大作用\" class=\"headerlink\" title=\"7.2 ServletConfig 三大作用\"></a>7.2 ServletConfig 三大作用</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">* 可以获取servlet程序的别名 servlet-name的值\n\n* 可以获取初始化参数 init-param\n\n* 获取 servletContext对象</code></pre>\n\n<p>web.xml 中的配置：</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;servlet&gt;\n    \n&lt;!--servlet-name 标签 Servlet 程序起一个别名（一般是类名） --&gt;\n&lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;\n&lt;!--servlet-class 是 Servlet 程序的全类名--&gt;\n&lt;servlet-class&gt;com.atguigu.servlet.HelloServlet&lt;&#x2F;servlet-class&gt;\n&lt;!--init-param 是初始化参数--&gt;\n    \n&lt;init-param&gt;\n&lt;!--是参数名--&gt;\n&lt;param-name&gt;username&lt;&#x2F;param-name&gt;\n&lt;!--是参数值--&gt;\n&lt;param-value&gt;root&lt;&#x2F;param-value&gt;\n&lt;&#x2F;init-param&gt;\n&lt;!--init-param 是初始化参数--&gt;\n&lt;init-param&gt;\n&lt;!--是参数名--&gt;\n&lt;param-name&gt;url&lt;&#x2F;param-name&gt;\n&lt;!--是参数值--&gt;\n&lt;param-value&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test&lt;&#x2F;param-value&gt;\n&lt;&#x2F;init-param&gt;\n    \n&lt;&#x2F;servlet&gt;\n\n&lt;!--servlet-mapping 标签给 servlet 程序配置访问地址--&gt;\n&lt;servlet-mapping&gt;\n&lt;!--servlet-name 标签的作用是告诉服务器，我当前配置的地址给哪个 Servlet 程序使用--&gt;\n&lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;\n&lt;!--\nurl-pattern 标签配置访问地址 &lt;br&#x2F;&gt;\n&#x2F; 斜杠在服务器解析的时候，表示地址为：http:&#x2F;&#x2F;ip:port&#x2F;工程路径 &lt;br&#x2F;&gt;\n&#x2F;hello 表示地址为：http:&#x2F;&#x2F;ip:port&#x2F;工程路径&#x2F;hello &lt;br&#x2F;&gt;\n--&gt;\n&lt;url-pattern&gt;&#x2F;hello&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;servlet-mapping&gt;</code></pre>\n\n<p>servlet中的代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * @content 1.使用idea工具创建Servlet.java\n *          2.测试ServletConfig类的三大作用\n **&#x2F; \n\n@Override\n    public void init(ServletConfig config) throws ServletException &#123;\n        &#x2F;*重写init方法必须加上调用父类的init()方法*&#x2F;\n        super.init(config);\n\n        &#x2F;*1.获取别名*&#x2F;\n        String servletName &#x3D; config.getServletName();\n        System.out.println(&quot;1.servletName是：&quot;+servletName);\n\n        &#x2F;*2.获取ServletContext对象*&#x2F;\n        ServletContext servletContext &#x3D; config.getServletContext();\n        System.out.println(&quot;2.ServletContext对象是：&quot;+servletContext);\n\n        &#x2F;*3.获取init-param*&#x2F;\n        String username &#x3D; config.getInitParameter(&quot;username&quot;);\n        System.out.println(&quot;3.username是:&quot;+username);\n        String url &#x3D; config.getInitParameter(&quot;url&quot;);\n        System.out.println(&quot;4.url是:&quot;+url);\n    &#125;</code></pre>\n\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/servlet%E9%87%8D%E5%86%99init.png\" alt=\"servlet_03_ServletConfig\"></p>\n<h3 id=\"8-ServletContext类\"><a href=\"#8-ServletContext类\" class=\"headerlink\" title=\"8. ServletContext类\"></a>8. ServletContext类</h3><h4 id=\"8-1-什么是ServletContext？\"><a href=\"#8-1-什么是ServletContext？\" class=\"headerlink\" title=\"8.1 什么是ServletContext？\"></a>8.1 什么是ServletContext？</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">* ServletContext 是一个接口，他表示Servlet 上下文对象\n\n* 一个Web工程，只有一个ServletContext对象\n\n* ServletContext对象 是一个域对象\n\n* ServletContext 是在 web工程部署启动的时候创建的，在 web 工程停止时，销毁</code></pre>\n\n<h4 id=\"8-2-什么是域对象？\"><a href=\"#8-2-什么是域对象？\" class=\"headerlink\" title=\"8.2 什么是域对象？\"></a>8.2 什么是域对象？</h4><div style=\"color:red;\">\n    <p>域对象，是可以像map一样存取数据的对象</p>\n    <p>域，指的是对象存取数据的操作范围，范围是：整个web工程</p>\n</div>\n#### 8.3 域对象存取数据的方法\n\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">存数据</th>\n<th align=\"center\">取数据</th>\n<th align=\"center\">删除数据</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Map</td>\n<td align=\"center\">put()</td>\n<td align=\"center\">get()</td>\n<td align=\"center\">remove()</td>\n</tr>\n<tr>\n<td align=\"center\">域对象</td>\n<td align=\"center\">setAttribute()</td>\n<td align=\"center\">getAttribute()</td>\n<td align=\"center\">removeAttribute()</td>\n</tr>\n</tbody></table>\n<h4 id=\"8-4-ServletContext-四个作用\"><a href=\"#8-4-ServletContext-四个作用\" class=\"headerlink\" title=\"8.4 ServletContext 四个作用\"></a>8.4 ServletContext 四个作用</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">1. 获取web.xml中配置的上下文参数 context-param\n\n   * 方法：getInitparameter()\n\n2. 获取当前的工程路径，格式：&#x2F;工程路径\n\n   * 方法：getContextpath()\n\n3. &lt;span style&#x3D;&quot;color:red;&quot;&gt;获取工程部署后在服务器硬盘上的绝对路径 ​【**重要**】​\n\n   * 方法：getrealpath()\n\n4. 像 Map一样存储数据\n\n   * 方法：setAttribute(“key”，“value”)    getAttribute()\n\n   * 注意：1.像 Map一样获取数据前（前提是已经存储了数据，不然获得的是空值）\n\n     ​\t\t   2.在储存数据之前获取，得到的也是空值\n\n     ​\t\t   3.ServletContext是域对象，一处存储数据，整个web工程内都能获取到（前提是，已经储存值）</code></pre>\n\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;context-param&gt;\n    &lt;param-name&gt;username&lt;&#x2F;param-name&gt;\n    &lt;param-value&gt;hh&lt;&#x2F;param-value&gt;\n&lt;&#x2F;context-param&gt;\n&lt;context-param&gt;\n    &lt;param-name&gt;password&lt;&#x2F;param-name&gt;\n    &lt;param-value&gt;521&lt;&#x2F;param-value&gt;\n&lt;&#x2F;context-param&gt;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void doGet(HttpServletRequest request, HttpServletResponse response) \n    \t\t\t\t\t\t\t\tthrows ServletException, IOException &#123;\n\n    \t&#x2F;*0.获取ServletContext对象*&#x2F;\n        ServletContext servletContext &#x3D; getServletConfig().getServletContext();\n\n        &#x2F;*1.获取 web.xml 中配置的上下文参数 context-param*&#x2F;\n        String username &#x3D; servletContext.getInitParameter(&quot;username&quot;);\n        Object password &#x3D; servletContext.getInitParameter(&quot;password&quot;);\n        System.out.println(username+&quot;:&quot;+password);\n        System.out.println(&quot;-----------------------&quot;);\n\n        &#x2F;*2.获取项目工程路径*&#x2F;\n        String contextPath &#x3D; servletContext.getContextPath();\n        System.out.println(contextPath);\n        System.out.println(&quot;-----------------------&quot;);\n\n        &#x2F;*3.获取web工程绝对路径*&#x2F;\n        String realPath &#x3D; servletContext.getRealPath(&quot;&#x2F;&quot;);\n        System.out.println(realPath);\n        System.out.println(&quot;-----------------------&quot;);\n\n        &#x2F;*4.像 Map一样存储数据*&#x2F;\n        servletContext.setAttribute(&quot;key1&quot;,&quot;value(h123)&quot;);\n\n        &#x2F;*4.像 Map一样获取数据（前提是已经存储了数据，不然获得的是空值）*&#x2F;\n        Object value &#x3D; servletContext.getAttribute(&quot;key1&quot;);\n        System.out.println(value);\n        System.out.println(&quot;-----------------------&quot;);\n    &#125;</code></pre>","text":"1. JavaEE概述1.1 什么是API？ 包括什么？* API：应用程序编程接口（这里所描述的接口不是interface） * API包括：源码，字节码，帮助文档（使用的时候要注意版本一致） 1.2 什么是JavaSE？* Java 标准版本 * SUN公司为程序员提供的一套...","link":"","photos":[],"count_time":{"symbolsCount":"8.3k","symbolsTime":"8 mins."},"categories":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/categories/JavaWeb.json"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/tags/JavaWeb.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-JavaEE%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1. JavaEE概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-%E4%BB%80%E4%B9%88%E6%98%AFAPI%EF%BC%9F-%E5%8C%85%E6%8B%AC%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">1.1 什么是API？ 包括什么？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-%E4%BB%80%E4%B9%88%E6%98%AFJavaSE%EF%BC%9F\"><span class=\"toc-text\">1.2 什么是JavaSE？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-%E4%BB%80%E4%B9%88%E6%98%AFJavaEE%EF%BC%9F\"><span class=\"toc-text\">1.3 什么是JavaEE？</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Servlet%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">2. Servlet简介</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-%E4%BB%80%E4%B9%88%E6%98%AFservlet%EF%BC%9F\"><span class=\"toc-text\">2.1 什么是servlet？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-Servlet-API-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">2.2 Servlet API (生命周期)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-HttpServlet%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.3 HttpServlet类的方法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%88%9B%E5%BB%BAServlet%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">3. 创建Servlet的两种方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-%E5%AE%9E%E7%8E%B0-Servlet-%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">3.1 实现 Servlet 接口</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-%E5%88%9B%E5%BB%BA%E7%B1%BB%E7%BB%A7%E6%89%BFHttpServlet\"><span class=\"toc-text\">3.2 创建类继承HttpServlet</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AEServlet%EF%BC%8C%E8%B7%AF%E5%BE%84%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">4. 如何访问Servlet，路径配置</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-1-url-%E5%9C%B0%E5%9D%80%E5%88%B0-Servlet%E7%9A%84%E8%AE%BF%E9%97%AE\"><span class=\"toc-text\">4.1 url 地址到 Servlet的访问</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-2-Servlet%E7%9A%84%E4%B8%89%E7%A7%8D%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84%E7%9A%84%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">4.2 Servlet的三种映射路径的配置</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-2-1-%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">4.2.1 映射路径的作用</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-2-2-%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84%E7%9A%84%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">4.2.2 映射路径的分类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#4-2-2-1-%E5%AE%8C%E5%85%A8%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">4.2.2.1 完全路径匹配</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#4-2-2-2-%E7%9B%AE%E5%BD%95%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">4.2.2.2 目录匹配</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#4-2-2-3-%E6%89%A9%E5%B1%95%E5%90%8D%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">4.2.2.3 扩展名匹配</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-GET-POST%E7%9A%84%E5%88%86%E5%8F%91%E5%A4%84%E7%90%86-%E4%B8%89%E7%A7%8D\"><span class=\"toc-text\">5. GET POST的分发处理(三种)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-%E5%AE%9E%E7%8E%B0servlet%E6%8E%A5%E5%8F%A3%E5%A4%84%E7%90%86\"><span class=\"toc-text\">5.1 实现servlet接口处理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-2-%E7%BB%A7%E6%89%BFHttpServlet%E5%A4%84%E7%90%86\"><span class=\"toc-text\">5.2 继承HttpServlet处理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-Servlet-%E9%85%8D%E7%BD%AE-%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB\"><span class=\"toc-text\">6. Servlet 配置 继承体系</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-1-%E4%B8%80%E4%B8%AAWeb-xml%E8%83%BD%E5%86%99%E5%A4%9A%E4%B8%AAservlet%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">6.1 一个Web.xml能写多个servlet程序配置</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-2-Servlet-%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%EF%BC%88%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%89\"><span class=\"toc-text\">6.2 Servlet 继承体系（源码解读）</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-ServletConfig%E7%B1%BB\"><span class=\"toc-text\">7. ServletConfig类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-1-ServletConfig%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">7.1 ServletConfig概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-2-ServletConfig-%E4%B8%89%E5%A4%A7%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">7.2 ServletConfig 三大作用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-ServletContext%E7%B1%BB\"><span class=\"toc-text\">8. ServletContext类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-1-%E4%BB%80%E4%B9%88%E6%98%AFServletContext%EF%BC%9F\"><span class=\"toc-text\">8.1 什么是ServletContext？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-2-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%9F%E5%AF%B9%E8%B1%A1%EF%BC%9F\"><span class=\"toc-text\">8.2 什么是域对象？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-4-ServletContext-%E5%9B%9B%E4%B8%AA%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">8.4 ServletContext 四个作用</span></a></li></ol></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"Servlet（下）","uid":"5be9ff575c28645ffc905ea202238d73","slug":"36-Servlet（下）","date":"2021-09-13T15:12:32.000Z","updated":"2021-09-15T10:27:25.523Z","comments":true,"path":"api/articles/36-Servlet（下）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"1. HttpServletRequest类1.1 作用每次只要有请求进入 Tomcat 服务器，Tomcat 服务器就会把请求过来的 HTTP 协议信息**解析好封装**到 Request 对象中。 然后传递到 service 方法（doGet 和 doPost）中给我们使用。...","link":"","photos":[],"count_time":{"symbolsCount":"9.5k","symbolsTime":"9 mins."},"categories":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/categories/JavaWeb.json"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/tags/JavaWeb.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"XML","uid":"1158d9e6c37bc3dd9f057cb155218f0c","slug":"34-Xml","date":"2021-09-13T15:10:32.000Z","updated":"2021-09-15T10:26:43.050Z","comments":true,"path":"api/articles/34-Xml.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"1. XML概述1.1 概念Extensible Markup Language 可扩展标记语言 可扩展：标签是自定义的 &lt;user&gt; &lt;学习&gt; 1.2 功能作为配置文件，存储数据 存储数据后也可以在网络中传输数据 1.3 XML与HTML的区别XML标签...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/categories/JavaWeb.json"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/tags/JavaWeb.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}