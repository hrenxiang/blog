{"title":"常用的类（上）","uid":"01fd53219624f0d973c128a92b2b96c5","slug":"07-常用的类（上）","date":"2021-09-13T14:41:32.000Z","updated":"2021-09-14T15:54:12.626Z","comments":true,"path":"api/articles/07-常用的类（上）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog7.jpg","content":"<h3 id=\"一、单例设计模式\"><a href=\"#一、单例设计模式\" class=\"headerlink\" title=\"一、单例设计模式\"></a>一、单例设计模式</h3><h4 id=\"1-1-概述\"><a href=\"#1-1-概述\" class=\"headerlink\" title=\"1.1 概述\"></a>1.1 概述</h4><p>单例模式，是一种常用的软件设计模式，在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中应用该模式的类一个类只有一个实例，即一个类只有一个对象实例。例如，windows操作系统里的回收站。</p>\n<p>单例设计模式分为饿汉式（立即加载型）和懒汉式（延迟加载型）。<br>由于懒汉式有线程安全问题，又衍生出了线程安全版的懒汉式以及DLC双检查锁（最佳实现方式）的懒汉式</p>\n<h4 id=\"1-2-做法\"><a href=\"#1-2-做法\" class=\"headerlink\" title=\"1.2 做法\"></a>1.2 做法</h4><ol>\n<li>将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。</li>\n<li>在该类内部产生一个唯一的实例化对象，并且将其封装为private static final类型。</li>\n<li>定义一个静态方法返回这个唯一对象。</li>\n</ol>\n<h4 id=\"1-3-饿汉式\"><a href=\"#1-3-饿汉式\" class=\"headerlink\" title=\"1.3 饿汉式\"></a>1.3 饿汉式</h4><h5 id=\"1-3-1-概述\"><a href=\"#1-3-1-概述\" class=\"headerlink\" title=\"1.3.1 概述\"></a>1.3.1 概述</h5><p>立即加载就是使用类的时候已经将对象创建完毕</p>\n<p>不管以后会不会使用到该实例化对象，先创建了再说。很着急的样子，故又被称为“饿汉模式”，常见的实现办法就是直接new实例化。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Singleton &#123;\n\n    &#x2F;&#x2F; 将自身实例化对象设置为一个属性，并用static修饰\n    private static final Singleton instance &#x3D; new Singleton();\n\n    &#x2F;&#x2F; 构造方法私有化\n    private Singleton() &#123;&#125;\n\n    &#x2F;&#x2F; 静态方法返回该实例\n    public static Singleton getInstance() &#123;\n        return instance;\n    &#125;\n&#125;</code></pre>\n\n<h5 id=\"1-3-2-特点\"><a href=\"#1-3-2-特点\" class=\"headerlink\" title=\"1.3.2 特点\"></a>1.3.2 特点</h5><p>优点：实现起来简单，没有多线程同步问题。</p>\n<p>缺点：当类SingletonTest被加载的时候，会初始化static的instance，静态变量被创建并分配内存空间，从这以后，这个static的instance对象便一直占着这段内存（即便你还没有用到这个实例），当类被卸载时，静态变量被摧毁，并释放所占有的内存，因此在某些特定条件下会耗费内存。</p>\n<h4 id=\"1-4-懒汉式\"><a href=\"#1-4-懒汉式\" class=\"headerlink\" title=\"1.4 懒汉式\"></a>1.4 懒汉式</h4><h5 id=\"1-4-1-概述\"><a href=\"#1-4-1-概述\" class=\"headerlink\" title=\"1.4.1 概述\"></a>1.4.1 概述</h5><p>延迟加载就是调用get()方法时实例才被创建（先不急着实例化出对象，等要用的时候才给你创建出来。不着急，故又称为“懒汉模式”），常见的实现方法就是在get方法中进行new实例化。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Singleton &#123;\n\n    &#x2F;&#x2F; 将自身实例化对象设置为一个属性，并用static修饰\n    private static Singleton instance;\n\n    &#x2F;&#x2F; 构造方法私有化\n    private Singleton() &#123;&#125;\n\n    &#x2F;&#x2F; 静态方法返回该实例\n    public static Singleton getInstance() &#123;\n        if(instance &#x3D;&#x3D; null) &#123;\n            instance &#x3D; new Singleton();\n        &#125;\n        return instance;\n    &#125;\n&#125;</code></pre>\n\n<h5 id=\"1-4-2-特点\"><a href=\"#1-4-2-特点\" class=\"headerlink\" title=\"1.4.2 特点\"></a>1.4.2 特点</h5><p>优点：实现起来比较简单，当类SingletonTest被加载的时候，静态变量static的instance未被创建并分配内存空间，当getInstance方法第一次被调用时，初始化instance变量，并分配内存，因此在某些特定条件下会节约了内存。</p>\n<p>缺点：在多线程环境中，这种实现方法是完全错误的，根本不能保证单例的状态</p>\n<h3 id=\"二、枚举类\"><a href=\"#二、枚举类\" class=\"headerlink\" title=\"二、枚举类\"></a>二、枚举类</h3><h4 id=\"2-1-概述\"><a href=\"#2-1-概述\" class=\"headerlink\" title=\"2.1 概述\"></a>2.1 概述</h4><p>枚举是一个被命名的整型常数的集合，用于声明一组带标识符的常数。枚举在曰常生活中很常见，例如一个人的性别只能是“男”或者“女”，一周的星期只能是 7 天中的一个等。类似这种当一个变量有几种固定可能的取值时，就可以将它定义为枚举类型。</p>\n<p>在 JDK 1.5 之前没有枚举类型，那时候一般用接口常量来替代。而使用 <a href=\"http://c.biancheng.net/java/\">Java</a> 枚举类型 enum 可以更贴近地表示这种常量。</p>\n<h4 id=\"2-2-枚举类的实现\"><a href=\"#2-2-枚举类的实现\" class=\"headerlink\" title=\"2.2  枚举类的实现\"></a>2.2  枚举类的实现</h4><h5 id=\"2-2-1-JDK-1-5-之前\"><a href=\"#2-2-1-JDK-1-5-之前\" class=\"headerlink\" title=\"2.2.1 JDK 1.5 之前\"></a>2.2.1 JDK 1.5 之前</h5><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(Season.SPRING);\n    &#125;\n&#125;\n\nclass Season &#123;\n    private Season() &#123;\n    &#125;\n    public static final Season SPRING &#x3D; new Season();\n    public static final Season SUMMER &#x3D; new Season();\n    public static final Season AUTUMN &#x3D; new Season();\n    public static final Season WINTER &#x3D; new Season();\n&#125;</code></pre>\n\n<h5 id=\"2-2-2-Enum的使用\"><a href=\"#2-2-2-Enum的使用\" class=\"headerlink\" title=\"2.2.2 Enum的使用\"></a>2.2.2 Enum的使用</h5><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">enum 枚举类类名 &#123;\n    对象1,对象2,对象3;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public enum Season&#123;\n    &#x2F;&#x2F; SPRING(),SUMMER(),AUTUMN(),WINTER();  调用构造函数，创建了四个对象，小括号可以省略\n\n    SPRINT,SUMMER,AUTUMN,WINTER;  &#x2F;&#x2F; 创建了四个对象\n    &#x2F;&#x2F; private Season()&#123;&#125; 构造方法可以不写，默认就有一个空参数构造方法\n&#125;\n\npublic enum WeekDay &#123;\n    &#x2F;&#x2F; 创建的实例对象时，必须要调用构造方法传入 name 参数\n    MON(&quot;周一&quot;), TUE(&quot;周二&quot;), WED(&quot;周三&quot;), THU(&quot;周四&quot;), FRI(&quot;周五&quot;), SAT(&quot;周六&quot;), SUN(&quot;周日&quot;);\n\n    private String name;\n    WeekDay(String name) &#123;  &#x2F;&#x2F; 还能自定义构造方法\n        this.name &#x3D; name;\n    &#125;\n\n    &#x2F;&#x2F; 像正常的类一样，可以使用 getter&#x2F;setter 方法\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"2-3-枚举类的特点\"><a href=\"#2-3-枚举类的特点\" class=\"headerlink\" title=\"2.3 枚举类的特点\"></a>2.3 枚举类的特点</h4><ul>\n<li>所有的枚举都继承自java.lang.Enum类，由于Java 不支持多继承，所以<strong>枚举对象不能再继承其他类</strong>（但是可以实现接口）。</li>\n<li>枚举类的所有实例对象都必须放在第一行展示（<strong>逗号隔开</strong>），并且默认都是以<code>public static final</code>修饰的常量，所以变量名通常都<strong>全大写</strong>。</li>\n<li>在创建实例对象时，不需使用new 关键字，也不需使用小括号显式调用构造器</li>\n<li>使用enum定义非抽象的枚举类<strong>默认使用final修饰</strong>，<strong>不可以被继承</strong>。</li>\n<li>枚举类的<strong>构造器只能是私有的</strong>，不允许在外部创建对象。</li>\n</ul>\n<h4 id=\"2-4-Enum中的方法\"><a href=\"#2-4-Enum中的方法\" class=\"headerlink\" title=\"2.4  Enum中的方法\"></a>2.4  Enum中的方法</h4><p><img src=\"https://gitee.com/xiuxiuai/picture/raw/master/img/EnumMethod.png\" alt=\"enum\"></p>\n<table>\n<thead>\n<tr>\n<th>方法名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>values()</td>\n<td>以数组形式返回枚举类型的所有成员</td>\n</tr>\n<tr>\n<td>valueOf()</td>\n<td>将普通字符串转换为枚举实例</td>\n</tr>\n<tr>\n<td>compareTo()</td>\n<td>比较两个枚举成员在定义时的顺序</td>\n</tr>\n<tr>\n<td>ordinal()</td>\n<td>获取枚举成员的索引位置</td>\n</tr>\n<tr>\n<td><strong>toString</strong>()</td>\n<td>返回对象名（常用♥）</td>\n</tr>\n<tr>\n<td>name()</td>\n<td>获取对象名（不常用）</td>\n</tr>\n</tbody></table>\n<h3 id=\"三、包装类\"><a href=\"#三、包装类\" class=\"headerlink\" title=\"三、包装类\"></a>三、包装类</h3><h4 id=\"3-1-概述\"><a href=\"#3-1-概述\" class=\"headerlink\" title=\"3.1 概述\"></a>3.1 概述</h4><p>在 <a href=\"http://c.biancheng.net/java/\">Java</a> 的设计中提倡一种思想，即一切皆对象。但是从数据类型的划分中，我们知道 Java 中的数据类型分为基本数据类型和引用数据类型，但是基本数据类型怎么能够称为对象呢？于是 Java 为每种基本数据类型分别设计了对应的类，称之为包装类（Wrapper Classes），也有地方称为外覆类或数据类型类。</p>\n<h4 id=\"3-2-关系\"><a href=\"#3-2-关系\" class=\"headerlink\" title=\"3.2 关系\"></a>3.2 关系</h4><table>\n<thead>\n<tr>\n<th>序号</th>\n<th>基本数据类型</th>\n<th>包装类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>byte</td>\n<td>Byte</td>\n</tr>\n<tr>\n<td>2</td>\n<td>short</td>\n<td>Short</td>\n</tr>\n<tr>\n<td>3</td>\n<td>int</td>\n<td><strong>Integer</strong></td>\n</tr>\n<tr>\n<td>4</td>\n<td>long</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>5</td>\n<td>char</td>\n<td><strong>Character</strong></td>\n</tr>\n<tr>\n<td>6</td>\n<td>float</td>\n<td>Float</td>\n</tr>\n<tr>\n<td>7</td>\n<td>double</td>\n<td>Double</td>\n</tr>\n<tr>\n<td>8</td>\n<td>boolean</td>\n<td>Boolean</td>\n</tr>\n</tbody></table>\n<p>从上表中我们可以看出，除了 Integer 和 Character 定义的名称与基本数据类型定义的名称相差较大外，其它的 6 种类型的名称都是很好掌握的。</p>\n<h4 id=\"3-3-装箱和拆箱\"><a href=\"#3-3-装箱和拆箱\" class=\"headerlink\" title=\"3.3 装箱和拆箱\"></a>3.3 装箱和拆箱</h4><ul>\n<li><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</li>\n<li><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int a &#x3D; 10;\n\n&#x2F;&#x2F; 装箱:使用构造方法 或者 valueOf 方法将基本数据类型a包装成为包装类型\nInteger i1 &#x3D; new Integer(a);\nInteger i2 &#x3D; Integer.valueOf(a);\n\n&#x2F;&#x2F; 拆箱:将包装类型转换成为基本数据类型\nint b &#x3D; i1.intValue();</code></pre>\n\n<ul>\n<li>自动装箱拆箱:由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Integer i &#x3D; 4; &#x2F;&#x2F;自动装箱。相当于Integer i &#x3D; Integer.valueOf(4);\ni &#x3D; i + 5; &#x2F;&#x2F;等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;\n&#x2F;&#x2F;加法运算完成后，再次装箱，把基本数值转成对象。</code></pre>\n\n<h4 id=\"3-4-包装类的应用\"><a href=\"#3-4-包装类的应用\" class=\"headerlink\" title=\"3.4 包装类的应用\"></a>3.4 包装类的应用</h4><h5 id=\"3-4-1-int-和-Integer-的相互转换\"><a href=\"#3-4-1-int-和-Integer-的相互转换\" class=\"headerlink\" title=\"3.4.1 int 和 Integer 的相互转换\"></a>3.4.1 int 和 Integer 的相互转换</h5><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n    public static void main(String[] args) &#123;\n        int m &#x3D; 500;\n        Integer obj &#x3D; new Integer(m);  &#x2F;&#x2F; 手动装箱\n        int n &#x3D; obj.intValue();  &#x2F;&#x2F; 手动拆箱\n        System.out.println(&quot;n &#x3D; &quot; + n);\n       \n        Integer obj1 &#x3D; new Integer(500);\n        System.out.println(&quot;obj等价于obj1的返回结果为&quot; + obj.equals(obj1));\n    &#125;\n&#125;</code></pre>\n\n<h5 id=\"3-4-2-将字符串转换为数值类型\"><a href=\"#3-4-2-将字符串转换为数值类型\" class=\"headerlink\" title=\"3.4.2 将字符串转换为数值类型\"></a>3.4.2 将字符串转换为数值类型</h5><p>① new Integer(String str);</p>\n<p>② Integer 类（String 转 int 型）<strong>parsenInt（）</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int parseInt(String s); s 为要转换的字符串。</code></pre>\n\n<p>注意：使用以上两种方法时，<strong>字符串中的数据必须由数字组成</strong>，否则转换时会出现程序错误。</p>\n<p>3.4.3 将整数转换为字符串</p>\n<p>Integer 类有一个静态的 <strong>toString()</strong> 方法，可以将整数转换为字符串。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n    public static void main(String[] args) &#123;\n        int m &#x3D; 500;\n        String s &#x3D; Integer.toString(m);\n        System.out.println(&quot;s &#x3D; &quot; + s);\n    &#125;\n&#125;</code></pre>\n\n<p>使用<code>+</code>将基本数据类型和字符串拼接，例如<code>String x = 1 + &quot;&quot;;</code>得到的结果x就是个字符串。</p>\n<p>调用String类的<code>valueOf</code>方法，例如<code>String x = String.valueOf(1);</code>得到的结果是一个字符串。</p>\n","text":"一、单例设计模式1.1 概述单例模式，是一种常用的软件设计模式，在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中应用该模式的类一个类只有一个实例，即一个类只有一个对象实例。例如，windows操作系统里的回收站。 单例设计模式分为饿汉式（立即加载型）和懒汉...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/tags/JavaSE.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">一、单例设计模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.1 概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-%E5%81%9A%E6%B3%95\"><span class=\"toc-text\">1.2 做法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-%E9%A5%BF%E6%B1%89%E5%BC%8F\"><span class=\"toc-text\">1.3 饿汉式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-3-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.3.1 概述</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-3-2-%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">1.3.2 特点</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-4-%E6%87%92%E6%B1%89%E5%BC%8F\"><span class=\"toc-text\">1.4 懒汉式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-4-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.4.1 概述</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-4-2-%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">1.4.2 特点</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E6%9E%9A%E4%B8%BE%E7%B1%BB\"><span class=\"toc-text\">二、枚举类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">2.1 概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">2.2  枚举类的实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-1-JDK-1-5-%E4%B9%8B%E5%89%8D\"><span class=\"toc-text\">2.2.1 JDK 1.5 之前</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-2-Enum%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">2.2.2 Enum的使用</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">2.3 枚举类的特点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-4-Enum%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.4  Enum中的方法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB\"><span class=\"toc-text\">三、包装类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">3.1 概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">3.2 关系</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-3-%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1\"><span class=\"toc-text\">3.3 装箱和拆箱</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-4-%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">3.4 包装类的应用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-4-1-int-%E5%92%8C-Integer-%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">3.4.1 int 和 Integer 的相互转换</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-4-2-%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">3.4.2 将字符串转换为数值类型</span></a></li></ol></li></ol></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"常用的类（中）","uid":"c660642989e58d8f24bf7e09ddf846f0","slug":"08-常用的类（中）","date":"2021-09-13T14:42:32.000Z","updated":"2021-09-14T15:54:22.816Z","comments":true,"path":"api/articles/08-常用的类（中）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog8.jpg","text":"一、Math类1、特点提供了操作数学元素的方法，都是静态的 2、常用方法int abs(int a)：返回整数的绝对值 int max(int a, int b)：返回两个整数的最大值 double random()：返回一个伪随机值(0--1 之间) double sqrt(d...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/tags/JavaSE.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"面向对象（下）","uid":"5a1c4f03caf8f9ffac125f63d3a94727","slug":"06-面向对象（下）","date":"2021-09-13T14:38:32.000Z","updated":"2021-09-14T15:53:58.076Z","comments":true,"path":"api/articles/06-面向对象（下）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog6.jpg","text":"一、内部类1.成员内部类1.1 概念在成员位置定义的类（定义在另一个类的内部，最普通的内部类），称之为成员内部类 1.2 成员内部类特点: 不能使用 static关键字，但是可以使用static final关键字定义常量。 成员内部类 可以无条件的访问外部类的 成员属性 和 成员...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/tags/JavaSE.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}