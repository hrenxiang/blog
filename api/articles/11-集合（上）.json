{"title":"集合（上）","uid":"42c17c71eb42c16b2fd355c959a76eb9","slug":"11-集合（上）","date":"2021-09-13T14:46:32.000Z","updated":"2021-09-14T15:54:50.726Z","comments":true,"path":"api/articles/11-集合（上）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog11.jpg","content":"<h3 id=\"一、为什么使用集合\"><a href=\"#一、为什么使用集合\" class=\"headerlink\" title=\"一、为什么使用集合\"></a>一、为什么使用集合</h3><p>为什么我们不采用数组存对象呢？</p>\n<ul>\n<li>因为数组长度是固定，而我们很多时候对对象的个数是 不确定的。</li>\n<li>所以，我们产生了集合框架，它是用于存储对象的。</li>\n</ul>\n<h3 id=\"二、集合和数组的区别\"><a href=\"#二、集合和数组的区别\" class=\"headerlink\" title=\"二、集合和数组的区别\"></a>二、集合和数组的区别</h3><ol>\n<li><p>集合长度是可变的，集合中不能存储基本数据类型值，只能存储对象(<strong>引用数据类型</strong>)。 </p>\n<p>数组的长度是固定的，可以存储对象，也可以存储基本数据类型。</p>\n</li>\n<li><p>数组只能存储同一种类型，集合可以存储不同类型（但一般来说，集合也只存储同一类型）</p>\n</li>\n<li><p>什么时候用哪个? 长度不固定，用集合。 长度固定，可以集合，可用数组。</p>\n</li>\n</ol>\n<h3 id=\"三、集合的体系结构\"><a href=\"#三、集合的体系结构\" class=\"headerlink\" title=\"三、集合的体系结构\"></a>三、集合的体系结构</h3><p><img src=\"https://gitee.com/xiuxiuai/picture/raw/master/img/%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png\" alt=\"image-20200906134716330\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">---------| Collection 单例集合的根接口\n------------| List  如果是实现了List接口的集合类， 具备的特点：有序，重复。\n----------------| ArraryList  底层 是使用了Object数组实现的，特点： 查询速度快，增删慢。\n----------------| LinkedList 底层是使用了链表数据结构实现 的， 特点： 查询速度慢，增删快。\n----------------| Vector Vector的实现与ArrayList是一致，但是是线程安全 的，操作效率低。 jdk1.0的时候出现的\n------------| Set  如果是实现了Set接口的集合类，具备的特点：无序，不可重复。\n----------------| HashSet  底层是使用了一个哈希表支持的， 特点：存取速度快。\n----------------| TreeSet  底层实现为二叉树，元素有序（从小到大）\n---------| Map 双链集合的根接口\n---------------| HashMap  接口实现类，没有同步，线程不安全\n---------------| LinkedHashMap  双向链表和哈希表实现\n---------------| TreeMap  红黑树对所有的key进行排序</code></pre>\n\n<h3 id=\"四、泛型\"><a href=\"#四、泛型\" class=\"headerlink\" title=\"四、泛型\"></a>四、泛型</h3><h4 id=\"1、基本和引用数据类型区别\"><a href=\"#1、基本和引用数据类型区别\" class=\"headerlink\" title=\"1、基本和引用数据类型区别\"></a>1、基本和引用数据类型区别</h4><ul>\n<li>基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接答存储在栈上。</li>\n<li>而引用专数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，<br>而对象的具体信息都存储在堆内存上，然后由栈上面的属引用指向堆中对象的地址。</li>\n<li>在数据做为参数传递的时候，基本数据类型是值传递，而引用数据类型是引用传递（地址传递）。</li>\n</ul>\n<h4 id=\"2、泛型的概念\"><a href=\"#2、泛型的概念\" class=\"headerlink\" title=\"2、泛型的概念\"></a>2、泛型的概念</h4><ul>\n<li>jdk1.5出现的安全机制，解决类型安全的问题，只能用于编译时期，提高安全性</li>\n</ul>\n<h4 id=\"3、泛型的好处\"><a href=\"#3、泛型的好处\" class=\"headerlink\" title=\"3、泛型的好处\"></a>3、泛型的好处</h4><ul>\n<li>将运行时期的问题 classCastExceptoin 转到了编译时期。 </li>\n<li>避免了强制转换的麻烦。</li>\n</ul>\n<h4 id=\"4、泛型类的定义格式\"><a href=\"#4、泛型类的定义格式\" class=\"headerlink\" title=\"4、泛型类的定义格式\"></a>4、泛型类的定义格式</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">1. 泛型类,在类上自定义泛型，实在创建对象实现确定,没指定为object类型\n   格式:修饰符    class     类名&lt;T t&gt; &#123; &#125;\n   范例: public     class     Generic&lt;T&gt;&#123; &#125;\n   此处T可以随便写为任意标识，常见的如T、E、 K、V等形式的参数常用于表示泛型\n\n2. 自定义方法泛型 格式： \n   修饰符 &lt;T&gt; 返回类型 方法名（T 参数） &#123; &#125;\n   范例: public static &lt;T&gt; void println(T t) &#123; &#125;\n         public static &lt;E&gt; E call(E e) &#123; &#125;\n\n3. 泛型接口,在实现接口是指定类型，没指定为object\n   interface CallBack&lt;T&gt; &#123; &#125;</code></pre>\n\n<h4 id=\"5、类型通配符\"><a href=\"#5、类型通配符\" class=\"headerlink\" title=\"5、类型通配符\"></a>5、类型通配符</h4><p>   为了表示各种泛型List的父类，可以使用类型通配符</p>\n<ul>\n<li>类型通配符: &lt;?&gt;</li>\n<li>List&lt;?&gt;:     表示元素类型未知的List,它的元素可以匹配任何的类型</li>\n<li>这种带通配符的List仅表示它是各种泛型List的父类，     并不能把元素添加到其中</li>\n</ul>\n<p>   如果说我们不希望List&lt;?&gt;是任何泛型List的父类，只希望它代表某一类泛型List的父类,可以使用</p>\n<ul>\n<li>类型通配符的上限<ul>\n<li>类型通配符 上限: &lt;? extends类型&gt;</li>\n<li>List&lt;? extends      Number&gt;:  它表示的类型是Number或者其子类型</li>\n</ul>\n</li>\n<li>类型通配符下限<ul>\n<li>类型通配符下限: &lt;?super 类型&gt;</li>\n<li>List&lt;? super      Number&gt;:  它表示的类型是Number或者其父类型<h3 id=\"五、collection集合\"><a href=\"#五、collection集合\" class=\"headerlink\" title=\"五、collection集合\"></a>五、collection集合</h3></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1、注意\"><a href=\"#1、注意\" class=\"headerlink\" title=\"1、注意\"></a>1、注意</h4><p><font color=\"ff6473\">collection集合不能直接实现，使用更为具体的子接口实现。牢记各种方法</font></p>\n<h4 id=\"2、collection集合概述\"><a href=\"#2、collection集合概述\" class=\"headerlink\" title=\"2、collection集合概述\"></a>2、collection集合概述</h4><ul>\n<li>collection集合是==单例集合的顶层接口==，他表示一组对象，这些对象也称为collection的元素</li>\n<li>JDK不提供此接口直接的实现，他提供更为具体的子接口的实现（Set 和 List）</li>\n</ul>\n<h4 id=\"3、创建collection对象\"><a href=\"#3、创建collection对象\" class=\"headerlink\" title=\"3、创建collection对象\"></a>3、创建collection对象</h4><ul>\n<li>多态的方式</li>\n<li>使用具体的实现类</li>\n</ul>\n<h4 id=\"4、collection接口的方法\"><a href=\"#4、collection接口的方法\" class=\"headerlink\" title=\"4、collection接口的方法\"></a>4、collection接口的方法</h4><pre><code>1. 添加\n   * Boolean  add(E e): 成功返回true，失败false\n   * Boolean  addAll(): 在集合中添加另外一个集合\n2. 删除\n   * Boolean  remove(object obj): 删除一个对象，会改变集合的长度\n   * Boolean  remove(Collection con): 删除一个集合，还有两个集合中相同的元素\n   * void  clear(): 删除所有 \n3. 判断\n   * Boolean  contains(object obj): 在集合中是否包含指定的对象\n   * Boolean  containsAll(Collection con): 在集合中是否包含另一个集合\n   * Boolean  isEmpty(): 判断集合是否为空\n4. 获取\n   * int  size():  得到集合的尺寸大小    数组：length   字符串：length();\n   * Iterator iterator()：取出元素的方式。迭代器。\n   - E next():  返回迭代中的下一个元素\n   * boolean hasNext():  如果迭代具有更多元素，则返回true\n   * 迭代器将容器的取出方式和容器的数据结构相分离，降低了耦合性\n5. 集合转数组\n   * Obiect[] toArray():  把集合转换为对象\n</code></pre>\n<h3 id=\"六、List集合\"><a href=\"#六、List集合\" class=\"headerlink\" title=\"六、List集合\"></a>六、List集合</h3><h4 id=\"1、注意-1\"><a href=\"#1、注意-1\" class=\"headerlink\" title=\"1、注意\"></a>1、注意</h4><p><font color=\"ff6473\">list集合，有序，可重复，通过索引进行查询，数组查询速度快，增删慢，链表查询慢，增删快</font>   </p>\n<h4 id=\"2、List集合的特点\"><a href=\"#2、List集合的特点\" class=\"headerlink\" title=\"2、List集合的特点\"></a>2、List集合的特点</h4><ul>\n<li>有序（存入和取出的顺序一致）</li>\n<li>元素都有索引（角标）</li>\n<li>存储元素可以重复（set集合不可）</li>\n<li>规律：凡是有索引的容器，都有增删改查的方法。</li>\n</ul>\n<h4 id=\"3、List集合的方法\"><a href=\"#3、List集合的方法\" class=\"headerlink\" title=\"3、List集合的方法\"></a>3、List集合的方法</h4><ul>\n<li><p>void add(int index,E element)： 在此集合指定位置添加元素</p>\n</li>\n<li><p>Object remove(index):删除指定的元素—-获取并删除</p>\n</li>\n<li><p>Object set(index,element):在指定位置改变元素，并返回被替换掉的元素。</p>\n</li>\n<li><p>Object get(index): 获取指定的元素</p>\n</li>\n<li><p>int indexOf(object ):返回对象所在的位置 </p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String s &#x3D; &quot;dd&quot;;\nint i &#x3D; list.indexOf(s);\nSystem.out.println(i);</code></pre></li>\n<li><p><strong>ListIterator</strong>：拥有了对元素进行增删改查的方法——-&gt;list 特有的！</p>\n</li>\n</ul>\n<h4 id=\"4、常见数据结构\"><a href=\"#4、常见数据结构\" class=\"headerlink\" title=\"4、常见数据结构\"></a>4、常见数据结构</h4><ul>\n<li>数组<br>查询数据通过索引定位，查询任意数据耗时相同，查询速率高<br>删除数据时，要将原始数据删除，同时后面每个数据前移，删除效率低<br>添加数据时，添加位置后的数据每个要后移，再添加元素，添加效率极低</li>\n<li>链表<br>链表是一种查询慢，增删快的模型（对比 数组 而言）<br>每次查询都要重头开始查询</li>\n</ul>\n<h4 id=\"5、List-接口的子类\"><a href=\"#5、List-接口的子类\" class=\"headerlink\" title=\"5、List 接口的子类\"></a>5、List 接口的子类</h4><ul>\n<li><code>Vector</code>: 内部是数组数据结构，是线程安全的。增删查询都很慢！（<strong>基本不用</strong>） </li>\n<li><code>ArrayList</code>: 内部是数组数据结构，是不同步的，代替了 vector.，查询的速度快<br>内存原理： 在 arrayList 集合中，是一种线性表，每个对象存储都是有序的，用角标确定对象所存储的位置<br>查询时，直接通过角标进行查询，速度会很快<br>但是如果要进行增添、修改、删除操作的 话，就要影响后面角标的对象，大部分对象都要移动，直接影响运行效率。 </li>\n<li><code>LinkedList</code>: 内部是链表结构，有很多自己特有的方法，查询慢，增删快，线程不安全</li>\n</ul>\n<h4 id=\"6、List集合子类特点\"><a href=\"#6、List集合子类特点\" class=\"headerlink\" title=\"6、List集合子类特点\"></a>6、List集合子类特点</h4><ul>\n<li>ArrayList：底层数据结构是数组，<strong>查询快，增删慢</strong>，线程不安全，效率高，可以存储重复元素</li>\n<li>LinkedList:：底层数据结构是双链表，<strong>查询慢，增删快</strong>，线程不安全，效率高，可以存储重复元素，（包括null ）</li>\n</ul>\n<h3 id=\"七、Set集合\"><a href=\"#七、Set集合\" class=\"headerlink\" title=\"七、Set集合\"></a>七、Set集合</h3><h4 id=\"1、Set集合概述和特点\"><a href=\"#1、Set集合概述和特点\" class=\"headerlink\" title=\"1、Set集合概述和特点\"></a>1、Set集合概述和特点</h4><p>Set集合没有特有方法，他的方法都来自Collection。</p>\n<h4 id=\"2、Set集合特点\"><a href=\"#2、Set集合特点\" class=\"headerlink\" title=\"2、Set集合特点\"></a>2、Set集合特点</h4><ul>\n<li>不包含重复元素的集合</li>\n<li>没有带索引的方法， 所以不能使用普通for循环遍历</li>\n</ul>\n<h4 id=\"3、哈希值\"><a href=\"#3、哈希值\" class=\"headerlink\" title=\"3、哈希值\"></a>3、哈希值</h4><ul>\n<li>哈希值: 是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值</li>\n<li>Object类中有一一个方法可以获取对象的哈希值</li>\n<li>public int <strong>hashCode()</strong>:返回对象的哈希码值</li>\n</ul>\n<h4 id=\"4、对象的哈希值特点\"><a href=\"#4、对象的哈希值特点\" class=\"headerlink\" title=\"4、对象的哈希值特点\"></a>4、对象的哈希值特点</h4><ul>\n<li>同一个对象多次调用hashCode()方法返回的哈希值 是相同的</li>\n<li>默认情况下、不同对象的哈希值是不同的。而重写hashCode()方法, 可以实现让不同对象的哈希值相同</li>\n</ul>\n<h4 id=\"5、HashSet集合特点\"><a href=\"#5、HashSet集合特点\" class=\"headerlink\" title=\"5、HashSet集合特点\"></a>5、HashSet集合特点</h4><ul>\n<li>底层数据结构是 哈希表 ， 元素无序且唯一，可以存储 null元素；</li>\n<li>唯一性是靠所存储元素类型是否重写hashCode()和equals()方法来保证的，如果没有重写这两个方法，则无法保证元素的唯一性。</li>\n<li>对集合的迭代顺序不作任何保证， 也就是说不保证存储和取出的元素顺序一致</li>\n<li>没有带索引的方法， 所以不能使用普通for循环遍历</li>\n<li>线程不安全</li>\n</ul>\n<h4 id=\"6、HashSet的底层实现\"><a href=\"#6、HashSet的底层实现\" class=\"headerlink\" title=\"6、HashSet的底层实现\"></a>6、HashSet的底层实现</h4><p>具体<strong>实现唯一性</strong>的比较过程：存储元素首先会使用hash()算法函数生成一个int类型hashCode散列值，然后已经的所存储的元素的hashCode值比较，<code>如果hashCode不相等，则所存储的两个对象一定不相等</code>，此时存储当前的新的hashCode值处的元素对象；如果hashCode相等，存储元素的对象还是不一定相等，此时会调用equals()方法判断两个对象的内容是否相等，如果内容相等，那么就是同一个对象，无需存储；如果比较的内容不相等，那么就是不同的对象，就该存储了，此时就要采用哈希的解决地址冲突算法，在当前hashCode值处类似一个新的链表， 在同一个hashCode值的后面存储存储不同的对象，这样就保证了元素的唯一性。</p>\n<p>Set的实现类的集合对象中不能够有重复元素，HashSet也一样他是使用了一种标识来确定元素的不重复，HashSet用一种算法来保证HashSet中的元素是不重复的， HashSet采用哈希算法，底层用数组存储数据。默认初始化容量16，加载因子0.75。</p>\n<p>Object类中的hashCode()的方法是所有子类都会继承这个方法，这个方法会用Hash算法算出一个Hash（哈希）码值返回，HashSet会用Hash码值去和数组长度取模， 模（这个模就是对象要存放在数组中的位置）相同时才会判断数组中的元素和要加入的对象的内容是否相同，如果不同才会添加进去。</p>\n<p>Hash算法是一种散列算法。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Set hs&#x3D;new HashSet();\nhs.add(o);</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">* o.hashCode();\n\n  o%当前总容量 (0–15)\n\n* 是否发生冲突\n\n  * 不发生冲突  -------------  直接存放\n\n  * 发生冲突  ------------  o1.equals(o2)\n\n    假（不相等)  -------------  找一个空位添加\n\n    是（相等）-------------  不添加</code></pre>\n\n<p>覆盖hashCode()方法的原则：</p>\n<p>1、一定要让那些我们认为相同的对象返回相同的hashCode值</p>\n<p>2、尽量让那些我们认为不同的对象返回不同的hashCode值，否则，就会增加冲突的概率。</p>\n<p>3、尽量的让hashCode值散列开（两值用<strong>异或</strong>运算可使结果的范围更广）</p>\n<p>HashSet 的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成，我们应该为保存到HashSet中的对象覆盖hashCode()和equals()，因为再将对象加入到HashSet中时，会首先调用hashCode方法计算出对象的hash值，接着根据此hash值调用HashMap中的hash方法，得到的值&amp; (length-1)得到该对象在hashMap的transient Entry[] table中的保存位置的索引，接着找到数组中该索引位置保存的对象，并调用equals方法比较这两个对象是否相等，如果相等则不添加，注意：所以要存入HashSet的集合对象中的自定义类必须覆盖hashCode(),equals()两个方法，才能保证集合中元素不重复。在覆盖equals()和hashCode()方法时， 要使相同对象的hashCode()方法返回相同值，覆盖equals()方法再判断其内容。为了保证效率，所以在覆盖hashCode()方法时， 也要尽量使不同对象尽量返回不同的Hash码值。</p>\n<p>如果数组中的元素和要加入的对象的hashCode()返回了相同的Hash值（相同对象）,才会用equals()方法来判断两个对象的内容是否相同。</p>\n<h4 id=\"7、LinkedHashSet\"><a href=\"#7、LinkedHashSet\" class=\"headerlink\" title=\"7、LinkedHashSet\"></a>7、LinkedHashSet</h4><ul>\n<li>哈希表和链表实现的Set接口, 具有可预测的迭代次序</li>\n<li>由链表保证元素有序， 也就是说元素的存储和取出顺序是一致的</li>\n<li>由哈希表保证元素唯一， 也就是说没有重复的元素</li>\n</ul>\n<h4 id=\"8、TreeSet集合特点\"><a href=\"#8、TreeSet集合特点\" class=\"headerlink\" title=\"8、TreeSet集合特点\"></a>8、TreeSet集合特点</h4><ul>\n<li><p>底层数据结构采用二叉树来实现，元素唯一且已经排好序</p>\n</li>\n<li><p>唯一性同样需要重写hashCode和equals()方法，二叉树结构保证了元素的有序性</p>\n</li>\n<li><p>构造方法不同，分为自然排序（无参构造）和比较器排序（有参构造）</p>\n<ul>\n<li><p>TreeSet(): 根据其元素的自然排序进行排序</p>\n</li>\n<li><p>TreeSet(Comparator comparator) :根据指定的比较器进行排序</p>\n<p>对Comparetor.compare(o1, o2)方法的返回值，</p>\n<p>返回0说明两个对象相同，不需要存储</p>\n</li>\n</ul>\n</li>\n<li><p>比较器排需要在TreeSet初始化是时候传入一个实现Comparator接口的比较器对象，或者采用匿名内部类的方式new一个Comparator对象，重写里面的compare()方法；</p>\n</li>\n<li><p>没有带索引的方法， 所以不能使用普通for循环遍历</p>\n</li>\n</ul>\n<h3 id=\"八、集合的使用技巧\"><a href=\"#八、集合的使用技巧\" class=\"headerlink\" title=\"八、集合的使用技巧\"></a>八、集合的使用技巧</h3><h4 id=\"1、同步和非同步\"><a href=\"#1、同步和非同步\" class=\"headerlink\" title=\"1、同步和非同步\"></a>1、同步和非同步</h4><ul>\n<li>明确具体集合名称的所属后缀，后缀是list和set的，属于list和set体系，通常为非同步。</li>\n<li>后缀不是所属接口名的，一般是同步的，如vector</li>\n</ul>\n<h4 id=\"2、集合的数据结构\"><a href=\"#2、集合的数据结构\" class=\"headerlink\" title=\"2、集合的数据结构\"></a>2、集合的数据结构</h4><ul>\n<li>前缀是数据结构，后缀是所属体系</li>\n<li>例如：ArrayList，Array明确是数组结构，查询快</li>\n<li>array：数组，查询快，有角标。 </li>\n<li>link：链表，增删快，就要想到 add get remove+first last 的方法。</li>\n<li>hash：哈希表，唯一性，就要想到 hashcode 和 equals </li>\n<li>tree：排序，二叉树，就要想到 comparable 和 comparator </li>\n<li>通常这些常用的是线程不安全的。</li>\n</ul>\n<h4 id=\"3、需要唯一嘛\"><a href=\"#3、需要唯一嘛\" class=\"headerlink\" title=\"3、需要唯一嘛\"></a>3、需要唯一嘛</h4><ul>\n<li>元素需要唯一：Set<ul>\n<li>需要制定顺序：TreeSet</li>\n<li>不需要指定顺序：HashSet</li>\n<li>想要存储顺序一致的：LinkedList</li>\n</ul>\n</li>\n<li>元素不需要唯一：List<ul>\n<li>需要频繁增删改：LinkedList</li>\n<li>不需要：ArrayList</li>\n</ul>\n</li>\n</ul>\n","text":"一、为什么使用集合为什么我们不采用数组存对象呢？ 因为数组长度是固定，而我们很多时候对对象的个数是 不确定的。 所以，我们产生了集合框架，它是用于存储对象的。 二、集合和数组的区别 集合长度是可变的，集合中不能存储基本数据类型值，只能存储对象(引用数据类型)。 数组的长度是固定的...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/tags/JavaSE.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88\"><span class=\"toc-text\">一、为什么使用集合</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">二、集合和数组的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">三、集合的体系结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E6%B3%9B%E5%9E%8B\"><span class=\"toc-text\">四、泛型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1、基本和引用数据类型区别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">2、泛型的概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84\"><span class=\"toc-text\">3、泛型的好处</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">4、泛型类的定义格式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%E3%80%81%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6\"><span class=\"toc-text\">5、类型通配符</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81collection%E9%9B%86%E5%90%88\"><span class=\"toc-text\">五、collection集合</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%B3%A8%E6%84%8F\"><span class=\"toc-text\">1、注意</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81collection%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">2、collection集合概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%88%9B%E5%BB%BAcollection%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">3、创建collection对象</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81collection%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">4、collection接口的方法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81List%E9%9B%86%E5%90%88\"><span class=\"toc-text\">六、List集合</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%B3%A8%E6%84%8F-1\"><span class=\"toc-text\">1、注意</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81List%E9%9B%86%E5%90%88%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">2、List集合的特点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81List%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">3、List集合的方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">4、常见数据结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%E3%80%81List-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AD%90%E7%B1%BB\"><span class=\"toc-text\">5、List 接口的子类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6%E3%80%81List%E9%9B%86%E5%90%88%E5%AD%90%E7%B1%BB%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">6、List集合子类特点</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%83%E3%80%81Set%E9%9B%86%E5%90%88\"><span class=\"toc-text\">七、Set集合</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81Set%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E5%92%8C%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">1、Set集合概述和特点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81Set%E9%9B%86%E5%90%88%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">2、Set集合特点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%93%88%E5%B8%8C%E5%80%BC\"><span class=\"toc-text\">3、哈希值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">4、对象的哈希值特点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%E3%80%81HashSet%E9%9B%86%E5%90%88%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">5、HashSet集合特点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6%E3%80%81HashSet%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">6、HashSet的底层实现</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7%E3%80%81LinkedHashSet\"><span class=\"toc-text\">7、LinkedHashSet</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8%E3%80%81TreeSet%E9%9B%86%E5%90%88%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">8、TreeSet集合特点</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AB%E3%80%81%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7\"><span class=\"toc-text\">八、集合的使用技巧</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%90%8C%E6%AD%A5%E5%92%8C%E9%9D%9E%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">1、同步和非同步</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E9%9B%86%E5%90%88%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">2、集合的数据结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E9%9C%80%E8%A6%81%E5%94%AF%E4%B8%80%E5%98%9B\"><span class=\"toc-text\">3、需要唯一嘛</span></a></li></ol></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"集合（下）","uid":"88ccd4775101a2a1232ec4d83ea6f5c4","slug":"12-集合（下）","date":"2021-09-13T14:47:32.000Z","updated":"2021-09-14T15:54:58.927Z","comments":true,"path":"api/articles/12-集合（下）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"一、Collections 要点 工具类，随机排序方法shuffle，，反转元素方法reverse以及升序排序方法sort collection：单列集合的父接口 collections：他是集合操作的一种 工具类，类中的方法全部是静态的，可以进行查找，排序等操作 Collect...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/tags/JavaSE.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"异常处理","uid":"5a74204f11299c4fc6660b81cabe549b","slug":"10-异常处理","date":"2021-09-13T14:45:32.000Z","updated":"2021-09-14T16:00:17.234Z","comments":true,"path":"api/articles/10-异常处理.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog10.png","text":"一、概述在使用计算机语言进行项目开发的过程中，即使程序员把代码写得尽善尽美，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避免的，比如：客户输入数据的格式，读取文件是否存在，网络是否始终保持通畅等等。 异常的出现就是为了记录程序在执行过程中，出现的非正常的情况，...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/tags/JavaSE.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}