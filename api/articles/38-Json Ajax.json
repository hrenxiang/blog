{"title":"Json Ajax","uid":"cf8cafd4cf1868b0ac65896e606a4625","slug":"38-Json Ajax","date":"2021-09-13T15:14:32.000Z","updated":"2021-09-15T10:28:40.121Z","comments":true,"path":"api/articles/38-Json Ajax.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","content":"<h4 id=\"beginner-​Json\"><a href=\"#beginner-​Json\" class=\"headerlink\" title=\":beginner: ​Json\"></a>:beginner: ​Json</h4><h4 id=\"①-json-的定义\"><a href=\"#①-json-的定义\" class=\"headerlink\" title=\"① json 的定义\"></a>① json 的定义</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">1. json 是由键值对组成，并且由 花括号（大括号）包围。\n\n2. 每个键由引号引起来，键和值之间使用 冒号进行分隔， 多组键值对之间进行 逗号进行分隔。\n\n例子♥: \n&#123;  &quot;name&quot;:&quot;json学习笔记&quot;，\n\n   &quot;author&quot;:&quot;Fred&quot;,\n\n   &quot;content&quot;:[&quot;json基础入门&quot;，&quot;json解析&quot;]\n\n   &quot;time&quot;:&#123;\n          &quot;value&quot;:30,\n          &quot;unit&quot;:&quot;分钟&quot;\n          &#125;\n&#125;</code></pre>\n\n<p>==注意：使用vue时，如果想让文本框中不自动渲染数字，那就用null表示==</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">data: &#123;\n            fname: &quot;&quot;,\n            price: null,\n            fcount: null,\n            remark: &quot;&quot;\n        &#125;</code></pre>\n\n<h4 id=\"②-json-的访问\"><a href=\"#②-json-的访问\" class=\"headerlink\" title=\"② json 的访问\"></a>② json 的访问</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">1. json 本身是一个对象。 json 中的 key 我们可以理解为是对象中的一个属性。 \n\n2. json 中的 key 访问就跟访问对象的属性一样： json 对象.key</code></pre>\n\n<h4 id=\"③-json-的两个常用方法\"><a href=\"#③-json-的两个常用方法\" class=\"headerlink\" title=\"③ json 的两个常用方法\"></a>③ json 的两个常用方法</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">1. json 的存在有两种形式。\n\n   * 一种是：对象的形式存在，我们叫它 json 对象。 \n\n   * 一种是：字符串的形式存在，我们叫它 json 字符串。 \n\n2. 一般我们要操作 json 中的数据的时候，需要 json 对象的格式。 一般我们要在客户端和服务器之间进行数据交换的时候，使用 json 字符串。 \n\n   * JSON.stringify() \t把 json 对象转换成为 json 字符串 \n   * JSON.parse()       把 json 字符串转换成为 json 对象\n   \n3. 可以使用eval来转换JSON字符到Object\n   * function myEval() &#123; \n\t var str &#x3D; &#39;&#123; &quot;name&quot;: &quot;Violet&quot;, &quot;occupation&quot;: &quot;character&quot; &#125;&#39;; \n \t var obj &#x3D; eval(&#39;(&#39; + str + &#39;)&#39;); \n\t alert(obj.toJSONString()); \n\t &#125; </code></pre>\n\n<h4 id=\"④-json-在java中的使用\"><a href=\"#④-json-在java中的使用\" class=\"headerlink\" title=\"④ json 在java中的使用\"></a>④ json 在java中的使用</h4><p>1.javaBean 和 json 的互转</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Test\npublic void javaBeanToJson() &#123;\n\n    student student &#x3D; new student(&quot;hh&quot;, 31);\n\n    Gson gson &#x3D; new Gson();\n\n    &#x2F;&#x2F;由javaBean对象转换为 json对象\n    String s &#x3D; gson.toJson(student);\n\n    System.out.println(s);\n\n    &#x2F;&#x2F;由json对象转换为 javaBean对象\n    com.bean.student student1 &#x3D; gson.fromJson(s, student.getClass());\n    System.out.println(student1);\n    System.out.println(student.getClass());\n\n&#125;</code></pre>\n\n<p>2.List 和 json 的互转</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Test\n    public void test2() &#123;\n\n        List&lt;student&gt; list &#x3D; new ArrayList&lt;student&gt;();\n\n        list.add(new student(&quot;hh&quot;, 21));\n        list.add(new student(&quot;ff&quot;, 22));\n\n        Gson gson &#x3D; new Gson();\n\n        String s &#x3D; gson.toJson(list);\n\n        System.out.println(s);\n\n        List&lt;student&gt; ss &#x3D; gson.fromJson(s, new TypeToken&lt;ArrayList&lt;student&gt;&gt;() &#123;\n        &#125;.getType());\n\n        student s1 &#x3D; ss.get(0);\n\n        System.out.println(s1);\n    &#125;</code></pre>\n\n<p>3.Map 和 json 的互转</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Test\n    public void test3() &#123;\n\n        Map&lt;Integer, student&gt; map &#x3D; new HashMap&lt;&gt;();\n\n        map.put(1, new student(&quot;hh&quot;, 21));\n        map.put(2, new student(&quot;gg&quot;, 22));\n\n        System.out.println(map);\n\n        Gson gson &#x3D; new Gson();\n\n        String s &#x3D; gson.toJson(map);\n\n        System.out.println(s);\n\n        Map&lt;Integer, student&gt; map1 &#x3D; gson.fromJson(s, new TypeToken&lt;HashMap&lt;Integer, student&gt;&gt;() &#123;\n        &#125;.getType());\n\n        System.out.println(map1.get(1));\n\n        Type type &#x3D; new TypeToken&lt;HashMap&lt;Integer, student&gt;&gt;() &#123;\n        &#125;.getType();\n\n        System.out.println(type);&#x2F;&#x2F;结果为:java.util.HashMap&lt;java.lang.Integer, com.bean.student&gt;\n    &#125;</code></pre>\n\n\n\n<h4 id=\"beginner-Ajax\"><a href=\"#beginner-Ajax\" class=\"headerlink\" title=\":beginner: Ajax\"></a>:beginner: Ajax</h4><h4 id=\"①-什么是ajax\"><a href=\"#①-什么是ajax\" class=\"headerlink\" title=\"① 什么是ajax\"></a>① 什么是ajax</h4><pre><code>AJAX 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的 网页开发技术。 \n\najax 是一种浏览器异步发起请求。局部更新页面的技术。\n</code></pre>\n<h4 id=\"②-不同浏览器的支持\"><a href=\"#②-不同浏览器的支持\" class=\"headerlink\" title=\"② 不同浏览器的支持\"></a>② 不同浏览器的支持</h4><p>现代浏览器中, 虽然几乎全部支持ajax, 但它们的技术方案却分为两种:</p>\n<p>① 标准浏览器通过 <code>XMLHttpRequest</code> 对象实现了ajax的功能. 只需要通过一行语句便可创建一个用于发送ajax请求的对象.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var xhr &#x3D; new XMLHttpRequest();复制代码</code></pre>\n\n<p>② IE浏览器通过 <code>XMLHttpRequest</code> 或者 <code>ActiveXObject</code> 对象同样实现了ajax的功能.</p>\n<h4 id=\"③-全兼容的XMLHttpRequest\"><a href=\"#③-全兼容的XMLHttpRequest\" class=\"headerlink\" title=\"③ 全兼容的XMLHttpRequest\"></a>③ 全兼容的XMLHttpRequest</h4><pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">var xmlHttpRequest &#x3D; null;\n\nfunction createXmlHttpRequest() &#123;\n    if (window.XMLHttpRequest) &#123;&#x2F;&#x2F; 兼容 IE7+, Firefox, Chrome, Opera, Safari\n        xmlHttpRequest &#x3D; new XMLHttpRequest();\n    &#125; else if (window.ActiveXObject) &#123;&#x2F;&#x2F;\n        try &#123;\n            xmlHttpRequest &#x3D; new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);\n        &#125; catch (e) &#123;\n            xmlHttpRequest &#x3D; new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);\n        &#125;\n    &#125;\n&#125;\n\nfunction checkUname(uname) &#123;\n\n    createXmlHttpRequest();\n\n    xmlHttpRequest.open(&quot;post&quot;, &quot;user.do&quot;, true);\n    xmlHttpRequest.setRequestHeader(&quot;Content-type&quot;, &quot;application&#x2F;x-www-form-urlencoded&quot;);\n\n    xmlHttpRequest.onreadystatechange &#x3D; function checkUnameCB&#x2F;*触发的回调函数*&#x2F;() &#123;\n        &#x2F;*if (xmlHttpRequest.readyState &#x3D;&#x3D; 4 &amp;&amp; xmlHttpRequest.status &#x3D;&#x3D; 200) &#123;\n            var responseText &#x3D; xmlHttpRequest.responseText;\n            var flagObj &#x3D; JSON.parse(responseText);\n            if (flagObj.uname !&#x3D; &quot;ok&quot;) &#123;\n                if (flagObj.flag) &#123;\n                    get(&quot;unameErrMess&quot;).innerText &#x3D; &#39;可被注册&#39;;\n                    get(&quot;unameErrMess&quot;).style.color &#x3D; &quot;green&quot;;\n                &#125; else &#123;\n                    get(&quot;unameErrMess&quot;).innerText &#x3D; &#39;已被注册&#39;;\n                    get(&quot;unameErrMess&quot;).style.color &#x3D; &quot;red&quot;;\n                &#125;\n            &#125;else &#123;\n                get(&quot;unameErrMess&quot;).innerText &#x3D; &#39;&#39;;\n                get(&quot;unameErrMess&quot;).style.color &#x3D; &quot;white&quot;;\n            &#125;\n        &#125;*&#x2F;\n        \n        就是注释部分的方法体（两端互通后要做的事）\n    &#125;;\n\n    xmlHttpRequest.send(&quot;oper&#x3D;checkUname&amp;uname&#x3D;&quot; + uname);\n&#125;\n\n&#x2F;*function get(id) &#123;\n    return document.getElementById(id);\n&#125;*&#x2F;</code></pre>\n\n<h4 id=\"④-GET和POST请求数据区别\"><a href=\"#④-GET和POST请求数据区别\" class=\"headerlink\" title=\"④ GET和POST请求数据区别\"></a>④ GET和POST请求数据区别</h4><ul>\n<li>使用Get请求时,参数在URL中显示,而使用Post方式,则放在send里面</li>\n<li>使用Get请求发送数据量小,Post请求发送数据量大</li>\n<li>使用Get请求安全性低，会被缓存，而Post请求反之 关于第一点区别，详情见下面两张图：</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/18/167bcf83ea7b3fbb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/18/167bcf7bd65db770?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\"></p>\n<h4 id=\"⑤-ajax没有破坏js单线程机制\"><a href=\"#⑤-ajax没有破坏js单线程机制\" class=\"headerlink\" title=\"⑤ ajax没有破坏js单线程机制\"></a>⑤ ajax没有破坏js单线程机制</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">对于这个问题, 我们先看下浏览器线程机制. 一般情况下, 浏览器有如下四种线程:\n\n* GUI渲染线程\n* javascript引擎线程\n* 浏览器事件触发线程\n* HTTP请求线程\n\n那么这么多线程, 它们究竟是怎么同js引擎线程交互的呢?\n\n通常, 它们的线程间交互以事件的方式发生, 通过事件回调的方式予以通知. 而事件回调, 又是以先进先出的方式添加到&#96;任务队列&#96; 的末尾 , 等到js引擎空闲时, &#96;任务队列&#96; 中排队的任务将会依次被执行. 这些事件回调包括 setTimeout, setInterval, click, ajax异步请求等回调.\n\n整个ajax请求过程中, 有涉及到浏览器的4种线程. 其中除了 GUI渲染线程 和 js引擎线程 是互斥的. 其他线程相互之间, 都是可以并行执行的. 通过这样的一种方式, ajax并没有破坏js的单线程机制.</code></pre>\n\n<h4 id=\"⑥-XMLHttpRequest-属性\"><a href=\"#⑥-XMLHttpRequest-属性\" class=\"headerlink\" title=\"⑥ XMLHttpRequest 属性\"></a>⑥ XMLHttpRequest 属性</h4><h5 id=\"1-readyState\"><a href=\"#1-readyState\" class=\"headerlink\" title=\"1. readyState\"></a>1. readyState</h5><p>只读属性, readyState属性记录了ajax调用过程中所有可能的状态. 它的取值简单明了, 如下:</p>\n<table>\n<thead>\n<tr>\n<th>readyState</th>\n<th>对应常量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0 (未初始化)</td>\n<td>xhr.UNSENT</td>\n<td>请求已建立, 但未初始化(此时未调用open方法)</td>\n</tr>\n<tr>\n<td>1 (初始化)</td>\n<td>xhr.OPENED</td>\n<td>请求已建立, 但未发送 (已调用open方法, 但未调用send方法)</td>\n</tr>\n<tr>\n<td>2 (发送数据)</td>\n<td>xhr.HEADERS_RECEIVED</td>\n<td>请求已发送 (send方法已调用, 已收到响应头)</td>\n</tr>\n<tr>\n<td>3 (数据传送中)</td>\n<td>xhr.LOADING</td>\n<td>请求处理中, 因响应内容不全, 这时通过responseBody和responseText获取可能会出现错误</td>\n</tr>\n<tr>\n<td>4 (完成)</td>\n<td>xhr.DONE</td>\n<td>数据接收完毕, 此时可以通过通过responseBody和responseText获取完整的响应数据</td>\n</tr>\n</tbody></table>\n<p>注意, readyState 是一个只读属性, 想要改变它的值是不可行的.</p>\n<h5 id=\"2-status\"><a href=\"#2-status\" class=\"headerlink\" title=\"2. status\"></a>2. status</h5><p>只读属性, status表示http请求的状态, 初始值为0. 如果服务器没有显式地指定状态码, 那么status将被设置为默认值, 即200.</p>\n<h5 id=\"3-statusText\"><a href=\"#3-statusText\" class=\"headerlink\" title=\"3. statusText\"></a>3. statusText</h5><p>只读属性, statusText表示服务器的响应状态信息, 它是一个 UTF-16 的字符串, 请求成功且status==20X时, 返回大写的 <code>OK</code> . 请求失败时返回空字符串. 其他情况下返回相应的状态描述. 比如: 301的 <code>Moved Permanently</code> , 302的 <code>Found</code> , 303的 <code>See Other</code> , 307 的 <code>Temporary Redirect</code> , 400的 <code>Bad Request</code> , 401的 <code>Unauthorized</code> 等等.</p>\n<h5 id=\"4-onreadystatechange\"><a href=\"#4-onreadystatechange\" class=\"headerlink\" title=\"4. onreadystatechange\"></a>4. onreadystatechange</h5><p>onreadystatechange事件回调方法在readystate状态改变时触发, 在一个收到响应的ajax请求周期中, onreadystatechange 方法会被触发4次. 因此可以在 onreadystatechange 方法中绑定一些事件回调, 比如:</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">xmlHttpRequest.onreadystatechange &#x3D; function checkUnameCB&#x2F;*触发的回调函数*&#x2F;() &#123;\n    if (xmlHttpRequest.readyState &#x3D;&#x3D; 4 &amp;&amp; xmlHttpRequest.status &#x3D;&#x3D; 200) &#123;\n        var responseText &#x3D; xmlHttpRequest.responseText;\n        var flagObj &#x3D; JSON.parse(responseText);\n        if (flagObj.uname !&#x3D; &quot;ok&quot;) &#123;\n            if (flagObj.flag) &#123;\n                get(&quot;unameErrMess&quot;).innerText &#x3D; &#39;可被注册&#39;;\n                get(&quot;unameErrMess&quot;).style.color &#x3D; &quot;green&quot;;\n            &#125; else &#123;\n                get(&quot;unameErrMess&quot;).innerText &#x3D; &#39;已被注册&#39;;\n                get(&quot;unameErrMess&quot;).style.color &#x3D; &quot;red&quot;;\n            &#125;\n        &#125;else &#123;\n            get(&quot;unameErrMess&quot;).innerText &#x3D; &#39;&#39;;\n            get(&quot;unameErrMess&quot;).style.color &#x3D; &quot;white&quot;;\n        &#125;\n    &#125;</code></pre>\n\n<h4 id=\"⑦-ajax\"><a href=\"#⑦-ajax\" class=\"headerlink\" title=\"⑦ $.ajax\"></a>⑦ $.ajax</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">$.ajax是jquery对原生ajax的一次封装. 通过封装ajax, jquery抹平了不同版本浏览器异步http的差异性, 取而代之的是高度统一的api. jquery作为js类库时代的先驱, 对前端发展有着深远的影响. 了解并熟悉其ajax方法, 不可谓不重要.</code></pre>\n\n<h5 id=\"1-参数列表\"><a href=\"#1-参数列表\" class=\"headerlink\" title=\"1. 参数列表\"></a>1. 参数列表</h5><p>$.ajax() 只有一个参数, 该参数为key-value设置对象. 实际上, jq发送的所有ajax请求, 都是通过调用该ajax方法实现的. 它的详细参数如下表:</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>参数</th>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td><strong>accepts</strong></td>\n<td><em>PlainObject</em></td>\n<td>用于通知服务器该请求需要接收何种类型的返回结果. 如有必要, 推荐在 <code>$.ajaxSetup()</code> 方法中设置一次.</td>\n</tr>\n<tr>\n<td>2</td>\n<td><strong>async</strong></td>\n<td><em>Boolean</em></td>\n<td>默认为true, 即异步.</td>\n</tr>\n<tr>\n<td>3</td>\n<td><strong>beforeSend</strong></td>\n<td><em>Function</em></td>\n<td>请求发送前的回调, 默认传入参数jqXHR和settings. 函数内显式返回false将取消本次请求.</td>\n</tr>\n<tr>\n<td>4</td>\n<td><strong>cache</strong></td>\n<td><em>Boolean</em></td>\n<td>请求是否开启缓存, 默认为true, 如不需要缓存请设置为false. 不过, dataType为”script”和”jsonp”时默认为false.</td>\n</tr>\n<tr>\n<td>5</td>\n<td><strong>complete</strong></td>\n<td><em>Function</em></td>\n<td>请求完成后的回调(请求<code>success</code> 和 <code>error</code>之后均调用), 默认传入参数jqXHR和textStatus(请求状态, 取值为 “success”,”notmodified”,”error”,”timeout”,”abort”,”parsererror”之一). 从jq1.5开始, complete可以设置为一个包含函数的数组. 如此每个函数将依次被调用.</td>\n</tr>\n<tr>\n<td>6</td>\n<td><strong>contents</strong></td>\n<td><em>PlainObject</em></td>\n<td>一个以”{字符串/正则表达式}”配对的对象, 根据给定的内容类型, 解析请求的返回结果.</td>\n</tr>\n<tr>\n<td>7</td>\n<td><strong>contentType</strong></td>\n<td><em>String</em></td>\n<td>编码类型, 相对应于http请求头域的”Content-Type”字段. 默认值为”application/x-www-form-urlencoded; charset=UTF-8”.</td>\n</tr>\n<tr>\n<td>8</td>\n<td><strong>context</strong></td>\n<td><em>Object</em></td>\n<td>设置ajax回调函数的上下文. 默认上下文为ajax请求传入的参数设置对象. 如设置为document.body, 那么所有ajax回调函数中将以body为上下文.</td>\n</tr>\n<tr>\n<td>9</td>\n<td><strong>converters</strong></td>\n<td><em>PlainObject</em></td>\n<td>一个数据类型到数据类型转换器的对象. 默认为 <code>&#123;&quot;* text&quot;: window.String, &quot;text html&quot;: true, &quot;text json&quot;: jQuery.parseJSON, &quot;text xml&quot;: jQuery.parseXML&#125;</code> . 如设置<code>converters:&#123;&quot;json jsonp&quot;: function(msg)&#123;&#125;&#125;</code></td>\n</tr>\n<tr>\n<td>10</td>\n<td><strong>crossDomain</strong></td>\n<td><em>Boolean</em></td>\n<td>默认同域请求为false, 跨域请求为true.</td>\n</tr>\n<tr>\n<td>11</td>\n<td><strong>data</strong></td>\n<td><em>Object, Array</em></td>\n<td>发送到服务器的数据, 默认data为键值对格式对象, 若data为数组则按照<code>traditional</code>参数的值, 自动转化为一个同名的多值查询字符串. 如{a:1,b:2}将转换为”&amp;a=1&amp;b=2”.</td>\n</tr>\n<tr>\n<td>12</td>\n<td><strong>dataFilter</strong></td>\n<td><em>Function</em></td>\n<td>处理XMLHttpRequest原始响应数据的回调, 默认传入data和type参数, data是Ajax返回的原始数据, type是调用$.ajax时提供的dataType参数</td>\n</tr>\n<tr>\n<td>13</td>\n<td><strong>dataTyp</strong></td>\n<td><em>String</em></td>\n<td>预期服务器返回的数据类型, 可设置为”xml”,”html”,”script”,”json”,”jsonp”,”text”之一, 其中设置为”xml”或”text”类型时, 数据不会经过处理.</td>\n</tr>\n<tr>\n<td>14</td>\n<td><strong>error</strong></td>\n<td><em>Function</em></td>\n<td>请求失败时的回调函数, 默认传入jqXHR(jq1.4以前为原生xhr对象),textStatus(请求状态,取值为null,”timeout”,”error”,”abort” 或 “parsererror”),errorString(错误内容), 当一个HTTP错误发生时, <code>errorThrown</code> 接收HTTP状态的文本部分,比如”Not Found”等. 从jq1.5开始, error可以设置为一个包含函数的数组. 如此每个函数将依次被调用.注意: 跨域脚本和JSONP请求时error不被调用.</td>\n</tr>\n<tr>\n<td>15</td>\n<td><strong>global</strong></td>\n<td><em>Boolean</em></td>\n<td>表示是否触发全局ajax事件, 默认为true. 设为false将不再触发ajaxStart,ajaxStop,ajaxSend,ajaxError等. 跨站脚本和jsonp请求, 该值自动设置为false.</td>\n</tr>\n<tr>\n<td>16</td>\n<td><strong>headers</strong></td>\n<td><em>PlainObject</em></td>\n<td>设置请求头, 格式为k-v键值对对象. 由于该设置会在beforeSend函数被调用之前生效, 因此可在beforeSend函数内覆盖该对象.</td>\n</tr>\n<tr>\n<td>17</td>\n<td><strong>ifModified</strong></td>\n<td><em>Boolean</em></td>\n<td>只有上次请求响应改变时, 才允许请求成功. 它使用HTTP包的Last-Modified 头信息判断, 默认为false. 若设置为true, 且数据自从上次请求后没有更改过就会报错.</td>\n</tr>\n<tr>\n<td>18</td>\n<td><strong>isLocal</strong></td>\n<td><em>Boolean</em></td>\n<td>运行当前环境设置为”本地”,默认为false, 若设置为true, 将影响请求发送时的协议.</td>\n</tr>\n<tr>\n<td>19</td>\n<td><strong>jsonp</strong></td>\n<td><em>String</em></td>\n<td>显式指定jsonp请求中的回调函数的名称. 如jsonp:cb, jq会将cb代替callback, 以 “cb=?”传给服务器. 从jq1.5开始, 若设置jsonp:false, 那么需要明确设置jsonpCallback:”callbackName”.</td>\n</tr>\n<tr>\n<td>20</td>\n<td><strong>jsonpCallback</strong></td>\n<td><em>String,Function</em></td>\n<td>为jsonp请求指定一个回调函数名, 以取代jq自动生成的随机函数名. 从jq1.5开始, 可以将该属性设置为一个函数, 函数的返回值就是jsonpCallback的结果.</td>\n</tr>\n<tr>\n<td>21</td>\n<td><strong>mimeType</strong></td>\n<td><em>String</em></td>\n<td>设置一个MIME类型, 以覆盖xhr的MIM类型(jq1.5新增)</td>\n</tr>\n<tr>\n<td>22</td>\n<td><strong>password</strong></td>\n<td><em>String</em></td>\n<td>设置认证请求中的密码</td>\n</tr>\n<tr>\n<td>23</td>\n<td><strong>processData</strong></td>\n<td><em>Boolean</em></td>\n<td>jq的ajax方法默认会将传入的data隐式转换为查询字符串(如”&amp;a=1&amp;b=2”), 以配合 默认内容类型 “application/x-www-form-urlencoded”, 如果不希望转换请设置为false. angular中想要禁用默认转换, 需要重写transformRequest方法.</td>\n</tr>\n<tr>\n<td>24</td>\n<td><strong>scriptCharset</strong></td>\n<td><em>String</em></td>\n<td>仅在”script”请求中使用(如跨域jsonp, dataType为”script”类型). 显式指定时, 请求中将在script标签上设置<code>charset</code>属性, 可在发现本地和远程编码不一致时使用.</td>\n</tr>\n<tr>\n<td>25</td>\n<td><strong>statusCode</strong></td>\n<td><em>PlainObject</em></td>\n<td>一组http状态码和回调函数对应的键值对对象. 该对象以 {404:function(){}} 这种形式表示. 可用于根据不同的http状态码, 执行不同的回调.(jq1.5新增)</td>\n</tr>\n<tr>\n<td>26</td>\n<td><strong>timeout</strong></td>\n<td><em>Number</em></td>\n<td>设置超时时间.</td>\n</tr>\n<tr>\n<td>27</td>\n<td><strong>traditional</strong></td>\n<td><em>Boolean</em></td>\n<td>是否按照默认方式序列化data对象, 默认值为false.</td>\n</tr>\n<tr>\n<td>28</td>\n<td><strong>type</strong></td>\n<td><em>String</em></td>\n<td>可以设置为8种http method之一, jq中不区分大小写.</td>\n</tr>\n<tr>\n<td>29</td>\n<td><strong>url</strong></td>\n<td><em>String</em></td>\n<td>请求的uri地址.</td>\n</tr>\n<tr>\n<td>30</td>\n<td><strong>username</strong></td>\n<td><em>String</em></td>\n<td>设置认证请求中的用户名</td>\n</tr>\n<tr>\n<td>31</td>\n<td><strong>xhr</strong></td>\n<td><em>Function</em></td>\n<td>在回调内创建并返回xhr对象</td>\n</tr>\n<tr>\n<td>32</td>\n<td><strong>xhrField</strong></td>\n<td><em>PlainObject</em></td>\n<td>键值对对象, 用于设置原生的xhr对象, 如可用来设置withCredentials:true(jq1.5.1新增</td>\n</tr>\n</tbody></table>\n<h5 id=\"2-支持promise\"><a href=\"#2-支持promise\" class=\"headerlink\" title=\"2. 支持promise\"></a>2. 支持promise</h5><h5 id=\"3-使用转换器\"><a href=\"#3-使用转换器\" class=\"headerlink\" title=\"3. 使用转换器\"></a>3. 使用转换器</h5><h5 id=\"4-事件触发顺序\"><a href=\"#4-事件触发顺序\" class=\"headerlink\" title=\"4. 事件触发顺序\"></a>4. 事件触发顺序</h5><h4 id=\"beginner-Axios\"><a href=\"#beginner-Axios\" class=\"headerlink\" title=\":beginner: Axios\"></a>:beginner: Axios</h4><h4 id=\"①-概述\"><a href=\"#①-概述\" class=\"headerlink\" title=\"① 概述\"></a>① 概述</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">实际上, 如果你仅仅只是想要一个不错的http库, 相比于庞大臃肿的jquery, 短小精悍的Axios可能更加适合你. 原因如下:\n\n* Axios支持node, jquery并不支持.\n* Axios基于promise语法, jq3.0才开始全面支持.\n* Axios短小精悍, 更加适合http场景, jquery大而全, 加载较慢.\n* vue作者尤大放弃推荐vue-resource, 转向推荐Axios. 以下为尤大原话.\n&quot;最近团队讨论了一下, Ajax 本身跟 Vue 并没有什么需要特别整合的地方, 使用 fetch polyfill 或是 axios、superagent 等等都可以起到同等的效果, vue-resource 提供的价值和其维护成本相比并不划算, 所以决定在不久以后取消对 vue-resource 的官方推荐.&quot;</code></pre>\n\n<p>Axios大小仅12k, 目前最新版本号为: <a href=\"https://www.npmjs.org/package/axios\"><img src=\"https://camo.githubusercontent.com/1f22b6c297d1cb0e3aa68b2e6fed42da8b002bbefca8d63e99e0b790da8cce9b/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f6178696f732e7376673f7374796c653d666c61742d737175617265\" alt=\"img\">npm version</a></p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">语法上Axios基本就和promise一样, 在then方法中处理回调, 在catch方法中处理异常. 如下:\n\naxios.get(&quot;https:&#x2F;&#x2F;api.github.com&#x2F;users&#x2F;louiszhai&quot;)\n  .then(function(response)&#123;\n    console.log(response);\n  &#125;)\n  .catch(function (error) &#123;\n    console.log(error);\n  &#125;);\n  \n除了get, 它还支持post, delete, head, put, patch, request请求. </code></pre>\n\n<p>除了get, 它还支持post, delete, head, put, patch, request请求. </p>\n<h4 id=\"②-使用\"><a href=\"#②-使用\" class=\"headerlink\" title=\"② 使用\"></a>② 使用</h4><pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">使用Axios和使用Vue一样，导入对应的*.js文件即可。官方提供的script标签引入方式为：\n\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;axios&#x2F;dist&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;\n\n我们可以把这个axios.min.js文件下载下来保存到本地来使用。</code></pre>\n\n<h4 id=\"③-基本用法\"><a href=\"#③-基本用法\" class=\"headerlink\" title=\"③ 基本用法\"></a>③ 基本用法</h4><h5 id=\"1-前端页面引入环境\"><a href=\"#1-前端页面引入环境\" class=\"headerlink\" title=\"1. 前端页面引入环境\"></a>1. 前端页面引入环境</h5><pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;demo&#x2F;static&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;demo&#x2F;static&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;</code></pre>\n\n<h5 id=\"2-发送普通请求参数\"><a href=\"#2-发送普通请求参数\" class=\"headerlink\" title=\"2. 发送普通请求参数\"></a>2. 发送普通请求参数</h5><h6 id=\"2-1-前端代码\"><a href=\"#2-1-前端代码\" class=\"headerlink\" title=\"2.1 前端代码\"></a>2.1 前端代码</h6><p>HTML标签：</p>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;button @click&#x3D;&quot;commonParam&quot;&gt;普通请求参数&lt;&#x2F;button&gt;\n&lt;&#x2F;div&gt;</code></pre>\n\n<p>Vue+axios代码：</p>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;script&gt;\nvar vue &#x3D; new Vue(&#123;\n    &quot;el&quot;:&quot;#app&quot;,\n    &quot;data&quot;:&#123;\n        &quot;message&quot;:&quot;&quot;\n    &#125;,\n    &quot;methods&quot;:&#123;\n        commonParam()&#123;\n            &#x2F;&#x2F;使用axios发送异步请求\n            axios(&#123;\n                &quot;method&quot;:&quot;post&quot;,\n                &quot;url&quot;:&quot;demo01&quot;,\n                &quot;params&quot;:&#123;\n                    &quot;userName&quot;:&quot;tom&quot;,\n                    &quot;userPwd&quot;:&quot;123456&quot;\n                &#125;\n            &#125;).then(response &#x3D;&gt; &#123;\n                &#x2F;&#x2F;then里面是处理请求成功的响应数据\n                &#x2F;&#x2F;response就是服务器端的响应数据,是json类型的\n                &#x2F;&#x2F;response里面的data就是响应体的数据\n                this.message &#x3D; response.data\n            &#125;).catch(error &#x3D;&gt; &#123;\n                &#x2F;&#x2F;error是请求失败的错误描述\n                &#x2F;&#x2F;error.response就是请求失败时候的响应信息\n                console.log(error.response)\n            &#125;)\n        &#125;\n    &#125;\n&#125;)\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>效果：所有请求参数都被放到URL地址后面了，哪怕我们现在用的是POST请求方式。</p>\n<h6 id=\"2-2-后端代码\"><a href=\"#2-2-后端代码\" class=\"headerlink\" title=\"2.2 后端代码\"></a>2.2 后端代码</h6><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.servlet;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n&#x2F;**\n * @author Leevi\n * 日期2021-05-21  09:15\n *&#x2F;\npublic class ServletDemo01 extends HttpServlet &#123;\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        doGet(request, response);\n    &#125;\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        request.setCharacterEncoding(&quot;UTF-8&quot;);\n        response.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);\n        &#x2F;&#x2F;1. 接收请求参数userName和userPwd\n        String userName &#x3D; request.getParameter(&quot;userName&quot;);\n        String userPwd &#x3D; request.getParameter(&quot;userPwd&quot;);\n        System.out.println(userName + &quot;:&quot; + userPwd);\n\n        &#x2F;&#x2F;模拟出现异常\n        &#x2F;&#x2F;int num &#x3D; 10&#x2F;0;\n\n        &#x2F;&#x2F;2. 向浏览器响应数据\n        response.getWriter().write(&quot;hello world!!!&quot;);\n    &#125;\n&#125;</code></pre>\n\n<h5 id=\"3-axios接收响应对象的结构\"><a href=\"#3-axios接收响应对象的结构\" class=\"headerlink\" title=\"3. axios接收响应对象的结构\"></a>3. axios接收响应对象的结构</h5><table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>config</td>\n<td>调用axios(config对象)方法时传入的JSON对象</td>\n</tr>\n<tr>\n<td>data</td>\n<td>服务器端返回的响应体数据</td>\n</tr>\n<tr>\n<td>headers</td>\n<td>响应消息头</td>\n</tr>\n<tr>\n<td>request</td>\n<td>原生JavaScript执行Ajax操作时使用的XMLHttpRequest</td>\n</tr>\n<tr>\n<td>status</td>\n<td>响应状态码</td>\n</tr>\n<tr>\n<td>statusText</td>\n<td>响应状态码的说明文本</td>\n</tr>\n</tbody></table>\n<h5 id=\"4-服务器处理请求失败后\"><a href=\"#4-服务器处理请求失败后\" class=\"headerlink\" title=\"4. 服务器处理请求失败后\"></a>4. 服务器处理请求失败后</h5><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">catch(error &#x3D;&gt; &#123;     &#x2F;&#x2F; catch()服务器端处理请求出错后，会调用\n\n    console.log(error);         &#x2F;&#x2F; error就是出错时服务器端返回的响应数据\n    console.log(error.response);        &#x2F;&#x2F; 在服务器端处理请求失败后，获取axios封装的JSON格式的响应数据对象\n    console.log(error.response.status); &#x2F;&#x2F; 在服务器端处理请求失败后，获取响应状态码\n    console.log(error.response.statusText); &#x2F;&#x2F; 在服务器端处理请求失败后，获取响应状态说明文本\n    console.log(error.response.data);   &#x2F;&#x2F; 在服务器端处理请求失败后，获取响应体数据\n\n&#125;);</code></pre>\n\n<p>在给catch()函数传入的回调函数中，error对象封装了服务器端处理请求失败后相应的错误信息。其中，axios封装的响应数据对象，是error对象的response属性。response属性对象的结构如下图所示：</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/axios1.png\" alt=\"images\"></p>\n<p>可以看到，response对象的结构还是和then()函数传入的回调函数中的response是一样的：</p>\n<p>回调函数：开发人员声明，但是调用时交给系统来调用。像单击响应函数、then()、catch()里面传入的都是回调函数。回调函数是相对于普通函数来说的，普通函数就是开发人员自己声明，自己调用：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function sum(a, b) &#123;\nreturn a+b;\n&#125;\n\nvar result &#x3D; sum(3, 2);\nconsole.log(&quot;result&#x3D;&quot;+result);</code></pre>\n\n<h4 id=\"④-发送请求体JSON\"><a href=\"#④-发送请求体JSON\" class=\"headerlink\" title=\"④ 发送请求体JSON\"></a>④ 发送请求体JSON</h4><h5 id=\"1-前端代码\"><a href=\"#1-前端代码\" class=\"headerlink\" title=\"1. 前端代码\"></a>1. 前端代码</h5><p>HTML代码：</p>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;button @click&#x3D;&quot;sendJsonBody&quot;&gt;请求体JSON&lt;&#x2F;button&gt;</code></pre>\n\n<p>Vue+axios代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;script&gt;\n    var vue &#x3D; new Vue(&#123;\n        &quot;el&quot;:&quot;#app&quot;,\n        &quot;data&quot;:&#123;\n            &quot;message&quot;:&quot;&quot;\n        &#125;,\n        &quot;methods&quot;:&#123;\n            sendJsonBody()&#123;\n                axios(&#123;\n                    &quot;method&quot;:&quot;post&quot;,\n                    &quot;url&quot;:&quot;demo02&quot;,\n                    &quot;data&quot;:&#123;\n                        &quot;username&quot;:&quot;奥巴马&quot;,\n                        &quot;password&quot;:&quot;123456&quot;,\n                        &quot;id&quot;:1,\n                        &quot;nickname&quot;:&quot;圣枪游侠&quot;\n                    &#125;\n                &#125;).then(response &#x3D;&gt; &#123;\n                    console.log(response.data)\n                &#125;)\n            &#125;\n        &#125;\n    &#125;)\n&lt;&#x2F;script&gt;</code></pre>\n\n<h5 id=\"2-后端代码\"><a href=\"#2-后端代码\" class=\"headerlink\" title=\"2. 后端代码\"></a>2. 后端代码</h5><h6 id=\"2-1-加入Gson包\"><a href=\"#2-1-加入Gson包\" class=\"headerlink\" title=\"2.1 加入Gson包\"></a>2.1 加入Gson包</h6><p>Gson是Google研发的一款非常优秀的==JSON数据解析和生成工具==，它可以帮助我们将数据在JSON字符串和Java对象之间互相转换。</p>\n<h6 id=\"2-2-User类\"><a href=\"#2-2-User类\" class=\"headerlink\" title=\"2.2 User类\"></a>2.2 User类</h6><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.user;\n\n&#x2F;**\n * 包名:com.atguigu.user\n *\n * @author Leevi\n * 日期2021-05-21  10:18\n *&#x2F;\npublic class User &#123;\n    private Integer id;\n    private String username;\n    private String password;\n    private String nickname;\n\n    public User() &#123;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;User&#123;&quot; +\n                &quot;id&#x3D;&quot; + id +\n                &quot;, username&#x3D;&#39;&quot; + username + &#39;\\&#39;&#39; +\n                &quot;, password&#x3D;&#39;&quot; + password + &#39;\\&#39;&#39; +\n                &quot;, nickname&#x3D;&#39;&quot; + nickname + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n\n    public User(Integer id, String username, String password, String nickname) &#123;\n        this.id &#x3D; id;\n        this.username &#x3D; username;\n        this.password &#x3D; password;\n        this.nickname &#x3D; nickname;\n    &#125;\n\n    public Integer getId() &#123;\n        return id;\n    &#125;\n\n    public void setId(Integer id) &#123;\n        this.id &#x3D; id;\n    &#125;\n\n    public String getUsername() &#123;\n        return username;\n    &#125;\n\n    public void setUsername(String username) &#123;\n        this.username &#x3D; username;\n    &#125;\n\n    public String getPassword() &#123;\n        return password;\n    &#125;\n\n    public void setPassword(String password) &#123;\n        this.password &#x3D; password;\n    &#125;\n\n    public String getNickname() &#123;\n        return nickname;\n    &#125;\n\n    public void setNickname(String nickname) &#123;\n        this.nickname &#x3D; nickname;\n    &#125;\n&#125;</code></pre>\n\n<h6 id=\"2-3-Servlet代码\"><a href=\"#2-3-Servlet代码\" class=\"headerlink\" title=\"2.3 Servlet代码\"></a>2.3 Servlet代码</h6><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.servlet;\n\nimport com.atguigu.user.User;\nimport com.atguigu.utils.JsonUtils;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n&#x2F;**\n * @author Leevi\n * 日期2021-05-21  10:06\n *&#x2F;\npublic class ServletDemo02 extends HttpServlet &#123;\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        doGet(request, response);\n    &#125;\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        request.setCharacterEncoding(&quot;UTF-8&quot;);\n        response.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);\n\n        &#x2F;&#x2F; 1.由于请求体数据有可能很大，所以Servlet标准在设计API的时候要求我们通过输入流来读取\n        BufferedReader reader &#x3D; request.getReader();\n\n        &#x2F;&#x2F; 2.创建StringBuilder对象来累加存储从请求体中读取到的每一行\n        StringBuilder builder &#x3D; new StringBuilder();\n\n        &#x2F;&#x2F; 3.声明临时变量\n        String bufferStr &#x3D; null;\n\n        &#x2F;&#x2F; 4.循环读取\n        while((bufferStr &#x3D; reader.readLine()) !&#x3D; null) &#123;\n            builder.append(bufferStr);\n        &#125;\n\n        &#x2F;&#x2F; 5.关闭流\n        reader.close();\n\n        &#x2F;&#x2F; 6.累加的结果就是整个请求体\n        String requestBody &#x3D; builder.toString();\n\n        &#x2F;&#x2F; 7.创建Gson对象用于解析JSON字符串\n        Gson gson &#x3D; new Gson();\n\n        &#x2F;&#x2F; 8.将JSON字符串还原为Java对象\n        User user &#x3D; gson.fromJson(requestBody, User.class);\n        System.out.println(&quot;user &#x3D; &quot; + user);\n\n        System.out.println(&quot;requestBody &#x3D; &quot; + requestBody);\n\n        response.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);\n        response.getWriter().write(&quot;hello world&quot;);\n    &#125;\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>P.S.：看着很麻烦是吧？别担心，将来我们有了<span style=\"color:blue;font-weight:bold;\">SpringMVC</span>之后，一个<span style=\"color:blue;font-weight:bold;\">@RequestBody</span>注解就能够搞定，非常方便！</p></blockquote>\n<h4 id=\"⑤-服务器端返回JSON数据\"><a href=\"#⑤-服务器端返回JSON数据\" class=\"headerlink\" title=\"⑤ 服务器端返回JSON数据\"></a>⑤ 服务器端返回JSON数据</h4><h5 id=\"1-前端代码-1\"><a href=\"#1-前端代码-1\" class=\"headerlink\" title=\"1. 前端代码\"></a>1. 前端代码</h5><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">sendJsonBody()&#123;\n    axios(&#123;\n        &quot;method&quot;:&quot;post&quot;,\n        &quot;url&quot;:&quot;demo03&quot;\n    &#125;).then(response &#x3D;&gt; &#123;\n        console.log(response.data.nickname)\n    &#125;)\n&#125;</code></pre>\n\n<h5 id=\"2-后端代码-1\"><a href=\"#2-后端代码-1\" class=\"headerlink\" title=\"2. 后端代码\"></a>2. 后端代码</h5><h6 id=\"2-1-加入Gson包-1\"><a href=\"#2-1-加入Gson包-1\" class=\"headerlink\" title=\"2.1 加入Gson包\"></a>2.1 加入Gson包</h6><p>仍然需要Gson支持，不用多说</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/axios-gson.png\"></p>\n<h6 id=\"2-2-Servlet代码\"><a href=\"#2-2-Servlet代码\" class=\"headerlink\" title=\"2.2 Servlet代码\"></a>2.2 Servlet代码</h6><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.servlet;\n\nimport com.atguigu.user.User;\nimport com.atguigu.utils.JsonUtils;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n&#x2F;**\n * @author Leevi\n * 日期2021-05-21  10:06\n *&#x2F;\npublic class ServletDemo03 extends HttpServlet &#123;\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        doGet(request, response);\n    &#125;\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        request.setCharacterEncoding(&quot;UTF-8&quot;);\n        response.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);\n\t\t&#x2F;&#x2F;1. 创建user对象设置数据\n\t\tUser user &#x3D; new User(1,&quot;aobama&quot;,&quot;123456&quot;,&quot;圣枪游侠&quot;);\n        &#x2F;&#x2F;2. 创建Gson对象用于将user对象转成json字符串\n        Gson gson &#x3D; new Gson();\n\n        &#x2F;&#x2F;3. 将user对象转成json字符串\n        String jsonStr &#x3D; gson.toJson(user);\n        response.getWriter().write(jsonStr);\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"6⃣️-跨域问题\"><a href=\"#6⃣️-跨域问题\" class=\"headerlink\" title=\"6⃣️ 跨域问题\"></a>6⃣️ 跨域问题</h4><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:08:26-16:23:50.png\" alt=\"image-20210826162349566\"></p>\n<p>为什么会出现跨域问题？</p>\n<ul>\n<li><p>出于浏览器的同源策略限制：</p>\n</li>\n<li><ul>\n<li>所谓同源（即指在同一个域）就是两个地址具有相同的协议（protocol），主机（host）和端口号（port）</li>\n<li>同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。</li>\n</ul>\n</li>\n<li><p>同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能。</p>\n</li>\n<li><p>例如：</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">http:&#x2F;&#x2F;www.atguigu.com&#x2F;index.html 调用 http:&#x2F;&#x2F;www.atguigu.com&#x2F;teacher&#x2F;listall （非跨域）\nhttp:&#x2F;&#x2F;www.atguigu.com&#x2F;index.html 调用 http:&#x2F;&#x2F;www.guigu.com&#x2F;server.php （主域名不同:atguigu&#x2F;guigu，跨域）\nhttp:&#x2F;&#x2F;abc.atguigu.com&#x2F;index.html 调用 http:&#x2F;&#x2F;def.atguigu.com&#x2F;server.php（子域名不同:abc&#x2F;def，跨域）\nhttp:&#x2F;&#x2F;www.atguigu.com:8080&#x2F;index.html调用 http:&#x2F;&#x2F;www.atguigu.com:8081&#x2F;server.php（端口不同:8080&#x2F;8081，跨域）\nhttp:&#x2F;&#x2F;www.atguigu.com&#x2F;index.html 调用 https:&#x2F;&#x2F;www.atguigu.com&#x2F;server.php（协议不同:http&#x2F;https，跨域）\n请注意：localhost和127.0.0.1虽然都指向本机，但也属于跨域。\n浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。</code></pre>\n\n<p>==解决跨域问题：在有跨域问题的Controller或@RequestMapping上添加注解==</p>\n<p>原理：利用spring的拦截器实现往response里添加 Access-Control-Allow-Origin等响应头信息允许跨域访问</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@CrossOrigin &#x2F;&#x2F;解决跨域问题,springmvc4.2以上版本支持</code></pre>\n\n\n\n<h4 id=\"beginner-​Fetch\"><a href=\"#beginner-​Fetch\" class=\"headerlink\" title=\":beginner: ​Fetch\"></a>:beginner: ​Fetch</h4><p>说到ajax, 就不得不提及fetch, 由于篇幅较长, fetch已从本文中独立出来, 请戳 <a href=\"http://louiszhai.github.io/2016/11/02/fetch/\">Fetch进阶指南</a> .</p>\n<p>fetch是前端发展的一种新技术产物。</p>\n<p>以下内容摘自mozilla：<br>Fetch API 提供了一个 JavaScript接口，用于访问和操纵HTTP管道的部分，例如请求和响应。它还提供了一个全局 fetch()方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。</p>\n<p>这种功能以前是使用 XMLHttpRequest实现的。Fetch提供了一个更好的替代方法，可以很容易地被其他技术使用，例如 Service Workers。Fetch还提供了单个逻辑位置来定义其他HTTP相关概念，例如CORS和HTTP的扩展。</p>\n<p>在使用fetch的时候需要注意：</p>\n<ul>\n<li>当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。</li>\n<li>默认情况下，fetch 不会从服务端发送或接收任何 cookies, 如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项）。</li>\n</ul>\n<p>一个使用fetch获取数据的例子</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">fetch(&#39;http:&#x2F;&#x2F;example.com&#x2F;movies.json&#39;)\n  .then(function(response) &#123;\n    return response.json();\n  &#125;)\n  .then(function(myJson) &#123;\n    console.log(myJson);\n  &#125;);</code></pre>\n\n<p>fetch代表着更先进的技术方向，但是目前兼容性不是很好，在项目中使用的时候得慎重。</p>\n<h4 id=\"beginner-​常见的状态码\"><a href=\"#beginner-​常见的状态码\" class=\"headerlink\" title=\":beginner: ​常见的状态码\"></a>:beginner: ​常见的状态码</h4><p>仅记录在 RFC2616 上的 HTTP 状态码就达 40 种，若再加上 WebDAV（RFC4918、5842）和附加 HTTP 状态码 （RFC6585）等扩展，数量就达 60 余种。接下来，我们就介绍一下这些具有代表性的一些状态码。</p>\n<ul>\n<li>200 表示从客户端发来的请求在服务器端被正常处理了。</li>\n<li>204 表示请求处理成功，但没有资源返回。</li>\n<li>301 表示永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。</li>\n<li>302 表示临时性重定向。</li>\n<li>304 表示客户端发送附带条件的请求时（指采用GET方法的请求报文中包含if-matched,if-modified-since,if-none-match,if-range,if-unmodified-since任一个首部）服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304Modified（服务器端资源未改变，可直接使用客户端未过期的缓存）</li>\n<li>400 表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。</li>\n<li>401 表示未授权（Unauthorized)，当前请求需要用户验证</li>\n<li>403 表示对请求资源的访问被服务器拒绝了</li>\n<li>404 表示服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</li>\n<li>500 表示服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。</li>\n<li>503 表示服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>\n</ul>\n","text":":beginner: ​Json① json 的定义1. json 是由键值对组成，并且由 花括号（大括号）包围。 2. 每个键由引号引起来，键和值之间使用 冒号进行分隔， 多组键值对之间进行 逗号进行分隔。 例子♥: &#123; &quot;name&quot;:&quot;...","link":"","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"23 mins."},"categories":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/categories/JavaWeb.json"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/tags/JavaWeb.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#beginner-%E2%80%8BJson\"><span class=\"toc-text\">:beginner: ​Json</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A0-json-%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">① json 的定义</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A1-json-%E7%9A%84%E8%AE%BF%E9%97%AE\"><span class=\"toc-text\">② json 的访问</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A2-json-%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">③ json 的两个常用方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A3-json-%E5%9C%A8java%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">④ json 在java中的使用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#beginner-Ajax\"><span class=\"toc-text\">:beginner: Ajax</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E4%BB%80%E4%B9%88%E6%98%AFajax\"><span class=\"toc-text\">① 什么是ajax</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E4%B8%8D%E5%90%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%94%AF%E6%8C%81\"><span class=\"toc-text\">② 不同浏览器的支持</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A2-%E5%85%A8%E5%85%BC%E5%AE%B9%E7%9A%84XMLHttpRequest\"><span class=\"toc-text\">③ 全兼容的XMLHttpRequest</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A3-GET%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">④ GET和POST请求数据区别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A4-ajax%E6%B2%A1%E6%9C%89%E7%A0%B4%E5%9D%8Fjs%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">⑤ ajax没有破坏js单线程机制</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A5-XMLHttpRequest-%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">⑥ XMLHttpRequest 属性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-readyState\"><span class=\"toc-text\">1. readyState</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-status\"><span class=\"toc-text\">2. status</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-statusText\"><span class=\"toc-text\">3. statusText</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-onreadystatechange\"><span class=\"toc-text\">4. onreadystatechange</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A6-ajax\"><span class=\"toc-text\">⑦ $.ajax</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8\"><span class=\"toc-text\">1. 参数列表</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E6%94%AF%E6%8C%81promise\"><span class=\"toc-text\">2. 支持promise</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E4%BD%BF%E7%94%A8%E8%BD%AC%E6%8D%A2%E5%99%A8\"><span class=\"toc-text\">3. 使用转换器</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">4. 事件触发顺序</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#beginner-Axios\"><span class=\"toc-text\">:beginner: Axios</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">① 概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">② 使用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A2-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">③ 基本用法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%BC%95%E5%85%A5%E7%8E%AF%E5%A2%83\"><span class=\"toc-text\">1. 前端页面引入环境</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E5%8F%91%E9%80%81%E6%99%AE%E9%80%9A%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">2. 发送普通请求参数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2-1-%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">2.1 前端代码</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2-2-%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">2.2 后端代码</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-axios%E6%8E%A5%E6%94%B6%E5%93%8D%E5%BA%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">3. axios接收响应对象的结构</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%A4%B1%E8%B4%A5%E5%90%8E\"><span class=\"toc-text\">4. 服务器处理请求失败后</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A3-%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E4%BD%93JSON\"><span class=\"toc-text\">④ 发送请求体JSON</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">1. 前端代码</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">2. 后端代码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2-1-%E5%8A%A0%E5%85%A5Gson%E5%8C%85\"><span class=\"toc-text\">2.1 加入Gson包</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2-2-User%E7%B1%BB\"><span class=\"toc-text\">2.2 User类</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2-3-Servlet%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">2.3 Servlet代码</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%BF%94%E5%9B%9EJSON%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">⑤ 服务器端返回JSON数据</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81-1\"><span class=\"toc-text\">1. 前端代码</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81-1\"><span class=\"toc-text\">2. 后端代码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2-1-%E5%8A%A0%E5%85%A5Gson%E5%8C%85-1\"><span class=\"toc-text\">2.1 加入Gson包</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2-2-Servlet%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">2.2 Servlet代码</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6%E2%83%A3%EF%B8%8F-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">6⃣️ 跨域问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#beginner-%E2%80%8BFetch\"><span class=\"toc-text\">:beginner: ​Fetch</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#beginner-%E2%80%8B%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81\"><span class=\"toc-text\">:beginner: ​常见的状态码</span></a></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"工具类，上传下载，验证码","uid":"cfe3c6b5bac26dbfd06dd74550839a48","slug":"39-utils kaptcher up down","date":"2021-09-13T15:15:32.000Z","updated":"2021-09-15T10:29:16.262Z","comments":true,"path":"api/articles/39-utils kaptcher up down.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"1. BeanUtils使用及方法分析1.1 概论1. BeanUtils被广泛的使用与三大框架。 在整个J2EE的编程过程中，我们经常会从各种配置文件中读取相应的数据，需要明白的一点是从配置文件中读取到的数据都是String，但是很显然我们的应用程序中不仅仅有String一种数...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/categories/JavaWeb.json"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/tags/JavaWeb.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"listener，filter，cookie，session","uid":"5e2a4e0d14846d085ea5bb260a2f8b57","slug":"37-listener filter cookie session","date":"2021-09-13T15:13:32.000Z","updated":"2021-09-15T10:28:17.089Z","comments":true,"path":"api/articles/37-listener filter cookie session.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"1. Listener监听器1.1 Listener是什么？* Listener 监听器是 JavaWeb 的三大组件之一。 * JavaWeb 的三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监 听器。 * Listener 它是 JavaEE ...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/categories/JavaWeb.json"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","count":13,"path":"api/tags/JavaWeb.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}