{"title":"网络编程","uid":"b85a5ed5aa29024c7191b1325f9b4bb8","slug":"16-网络编程","date":"2021-09-13T14:51:32.000Z","updated":"2021-09-15T10:16:58.700Z","comments":true,"path":"api/articles/16-网络编程.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","content":"<h3 id=\"一、实现通信需解决的两个问题\"><a href=\"#一、实现通信需解决的两个问题\" class=\"headerlink\" title=\"一、实现通信需解决的两个问题\"></a>一、实现通信需解决的两个问题</h3><ul>\n<li>1.如何准确地定位网络上一台或多台主机；定位主机上的特定的应用</li>\n<li>2.找到主机后如何可靠高效地进行数据传输</li>\n</ul>\n<h3 id=\"二、网络通信的两个要素\"><a href=\"#二、网络通信的两个要素\" class=\"headerlink\" title=\"二、网络通信的两个要素\"></a>二、网络通信的两个要素</h3><ul>\n<li>对应问题一：IP和端口号</li>\n<li>对应问题二：提供网络通信协议：TCP/IP参考模型（应用层、传输层、网络层、物理+数据链路层）</li>\n</ul>\n<h3 id=\"三、通信要素一：IP和端口号\"><a href=\"#三、通信要素一：IP和端口号\" class=\"headerlink\" title=\"三、通信要素一：IP和端口号\"></a>三、通信要素一：IP和端口号</h3><h4 id=\"1、IP的理解\"><a href=\"#1、IP的理解\" class=\"headerlink\" title=\"1、IP的理解\"></a>1、IP的理解</h4><ul>\n<li><ol>\n<li>IP:唯一的标识 Internet 上的计算机（通信实体）</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>在Java中使用InetAddress类代表IP</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>IP分类：IPv4 和 IPv6 ; 万维网 和 局域网</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>域名:   <a href=\"http://www.baidu.com/\">www.baidu.com</a>   <a href=\"http://www.mi.com/\">www.mi.com</a>  <a href=\"http://www.sina.com/\">www.sina.com</a>  <a href=\"http://www.jd.com/\">www.jd.com</a></li>\n</ol>\n</li>\n<li>   域名解析：域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS)负责将域名转化成IP地址，这样才能和主机建立连接。 ——-域名解析</li>\n<li><ol start=\"5\">\n<li>本地回路地址：127.0.0.1 对应着：localhost</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"2、InetAddress类\"><a href=\"#2、InetAddress类\" class=\"headerlink\" title=\"2、InetAddress类\"></a>2、InetAddress类</h4><p>此类的一个对象就代表着一个具体的IP地址</p>\n<h5 id=\"2-1-实例化\"><a href=\"#2-1-实例化\" class=\"headerlink\" title=\"2.1 实例化\"></a>2.1 实例化</h5><p>getByName(String host) 、 getLocalHost()</p>\n<h5 id=\"2-2-常用方法\"><a href=\"#2-2-常用方法\" class=\"headerlink\" title=\"2.2 常用方法\"></a>2.2 常用方法</h5><p>getHostName() / getHostAddress()</p>\n<h5 id=\"2-3-端口号：正在计算机上运行的进程。\"><a href=\"#2-3-端口号：正在计算机上运行的进程。\" class=\"headerlink\" title=\"2.3 端口号：正在计算机上运行的进程。\"></a>2.3 端口号：正在计算机上运行的进程。</h5><ul>\n<li>要求：不同的进程不同的端口号</li>\n<li>范围：被规定为一个 16 位的整数 0~65535。</li>\n</ul>\n<p>端口号与IP地址的组合得出一个网络套接字：Socket</p>\n<h3 id=\"四、通信要素二：网络通信协议\"><a href=\"#四、通信要素二：网络通信协议\" class=\"headerlink\" title=\"四、通信要素二：网络通信协议\"></a>四、通信要素二：网络通信协议</h3><h4 id=\"1、分型模型\"><a href=\"#1、分型模型\" class=\"headerlink\" title=\"1、分型模型\"></a>1、分型模型</h4><p><img src=\"https://gitee.com/xiuxiuai/picture/raw/master/img/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E5%88%86%E5%9E%8B%E6%A8%A1%E5%9E%8B.png\" alt=\"image-20210505093002795\"></p>\n<h4 id=\"2、TCP和UDP的区别\"><a href=\"#2、TCP和UDP的区别\" class=\"headerlink\" title=\"2、TCP和UDP的区别\"></a>2、TCP和UDP的区别</h4><p><img src=\"https://gitee.com/xiuxiuai/picture/raw/master/img/TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB.png\" alt=\"image-20210505093206207\"></p>\n<h4 id=\"3、TCP三次握手和四次挥手\"><a href=\"#3、TCP三次握手和四次挥手\" class=\"headerlink\" title=\"3、TCP三次握手和四次挥手\"></a>3、TCP三次握手和四次挥手</h4><p><img src=\"https://gitee.com/xiuxiuai/picture/raw/master/img/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png\" alt=\"image-20210505093300133\"></p>\n<p><img src=\"https://gitee.com/xiuxiuai/picture/raw/master/img/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png\" alt=\"image-20210505093318812\"></p>\n<h3 id=\"五、UDP代码示例\"><a href=\"#五、UDP代码示例\" class=\"headerlink\" title=\"五、UDP代码示例\"></a>五、UDP代码示例</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">代码示例：\n\n&#x2F;&#x2F;发送端\n@Test\npublic void sender() throws IOException &#123;\n\n    DatagramSocket socket &#x3D; new DatagramSocket();\n\n\n\n    String str &#x3D; &quot;我是UDP方式发送的导弹&quot;;\n    byte[] data &#x3D; str.getBytes();\n    InetAddress inet &#x3D; InetAddress.getLocalHost();\n    DatagramPacket packet &#x3D; new DatagramPacket(data,0,data.length,inet,9090);\n\n    socket.send(packet);\n\n    socket.close();\n\n&#125;\n&#x2F;&#x2F;接收端\n@Test\npublic void receiver() throws IOException &#123;\n\n    DatagramSocket socket &#x3D; new DatagramSocket(9090);\n\n    byte[] buffer &#x3D; new byte[100];\n    DatagramPacket packet &#x3D; new DatagramPacket(buffer,0,buffer.length);\n\n    socket.receive(packet);\n\n    System.out.println(new String(packet.getData(),0,packet.getLength()));\n\n    socket.close();\n&#125;</code></pre>\n\n<h3 id=\"六、TCP代码示例\"><a href=\"#六、TCP代码示例\" class=\"headerlink\" title=\"六、TCP代码示例\"></a>六、TCP代码示例</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">代码示例1：客户端发送信息给服务端，服务端将数据显示在控制台上\n&#x2F;&#x2F;客户端\n    @Test\n    public void client()  &#123;\n        Socket socket &#x3D; null;\n        OutputStream os &#x3D; null;\n        try &#123;\n            &#x2F;&#x2F;1.创建Socket对象，指明服务器端的ip和端口号\n            InetAddress inet &#x3D; InetAddress.getByName(&quot;192.168.14.100&quot;);\n            socket &#x3D; new Socket(inet,8899);\n            &#x2F;&#x2F;2.获取一个输出流，用于输出数据\n            os &#x3D; socket.getOutputStream();\n            &#x2F;&#x2F;3.写出数据的操作\n            os.write(&quot;你好，我是客户端mm&quot;.getBytes());\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            &#x2F;&#x2F;4.资源的关闭\n            if(os !&#x3D; null)&#123;\n                try &#123;\n                    os.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n\n            &#125;\n            if(socket !&#x3D; null)&#123;\n                try &#123;\n                    socket.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n\n            &#125;\n        &#125;\n\n\n\n    &#125;\n    &#x2F;&#x2F;服务端\n    @Test\n    public void server()  &#123;\n\n        ServerSocket ss &#x3D; null;\n        Socket socket &#x3D; null;\n        InputStream is &#x3D; null;\n        ByteArrayOutputStream baos &#x3D; null;\n        try &#123;\n            &#x2F;&#x2F;1.创建服务器端的ServerSocket，指明自己的端口号\n            ss &#x3D; new ServerSocket(8899);\n            &#x2F;&#x2F;2.调用accept()表示接收来自于客户端的socket\n            socket &#x3D; ss.accept();\n            &#x2F;&#x2F;3.获取输入流\n            is &#x3D; socket.getInputStream();\n\n            &#x2F;&#x2F;不建议这样写，可能会乱码\n&#x2F;&#x2F;        byte[] buffer &#x3D; new byte[1024];\n&#x2F;&#x2F;        int len;\n&#x2F;&#x2F;        while((len &#x3D; is.read(buffer)) !&#x3D; -1)&#123;\n&#x2F;&#x2F;            String str &#x3D; new String(buffer,0,len);\n&#x2F;&#x2F;            System.out.print(str);\n&#x2F;&#x2F;        &#125;\n            &#x2F;&#x2F;4.读取输入流中的数据\n            baos &#x3D; new ByteArrayOutputStream();\n            byte[] buffer &#x3D; new byte[5];\n            int len;\n            while((len &#x3D; is.read(buffer)) !&#x3D; -1)&#123;\n                baos.write(buffer,0,len);\n            &#125;\n\n            System.out.println(baos.toString());\n\n            System.out.println(&quot;收到了来自于：&quot; + socket.getInetAddress().getHostAddress() + &quot;的数据&quot;);\n\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            if(baos !&#x3D; null)&#123;\n                &#x2F;&#x2F;5.关闭资源\n                try &#123;\n                    baos.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if(is !&#x3D; null)&#123;\n                try &#123;\n                    is.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if(socket !&#x3D; null)&#123;\n                try &#123;\n                    socket.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if(ss !&#x3D; null)&#123;\n                try &#123;\n                    ss.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n\n        &#125;\n\n    &#125;\n\n代码示例2：客户端发送文件给服务端，服务端将文件保存在本地。\n&#x2F;*\n这里涉及到的异常，应该使用try-catch-finally处理\n *&#x2F;\n@Test\npublic void client() throws IOException &#123;\n    &#x2F;&#x2F;1.\n    Socket socket &#x3D; new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;),9090);\n    &#x2F;&#x2F;2.\n    OutputStream os &#x3D; socket.getOutputStream();\n    &#x2F;&#x2F;3.\n    FileInputStream fis &#x3D; new FileInputStream(new File(&quot;beauty.jpg&quot;));\n    &#x2F;&#x2F;4.\n    byte[] buffer &#x3D; new byte[1024];\n    int len;\n    while((len &#x3D; fis.read(buffer)) !&#x3D; -1)&#123;\n        os.write(buffer,0,len);\n    &#125;\n    &#x2F;&#x2F;5.\n    fis.close();\n    os.close();\n    socket.close();\n&#125;\n\n&#x2F;*\n这里涉及到的异常，应该使用try-catch-finally处理\n *&#x2F;\n@Test\npublic void server() throws IOException &#123;\n    &#x2F;&#x2F;1.\n    ServerSocket ss &#x3D; new ServerSocket(9090);\n    &#x2F;&#x2F;2.\n    Socket socket &#x3D; ss.accept();\n    &#x2F;&#x2F;3.\n    InputStream is &#x3D; socket.getInputStream();\n    &#x2F;&#x2F;4.\n    FileOutputStream fos &#x3D; new FileOutputStream(new File(&quot;beauty1.jpg&quot;));\n    &#x2F;&#x2F;5.\n    byte[] buffer &#x3D; new byte[1024];\n    int len;\n    while((len &#x3D; is.read(buffer)) !&#x3D; -1)&#123;\n        fos.write(buffer,0,len);\n    &#125;\n    &#x2F;&#x2F;6.\n    fos.close();\n    is.close();\n    socket.close();\n    ss.close();\n\n&#125;\n\n代码示例3：从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。并关闭相应的连接。\n\n&#x2F;*\n    这里涉及到的异常，应该使用try-catch-finally处理\n     *&#x2F;\n@Test\npublic void client() throws IOException &#123;\n    &#x2F;&#x2F;1.\n    Socket socket &#x3D; new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;),9090);\n    &#x2F;&#x2F;2.\n    OutputStream os &#x3D; socket.getOutputStream();\n    &#x2F;&#x2F;3.\n    FileInputStream fis &#x3D; new FileInputStream(new File(&quot;beauty.jpg&quot;));\n    &#x2F;&#x2F;4.\n    byte[] buffer &#x3D; new byte[1024];\n    int len;\n    while((len &#x3D; fis.read(buffer)) !&#x3D; -1)&#123;\n        os.write(buffer,0,len);\n    &#125;\n    &#x2F;&#x2F;关闭数据的输出\n    socket.shutdownOutput();\n\n    &#x2F;&#x2F;5.接收来自于服务器端的数据，并显示到控制台上\n    InputStream is &#x3D; socket.getInputStream();\n    ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream();\n    byte[] bufferr &#x3D; new byte[20];\n    int len1;\n    while((len1 &#x3D; is.read(buffer)) !&#x3D; -1)&#123;\n        baos.write(buffer,0,len1);\n    &#125;\n\n    System.out.println(baos.toString());\n\n    &#x2F;&#x2F;6.\n    fis.close();\n    os.close();\n    socket.close();\n    baos.close();\n&#125;\n\n&#x2F;*\n这里涉及到的异常，应该使用try-catch-finally处理\n *&#x2F;\n@Test\npublic void server() throws IOException &#123;\n    &#x2F;&#x2F;1.\n    ServerSocket ss &#x3D; new ServerSocket(9090);\n    &#x2F;&#x2F;2.\n    Socket socket &#x3D; ss.accept();\n    &#x2F;&#x2F;3.\n    InputStream is &#x3D; socket.getInputStream();\n    &#x2F;&#x2F;4.\n    FileOutputStream fos &#x3D; new FileOutputStream(new File(&quot;beauty2.jpg&quot;));\n    &#x2F;&#x2F;5.\n    byte[] buffer &#x3D; new byte[1024];\n    int len;\n    while((len &#x3D; is.read(buffer)) !&#x3D; -1)&#123;\n        fos.write(buffer,0,len);\n    &#125;\n\n    System.out.println(&quot;图片传输完成&quot;);\n\n    &#x2F;&#x2F;6.服务器端给予客户端反馈\n    OutputStream os &#x3D; socket.getOutputStream();\n    os.write(&quot;你好，美女，照片我已收到，非常漂亮！&quot;.getBytes());\n\n    &#x2F;&#x2F;7.\n    fos.close();\n    is.close();\n    socket.close();\n    ss.close();\n    os.close();\n\n&#125;</code></pre>\n\n","text":"一、实现通信需解决的两个问题 1.如何准确地定位网络上一台或多台主机；定位主机上的特定的应用 2.找到主机后如何可靠高效地进行数据传输 二、网络通信的两个要素 对应问题一：IP和端口号 对应问题二：提供网络通信协议：TCP/IP参考模型（应用层、传输层、网络层、物理+数据链路层）...","link":"","photos":[],"count_time":{"symbolsCount":"8.5k","symbolsTime":"8 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/tags/JavaSE.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%AE%9E%E7%8E%B0%E9%80%9A%E4%BF%A1%E9%9C%80%E8%A7%A3%E5%86%B3%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">一、实现通信需解决的两个问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%A6%81%E7%B4%A0\"><span class=\"toc-text\">二、网络通信的两个要素</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E9%80%9A%E4%BF%A1%E8%A6%81%E7%B4%A0%E4%B8%80%EF%BC%9AIP%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7\"><span class=\"toc-text\">三、通信要素一：IP和端口号</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81IP%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">1、IP的理解</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81InetAddress%E7%B1%BB\"><span class=\"toc-text\">2、InetAddress类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-1-%E5%AE%9E%E4%BE%8B%E5%8C%96\"><span class=\"toc-text\">2.1 实例化</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.2 常用方法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-3-%E7%AB%AF%E5%8F%A3%E5%8F%B7%EF%BC%9A%E6%AD%A3%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E3%80%82\"><span class=\"toc-text\">2.3 端口号：正在计算机上运行的进程。</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E9%80%9A%E4%BF%A1%E8%A6%81%E7%B4%A0%E4%BA%8C%EF%BC%9A%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">四、通信要素二：网络通信协议</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%88%86%E5%9E%8B%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">1、分型模型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">2、TCP和UDP的区别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\"><span class=\"toc-text\">3、TCP三次握手和四次挥手</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81UDP%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">五、UDP代码示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81TCP%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">六、TCP代码示例</span></a></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"Lambda 表达式","uid":"c7c150790ff577b4efb11f92f9e10f6d","slug":"17-Lambda","date":"2021-09-13T14:52:32.000Z","updated":"2021-09-15T10:17:28.153Z","comments":true,"path":"api/articles/17-Lambda.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"一、函数式编程思想在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。编程中的函数，也有类似的概念，你调用我的时候，给我实参为形参赋值，然后通过运行方法体，给你返回一个结果。对于调用者来做，关注这个方法具备什么样的功能。相对而言，面向对象过分强调“必...","link":"","photos":[],"count_time":{"symbolsCount":"9.6k","symbolsTime":"9 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/tags/JavaSE.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"多线程","uid":"ed728f6a9d3e4347d3410adc7305d745","slug":"15-多线程","date":"2021-09-13T14:50:32.000Z","updated":"2021-09-15T10:16:45.091Z","comments":true,"path":"api/articles/15-多线程.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"一、多任务我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？为什么操作系统上可以同时运行多个程序而用户感觉不出来？ 这是因为无论是单CPU还是多CPU，操作系统都营造出了可以同时运行多个程序的假象。实际的过程操作...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/tags/JavaSE.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}