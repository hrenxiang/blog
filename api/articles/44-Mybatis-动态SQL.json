{"title":"Mybatis 动态SQL","uid":"650dc14f73504516668e17ca7e793b09","slug":"44-Mybatis-动态SQL","date":"2021-09-13T15:21:32.000Z","updated":"2021-09-15T10:51:57.620Z","comments":true,"path":"api/articles/44-Mybatis-动态SQL.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog10.jpg","content":"<h4 id=\"1-什么是动态SQL\"><a href=\"#1-什么是动态SQL\" class=\"headerlink\" title=\"1. 什么是动态SQL\"></a>1. 什么是动态SQL</h4><p>动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。</p>\n<p>使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。</p>\n<p>如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。</p>\n<ul>\n<li>if</li>\n<li>choose (when, otherwise)</li>\n<li>trim (where, set)</li>\n<li>foreach</li>\n</ul>\n<p>==动态sql中的判断：==</p>\n<p>① “!=” : 表示不等于 ② “=”：表示等于。注意是一个等号。 ③ “and” : 逻辑与(小写) ④ “or” ： 逻辑或(小写)</p>\n<p>==动态sql中进行传入的数据判断时：==</p>\n<ul>\n<li>单个参数没有使用别名，直接使用value进行替代，或者使用别名</li>\n<li>多个参数就直接使用别名</li>\n</ul>\n<h4 id=\"2-if-标签\"><a href=\"#2-if-标签\" class=\"headerlink\" title=\"2. if 标签\"></a>2. if 标签</h4><p>使用动态 SQL 最常见情景是根据条件包含 where 子句的一部分。比如：</p>\n<p><strong>1 = 1</strong> 是为了解决  没有条件满足时，也能正常查询，不然，where后什么都没有，sql语句就语法错误了</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;select id&#x3D;&quot;selectEmployee2&quot; resultType&#x3D;&quot;employee&quot;&gt;\n        select * from t_emp2 where 1 &#x3D; 1\n        &lt;if test&#x3D;&quot;empName!&#x3D;null and empName!&#x3D;&#39;&#39;&quot;&gt;\n            and emp_name like concat(&#39;%&#39;,#&#123;empName&#125;,&#39;%&#39;)\n        &lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;empSalary!&#x3D;0&quot;&gt;\n            and emp_salary &gt;&#x3D; #&#123;empSalary&#125;;\n        &lt;&#x2F;if&gt;\n&lt;&#x2F;select&gt;</code></pre>\n\n<p>这是最好的改进，加入<where>标签</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;select id&#x3D;&quot;selectEmployee3&quot; resultType&#x3D;&quot;employee&quot;&gt;\n        select * from t_emp2\n        &lt;where&gt;\n            &lt;if test&#x3D;&quot;empName!&#x3D;null and empName!&#x3D;&#39;&#39;&quot;&gt;\n                and emp_name like concat(&#39;%&#39;,#&#123;empName&#125;,&#39;%&#39;)\n            &lt;&#x2F;if&gt;\n            &lt;if test&#x3D;&quot;empSalary!&#x3D;0&quot;&gt;\n                and emp_salary &gt;&#x3D; #&#123;empSalary&#125;;\n            &lt;&#x2F;if&gt;\n        &lt;&#x2F;where&gt;\n&lt;&#x2F;select&gt;</code></pre>\n\n<p>这条语句提供了可选的查找文本功能。</p>\n<h4 id=\"3-choose、when、otherwise\"><a href=\"#3-choose、when、otherwise\" class=\"headerlink\" title=\"3. choose、when、otherwise\"></a>3. choose、when、otherwise</h4><p>有时候，我们不想使用所有的条件，而只是想从<strong>多个条件中选择一个使用</strong>。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p>\n<p>注意：当第一个直接满足条件后，就不看后面的了，<strong>仅仅选择一个条件来使用</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;select id&#x3D;&quot;selectEmployee5&quot; resultType&#x3D;&quot;employee&quot;&gt;\n        select * from t_emp2\n        &lt;where&gt;\n            &lt;!--\n            第一种情况：第一个when满足条件 where emp_name&#x3D;?\n            第二种情况：第二个when满足条件 where emp_salary &lt; 3000\n            第三种情况：两个when都不满足 where 1&#x3D;1 执行了otherwise\n            --&gt;\n            &lt;choose&gt;\n                &lt;when test&#x3D;&quot;empName!&#x3D;null and empName!&#x3D;&#39;&#39;&quot;&gt; emp_name like concat(&#39;%&#39;,#&#123;empName&#125;,&#39;%&#39;)&lt;&#x2F;when&gt;\n                &lt;when test&#x3D;&quot;empSalary!&#x3D;0&quot;&gt;emp_salary &gt;&#x3D; #&#123;empSalary&#125;&lt;&#x2F;when&gt;\n                &lt;otherwise&gt;1&#x3D;1&lt;&#x2F;otherwise&gt;\n            &lt;&#x2F;choose&gt;\n        &lt;&#x2F;where&gt;\n    &lt;&#x2F;select&gt;</code></pre>\n\n<h4 id=\"4-where、trim、set\"><a href=\"#4-where、trim、set\" class=\"headerlink\" title=\"4. where、trim、set\"></a>4. where、trim、set</h4><p>前面几个例子已经方便地解决了一个臭名昭著的动态 SQL 问题。现在回到之前的 “if” 示例，如果没有匹配的条件会怎么样？最终这条 SQL 会变成这样：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">SELECT * FROM BLOG\nWHERE</code></pre>\n\n<p>这会导致查询失败。如果匹配的只是第二个条件又会怎样？这条 SQL 会是这样:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">SELECT * FROM BLOG\nWHERE\nAND title like ‘someTitle’</code></pre>\n\n<p>这个查询也会失败。这个问题不能简单地用条件元素来解决。这个问题是如此的难以解决，以至于解决过的人不会再想碰到这种问题。</p>\n<p>MyBatis 有一个简单且适合大多数场景的解决办法。而在其他场景中，可以对其进行自定义以符合需求。而这，只需要一处简单的改动：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;select id&#x3D;&quot;selectEmployee3&quot; resultType&#x3D;&quot;employee&quot;&gt;\n        select * from t_emp2\n        &lt;where&gt;\n            &lt;if test&#x3D;&quot;empName!&#x3D;null and empName!&#x3D;&#39;&#39;&quot;&gt;\n                and emp_name like concat(&#39;%&#39;,#&#123;empName&#125;,&#39;%&#39;)\n            &lt;&#x2F;if&gt;\n            &lt;if test&#x3D;&quot;empSalary!&#x3D;0&quot;&gt;\n                and emp_salary &gt;&#x3D; #&#123;empSalary&#125;;\n            &lt;&#x2F;if&gt;\n        &lt;&#x2F;where&gt;\n&lt;&#x2F;select&gt;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><em>*<em>where</em> 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，*where</em> 元素也会将它们去除。**</p></blockquote>\n<p>可以通过自定义 <strong>trim</strong> 元素来定制 <em>where</em> 元素的功能。比如，和 <em>where</em> 元素等价的自定义 trim 元素为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;trim prefix&#x3D;&quot;WHERE&quot; prefixOverrides&#x3D;&quot;AND |OR &quot;&gt;\n  ...\n&lt;&#x2F;trim&gt;</code></pre>\n\n<p><em>prefixOverrides</em> 属性会<strong>忽略通过管道符分隔的文本序列</strong>（注意此例中的空格是必要的）。上述例子会移除所有 <em>prefixOverrides</em> 属性中指定的内容，并且<strong>插入 <em>prefix</em> 属性中指定的内容</strong>。</p>\n<p>用于动态更新语句的类似解决方案叫做 <em>set</em>。<em><strong>set</strong></em> 元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;select id&#x3D;&quot;updateEmployee2&quot; resultType&#x3D;&quot;employee&quot;&gt;\n        update t_emp2\n        &lt;set&gt;\n            &lt;if test&#x3D;&quot;empName!&#x3D;null and empName!&#x3D;&#39;&#39;&quot;&gt;\n                emp_name &#x3D; #&#123;empName&#125;,\n            &lt;&#x2F;if&gt;\n            &lt;if test&#x3D;&quot;empSalary!&#x3D;0&quot;&gt;\n                emp_salary &#x3D; #&#123;empSalary&#125;,\n            &lt;&#x2F;if&gt;\n        &lt;&#x2F;set&gt;\n        where emp_id &#x3D; #&#123;empId&#125;\n&lt;&#x2F;select&gt;</code></pre>\n\n<p>这个例子中，<em>set</em> 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。</p>\n<p>来看看与 <em>set</em> 元素等价的自定义 <em>trim</em> 元素吧：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;trim prefix&#x3D;&quot;SET&quot; suffixOverrides&#x3D;&quot;,&quot;&gt;\n  ...\n&lt;&#x2F;trim&gt;</code></pre>\n\n<p>注意，我们覆盖了后缀值设置，并且自定义了前缀值。</p>\n<h4 id=\"5-foreach\"><a href=\"#5-foreach\" class=\"headerlink\" title=\"5. foreach\"></a>5. foreach</h4><p>动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;select id&#x3D;&quot;selectEmployee7&quot; resultType&#x3D;&quot;employee&quot;&gt;\n        select\n        &lt;include refid&#x3D;&quot;EmployeeSql&quot;&#x2F;&gt;&lt;!--这里包含的是，提取出的需要查询的字段及别名--&gt;\n        from t_emp2 where emp_id in\n        &lt;foreach collection&#x3D;&quot;empIdArr&quot; open&#x3D;&quot;(&quot; close&#x3D;&quot;)&quot; separator&#x3D;&quot;,&quot; item&#x3D;&quot;empId&quot;&gt;\n            #&#123;empId&#125;\n        &lt;&#x2F;foreach&gt;\n&lt;&#x2F;select&gt;\n\n&lt;sql id&#x3D;&quot;EmployeeSql&quot;&gt;\n        emp_id\n        empId,emp_name empName ,emp_salary empSalary\n&lt;&#x2F;sql&gt;</code></pre>\n\n<p><em>foreach</em> 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！</p>\n<p>提示 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 <em>foreach</em>。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，<strong>index 是键，item 是值</strong>。</p>\n<p>至此，我们已经完成了与 XML 配置及映射文件相关的讨论。下一章将详细探讨 Java API，以便你能充分利用已经创建的映射配置。</p>\n<h4 id=\"6-script\"><a href=\"#6-script\" class=\"headerlink\" title=\"6. script\"></a>6. script</h4><p>要在带注解的映射器接口类中使用动态 SQL，可以使用 <em>script</em> 元素。比如:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Update(&#123;&quot;&lt;script&gt;&quot;,\n  &quot;update Author&quot;,\n  &quot;  &lt;set&gt;&quot;,\n  &quot;    &lt;if test&#x3D;&#39;username !&#x3D; null&#39;&gt;username&#x3D;#&#123;username&#125;,&lt;&#x2F;if&gt;&quot;,\n  &quot;    &lt;if test&#x3D;&#39;password !&#x3D; null&#39;&gt;password&#x3D;#&#123;password&#125;,&lt;&#x2F;if&gt;&quot;,\n  &quot;    &lt;if test&#x3D;&#39;email !&#x3D; null&#39;&gt;email&#x3D;#&#123;email&#125;,&lt;&#x2F;if&gt;&quot;,\n  &quot;    &lt;if test&#x3D;&#39;bio !&#x3D; null&#39;&gt;bio&#x3D;#&#123;bio&#125;&lt;&#x2F;if&gt;&quot;,\n  &quot;  &lt;&#x2F;set&gt;&quot;,\n  &quot;where id&#x3D;#&#123;id&#125;&quot;,\n  &quot;&lt;&#x2F;script&gt;&quot;&#125;)\nvoid updateAuthorValues(Author author);</code></pre>\n\n<h4 id=\"7-bind\"><a href=\"#7-bind\" class=\"headerlink\" title=\"7. bind\"></a>7. bind</h4><p><code>bind</code> 元素允许你在 OGNL 表达式以外创建一个变量，并将其绑定到当前的上下文。比如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;select id&#x3D;&quot;selectBlogsLike&quot; resultType&#x3D;&quot;Blog&quot;&gt;\n  &lt;bind name&#x3D;&quot;pattern&quot; value&#x3D;&quot;&#39;%&#39; + _parameter.getTitle() + &#39;%&#39;&quot; &#x2F;&gt;\n  SELECT * FROM BLOG\n  WHERE title LIKE #&#123;pattern&#125;\n&lt;&#x2F;select&gt;</code></pre>\n\n<h4 id=\"8-多数据库支持\"><a href=\"#8-多数据库支持\" class=\"headerlink\" title=\"8. 多数据库支持\"></a>8. 多数据库支持</h4><p>如果配置了 databaseIdProvider，你就可以在动态代码中使用名为 “_databaseId” 的变量来为不同的数据库构建特定的语句。比如下面的例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;insert id&#x3D;&quot;insert&quot;&gt;\n  &lt;selectKey keyProperty&#x3D;&quot;id&quot; resultType&#x3D;&quot;int&quot; order&#x3D;&quot;BEFORE&quot;&gt;\n    &lt;if test&#x3D;&quot;_databaseId &#x3D;&#x3D; &#39;oracle&#39;&quot;&gt;\n      select seq_users.nextval from dual\n    &lt;&#x2F;if&gt;\n    &lt;if test&#x3D;&quot;_databaseId &#x3D;&#x3D; &#39;db2&#39;&quot;&gt;\n      select nextval for seq_users from sysibm.sysdummy1&quot;\n    &lt;&#x2F;if&gt;\n  &lt;&#x2F;selectKey&gt;\n  insert into users values (#&#123;id&#125;, #&#123;name&#125;)\n&lt;&#x2F;insert&gt;</code></pre>\n\n<h4 id=\"9-动态-SQL-中的插入脚本语言\"><a href=\"#9-动态-SQL-中的插入脚本语言\" class=\"headerlink\" title=\"9. 动态 SQL 中的插入脚本语言\"></a>9. 动态 SQL 中的插入脚本语言</h4><p>MyBatis 从 3.2 版本开始支持插入脚本语言，这允许你插入一种语言驱动，并基于这种语言来编写动态 SQL 查询语句。</p>\n<p>可以通过实现以下接口来插入一种语言：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface LanguageDriver &#123;\n  ParameterHandler createParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql);\n  SqlSource createSqlSource(Configuration configuration, XNode script, Class&lt;?&gt; parameterType);\n  SqlSource createSqlSource(Configuration configuration, String script, Class&lt;?&gt; parameterType);\n&#125;</code></pre>\n\n<p>实现自定义语言驱动</p>\n<p>后，你就可以在 mybatis-config.xml 文件中将它设置为默认语言：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;typeAliases&gt;\n  &lt;typeAlias type&#x3D;&quot;org.sample.MyLanguageDriver&quot; alias&#x3D;&quot;myLanguage&quot;&#x2F;&gt;\n&lt;&#x2F;typeAliases&gt;\n&lt;settings&gt;\n  &lt;setting name&#x3D;&quot;defaultScriptingLanguage&quot; value&#x3D;&quot;myLanguage&quot;&#x2F;&gt;\n&lt;&#x2F;settings&gt;</code></pre>\n\n<p>或者，你也可以使用 <code>lang</code> 属性为特定的语句指定语言：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;select id&#x3D;&quot;selectBlog&quot; lang&#x3D;&quot;myLanguage&quot;&gt;\n  SELECT * FROM BLOG\n&lt;&#x2F;select&gt;</code></pre>\n\n<p>或者，在你的 mapper 接口上添加 <code>@Lang</code> 注解：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface Mapper &#123;\n  @Lang(MyLanguageDriver.class)\n  @Select(&quot;SELECT * FROM BLOG&quot;)\n  List&lt;Blog&gt; selectBlog();\n&#125;</code></pre>\n\n<p>提示 可以使用 Apache Velocity 作为动态语言，更多细节请参考 MyBatis-Velocity 项目。</p>\n<p>你前面看到的所有 xml 标签都由默认 MyBatis 语言提供，而它由语言驱动 <code>org.apache.ibatis.scripting.xmltags.XmlLanguageDriver</code>（别名为 <code>xml</code>）所提供。</p>\n","text":"1. 什么是动态SQL动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦...","link":"","photos":[],"count_time":{"symbolsCount":"9k","symbolsTime":"8 mins."},"categories":[{"name":"Mybatis","slug":"Mybatis","count":6,"path":"api/categories/Mybatis.json"}],"tags":[{"name":"Mybatis","slug":"Mybatis","count":6,"path":"api/tags/Mybatis.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81SQL\"><span class=\"toc-text\">1. 什么是动态SQL</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-if-%E6%A0%87%E7%AD%BE\"><span class=\"toc-text\">2. if 标签</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-choose%E3%80%81when%E3%80%81otherwise\"><span class=\"toc-text\">3. choose、when、otherwise</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-where%E3%80%81trim%E3%80%81set\"><span class=\"toc-text\">4. where、trim、set</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-foreach\"><span class=\"toc-text\">5. foreach</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-script\"><span class=\"toc-text\">6. script</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-bind\"><span class=\"toc-text\">7. bind</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%AF%E6%8C%81\"><span class=\"toc-text\">8. 多数据库支持</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-%E5%8A%A8%E6%80%81-SQL-%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80\"><span class=\"toc-text\">9. 动态 SQL 中的插入脚本语言</span></a></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"Mybatis 对一对多","uid":"b4fe850bfca7fffe4256d22b623aea94","slug":"45-Mybatis-对一对多","date":"2021-09-13T15:22:32.000Z","updated":"2021-09-15T10:51:50.014Z","comments":true,"path":"api/articles/45-Mybatis-对一对多.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog11.jpg","text":"1. 一对一1.1. resultType实现 sql语句 确定查询的主表：订单表 确定查询的关联表：用户表 关联查询使用内连接？还是外连接？ 由于orders表中有一个外键（user_id），通过外键关联查询用户表只能查询出一条记录，可以使用内连接。 SELECT orders...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[{"name":"Mybatis","slug":"Mybatis","count":6,"path":"api/categories/Mybatis.json"}],"tags":[{"name":"Mybatis","slug":"Mybatis","count":6,"path":"api/tags/Mybatis.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"Mybatis 基础要点","uid":"a439be0041fedf424a1ac2607c12651d","slug":"43-Mybatis-基础要点","date":"2021-09-13T15:20:32.000Z","updated":"2021-09-15T10:52:04.327Z","comments":true,"path":"api/articles/43-Mybatis-基础要点.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog9.jpg","text":":hatching_chick: 回忆JDBC① JDBC 编程步骤1. 加载驱动 2. 获取连接 3. 获取数据库操作对象 4. 编写sql，赋值 5. 执行sql 6. 处理查询结果集 7. 释放资源 ② 遗留问题1.数据库连接，使用时就创建，不使用立即释放，对数据库进行频繁...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"Mybatis","slug":"Mybatis","count":6,"path":"api/categories/Mybatis.json"}],"tags":[{"name":"Mybatis","slug":"Mybatis","count":6,"path":"api/tags/Mybatis.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}