{"title":"Redis","uid":"a978a5e93d8e6628e9f4ee713be55be8","slug":"42-Redis","date":"2021-09-13T15:19:32.000Z","updated":"2021-09-15T10:52:16.306Z","comments":true,"path":"api/articles/42-Redis.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","content":"<h3 id=\"1-NoSQL数据库\"><a href=\"#1-NoSQL数据库\" class=\"headerlink\" title=\"1. NoSQL数据库\"></a>1. NoSQL数据库</h3><h4 id=\"1-1-技术发展\"><a href=\"#1-1-技术发展\" class=\"headerlink\" title=\"1.1  技术发展\"></a>1.1  <strong>技术发展</strong></h4><p>技术的分类</p>\n<p>1、解决功能性的问题：Java、JSP、RDBMS、Tomcat、HTML、Linux、JDBC、SVN</p>\n<p>2、解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis</p>\n<p>3、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</p>\n<h4 id=\"1-2-NoSQL特点-适用场合\"><a href=\"#1-2-NoSQL特点-适用场合\" class=\"headerlink\" title=\"1.2 NoSQL特点 适用场合\"></a>1.2 NoSQL特点 适用场合</h4><ul>\n<li>特点<ul>\n<li>易扩展：不依赖业务逻辑方式存储，以简单的key-value模式存储，扩展能力高</li>\n<li>大数据量，高性能：NoSQL泛指非关系型数据库，关系简单，数据库结构简单</li>\n<li>灵活的数据模型（视频/音频/位置地图等）：不遵循sql标准，无需事先为要存储的数据建立字段，随时自定义数据存储格式</li>\n<li>高可用：nosql数据库不是强一致的，而是最终一致的，也没有严格遵守ACID约束</li>\n</ul>\n</li>\n<li>适用场景<ul>\n<li>对数据高并发读写</li>\n<li>海量数据的读写</li>\n<li>对数据高可扩展性</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">### 计数器\n\n可以对 String 进行自增自减运算，从而实现计数器功能。\n\nRedis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。\n\n### 缓存\n\n将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。\n\n### 查找表\n\n例如 DNS 记录就很适合使用 Redis 进行存储。\n\n查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。\n\n### 消息队列\n\nList 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息\n\n不过最好使用 Kafka、RabbitMQ 等消息中间件。\n\n### 会话缓存\n\n可以使用 Redis 来统一存储多台应用服务器的会话信息。\n\n当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。\n\n### 分布式锁实现\n\n在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。\n\n可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。\n\n### 其它\n\nSet 可以实现交集、并集等操作，从而实现共同好友等功能。\n\nZSet 可以实现有序性操作，从而实现排行榜等功能。</code></pre>\n\n<ul>\n<li>不适用场景<ul>\n<li>需要事务支持</li>\n<li>基于sql的结构化查询存储，处理复杂的关系，需要即席查询</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-3-主要的NoSQL数据库\"><a href=\"#1-3-主要的NoSQL数据库\" class=\"headerlink\" title=\"1.3 主要的NoSQL数据库\"></a>1.3 主要的NoSQL数据库</h4><ul>\n<li><p>Memcache nosql数据库</p>\n<ul>\n<li>临时性键值存储，一般不支持持久化，支持类型单一，一般作为缓存数据库辅助持久化数据库</li>\n</ul>\n</li>\n<li><p>Redis 缓存数据库</p>\n<ul>\n<li><p>redis支持两种持久化策略（RDB 快照和 AOF 日志），主要用作备份恢复</p>\n</li>\n<li><p>支持多种数据结构存储，如key-value，list，set，hash，zset，一般也是作为缓存数据库辅助持久化数据库</p>\n</li>\n<li><p>Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</p>\n<p>Redis Cluster 实现了分布式的支持。</p>\n</li>\n<li><p>在 ==Redis 中，并不是所有数据都一直存储在内存中==，可以将一些很久没用的 value 交换到磁盘，而 ==Memcached== 的数据则==会一直在内存中==。</p>\n</li>\n</ul>\n</li>\n<li><p>MongoDB  文档型数据库</p>\n<ul>\n<li>数据都在内存中，若内存不足，则吧不常用的保存到硬盘中</li>\n<li>虽然是key-value模式，但对value提供了丰富的查询功能</li>\n<li>支持二进制数据及大型对象</li>\n<li>可根据特点替代 RDBMS，或配合RDBMS 存储特定的数据</li>\n</ul>\n</li>\n<li><p>面向列的数据库</p>\n<ul>\n<li>Hbase hadoop生态系统中原生的一种nosql数据库，重量级的分布式nosql数据库，用于海量数据的场景，实时的读写</li>\n<li>Cassandra hadoop生态系统中原生的一种分布式nosql数据库，管理庞大集群上的海量数据集，对读写操作进行了规模调整</li>\n</ul>\n</li>\n<li><p>图关系型数据库</p>\n<ul>\n<li>Neo4j 主要应用于社会关系，交通网路，它以节点，关系和属性的形式存储应用程序的数据</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-Redis\"><a href=\"#2-Redis\" class=\"headerlink\" title=\"2. Redis\"></a>2. Redis</h3><h4 id=\"2-1-概述\"><a href=\"#2-1-概述\" class=\"headerlink\" title=\"2.1 概述\"></a>2.1 概述</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和多种不同类型的值之间的映射。\n\n键的类型只能为字符串，支持多种数据结构，如 string（字符串）、 list(双向链表)、dict(hash表)、set(集合）、zset(排序set)、hyperloglog（基数估算）\n\nRedis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。</code></pre>\n\n<h4 id=\"2-2-特点和应用场景\"><a href=\"#2-2-特点和应用场景\" class=\"headerlink\" title=\"2.2 特点和应用场景\"></a>2.2 特点和应用场景</h4><ul>\n<li>特点<ul>\n<li>支持多种数据结构</li>\n<li>支持持久化操作，可以进行aof及rdb数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失的手段。</li>\n<li>支持数据复制，通过master-slave机制，可以实时进行数据的同步复制，支持多级复制和增量复制，master-slave机制是Redis进行HA的重要手段。</li>\n<li>单线程请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。性能受限于CPU性能</li>\n<li>数据都是缓存在内存中。区别是Redis会周期性把更新的数据写入磁盘或把修改操作写入追加的记录文件。</li>\n<li>支持简单的事务需求</li>\n</ul>\n</li>\n<li>应用场景<ul>\n<li>配合关系型数据库做高速缓存</li>\n<li>多样的数据结构存储持久化数据</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-3-安装目录介绍\"><a href=\"#2-3-安装目录介绍\" class=\"headerlink\" title=\"2.3 安装目录介绍\"></a>2.3 安装目录介绍</h4><p>redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何</p>\n<p>redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲</p>\n<p>redis-check-dump：修复有问题的dump.rdb文件</p>\n<p>redis-sentinel：Redis集群使用</p>\n<p>redis-server：Redis服务器启动命令</p>\n<p>redis-cli：客户端，操作入口</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">bind 127.0.0.1 #注释掉这部分，这是限制redis只能本地访问\n\nprotected-mode no #默认yes，开启保护模式，限制为本地访问\n\ndaemonize no#默认no，改为yes意为以守护进程方式启动，可后台运行，除非kill进程，改为yes会使配置文件方式启动redis失败\n\ndatabases 16 #数据库个数（可选），我修改了这个只是查看是否生效。。\n\ndir  .&#x2F; #输入本地redis数据库存放文件夹（可选）\n\nappendonly yes #redis持久化（可选）</code></pre>\n\n<h4 id=\"2-4-设置后台启动\"><a href=\"#2-4-设置后台启动\" class=\"headerlink\" title=\"2.4 设置后台启动\"></a>2.4 设置后台启动</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">前台启动（不推荐）：前台启动，命令行窗口不能关闭，否则服务器停止\n\n后台启动（推荐）\n1.\t备份redis.conf ，拷贝一份redis.conf到其他目录\n\t[root@localhost opt]# mkdir &#x2F;myredis\n\t[root@localhost opt]# cp redis-6.2.1&#x2F;redis.conf &#x2F;myredis&#x2F;redis.conf\n\t\n2.  cd reids-6.2.1\n\t  make\n\t  make install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis\n\t\n2.\t后台启动设置daemonize no改成yes\n\t修改redis.conf(128行)文件将里面的daemonize no 改成 yes，让服务在后台启动\n\t\n3.\tRedis启动\n\t&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server  &#x2F;myredis&#x2F;redis.conf\n \n4.\t用客户端访问：redis-cli\n \n5.\t多个端口可以：redis-cli -p 6379\n\n6.\t测试验证： ping\nRedis Ping 命令使用客户端向 Redis 服务器发送一个 PING ，如果服务器运作正常的话，会返回一个 PONG 。通常用于测试与服务器的连接是否仍然生效，或者用于测量延迟值。\n\n7.\tRedis关闭\n单实例关闭：redis-cli shutdown\n \n也可以进入终端后再关闭\n \n多实例关闭，指定端口关闭：redis-cli -p 6379 shutdown\n</code></pre>\n\n<h4 id=\"2-5-命令手册网址\"><a href=\"#2-5-命令手册网址\" class=\"headerlink\" title=\"2.5 命令手册网址\"></a>2.5 命令手册网址</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">https:&#x2F;&#x2F;www.redis.net.cn&#x2F;order&#x2F;\n\nhttp:&#x2F;&#x2F;doc.redisfans.com&#x2F;\n\nhttp:&#x2F;&#x2F;www.redis.cn&#x2F;commands.html</code></pre>\n\n\n\n<h3 id=\"3-数据类型\"><a href=\"#3-数据类型\" class=\"headerlink\" title=\"3. 数据类型\"></a>3. 数据类型</h3><table>\n<thead>\n<tr>\n<th align=\"center\">数据类型</th>\n<th align=\"center\">可以存储的值</th>\n<th align=\"center\">操作</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">STRING</td>\n<td align=\"center\">字符串、整数或者浮点数</td>\n<td align=\"center\">对整个字符串或者字符串的其中一部分执行操作<br/> 对整数和浮点数执行自增或者自减操作</td>\n</tr>\n<tr>\n<td align=\"center\">LIST</td>\n<td align=\"center\">列表</td>\n<td align=\"center\">从两端压入或者弹出元素 <br/> 对单个或者多个元素进行修剪，<br/> 只保留一个范围内的元素</td>\n</tr>\n<tr>\n<td align=\"center\">SET</td>\n<td align=\"center\">无序集合</td>\n<td align=\"center\">添加、获取、移除单个元素<br/> 检查一个元素是否存在于集合中<br/> 计算交集、并集、差集<br/> 从集合里面随机获取元素</td>\n</tr>\n<tr>\n<td align=\"center\">HASH</td>\n<td align=\"center\">包含键值对的无序散列表</td>\n<td align=\"center\">添加、获取、移除单个键值对<br/> 获取所有键值对<br/> 检查某个键是否存在</td>\n</tr>\n<tr>\n<td align=\"center\">ZSET</td>\n<td align=\"center\">有序集合</td>\n<td align=\"center\">添加、获取、删除元素<br/> 根据分值范围或者成员来获取元素<br/> 计算一个键的排名</td>\n</tr>\n</tbody></table>\n<h4 id=\"3-1-几个基本的命令\"><a href=\"#3-1-几个基本的命令\" class=\"headerlink\" title=\"3.1 几个基本的命令\"></a>3.1 几个基本的命令</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">KEYS * 获得当前数据库的所有键\n\nEXISTS key [key ...]  判断键是否存在，返回个数，如果key有一样的也是叠加数\n\nDEL key [key ...]       删除键，返回删除的个数\n\nTYPE key                  获取减值的数据类型（string，hash，list，set，zset）\n\nFLUSHALL                清空所有数据库\n\nCONFIG [get、set]    redis配置\n\n-inf 负无穷\n\n+inf正无穷</code></pre>\n\n<h4 id=\"3-2-字符串String\"><a href=\"#3-2-字符串String\" class=\"headerlink\" title=\"3.2 字符串String\"></a>3.2 字符串String</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">字符串类型是Redis的最基本类型，它可以存储任何形式的字符串。其它的四种类型都是字符串类型的不同形式。\n\n最基本的命令：GET、SET         语法：GET key，SET key value   value如果有空格需要双引号以示区分\n\n整数递增：INCR                语法：INCR key    默认值为0，所以首先执行命令得到 1 ，不是整型提示错误\n\n增加指定的整数：INCRBY         语法：INCRBY key increment\n\n整数递减：DECR                语法：DECR key   默认值为0，所以首先执行命令得到 -1，不是整型提示错误\n\n减少指定的整数：DECRBY         语法：DECRBY key increment\n\n增加指定浮点数：INCRBYFLOAT    语法：INCRBYFLOAT key increment  与INCR命令类似，只不过可以递增一个双精度浮点数\n\n向尾部追加值：APPEND           语法：APPEND key value   redis客户端并不是输出追加后的字符串，而是输出字符串总长度\n\n获取字符串长度：STRLEN         语法：STRLEN key  如果键不存在返回0，注意如果有中文时，一个中文长度是3，redis是使用UTF-8编码中文的\n\n获取多个键值：MGET             语法：MGET key [key ...]  例如：MGET key1 key2 \n\n设置多个键值：MSET             语法：MSET key value [key value ...]  例如：MSET key1 1 key2 &quot;hello redis&quot;\n\n二进制指定位置值：GETBIT        语法：GETBIT key offset   例如：GETBIT key1 2 ，key1为hello 返回 1，返回的值只有0或1，当key不存在或超出实际长度时为0\n\n设置二进制位置值：SETBIT        语法：SETBIT key offset value ，返回该位置的旧值\n\n二进制是1的个数：BITCOUNT       语法：BITCOUNT key [start end] ，start 、end为开始和结束字节\n\n位运算：BITOP                 语法：BITOP operation destkey key [key ...]  ，operation支持AND、OR、XOR、NOT\n\n偏移：BITPOS                        语法：BITPOS key bit [start] [end]</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">在set时，set后跟不同的后缀有不一样的效果：\n\t*NX：当数据库中key不存在时，可以将key-value添加数据库\n\t*XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥\n\t*EX：key的超时秒数\n\t*PX：key的超时毫秒数，与EX互斥\n\t\nmsetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;  ..... \n同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。\n\ngetrange  &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;\n获得值的范围，类似java中的substring，前包，后包\n\nsetrange  &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;\n用 &lt;value&gt;  覆写&lt;key&gt;所储存的字符串值，从&lt;起始位置&gt;开始(索引从0开始)。\n\nsetex  &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;\n设置键值的同时，设置过期时间，单位秒。\n\ngetset &lt;key&gt;&lt;value&gt;\n以新换旧，设置了新值同时获得旧值。\n</code></pre>\n\n<h4 id=\"3-3-列表类型（list）\"><a href=\"#3-3-列表类型（list）\" class=\"headerlink\" title=\"3.3 列表类型（list）\"></a>3.3 列表类型（list）</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">单键多值\n\nRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。\n\n它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">添加左边元素：LPUSH             语法：LPUSH key value [value ...]  ，返回添加后的列表元素的总个数\n\n添加右边元素：RPUSH             语法：RPUSH key value [value ...]  ，返回添加后的列表元素的总个数\n\n移除左边第一个元素：LPOP         语法：LPOP key  ，返回被移除的元素值\n\n移除右边第一个元素：RPOP         语法：RPOP key ，返回被移除的元素值 \n\n列表元素个数：LLEN              语法：LLEN key， 不存在时返回0，redis是直接读取现成的值，并不是统计个数\n\n获取列表片段：LRANGE            语法：LRANGE key start stop，如果start比stop靠后时返回空列表，0 -1 返回整个列表\n\t\t\t\t\t\t\t  正数时：start 开始索引值，stop结束索引值（索引从0开始）\n    \t\t\t\t\t\t  负数时：例如 lrange num -2 -1，-2表示最右边第二个，-1表示最右边第一个，\n\n删除指定值：LREM                语法：LREM key count value，返回被删除的个数\n\t\t\t\t\t\t\t\t\tcount&gt;0，从左边开始删除前count个值为value的元素\n    \t\t\t\t\t\t\t\tcount&lt;0，从右边开始删除前|count|个值为value的元素\n    \t\t\t\t\t\t\t\tcount&#x3D;0，删除所有值为value的元素\n\n索引元素值：LINDEX              语法：LINDEX key index ，返回索引的元素值，-1表示从最右边的第一位\n\n设置元素值：LSET                语法：LSET key index value\n\n保留列表片段：LTRIM              语法：LTRIM key start stop，start、top 参考lrange命令\n\n一个列表转移另一个列表：RPOPLPUSH  \n语法：RPOPLPUSH source desctination ，从source列表转移到desctination列表，命令分两步看，首先source列表RPOP右移除，再desctination列表LPUSH</code></pre>\n\n<h4 id=\"3-4-集合类型（set）\"><a href=\"#3-4-集合类型（set）\" class=\"headerlink\" title=\"3.4 集合类型（set）\"></a>3.4 集合类型（set）</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">集合类型  值具有 唯一性 ，常用操作是向集合添加、删除、判断某个值是否存在，集合内部是使用值为空的散列表实现的\n\nRedis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是O(1)。</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">添加元素：SADD                  语法：SADD key member [member ...] ，向一个集合添加一个或多个元素，因为集合的唯一性，所以添加相同值时会被忽略。返回成功添加元素的数量。\n\n删除元素：SREM                  语法：SREM key member [member ...] 删除集合中一个或多个元素，返回成功删除的个数。\n\n获取全部元素：SMEMBERS           语法：SMEMBERS key ，返回集合全部元素\n\n值是否存在：SISMEMBER            语法：SISMEMBER key member ，如果存在返回1，不存在返回0\n\n差运算：SDIFF                   语法：SDIFF key [key ...] ，例如：集合A和集合B，差集表示A-B，在A里有的元素B里没有，返回差集合；多个集合(A-B)-C\n\n交运算：SINTER             　　  语法：SINTER key [key ...]，返回交集集合，每个集合都有的元素\n\n并运算：SUNION　　　　　　        语法：SUNION key [key ...]，返回并集集合，所有集合的元素\n\n集合元素个数：SCARD              语法：SCARD key ，返回集合元素个数\n\n集合运算后存储结果                语法：SDIFFSTROE destination key [key ...] ，差运算并存储到destination新集合中\n\t\t\t\t\t\t\t\t\tSINTERSTROE destination key [key ...]，交运算并存储到destination新集合中\t\t\t\t\t\t\t\t\tSUNIONSTROE destination key [key ...]，并运算并存储到destination新集合中\n\n随机获取元素：SRANDMEMGER 语法：SRANDMEMBER key [count]，根据count不同有不同结果，count大于元素总数时返回全部元素\n\t\t\t\t\t\t\tcount&gt;0 ，返回集合中count不重复的元素\n\t\t\t\t\t\t\tcount&lt;0，返回集合中count的绝对值个元素，但元素可能会重复\n\n弹出元素：SPOP                 语法：SPOP key [count] ，因为集合是无序的，所以spop会随机弹出一个元素\n\n把集合中一个值从一个集合移动到另一个集合  语法：smove &lt;source&gt;&lt;destination&gt;value</code></pre>\n\n<h4 id=\"3-5-散列类型（hash）\"><a href=\"#3-5-散列类型（hash）\" class=\"headerlink\" title=\"3.5 散列类型（hash）\"></a>3.5 散列类型（hash）</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">Redis hash 是一个键值对集合，value是一个string类型的field和value的映射表，hash特别适合用于存储对象，类似Java里面的Map&lt;String,Object&gt;</code></pre>\n\n<img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/redisHash.png\" alt=\"image-20210706203409653\" style=\"zoom: 50%;\"  />\n\n<img src=\"C:\\Users\\john\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210706203635062.png\" alt=\"image-20210706203635062\" style=\"zoom:50%;float:center\" />\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">设置单个：HSET                    语法：HSET key field value，不存在时返回1，存在时返回0，没有更新和插入之分\n\n设置多个：HMSET                   语法：HMSET key field value [field value ...]\n\n读取单个：HGET                    语法：HGET key field，不存在是返回nil\n\n读取多个：HMGET                   语法：HMGET key field [field ...]\n\n读取全部：HGETALL                 语法：HGETALL key，返回时字段和字段值的列表\n\n判断字段是否存在：HEXISTS          语法：HEXISTS key field，存在返回1 ，不存在返回0\n\n字段不存在时赋值：HSETNX           语法：HSETNX key field value，与hset命令不同，hsetnx是键不存在时设置值\n\n增加数字：HINCRBY                 语法：HINCRBY key field increment ，返回增加后的数，不是整数时会提示错误\n\n删除字段：HDEL                    语法：HDEL key field [field ...] ，返回被删除字段的个数\n\n只获取字段名：HKEYS               语法：HKEYS key ，返回键的所有字段名\n\n只获取字段值：HVALS               语法：HVALS key  ，返回键的所有字段值\n\n字段数量：HLEN                    语法：HLEN key ，返回字段总数</code></pre>\n\n<h4 id=\"3-6-有序集合类型（zset）\"><a href=\"#3-6-有序集合类型（zset）\" class=\"headerlink\" title=\"3.6 有序集合类型（zset）\"></a>3.6 有序集合类型（zset）</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。\n\n不同之处是有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。\n\n因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。\n\n访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">添加集合元素：ZADD            语法：ZADD key [NX|XX] [CH] [INCR] score member [score member ...]，不存在添加，存在更新。\n\n返回该有序集合的元素个数\t\t语法：zcard&lt;key&gt;\n\n统计该集合，分数区间内的元素个数 语法：zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;\n\n获取元素分数：ZSCORE          语法：ZSCORE key member ，返回元素成员的score 分数\n\n元素小到大：ZRANGE            语法：ZRANGE key start top [WITHSCORES] ，参考LRANGE ，加上withscores 返回带元素，即元素，分数当分数一样时，按元素排序\n\n元素大到小：ZREVRANGE         语法：ZREVRANGE key start [WITHSCORES] ，与zrange区别在于zrevrange是从大到小排序\n\n指定分数范围元素：ZRANGEBYSCORE   语法：ZRANGEBYSCORE key min max [WITHSCORE] [LIMIT offest count]返回从小到大的在min和max之间的元素，( 符号表示不包含，例如：80-100，(80 100，withscore返回带分数,limit offest count 向左偏移offest个元素，并获取前count个元素指定分数范围元素：ZREVRANGESCORE   语法：ZREVRANGEBYSCORE key max  min [WITHSCORE] [LIMIT offest count]与zrangebyscore类似，只不过该命令是从大到小排序的。\n\n增加分数：ZINCRBY             语法：ZINCRBY key increment member ，注意是增加分数，返回增加后的分数；如果成员不存在，则添加一个为0的成员。\n\nzrem  &lt;key&gt;&lt;member &gt;删除该集合下，指定值的元素 \n\nzrank &lt;key&gt;&lt;member &gt; 返回有序集 key 中成员member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。排名以 0 为底，也就是说， score 值最小的成员排名为 0 。\n\nzrevrank &lt;key&gt;&lt;member &gt; 获得成员按 score 值递减(从大到小)排列的排名。\n</code></pre>\n\n\n\n<h3 id=\"4-键过期时间-数据淘汰策略\"><a href=\"#4-键过期时间-数据淘汰策略\" class=\"headerlink\" title=\"4. 键过期时间 数据淘汰策略\"></a>4. 键过期时间 数据淘汰策略</h3><h4 id=\"4-1-键过期时间\"><a href=\"#4-1-键过期时间\" class=\"headerlink\" title=\"4.1 键过期时间\"></a>4.1 键过期时间</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。\n\n对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。</code></pre>\n\n<h4 id=\"4-2-数据淘汰策略\"><a href=\"#4-2-数据淘汰策略\" class=\"headerlink\" title=\"4.2 数据淘汰策略\"></a>4.2 数据淘汰策略</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。</code></pre>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">策略</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">volatile-lru</td>\n<td align=\"center\">从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td>\n</tr>\n<tr>\n<td align=\"center\">volatile-ttl</td>\n<td align=\"center\">从已设置过期时间的数据集中挑选将要过期的数据淘汰</td>\n</tr>\n<tr>\n<td align=\"center\">volatile-random</td>\n<td align=\"center\">从已设置过期时间的数据集中任意选择数据淘汰</td>\n</tr>\n<tr>\n<td align=\"center\">allkeys-lru</td>\n<td align=\"center\">从所有数据集中挑选最近最少使用的数据淘汰</td>\n</tr>\n<tr>\n<td align=\"center\">allkeys-random</td>\n<td align=\"center\">从所有数据集中任意选择数据进行淘汰</td>\n</tr>\n<tr>\n<td align=\"center\">noeviction</td>\n<td align=\"center\">禁止驱逐数据</td>\n</tr>\n</tbody></table>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。\n\n使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。\n\nRedis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</code></pre>\n\n\n\n<h3 id=\"5-Redis配置文件介绍\"><a href=\"#5-Redis配置文件介绍\" class=\"headerlink\" title=\"5. Redis配置文件介绍\"></a>5. Redis配置文件介绍</h3><h4 id=\"5-1-开头说明\"><a href=\"#5-1-开头说明\" class=\"headerlink\" title=\"5.1 开头说明\"></a>5.1 开头说明</h4><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/redis1.png\" alt=\"image-20210706205914378\"  />\n\n<p>这里没什么好说的，需要注意的是后面需要使用内存大小时，可以指定单位，通常是以 k,gb,m的形式出现，并且<strong>单位不区分大小写</strong>。</p>\n<h4 id=\"5-2-INCLUDES\"><a href=\"#5-2-INCLUDES\" class=\"headerlink\" title=\"5.2 INCLUDES\"></a>5.2 INCLUDES</h4><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/redis-Includes.png\" alt=\"image-20210707203620377\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">我们知道Redis只有一个配置文件，如果多个人进行开发维护，那么就需要多个这样的配置文件，这时候多个配置文件就可以在此通过 include &#x2F;path&#x2F;to&#x2F;local.conf 配置进来，而原本的 redis.conf 配置文件就作为一个总闸。\n\n另外需要注意的时，如果将此配置写在redis.conf 文件的开头，那么后面的配置会覆盖引入文件的配置，如果想以引入文件的配置为主，那么需要将 include 配置写在 redis.conf 文件的末尾。</code></pre>\n\n<h4 id=\"5-3-MODULES\"><a href=\"#5-3-MODULES\" class=\"headerlink\" title=\"5.3 MODULES\"></a>5.3 MODULES</h4><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/redis-MODULES.png\" alt=\"image-20210707203728521\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">redis3.0的爆炸功能是新增了集群，而redis4.0就是在3.0的基础上新增了许多功能，其中这里的 自定义模块配置就是其中之一。通过这里的 loadmodule 配置将引入自定义模块来新增一些功能。</code></pre>\n\n<h4 id=\"5-4-NETWORK\"><a href=\"#5-4-NETWORK\" class=\"headerlink\" title=\"5.4 NETWORK\"></a>5.4 NETWORK</h4><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/redis-network-1.png\" alt=\"image-20210707203821140\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">只截取了一部分，下同。\n\n　　①、bind:绑定redis服务器网卡IP，默认为127.0.0.1,即本地回环地址。这样的话，访问redis服务只能通过本机的客户端连接，而无法通过远程连接。如果bind选项为空的话，那会接受所有来自于可用网络接口的连接。\n\n　　②、port：指定redis运行的端口，默认是6379。由于Redis是单线程模型，因此单机开多个Redis进程的时候会修改端口。\n\n　　③、timeout：设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么关闭该连接。默认值为0，表示不关闭。\n\n　　④、tcp-keepalive ：单位是秒，表示将周期性的使用SO_KEEPALIVE检测客户端是否还处于健康状态，避免服务器一直阻塞，官方给出的建议值是300s，如果设置为0，则不会周期性的检测。</code></pre>\n\n<h4 id=\"5-5-GENERAL\"><a href=\"#5-5-GENERAL\" class=\"headerlink\" title=\"5.5 GENERAL\"></a>5.5 GENERAL</h4><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/redis-general.png\" alt=\"image-20210707203946045\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">具体配置详解：\n\n　　①、daemonize:设置为yes表示指定Redis以守护进程的方式启动（后台启动）。默认值为 no\n\n　　②、pidfile:配置PID文件路径，当redis作为守护进程运行的时候，它会把 pid 默认写到 &#x2F;var&#x2F;redis&#x2F;run&#x2F;redis_6379.pid 文件里面\n\n　　③、loglevel ：定义日志级别。默认值为notice，有如下4种取值：\n\n　　　　　　　　　　debug（记录大量日志信息，适用于开发、测试阶段）\n\n　　　　　　　　　　verbose（较多日志信息）\n\n　　　　　　　　　　notice（适量日志信息，使用于生产环境）\n\n　　　　　　　　　　warning（仅有部分重要、关键信息才会被记录）\n\n　　④、logfile ：配置log文件地址,默认打印在命令行终端的窗口上\n\n　　⑤、databases：设置数据库的数目。默认的数据库是DB 0 ，可以在每个连接上使用select  &lt;dbid&gt; 命令选择一个不同的数据库，dbid是一个介于0到databases - 1 之间的数值。默认值是 16，也就是说默认Redis有16个数据库。</code></pre>\n\n<h4 id=\"5-6-SNAPSHOTTING\"><a href=\"#5-6-SNAPSHOTTING\" class=\"headerlink\" title=\"5.6 SNAPSHOTTING\"></a>5.6 SNAPSHOTTING</h4><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/redis-snapshotting.png\" alt=\"image-20210707204048848\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">①、save：这里是用来配置触发 Redis的持久化条件，也就是什么时候将内存中的数据保存到硬盘。默认如下配置：\n\nsave 900 1：表示900 秒内如果至少有 1 个 key 的值变化，则保存\nsave 300 10：表示300 秒内如果至少有 10 个 key 的值变化，则保存\nsave 60 10000：表示60 秒内如果至少有 10000 个 key 的值变化，则保存\n　　　　当然如果你只是用Redis的缓存功能，不需要持久化，那么你可以注释掉所有的 save 行来停用保存功能。可以直接一个空字符串来实现停用：save &quot;&quot;\n\n　　②、stop-writes-on-bgsave-error ：默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了\n\n　　③、rdbcompression ；默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。\n\n　　④、rdbchecksum ：默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。\n\n　　⑤、dbfilename ：设置快照的文件名，默认是 dump.rdb\n\n　　⑥、dir：设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。使用上面的 dbfilename 作为保存的文件名。</code></pre>\n\n<h4 id=\"5-7-REPLICATION\"><a href=\"#5-7-REPLICATION\" class=\"headerlink\" title=\"5.7 REPLICATION\"></a>5.7 REPLICATION</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">①、slave-serve-stale-data：默认值为yes。当一个 slave 与 master 失去联系，或者复制正在进行的时候，slave 可能会有两种表现：\n\n  　　　　1) 如果为 yes ，slave 仍然会应答客户端请求，但返回的数据可能是过时，或者数据可能是空的在第一次同步的时候 \n\n  　　　　2) 如果为 no ，在你执行除了 info he salveof 之外的其他命令时，slave 都将返回一个 &quot;SYNC with master in progress&quot; 的错误\n\n　　②、slave-read-only：配置Redis的Slave实例是否接受写操作，即Slave是否为只读Redis。默认值为yes。\n\n　　③、repl-diskless-sync：主从数据复制是否使用无硬盘复制功能。默认值为no。\n\n　　④、repl-diskless-sync-delay：当启用无硬盘备份，服务器等待一段时间后才会通过套接字向从站传送RDB文件，这个等待时间是可配置的。  这一点很重要，因为一旦传送开始，就不可能再为一个新到达的从站服务。从站则要排队等待下一次RDB传送。因此服务器等待一段  时间以期更多的从站到达。延迟时间以秒为单位，默认为5秒。要关掉这一功能，只需将它设置为0秒，传送会立即启动。默认值为5。\n\n　　⑤、repl-disable-tcp-nodelay：同步之后是否禁用从站上的TCP_NODELAY 如果你选择yes，redis会使用较少量的TCP包和带宽向从站发送数据。但这会导致在从站增加一点数据的延时。  Linux内核默认配置情况下最多40毫秒的延时。如果选择no，从站的数据延时不会那么多，但备份需要的带宽相对较多。默认情况下我们将潜在因素优化，但在高负载情况下或者在主从站都跳的情况下，把它切换为yes是个好主意。默认值为no。</code></pre>\n\n<h4 id=\"5-8-SECURITY\"><a href=\"#5-8-SECURITY\" class=\"headerlink\" title=\"5.8 SECURITY\"></a>5.8 SECURITY</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">①、rename-command：命令重命名，对于一些危险命令例如：\n\n　　　　flushdb（清空数据库）\n\n　　　　flushall（清空所有记录）\n\n　　　　config（客户端连接后可配置服务器）\n\n　　　　keys（客户端连接后可查看所有存在的键）                   \n\n　　作为服务端redis-server，常常需要禁用以上命令来使得服务器更加安全，禁用的具体做法是是：\n\nrename-command FLUSHALL &quot;&quot;\n也可以保留命令但是不能轻易使用，重命名这个命令即可：\n\nrename-command FLUSHALL abcdefg\n　　这样，重启服务器后则需要使用新命令来执行操作，否则服务器会报错unknown command。\n\n　　②、requirepass:设置redis连接密码\n\n　　比如: requirepass 123  表示redis的连接密码为123</code></pre>\n\n<h4 id=\"5-9-CLIENTS\"><a href=\"#5-9-CLIENTS\" class=\"headerlink\" title=\"5.9 CLIENTS\"></a>5.9 CLIENTS</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">①、maxclients ：设置客户端最大并发连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件。  描述符数-32（redis server自身会使用一些），如果设置 maxclients为0 。表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</code></pre>\n\n<h4 id=\"5-10-MEMORY-MANAGEMENT\"><a href=\"#5-10-MEMORY-MANAGEMENT\" class=\"headerlink\" title=\"5.10 MEMORY MANAGEMENT\"></a>5.10 MEMORY MANAGEMENT</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">①、maxmemory：设置Redis的最大内存，如果设置为0 。表示不作限制。通常是配合下面介绍的maxmemory-policy参数一起使用。\n\n　　②、maxmemory-policy ：当内存使用达到maxmemory设置的最大值时，redis使用的内存清除策略。有以下几种可以选择：\n\n　　　　1）volatile-lru   利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used ) \n\n　　　　2）allkeys-lru   利用LRU算法移除任何key \n\n　　　　3）volatile-random 移除设置过过期时间的随机key \n\n　　　　4）allkeys-random  移除随机ke\n\n　　　　5）volatile-ttl   移除即将过期的key(minor TTL) \n\n　　　　6）noeviction  noeviction   不移除任何key，只是返回一个写错误 ，默认选项\n\n 　　③、maxmemory-samples ：LRU 和 minimal TTL 算法都不是精准的算法，但是相对精确的算法(为了节省内存)。随意你可以选择样本大小进行检，redis默认选择3个样本进行检测，你可以通过maxmemory-samples进行设置样本数。</code></pre>\n\n<h4 id=\"5-11-APPEND-ONLY-MODE\"><a href=\"#5-11-APPEND-ONLY-MODE\" class=\"headerlink\" title=\"5.11 APPEND ONLY MODE\"></a>5.11 APPEND ONLY MODE</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">①、appendonly：默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append Only File是另一种持久化方式，  可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入appendonly.aof文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。默认值为no。\n\n　　②、appendfilename ：aof文件名，默认是&quot;appendonly.aof&quot;\n\n　　③、appendfsync：aof持久化策略的配置；no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快；always表示每次写入都执行fsync，以保证数据同步到磁盘；everysec表示每秒执行一次fsync，可能会导致丢失这1s数据\n\n　　④、no-appendfsync-on-rewrite：在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。   设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。Linux的默认fsync策略是30秒。可能丢失30秒数据。默认值为no。\n\n　　⑤、auto-aof-rewrite-percentage：默认值为100。aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。\n\n　　⑥、auto-aof-rewrite-min-size：64mb。设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写。\n\n　　⑦、aof-load-truncated：aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data&#x3D;ordered选项，出现这种现象  redis宕机或者异常终止不会造成尾部不完整现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。默认值为 yes。\n\n</code></pre>\n\n<h4 id=\"5-12-LUA-SCRIPTING\"><a href=\"#5-12-LUA-SCRIPTING\" class=\"headerlink\" title=\"5.12 LUA SCRIPTING\"></a>5.12 LUA SCRIPTING</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">①、lua-time-limit：一个lua脚本执行的最大时间，单位为ms。默认值为5000.</code></pre>\n\n<h4 id=\"5-13-REDIS-CLUSTER\"><a href=\"#5-13-REDIS-CLUSTER\" class=\"headerlink\" title=\"5.13 REDIS CLUSTER\"></a>5.13 REDIS CLUSTER</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">①、cluster-enabled：集群开关，默认是不开启集群模式。\n\n　　②、cluster-config-file：集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。 这个文件并不需要手动配置，这个配置文件有Redis生成并更新，每个Redis集群节点需要一个单独的配置文件。请确保与实例运行的系统中配置文件名称不冲突。默认配置为nodes-6379.conf。\n\n　　③、cluster-node-timeout ：可以配置值为15000。节点互连超时的阀值，集群节点超时毫秒数\n\n　　④、cluster-slave-validity-factor ：可以配置值为10。在进行故障转移的时候，全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了，  导致数据过于陈旧，这样的slave不应该被提升为master。该参数就是用来判断slave节点与master断线的时间是否过长。判断方法是：比较slave断开连接的时间和(node-timeout * slave-validity-factor) + repl-ping-slave-period     如果节点超时时间为三十秒, 并且slave-validity-factor为10,假设默认的repl-ping-slave-period是10秒，即如果超过310秒slave将不会尝试进行故障转移\n\n　　⑤、cluster-migration-barrier ：可以配置值为1。master的slave数量大于该值，slave才能迁移到其他孤立master上，如这个参数若被设为2，那么只有当一个主节点拥有2 个可工作的从节点时，它的一个从节点会尝试迁移。\n\n　　⑥、cluster-require-full-coverage：默认情况下，集群全部的slot有节点负责，集群状态才为ok，才能提供服务。  设置为no，可以在slot没有全部分配的时候提供服务。不建议打开该配置，这样会造成分区的时候，小分区的master一直在接受写请求，而造成很长时间数据不一致。</code></pre>\n\n\n\n<h3 id=\"6-Jedis测试\"><a href=\"#6-Jedis测试\" class=\"headerlink\" title=\"6. Jedis测试\"></a>6. Jedis测试</h3><h4 id=\"6-1-概述\"><a href=\"#6-1-概述\" class=\"headerlink\" title=\"6.1 概述\"></a>6.1 概述</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">Jedis是Redis官方推荐的Java连接开发工具。好比Java提供了JDBC来访问关系型数据库一样，Java中也可以使用Jedis来操作Redis。Jedis操作非常简单，因为Jedis的API 和redis的命令基本是相同的。</code></pre>\n\n<h4 id=\"6-2-添加依赖\"><a href=\"#6-2-添加依赖\" class=\"headerlink\" title=\"6.2 添加依赖\"></a>6.2 添加依赖</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;dependency&gt;\n&lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;\n&lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;\n&lt;version&gt;3.2.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<h4 id=\"6-3-连接前注意事项\"><a href=\"#6-3-连接前注意事项\" class=\"headerlink\" title=\"6.3 连接前注意事项\"></a>6.3 连接前注意事项</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">禁用Linux的防火墙：Linux(CentOS7)里执行命令\nsystemctl stop&#x2F;disable firewalld.service   \nredis.conf中注释掉bind 127.0.0.1 ,然后 protected-mode no</code></pre>\n\n<h4 id=\"6-4-创建测试Maven工程\"><a href=\"#6-4-创建测试Maven工程\" class=\"headerlink\" title=\"6.4 创建测试Maven工程\"></a>6.4 创建测试Maven工程</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.jedis;\nimport redis.clients.jedis.Jedis;\n\npublic class Demo01 &#123;\n    public static void main(String[] args) &#123;\n    Jedis jedis &#x3D; new Jedis(&quot;192.168.137.3&quot;,6379);\n    String pong &#x3D; jedis.ping();\n    System.out.println(&quot;连接成功：&quot;+pong);\n    jedis.close();\n\t&#125;\n&#125;\n\n\npublic class TestJedis3 &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;指定Jedis连接池的配置信息\n        JedisPoolConfig poolConfig &#x3D; new JedisPoolConfig();\n        poolConfig.setMaxTotal(200);\n        poolConfig.setMaxIdle(32);\n        poolConfig.setMaxWaitMillis(100*1000);\n        poolConfig.setBlockWhenExhausted(true);\n        poolConfig.setTestOnBorrow(true);  &#x2F;&#x2F; ping  PONG\n\n        &#x2F;&#x2F;根据配置创建Jedis连接池\n        JedisPool jedisPool &#x3D; new JedisPool(poolConfig, &quot;192.168.80.128&quot;, 6379, 60000 );\n        Jedis jedis &#x3D; jedisPool.getResource();\n        String result &#x3D; jedis.ping();\n        System.out.println(result);\n    &#125;\n&#125;\n\n接下来就是测试各种数据类型的方法</code></pre>\n\n\n\n<h3 id=\"7-Redis事务\"><a href=\"#7-Redis事务\" class=\"headerlink\" title=\"7. Redis事务\"></a>7. Redis事务</h3><h4 id=\"7-1-概述\"><a href=\"#7-1-概述\" class=\"headerlink\" title=\"7.1 概述\"></a>7.1 概述</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。\n\n事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。\n\nRedis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。\nRedis事务的主要作用就是串联多个命令防止别的命令插队。\n\nRedis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。\n\n从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。组队的过程中可以通过discard来放弃组队。\n\n*** 组队中某个命令出现了报告错误，执行时整个队列中所有命令都会被取消。\n*** 执行阶段某个命令报错，则只有报错命令不会被执行，而其他命令都会执行，不会回滚。（Redis事务没有原子性）</code></pre>\n\n<h5 id=\"7-1-1-原子性\"><a href=\"#7-1-1-原子性\" class=\"headerlink\" title=\"7.1.1 原子性\"></a>7.1.1 原子性</h5><p>1、事务队列中出错，直接失败</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/redis%E9%AA%8C%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7.png\" alt=\"image-20210708095619985\"></p>\n<p>2、事务队列中不出错，但是，有一个语句错误，发现并没有同时失败（错误的话，应该回滚，但是redis并没有回滚）</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/redis%E9%AA%8C%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A72.png\" alt=\"image-20210708100013130\"></p>\n<p>所以从严格意义上来讲，redis并不具备原子性</p>\n<h5 id=\"7-1-2-一致性\"><a href=\"#7-1-2-一致性\" class=\"headerlink\" title=\"7.1.2 一致性\"></a>7.1.2 一致性</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">如果加上业务去谈一致性，例如，A 转账给 B，A 减少 10 块钱，B 增加 10 块钱，因为 Redis 并不具备回滚，也就不具备传统意义上的原子性，所以 Redis 也应该不具备传统的一致性。</code></pre>\n\n<h5 id=\"7-1-3-隔离性\"><a href=\"#7-1-3-隔离性\" class=\"headerlink\" title=\"7.1.3 隔离性\"></a>7.1.3 隔离性</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">Redis 事务总是以串行的方式运行，事务也具备隔离性。</code></pre>\n\n<h5 id=\"7-1-4-持久性\"><a href=\"#7-1-4-持久性\" class=\"headerlink\" title=\"7.1.4 持久性\"></a>7.1.4 持久性</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">取决于redis的策略模式\n纯内存模式，不支持\nrdb aof 支持</code></pre>\n\n<h5 id=\"7-1-5-小结\"><a href=\"#7-1-5-小结\" class=\"headerlink\" title=\"7.1.5 小结\"></a>7.1.5 小结</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">Redis 具备了一定的原子性，但不支持回滚；\n\nRedis 不具备 ACID 中一致性的概念。(或者说 Redis 在设计时就无视这点)；\n\nRedis 具备隔离性；\n\nRedis 通过一定策略可以保证持久性。</code></pre>\n\n<h4 id=\"7-2-悲观锁\"><a href=\"#7-2-悲观锁\" class=\"headerlink\" title=\"7.2 悲观锁\"></a>7.2 悲观锁</h4><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/pessimisticLock.png\" alt=\"image-20210706212039587\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。\n传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</code></pre>\n\n<h4 id=\"7-3-乐观锁\"><a href=\"#7-3-乐观锁\" class=\"headerlink\" title=\"7.3 乐观锁\"></a>7.3 乐观锁</h4><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/optimisticLock.png\" alt=\"image-20210706212131231\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。\n乐观锁适用于多读的应用类型，这样可以提高吞吐量。Redis就是利用这种check-and-set机制实现事务的。</code></pre>\n\n<h4 id=\"7-4-watch-key-【key…】\"><a href=\"#7-4-watch-key-【key…】\" class=\"headerlink\" title=\"7.4 watch key 【key…】\"></a>7.4 watch key 【key…】</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key\n\nhttps:&#x2F;&#x2F;gitee.com&#x2F;hrenxiang&#x2F;picture&#x2F;raw&#x2F;master&#x2F;img&#x2F;optimisticLock.png</code></pre>\n\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/redis-watch.png\" alt=\"image-20210708101510568\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置更新为新值。否则，处理器不做任何操作。\n\n开始监视后，就会将监视的key的值保存下来，作为原值\n\n如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</code></pre>\n\n<h4 id=\"7-5-Redis事务三特性\"><a href=\"#7-5-Redis事务三特性\" class=\"headerlink\" title=\"7.5 Redis事务三特性\"></a>7.5 Redis事务三特性</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">单独的隔离操作 \n\t事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 \n没有隔离级别的概念 \n\t队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行\n不保证原子性 \n\t事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</code></pre>\n\n<p><strong>Redis</strong> 事务和 **MySQL ** 事务的区别</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">MySQL事务遵守严格的ACID特征，而Redis 设计更多的是追求简单与高性能，所以事务不会也没有必要受制于传统 ACID 的束缚。\n\n Redis 具备了一定的原子性，但不支持回滚，严格意义上无法保证原子性。\n\n Redis 不支持回滚，也就无法保证业务上的数据一致性。\n\n Redis 具备隔离性，但是没有隔离级别。\n\nRedis 通过一定策略可以保证持久性。Redis 是否具备持久化，取决于 Redis 的持久化模式比如AOF、RDB及其策略设置</code></pre>\n\n<h4 id=\"7-6-秒杀案例\"><a href=\"#7-6-秒杀案例\" class=\"headerlink\" title=\"7.6 秒杀案例\"></a>7.6 秒杀案例</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">1. 超卖问题  (库存会出现负数)\n2. 乐观锁解决超卖问题，(有库存剩余问题和连接超时)\n3. lua脚本解决问题</code></pre>\n\n<h4 id=\"7-7-Lua脚本\"><a href=\"#7-7-Lua脚本\" class=\"headerlink\" title=\"7.7 Lua脚本\"></a>7.7 Lua脚本</h4><h5 id=\"7-7-1-概述\"><a href=\"#7-7-1-概述\" class=\"headerlink\" title=\"7.7.1 概述\"></a>7.7.1 概述</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</code></pre>\n\n<h5 id=\"7-7-2-特性\"><a href=\"#7-7-2-特性\" class=\"headerlink\" title=\"7.7.2 特性\"></a>7.7.2 特性</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">轻量级: 它用标准C语言编写并以源代码形式开放，编译后仅仅一百余K，可以很方便的嵌入别的程序里。\n可扩展: Lua提供了非常易于使用的扩展接口和机制：由宿主语言(通常是C或C++)提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。\n\n其它特性:\n支持面向过程(procedure-oriented)编程和函数式编程(functional programming)；\n自动内存管理；只提供了一种通用类型的表（table），用它可以实现数组，哈希表，集合，对象；\n语言内置模式匹配；闭包(closure)；函数也可以看做一个值；提供多线程（协同进程，并非操作系统所支持的线程）支持；\n通过闭包和table可以很方便地支持面向对象编程所需要的一些关键机制，比如数据抽象，虚函数，继承和重载等。</code></pre>\n\n<h5 id=\"7-7-3-应用场景\"><a href=\"#7-7-3-应用场景\" class=\"headerlink\" title=\"7.7.3 应用场景\"></a>7.7.3 应用场景</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">游戏开发\n独立应用脚本\nWeb 应用脚本\n扩展和数据库插件如：MySQL Proxy 和 MySQL WorkBench\n安全系统，如入侵检测系统</code></pre>\n\n<h5 id=\"7-7-4-LUA脚本在Redis中的优势\"><a href=\"#7-7-4-LUA脚本在Redis中的优势\" class=\"headerlink\" title=\"7.7.4 LUA脚本在Redis中的优势\"></a>7.7.4 LUA脚本在Redis中的优势</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数。提升性能。\n\nLUA脚本是类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作。\n\n但是注意redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用。\n\n利用lua脚本淘汰用户，解决超卖问题。\n\nredis 2.6版本以后，通过lua脚本解决**争抢问题**，实际上是**redis** **利用其单线程的特性，用任务队列的方式解决多任务并发问题**。</code></pre>\n\n\n\n<h3 id=\"8-Redis持久化\"><a href=\"#8-Redis持久化\" class=\"headerlink\" title=\"8. Redis持久化\"></a>8. Redis持久化</h3><h4 id=\"8-1-概述\"><a href=\"#8-1-概述\" class=\"headerlink\" title=\"8.1 概述\"></a>8.1 概述</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后回复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</code></pre>\n\n<table>\n<thead>\n<tr>\n<th>两种持久化方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Redis不同于Memcached的很重一点就是，<strong>Redis支持持久化</strong>，而且支持两种不同的持久化操作。<br/>Redis的一种持久化方式叫<strong>快照（snapshotting，RDB）</strong>,另一种方式是<strong>只追加文件（append-only file,AOF）</strong></td>\n</tr>\n</tbody></table>\n<h4 id=\"8-2-快照（snapshotting，RDB）\"><a href=\"#8-2-快照（snapshotting，RDB）\" class=\"headerlink\" title=\"8.2 快照（snapshotting，RDB）\"></a>8.2 快照（snapshotting，RDB）</h4><h5 id=\"8-2-1-快照概述\"><a href=\"#8-2-1-快照概述\" class=\"headerlink\" title=\"8.2.1 快照概述\"></a>8.2.1 快照概述</h5><p>Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。</p>\n<p>如果在新的快照文件创建完毕之前，Redis、系统或者硬件这三者中的任意一个崩溃了，那么Redis将丢失最近一次创建快照写入的所有数据。</p>\n<p>如果数据量很大，保存快照的时间会很长。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">举个例子：假设Redis的上一个快照是2：35开始创建的，并且已经创建成功。下午3：06时，Redis又开始创建新的快照，并且在下午3：08快照创建完毕之前，有35个键进行了更新。如果在下午3：06到3：08期间，系统发生了崩溃，导致Redis无法完成新快照的创建工作，那么Redis将丢失下午2：35之后写入的所有数据。另一方面，如果系统恰好在新的快照文件创建完毕之后崩溃，那么Redis将丢失35个键的更新数据。</code></pre>\n\n\n\n<p><strong>快照持久化是Redis默认采用的持久化方式</strong>，在redis.conf配置文件中默认有此下配置：</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/redisRDBConfig.png\" alt=\"image-20210706223512673\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">save 900 1              #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。\n\nsave 300 10            #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。\n\nsave 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</code></pre>\n\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/redisDBfilename.png\" alt=\"image-20210706223725359\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">根据配置，快照将被写入dbfilename选项指定的文件里面，并存储在dir选项指定的路径上面。</code></pre>\n\n<h5 id=\"8-2-2-备份是如何执行的\"><a href=\"#8-2-2-备份是如何执行的\" class=\"headerlink\" title=\"8.2.2 备份是如何执行的\"></a>8.2.2 备份是如何执行的</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</code></pre>\n\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/redisBaseFork.png\" alt=\"image-20210706234113466\"></p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/redisBaseFork2.png\" alt=\"image-20210706234444273\"></p>\n<p>==<strong>fork</strong>==</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程\n\nLinux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux引入“写时复制技术（CopyOnWrite）”\n\n一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。\n\n目前有两大类存储快照，一种叫做即写即拷（copy-on-write）快照【别名：写时复制】，另一种叫做分割镜像快照；</code></pre>\n\n<h5 id=\"8-2-3-创建快照的办法\"><a href=\"#8-2-3-创建快照的办法\" class=\"headerlink\" title=\"8.2.3 创建快照的办法\"></a>8.2.3 创建快照的办法</h5><ul>\n<li><strong>BGSAVE命令：</strong> 客户端向Redis发送 <strong>BGSAVE命令</strong> 来创建一个快照。对于支持BGSAVE命令的平台来说（基本上所有平台支持，除了Windows平台），Redis会调用fork来创建一个子进程，然后子进程负责将快照写入硬盘，而父进程则继续处理命令请求。</li>\n<li><strong>SAVE命令：</strong> 客户端还可以向Redis发送 <strong>SAVE命令</strong> 来创建一个快照，接到SAVE命令的Redis服务器在快照创建完毕之前不会再响应任何其他命令。SAVE命令不常用，我们通常只会在没有足够内存去执行BGSAVE命令的情况下，又或者即使等待持久化操作执行完毕也无所谓的情况下，才会使用这个命令。</li>\n<li><strong>save选项：</strong> 如果用户设置了save选项（一般会默认设置），比如 <strong>save 60 10000</strong>，那么从Redis最近一次创建快照之后开始算起，当“60秒之内有10000次写入”这个条件被满足时，Redis就会自动触发BGSAVE命令。</li>\n<li><strong>SHUTDOWN命令：</strong>  当Redis通过SHUTDOWN命令接收到关闭服务器的请求时，或者接收到标准TERM信号时，会执行一个SAVE命令，阻塞所有客户端，不再执行客户端发送的任何命令，并在SAVE命令执行完毕之后关闭服务器。</li>\n<li><strong>一个Redis服务器连接到另一个Redis服务器：</strong> 当一个Redis服务器连接到另一个Redis服务器，并向对方发送SYNC命令来开始一次复制操作的时候，如果主服务器目前没有执行BGSAVE操作，或者主服务器并非刚刚执行完BGSAVE操作，那么主服务器就会执行BGSAVE命令</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">RDB的持久化策略（触发持久化，其实就是上面的）\n\n\t配置文件中默认的快照配置（自动持久化）\n\tsave VS bgsave\n\tflushall：rdb文件将没有数据（貌似没有flushdb）\n\tshutdown：正常关闭</code></pre>\n\n<p>如果系统真的发生崩溃，用户将丢失最近一次生成快照之后更改的所有数据。因此，快照持久化只适用于即使丢失一部分数据也不会造成一些大问题的应用程序。不能接受这个缺点的话，可以考虑AOF持久化。</p>\n<h5 id=\"8-2-4-RDB文件结构\"><a href=\"#8-2-4-RDB文件结构\" class=\"headerlink\" title=\"8.2.4 RDB文件结构\"></a>8.2.4 RDB文件结构</h5><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/RDBstructer.png\" alt=\"rdbfile\"></p>\n<table>\n<thead>\n<tr>\n<th>数据部分</th>\n<th>数据类型</th>\n<th>长度</th>\n<th>数据含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>REDIS</td>\n<td>常量</td>\n<td>5字节</td>\n<td><code>RDB</code>文件标识，用来快速检查载入的文件是否是<code>RDB</code>文件</td>\n</tr>\n<tr>\n<td>db_version</td>\n<td>变量</td>\n<td>4字节</td>\n<td><code>RDB</code>文件版本号</td>\n</tr>\n<tr>\n<td>database</td>\n<td>数据</td>\n<td>不定</td>\n<td><code>Redis</code>各个非空数据库状态</td>\n</tr>\n<tr>\n<td>EOF</td>\n<td>常量</td>\n<td>1字节</td>\n<td>标志着<code>RDB</code>文件正文内容结束</td>\n</tr>\n<tr>\n<td>check_sum</td>\n<td>变量</td>\n<td>8字节</td>\n<td>校验和，根据前面4部分计算而来，用来检查<code>RDB</code>文件完整性</td>\n</tr>\n</tbody></table>\n<p><strong>database部分</strong></p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/redisRDBdatabase.png\" alt=\"rdb-database\"></p>\n<table>\n<thead>\n<tr>\n<th>数据部分</th>\n<th>数据类型</th>\n<th>长度</th>\n<th>数据含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SELECT_DB</td>\n<td>常量</td>\n<td>1字节</td>\n<td>数据库开头标识</td>\n</tr>\n<tr>\n<td>db_number</td>\n<td>变量</td>\n<td>1-5个字节</td>\n<td>数据库开头号码</td>\n</tr>\n<tr>\n<td>key_value_pairs</td>\n<td>数据</td>\n<td>不定</td>\n<td>数据库所有键值对数据</td>\n</tr>\n</tbody></table>\n<p><strong>key_value_pairs部分</strong></p>\n<p><code>key_value_pairs</code>部分保存了一个数据所有的键值对数据，其中不带过期时间的键值对有<code>TYPE</code>、<code>key</code>、<code>value</code>三部分组成，带过期时间的话，会在前面多出<code>EXPIRETIME_MS</code>和<code>ms</code>两部分。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/955ec99cd09f9bf0504cae07de90960c.png\" alt=\"rdb-kv\"></p>\n<table>\n<thead>\n<tr>\n<th>数据部分</th>\n<th>数据类型</th>\n<th>长度</th>\n<th>数据含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>EXPIRETIME_MS</td>\n<td>常量</td>\n<td>1字节</td>\n<td>键值对过期时间标识</td>\n</tr>\n<tr>\n<td>ms</td>\n<td>变量</td>\n<td>8字节</td>\n<td>键值对的过期时间（毫秒）</td>\n</tr>\n<tr>\n<td>TYPE</td>\n<td>常量</td>\n<td>1字节</td>\n<td>数据库值的类型</td>\n</tr>\n<tr>\n<td>key</td>\n<td>变量</td>\n<td>不定</td>\n<td>数据库键，永远是字符串对象</td>\n</tr>\n<tr>\n<td>value</td>\n<td>变量</td>\n<td>不定</td>\n<td>数据库值，根据<code>TYPE</code>不用，<code>value</code>保存结构也不同</td>\n</tr>\n</tbody></table>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>每个<code>value</code>都保存着一个值对象，每个值对象的类型由<code>TYPE</code>字段记录。根据<code>TYPE</code>类型不同，<code>value</code>部分的结构、长度也会有所不同。这块思想上跟内存中底层数据结构类似，这里就不展开细讲了。</p></blockquote>\n<p>至此，一个<code>RDB</code>文件完整的部分就出来了，如下所示：<img src=\"https://img-blog.csdnimg.cn/img_convert/b2defba05d7779dfc9f8da594fe50f34.png\" alt=\"rdb-all\"></p>\n<h5 id=\"8-2-5-RDB的优缺点\"><a href=\"#8-2-5-RDB的优缺点\" class=\"headerlink\" title=\"8.2.5 RDB的优缺点\"></a>8.2.5 RDB的优缺点</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">优点：\n    适合大规模的数据恢复\n    对数据完整性和一致性要求不高更适合使用\n    节省磁盘空间\n    恢复速度快\n\n缺点：\n\tFork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑\n\t虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。\n\t在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</code></pre>\n\n<h5 id=\"8-2-6-小总结\"><a href=\"#8-2-6-小总结\" class=\"headerlink\" title=\"8.2.6 小总结\"></a>8.2.6 小总结</h5><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/redisRDBALL.png\" alt=\"image-20210707005903319\"></p>\n<h4 id=\"8-3-只追加文件（append-only-file-AOF）\"><a href=\"#8-3-只追加文件（append-only-file-AOF）\" class=\"headerlink\" title=\"8.3 只追加文件（append-only file,AOF）\"></a>8.3 只追加文件（append-only file,AOF）</h4><h5 id=\"8-3-1-AOF-概述\"><a href=\"#8-3-1-AOF-概述\" class=\"headerlink\" title=\"8.3.1 AOF 概述\"></a>8.3.1 AOF 概述</h5><p>以<strong>日志</strong>的形式来记录<strong>每个写操作</strong>（增量保存），将Redis执行过的所有写指令记录下来(<strong>读操作不记录</strong>)， <strong>只许追加文件但不可以改写文件</strong>，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>\n<p>==注意：文件越来越大；可以进行rewrite来减少大小。==</p>\n<h5 id=\"8-3-2-AOF-RDB共同使用\"><a href=\"#8-3-2-AOF-RDB共同使用\" class=\"headerlink\" title=\"8.3.2 AOF RDB共同使用\"></a>8.3.2 AOF RDB共同使用</h5><p>与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。</p>\n<p>AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）</p>\n<h5 id=\"8-3-3-AOF-参数配置\"><a href=\"#8-3-3-AOF-参数配置\" class=\"headerlink\" title=\"8.3.3 AOF 参数配置\"></a>8.3.3 AOF 参数配置</h5><p>默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">appendonly yes</code></pre>\n\n<p>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。</p>\n<p><strong>在Redis的配置文件中存在三种同步方式，它们分别是：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">appendfsync always     #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度\nappendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘\nappendfsync no      #让操作系统决定何时进行同步</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">**appendfsync always** 可以实现将数据丢失减到最少，不过这种方式需要对硬盘进行大量的写入而且每次只写入一个命令，十分影响Redis的速度。另外使用固态硬盘的用户谨慎使用appendfsync always选项，因为这会明显降低固态硬盘的使用寿命。\n\n为了兼顾数据和写入性能，用户可以考虑 **appendfsync everysec选项** ，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。\n\n\n**appendfsync no**  选项一般不推荐，这种方案会使Redis丢失不定量的数据而且如果用户的硬盘处理写入操作的速度不够的话，那么当缓冲区被等待写入的数据填满时，Redis的写入操作将被阻塞，这会导致Redis的请求速度变慢。</code></pre>\n\n<p>虽然AOF持久化非常灵活地提供了多种不同的选项来满足不同应用程序对数据安全的不同要求，但AOF持久化也有缺陷——==AOF文件的体积太大==</p>\n<h5 id=\"8-3-4-AOF-持久化实现流程\"><a href=\"#8-3-4-AOF-持久化实现流程\" class=\"headerlink\" title=\"8.3.4 AOF 持久化实现流程\"></a>8.3.4 AOF 持久化实现流程</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">AOF 持久化实现可以分为以下三个步骤：\n1. 命令追加\n2. 文件写入\n3. 文件同步（刷盘）</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">命令追加 ---&gt; 客户端的请求写命令会被append追加到AOF缓冲区内；\n文件写入 ---&gt; AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；\n文件同步 ---&gt; AOF 文件大小超过重写策略 或 手动重写 时，会对AOF文件rewrite重写，压缩AOF文件容量；</code></pre>\n\n<p>Redis服务重启时，会重新load加载AOF文件中的 <strong>写操作</strong> 达到数据恢复的目的；</p>\n<h5 id=\"8-3-5-重写-压缩AOF\"><a href=\"#8-3-5-重写-压缩AOF\" class=\"headerlink\" title=\"8.3.5 重写 压缩AOF\"></a>8.3.5 重写 压缩AOF</h5><p>AOF虽然在某个角度可以将数据丢失降低到最小而且对性能影响也很小，但是极端的情况下，体积不断增大的AOF文件很可能会用完硬盘空间。另外，如果AOF体积过大，那么还原操作执行时间就可能会非常长。</p>\n<p>为了解决AOF体积过大的问题，用户可以向Redis发送 <strong>BGREWRITEAOF命令</strong> ，这个命令会通过移除AOF文件中的冗余命令来重写（rewrite）AOF文件来减小AOF文件的体积。BGREWRITEAOF命令和BGSAVE创建快照原理十分相似，所以AOF文件重写也需要用到子进程，这样会导致性能问题和内存占用问题，和快照持久化一样。更糟糕的是，如果不加以控制的话，AOF文件的体积可能会比快照文件大好几倍。</p>\n<p>文件重写流程图如下：</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/bgrewriteaofLC.png\" alt=\"文件重写流程\"></p>\n<p>和快照持久化可以通过设置save选项来自动执行BGSAVE一样，AOF持久化也可以通过设置</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">auto-aof-rewrite-percentage</code></pre>\n\n<p>选项和</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">auto-aof-rewrite-min-size</code></pre>\n\n<p>选项自动执行BGREWRITEAOF命令。举例：假设用户对Redis设置了如下配置选项并且启用了AOF持久化。那么当AOF文件体积大于64mb，并且AOF的体积比上一次重写之后的体积大了至少一倍（100%）的时候，Redis将执行BGREWRITEAOF命令。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">auto-aof-rewrite-percentage 100  \nauto-aof-rewrite-min-size 64mb</code></pre>\n\n<p>20M（重写后）——-&gt;40M(100%)————&gt;80M(100%)——–rewrite—-&gt; 30M</p>\n<p>无论是AOF持久化还是快照持久化，将数据持久化到硬盘上都是非常有必要的，但除了进行持久化外，用户还必须对持久化得到的文件进行备份（<strong>最好是备份到不同的地方</strong>），这样才能尽量避免数据丢失事故发生，备份前尽量先关闭redis服务。如果条件允许的话，最好能将快照文件和重新重写的AOF文件备份到不同的服务器上面。</p>\n<p>随着负载量的上升，或者数据的完整性变得 越来越重要时，用户可能需要使用到<strong>复制特性</strong></p>\n<h4 id=\"8-4-Redis-4-0对持久化的优化\"><a href=\"#8-4-Redis-4-0对持久化的优化\" class=\"headerlink\" title=\"8.4 Redis 4.0对持久化的优化\"></a>8.4 Redis 4.0对持久化的优化</h4><p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>\n<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分就是压缩格式不再是 AOF 格式，可读性较差。</p>\n<h4 id=\"8-5-AOF-文件损坏\"><a href=\"#8-5-AOF-文件损坏\" class=\"headerlink\" title=\"8.5 AOF 文件损坏\"></a>8.5 AOF 文件损坏</h4><p>如遇到**AOF文件损坏，通过/usr/local/bin/<strong>redis-check-aof–fix appendonly.aof</strong>进行恢复</p>\n<h4 id=\"8-6-RDB-AOF优缺点\"><a href=\"#8-6-RDB-AOF优缺点\" class=\"headerlink\" title=\"8.6 RDB AOF优缺点\"></a>8.6 RDB AOF优缺点</h4><ul>\n<li><p>RDB的优缺点</p>\n<ul>\n<li>适合大规模的数据恢复</li>\n<li>对数据完整性和一致性要求不高更适合使用</li>\n<li>节省磁盘空间</li>\n<li>恢复速度快</li>\n</ul>\n</li>\n<li><p>AOF优点</p>\n<ul>\n<li><p>备份机制更稳健，丢失数据概率更低。</p>\n</li>\n<li><p>可读的日志文本，通过操作AOF稳健，可以处理误操作。</p>\n<p>rdb的文件是一个二进制文件，但是aof的文件是一个可读文件</p>\n</li>\n</ul>\n</li>\n<li><p>AOF缺点</p>\n<ul>\n<li>比起RDB占用更多的磁盘空间。</li>\n<li>恢复备份速度要慢。</li>\n<li>每次读写都同步的话，有一定的性能压力。</li>\n<li>存在个别Bug，造成恢复不能。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"8-7-使用哪个\"><a href=\"#8-7-使用哪个\" class=\"headerlink\" title=\"8.7 使用哪个\"></a>8.7 使用哪个</h4><p>如果对数据不敏感，可以选单独用RDB。</p>\n<p>如果对数据敏感，两个都使用。</p>\n<p>如果只是做纯内存缓存，可以都不用。</p>\n<h3 id=\"9-Redis主从复制\"><a href=\"#9-Redis主从复制\" class=\"headerlink\" title=\"9. Redis主从复制\"></a>9. Redis主从复制</h3><h4 id=\"9-1-是什么\"><a href=\"#9-1-是什么\" class=\"headerlink\" title=\"9.1 是什么\"></a>9.1 是什么</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">持久化后的数据仍然只在一台机器上，因此当硬件发生故障时，比如主板或CPU坏了，这时候无法重启服务器，有什么办法可以保证服务器发生故障时数据的安全性？或者可以快速恢复数据呢？想做到这一点，我们需要再了解Redis另外一种机制：主从复制。\n\n主从复制：主机数据更新后根据配置和策略，自动同步到备机的master&#x2F;slave机制，Master以写为主，Slave以读为主</code></pre>\n\n<h4 id=\"9-2-干什么\"><a href=\"#9-2-干什么\" class=\"headerlink\" title=\"9.2 干什么\"></a>9.2 干什么</h4><p><code>Redis</code>的主从复制机制是指可以让从服务器(<code>slave</code>)能精确复制主服务器(<code>master</code>)的数据</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/master-salver-replication-2\" alt=\"img\"></p>\n<p>一台<code>master</code>服务器也可以对应多台<code>slave</code>服务器</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/master-salver-replication-3.png\" alt=\"img\"></p>\n<p><code>slave</code>服务器也可以有自己的<code>slave</code>服务器，这样的服务器称为<code>sub-slave</code>,而这些<code>sub-slave</code>通过主从复制最终数据也能与<code>master</code>保持一致</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/master-salver-replication-4.png\" alt=\"img\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">读写分离，性能扩展\n容灾快速恢复，提高可用性</code></pre>\n\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/master-salver-replication-1.png\" alt=\"image-20210707010643130\"></p>\n<h4 id=\"9-3-怎么用\"><a href=\"#9-3-怎么用\" class=\"headerlink\" title=\"9.3 怎么用\"></a>9.3 怎么用</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">实现方案\n    方案1：三台物理机\n    方案2：三台虚拟机\n    方案3：一台虚拟机，3个端口\n    \n方案三实现步骤\n准备三个配置文件（dump6379.conf  dump6380.conf dump6381.conf）\n    include &#x2F;myredis&#x2F;redis.conf\n    pidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid\n    port 6379\n    dbfilename dump6379.rdb\n\n启动三个redis服务器\n[root@localhost myredis]# redis-server  &#x2F;myredis&#x2F;redis-6379.conf \n[root@localhost myredis]# redis-server  &#x2F;myredis&#x2F;redis-6380.conf \n[root@localhost myredis]# redis-server  &#x2F;myredis&#x2F;redis-6381.conf</code></pre>\n\n<img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/master-slaver-replication-5.png\" alt=\"image-20210707014519152\" style=\"zoom:150%;\" />\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">使用 slaveof ip port  指定主机  例如指定IP为12.168.96.66 port为6379的机子为主机   slaveof  192.168.96.66  6379</code></pre>\n\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/master-slaver-replication-6.png\" alt=\"image-20210707014857768\"></p>\n<h4 id=\"9-4-主从复制-—-一主二仆\"><a href=\"#9-4-主从复制-—-一主二仆\" class=\"headerlink\" title=\"9.4 主从复制 — 一主二仆\"></a>9.4 主从复制 — 一主二仆</h4><ol>\n<li><p>主机的内容会同步到从机</p>\n</li>\n<li><p>==主机可以写可以读，从机只能读==</p>\n</li>\n<li><p>主机宕机，从机不会上位；主机重新启动，依旧是大哥</p>\n</li>\n<li><p><strong>从机</strong>宕机，不是从机了；<strong>重新启动需要重新拜大哥</strong></p>\n</li>\n<li><p>可以将配置增加到文件redis.conf中。永久生效。</p>\n</li>\n<li><p>主机又回来了后，主机新增记录，从机能顺利复制</p>\n</li>\n</ol>\n<h4 id=\"9-5-主从复制-—-薪火相传\"><a href=\"#9-5-主从复制-—-薪火相传\" class=\"headerlink\" title=\"9.5 主从复制 — 薪火相传\"></a>9.5 主从复制 — 薪火相传</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">从机（同时又是主机）的状态\n\n上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。通过分封制，由之前的天子--百姓结构变成了天子--诸侯--卿大夫---百姓结构，减轻了天子的负担。</code></pre>\n\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/master-salver-replication-4.png\" alt=\"img\"></p>\n<ol>\n<li>从机（同时又是主机）是否可以写：不可以写</li>\n<li>主机挂了，从机还是从机，无法写数据了</li>\n<li>从机（同时又是主机）宕机，其下级从机和其上级主机断线；</li>\n<li>中途变更转向:会清除之前的数据，重新建立拷贝最新的</li>\n<li>风险是一旦某个slave宕机，后面的slave都没法备份</li>\n</ol>\n<h4 id=\"9-6-主从复制-—-反客为主\"><a href=\"#9-6-主从复制-—-反客为主\" class=\"headerlink\" title=\"9.6 主从复制 — 反客为主\"></a>9.6 主从复制 — 反客为主</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">当一个master宕机后，后面的slave可以变为master主机，从而可以进行写操作。\n\n手动用 slaveof no one  将从机变为主机。\n\n其他没有变为master的slave需要手动指定新master(重新拜大哥)</code></pre>\n\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/master-slaver-replication-7.png\" alt=\"image-20210707020842188\"></p>\n<p>美好的愿望：如果上面的这三个手动都能变成自动，那该多好呀！！！！好的，不是问题；哨兵模式来解决！！！</p>\n<h4 id=\"9-7-主从复制-—-哨兵模式\"><a href=\"#9-7-主从复制-—-哨兵模式\" class=\"headerlink\" title=\"9.7 主从复制 — 哨兵模式\"></a>9.7 主从复制 — 哨兵模式</h4><p>哨兵模式就是<strong>反客为主</strong>的主从复制的==自动版==。能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p>\n<h5 id=\"9-7-1-怎么用\"><a href=\"#9-7-1-怎么用\" class=\"headerlink\" title=\"9.7.1 怎么用\"></a>9.7.1 怎么用</h5><ol>\n<li><p>开启一主二仆模式</p>\n</li>\n<li><p>自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错</p>\n</li>\n<li><p>文件中的内容</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">sentinel monitor mymaster 127.0.0.1 6379 1\n其中mymaster为监控对象起的服务器名称\n1为至少有多少个哨兵同意迁移的数量。</code></pre></li>\n<li><p>开启哨兵</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">redis-sentinel  &#x2F;myredis&#x2F;sentinel.conf</code></pre></li>\n<li><p>主机挂，自动的反客为主</p>\n</li>\n</ol>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/master-slave-replication-sentinel.png\" alt=\"哨兵机制-拓扑图\"></p>\n<h5 id=\"9-7-2-选新master规则（故障恢复）\"><a href=\"#9-7-2-选新master规则（故障恢复）\" class=\"headerlink\" title=\"9.7.2 选新master规则（故障恢复）\"></a>9.7.2 选新master规则（故障恢复）</h5><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/master-slave-replication.png\" alt=\"image-20210707021851221\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">优先级在redis.conf中默认：replica-priority 100，值越小优先级越高\n偏移量是指获得原主机数据最全的\n每个redis实例启动后都会随机生成一个40位的runid（通过info server获取查看）</code></pre>\n\n<h4 id=\"9-8-复制延时\"><a href=\"#9-8-复制延时\" class=\"headerlink\" title=\"9.8 复制延时\"></a>9.8 复制延时</h4><p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p>\n<h4 id=\"9-9-复制原理\"><a href=\"#9-9-复制原理\" class=\"headerlink\" title=\"9.9 复制原理\"></a>9.9 复制原理</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">slave启动成功连接到master后会发送一个sync命令\n\nMaster接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步\n\n全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。\n\n增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步\n\n但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</code></pre>\n\n<h3 id=\"10-Redis集群\"><a href=\"#10-Redis集群\" class=\"headerlink\" title=\"10. Redis集群\"></a>10. Redis集群</h3><h4 id=\"10-1-遗留问题\"><a href=\"#10-1-遗留问题\" class=\"headerlink\" title=\"10.1 遗留问题\"></a>10.1 遗留问题</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">一个Redis主机缓存容量不够，如何进行扩容？\n\n更多的客户端对一个Redis主机进行并发写操作，忙不过来了， Redis如何分摊？\n\n另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。\n\n之前通过代理主机来解决，Redis3.0开始提供了解决方案，就是无中心化集群配置。</code></pre>\n\n<h4 id=\"10-2-什么是集群\"><a href=\"#10-2-什么是集群\" class=\"headerlink\" title=\"10.2 什么是集群\"></a>10.2 什么是集群</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">Redis Cluster 是 Redis 的 分布式解决方案，在 3.0 版本正式推出，有效地解决了 Redis 在 分布式 方面的需求。当遇到 单机内存、并发、流量 等瓶颈时，可以采用 Cluster 架构方案达到 负载均衡 的目的。\n\nRedis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1&#x2F;N。\n\nRedis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</code></pre>\n\n<h4 id=\"10-3-cluster集群特点\"><a href=\"#10-3-cluster集群特点\" class=\"headerlink\" title=\"10.3 cluster集群特点\"></a>10.3 cluster集群特点</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">* 多个redis节点网络互联，数据共享\n\n* 所有的节点都是一主一从（也可以是一主多从），其中从不提供服务，仅作为备用\n\n* 不支持同时处理多个key（如MSET&#x2F;MGET），因为redis需要把key均匀分布在各个节点上，\n  并发量很高的情况下同时创建key-value会降低性能并导致不可预测的行为\n  \n* 支持在线增加、删除节点\n\n* 客户端可以连接任何一个主节点进行读写</code></pre>\n\n<h4 id=\"10-4-redis-cluster配置修改\"><a href=\"#10-4-redis-cluster配置修改\" class=\"headerlink\" title=\"10.4 redis cluster配置修改\"></a>10.4 redis cluster配置修改</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">cluster-enabled yes    打开集群模式\ncluster-config-file nodes-6379.conf  设定节点配置文件名\ncluster-node-timeout 15000   设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。</code></pre>\n\n<h4 id=\"10-5-开始测试\"><a href=\"#10-5-开始测试\" class=\"headerlink\" title=\"10.5 开始测试\"></a>10.5 开始测试</h4><ol>\n<li>制作六个实例（先删除其他的rdb，aof文件）（创建几个已.conf结束的文件）</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">include &#x2F;etc&#x2F;redis.conf\npidfile &quot;&#x2F;var&#x2F;run&#x2F;redis_6379.pid&quot;\nport 6379\ndbfilename &quot;dump6379.rdb&quot;\ncluster-enabled yes\ncluster-config-file nodes-6379.conf\ncluster-node-timeout 15000</code></pre>\n\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/redis-cluster1.png\" alt=\"image-20210707024540963\"></p>\n<ol start=\"2\">\n<li><p>启动六个redis服务</p>\n</li>\n<li><p>将六个节点合成一个集群</p>\n<p>组合之前，请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。</p>\n<p>cd /opt/redis-6.2.1/src</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">redis-cli --cluster create --cluster-replicas 1 192.168.11.101:6379 192.168.11.101:6380 192.168.11.101:6381 192.168.11.101:6389 192.168.11.101:6390 192.168.11.101:6391\n\n此处不要用127.0.0.1， 请用真实IP地址\n--replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组</code></pre></li>\n<li><p>登录</p>\n<ul>\n<li><p>普通方式登录：可能直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，应该以集群方式登录。</p>\n<p>redis-cli -p 6379</p>\n</li>\n<li><p>c 采用集群策略连接，设置数据会自动切换到相应的写主机</p>\n<p>redis-cli -c -p 6379</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"10-6-查看集群状态\"><a href=\"#10-6-查看集群状态\" class=\"headerlink\" title=\"10.6 查看集群状态\"></a>10.6 查看集群状态</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">cluster nodes</code></pre>\n\n<h4 id=\"10-7-cluster-如何分配六个节点\"><a href=\"#10-7-cluster-如何分配六个节点\" class=\"headerlink\" title=\"10.7 cluster 如何分配六个节点\"></a>10.7 cluster 如何分配六个节点</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">一个集群至少要有三个主节点。\n选项 --cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。\n分配原则尽量保证每个主数据库运行在不同IP地址，每个从库主库不在一个IP地址。</code></pre>\n\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/redis-cluster-1.png\" alt=\"image-20210708135950845\"></p>\n<h4 id=\"10-8-什么是slots\"><a href=\"#10-8-什么是slots\" class=\"headerlink\" title=\"10.8 什么是slots\"></a>10.8 什么是slots</h4><p>一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个</p>\n<p>集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p>\n<p>集群中每个节点负责处理一部分插槽。 例如， 如果一个集群可以有主节点， 其中：</p>\n<p>​        节点 A 负责处理 0 号至 5460 号插槽。</p>\n<p>​        节点 B 负责处理 5461 号至 10922 号插槽。</p>\n<p>​        节点 C 负责处理 10923 号至 16383 号插槽。</p>\n<h4 id=\"10-9-在集群中录入值\"><a href=\"#10-9-在集群中录入值\" class=\"headerlink\" title=\"10.9 在集群中录入值\"></a>10.9 在集群中录入值</h4><p>在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。</p>\n<p>redis-cli客户端提供了 –c 参数实现自动重定向。</p>\n<p>如 redis-cli -c –p 6379 登入后，再录入、查询键值对可以自动重定向。</p>\n<p>不在一个slot下的键值，是不能使用mget,mset等多键操作。</p>\n<p>可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去。</p>\n<h4 id=\"10-10-查询集群中的值\"><a href=\"#10-10-查询集群中的值\" class=\"headerlink\" title=\"10.10 查询集群中的值\"></a>10.10 查询集群中的值</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">CLUSTER GETKEYSINSLOT &lt;slot&gt;&lt;count&gt; 返回 count 个 slot 槽中的键。</code></pre>\n\n<h4 id=\"10-11-故障恢复\"><a href=\"#10-11-故障恢复\" class=\"headerlink\" title=\"10.11 故障恢复\"></a>10.11 故障恢复</h4><ul>\n<li>如果主节点下线？从节点能否自动升为主节点？注意：15秒超时，主机挂，从机变主机；</li>\n<li>主节点恢复后，主从关系会如何？主节点回来变成从机。</li>\n<li>如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?<br>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉<br>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。<br>redis.conf中的参数  cluster-require-full-coverage</li>\n</ul>\n<h4 id=\"10-12-Redis集群优缺点\"><a href=\"#10-12-Redis集群优缺点\" class=\"headerlink\" title=\"10.12 Redis集群优缺点\"></a>10.12 Redis集群优缺点</h4><ul>\n<li><p>优点</p>\n<p>实现扩容</p>\n<p>分摊压力</p>\n<p>无中心配置相对简单</p>\n</li>\n<li><p>缺点</p>\n<p>多键操作是不被支持的 </p>\n<p>多键的Redis事务是不被支持的。lua脚本不被支持</p>\n<p>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</p>\n</li>\n</ul>\n<h3 id=\"11-总结\"><a href=\"#11-总结\" class=\"headerlink\" title=\"11. 总结\"></a>11. 总结</h3><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/redisALl.jpg\"></p>\n","text":"1. NoSQL数据库1.1 技术发展技术的分类 1、解决功能性的问题：Java、JSP、RDBMS、Tomcat、HTML、Linux、JDBC、SVN 2、解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis 3、解决性能的问题...","link":"","photos":[],"count_time":{"symbolsCount":"34k","symbolsTime":"31 mins."},"categories":[{"name":"Redis","slug":"Redis","count":1,"path":"api/categories/Redis.json"}],"tags":[{"name":"Redis","slug":"Redis","count":1,"path":"api/tags/Redis.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93\"><span class=\"toc-text\">1. NoSQL数据库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95\"><span class=\"toc-text\">1.1  技术发展</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-NoSQL%E7%89%B9%E7%82%B9-%E9%80%82%E7%94%A8%E5%9C%BA%E5%90%88\"><span class=\"toc-text\">1.2 NoSQL特点 适用场合</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-%E4%B8%BB%E8%A6%81%E7%9A%84NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93\"><span class=\"toc-text\">1.3 主要的NoSQL数据库</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Redis\"><span class=\"toc-text\">2. Redis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">2.1 概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-%E7%89%B9%E7%82%B9%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">2.2 特点和应用场景</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">2.3 安装目录介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-4-%E8%AE%BE%E7%BD%AE%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8\"><span class=\"toc-text\">2.4 设置后台启动</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-5-%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C%E7%BD%91%E5%9D%80\"><span class=\"toc-text\">2.5 命令手册网址</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">3. 数据类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-%E5%87%A0%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">3.1 几个基本的命令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-%E5%AD%97%E7%AC%A6%E4%B8%B2String\"><span class=\"toc-text\">3.2 字符串String</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-3-%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B%EF%BC%88list%EF%BC%89\"><span class=\"toc-text\">3.3 列表类型（list）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-4-%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%88set%EF%BC%89\"><span class=\"toc-text\">3.4 集合类型（set）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-5-%E6%95%A3%E5%88%97%E7%B1%BB%E5%9E%8B%EF%BC%88hash%EF%BC%89\"><span class=\"toc-text\">3.5 散列类型（hash）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-6-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%88zset%EF%BC%89\"><span class=\"toc-text\">3.6 有序集合类型（zset）</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E9%94%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4-%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">4. 键过期时间 数据淘汰策略</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-1-%E9%94%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">4.1 键过期时间</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-2-%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">4.2 数据淘汰策略</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">5. Redis配置文件介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-%E5%BC%80%E5%A4%B4%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">5.1 开头说明</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-2-INCLUDES\"><span class=\"toc-text\">5.2 INCLUDES</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-3-MODULES\"><span class=\"toc-text\">5.3 MODULES</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-4-NETWORK\"><span class=\"toc-text\">5.4 NETWORK</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-5-GENERAL\"><span class=\"toc-text\">5.5 GENERAL</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-6-SNAPSHOTTING\"><span class=\"toc-text\">5.6 SNAPSHOTTING</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-7-REPLICATION\"><span class=\"toc-text\">5.7 REPLICATION</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-8-SECURITY\"><span class=\"toc-text\">5.8 SECURITY</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-9-CLIENTS\"><span class=\"toc-text\">5.9 CLIENTS</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-10-MEMORY-MANAGEMENT\"><span class=\"toc-text\">5.10 MEMORY MANAGEMENT</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-11-APPEND-ONLY-MODE\"><span class=\"toc-text\">5.11 APPEND ONLY MODE</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-12-LUA-SCRIPTING\"><span class=\"toc-text\">5.12 LUA SCRIPTING</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-13-REDIS-CLUSTER\"><span class=\"toc-text\">5.13 REDIS CLUSTER</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-Jedis%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">6. Jedis测试</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">6.1 概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-2-%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">6.2 添加依赖</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-3-%E8%BF%9E%E6%8E%A5%E5%89%8D%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">6.3 连接前注意事项</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-4-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95Maven%E5%B7%A5%E7%A8%8B\"><span class=\"toc-text\">6.4 创建测试Maven工程</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-Redis%E4%BA%8B%E5%8A%A1\"><span class=\"toc-text\">7. Redis事务</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">7.1 概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7-1-1-%E5%8E%9F%E5%AD%90%E6%80%A7\"><span class=\"toc-text\">7.1.1 原子性</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7-1-2-%E4%B8%80%E8%87%B4%E6%80%A7\"><span class=\"toc-text\">7.1.2 一致性</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7-1-3-%E9%9A%94%E7%A6%BB%E6%80%A7\"><span class=\"toc-text\">7.1.3 隔离性</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7-1-4-%E6%8C%81%E4%B9%85%E6%80%A7\"><span class=\"toc-text\">7.1.4 持久性</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7-1-5-%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">7.1.5 小结</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-2-%E6%82%B2%E8%A7%82%E9%94%81\"><span class=\"toc-text\">7.2 悲观锁</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-3-%E4%B9%90%E8%A7%82%E9%94%81\"><span class=\"toc-text\">7.3 乐观锁</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-4-watch-key-%E3%80%90key%E2%80%A6%E3%80%91\"><span class=\"toc-text\">7.4 watch key 【key…】</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-5-Redis%E4%BA%8B%E5%8A%A1%E4%B8%89%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">7.5 Redis事务三特性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-6-%E7%A7%92%E6%9D%80%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">7.6 秒杀案例</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-7-Lua%E8%84%9A%E6%9C%AC\"><span class=\"toc-text\">7.7 Lua脚本</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7-7-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">7.7.1 概述</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7-7-2-%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">7.7.2 特性</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7-7-3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">7.7.3 应用场景</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7-7-4-LUA%E8%84%9A%E6%9C%AC%E5%9C%A8Redis%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">7.7.4 LUA脚本在Redis中的优势</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-Redis%E6%8C%81%E4%B9%85%E5%8C%96\"><span class=\"toc-text\">8. Redis持久化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">8.1 概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-2-%E5%BF%AB%E7%85%A7%EF%BC%88snapshotting%EF%BC%8CRDB%EF%BC%89\"><span class=\"toc-text\">8.2 快照（snapshotting，RDB）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-2-1-%E5%BF%AB%E7%85%A7%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">8.2.1 快照概述</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-2-2-%E5%A4%87%E4%BB%BD%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84\"><span class=\"toc-text\">8.2.2 备份是如何执行的</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-2-3-%E5%88%9B%E5%BB%BA%E5%BF%AB%E7%85%A7%E7%9A%84%E5%8A%9E%E6%B3%95\"><span class=\"toc-text\">8.2.3 创建快照的办法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-2-4-RDB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">8.2.4 RDB文件结构</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-2-5-RDB%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">8.2.5 RDB的优缺点</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-2-6-%E5%B0%8F%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">8.2.6 小总结</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-3-%E5%8F%AA%E8%BF%BD%E5%8A%A0%E6%96%87%E4%BB%B6%EF%BC%88append-only-file-AOF%EF%BC%89\"><span class=\"toc-text\">8.3 只追加文件（append-only file,AOF）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-3-1-AOF-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">8.3.1 AOF 概述</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-3-2-AOF-RDB%E5%85%B1%E5%90%8C%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">8.3.2 AOF RDB共同使用</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-3-3-AOF-%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">8.3.3 AOF 参数配置</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-3-4-AOF-%E6%8C%81%E4%B9%85%E5%8C%96%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">8.3.4 AOF 持久化实现流程</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-3-5-%E9%87%8D%E5%86%99-%E5%8E%8B%E7%BC%A9AOF\"><span class=\"toc-text\">8.3.5 重写 压缩AOF</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-4-Redis-4-0%E5%AF%B9%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">8.4 Redis 4.0对持久化的优化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-5-AOF-%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F\"><span class=\"toc-text\">8.5 AOF 文件损坏</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-6-RDB-AOF%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">8.6 RDB AOF优缺点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-7-%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%AA\"><span class=\"toc-text\">8.7 使用哪个</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6\"><span class=\"toc-text\">9. Redis主从复制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-1-%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">9.1 是什么</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-2-%E5%B9%B2%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">9.2 干什么</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-3-%E6%80%8E%E4%B9%88%E7%94%A8\"><span class=\"toc-text\">9.3 怎么用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-4-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E2%80%94-%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%86\"><span class=\"toc-text\">9.4 主从复制 — 一主二仆</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-5-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E2%80%94-%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0\"><span class=\"toc-text\">9.5 主从复制 — 薪火相传</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-6-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E2%80%94-%E5%8F%8D%E5%AE%A2%E4%B8%BA%E4%B8%BB\"><span class=\"toc-text\">9.6 主从复制 — 反客为主</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-7-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E2%80%94-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">9.7 主从复制 — 哨兵模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#9-7-1-%E6%80%8E%E4%B9%88%E7%94%A8\"><span class=\"toc-text\">9.7.1 怎么用</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#9-7-2-%E9%80%89%E6%96%B0master%E8%A7%84%E5%88%99%EF%BC%88%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D%EF%BC%89\"><span class=\"toc-text\">9.7.2 选新master规则（故障恢复）</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-8-%E5%A4%8D%E5%88%B6%E5%BB%B6%E6%97%B6\"><span class=\"toc-text\">9.8 复制延时</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-9-%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">9.9 复制原理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-Redis%E9%9B%86%E7%BE%A4\"><span class=\"toc-text\">10. Redis集群</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-1-%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">10.1 遗留问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-2-%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%86%E7%BE%A4\"><span class=\"toc-text\">10.2 什么是集群</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-3-cluster%E9%9B%86%E7%BE%A4%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">10.3 cluster集群特点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-4-redis-cluster%E9%85%8D%E7%BD%AE%E4%BF%AE%E6%94%B9\"><span class=\"toc-text\">10.4 redis cluster配置修改</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-5-%E5%BC%80%E5%A7%8B%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">10.5 开始测试</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-6-%E6%9F%A5%E7%9C%8B%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">10.6 查看集群状态</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-7-cluster-%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E5%85%AD%E4%B8%AA%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">10.7 cluster 如何分配六个节点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-8-%E4%BB%80%E4%B9%88%E6%98%AFslots\"><span class=\"toc-text\">10.8 什么是slots</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-9-%E5%9C%A8%E9%9B%86%E7%BE%A4%E4%B8%AD%E5%BD%95%E5%85%A5%E5%80%BC\"><span class=\"toc-text\">10.9 在集群中录入值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-10-%E6%9F%A5%E8%AF%A2%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E5%80%BC\"><span class=\"toc-text\">10.10 查询集群中的值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-11-%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D\"><span class=\"toc-text\">10.11 故障恢复</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-12-Redis%E9%9B%86%E7%BE%A4%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">10.12 Redis集群优缺点</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">11. 总结</span></a></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"Mybatis 基础要点","uid":"a439be0041fedf424a1ac2607c12651d","slug":"43-Mybatis-基础要点","date":"2021-09-13T15:20:32.000Z","updated":"2021-09-15T10:52:04.327Z","comments":true,"path":"api/articles/43-Mybatis-基础要点.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog9.jpg","text":":hatching_chick: 回忆JDBC① JDBC 编程步骤1. 加载驱动 2. 获取连接 3. 获取数据库操作对象 4. 编写sql，赋值 5. 执行sql 6. 处理查询结果集 7. 释放资源 ② 遗留问题1.数据库连接，使用时就创建，不使用立即释放，对数据库进行频繁...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"Mybatis","slug":"Mybatis","count":6,"path":"api/categories/Mybatis.json"}],"tags":[{"name":"Mybatis","slug":"Mybatis","count":6,"path":"api/tags/Mybatis.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"Linux（软件）","uid":"0f4e1baf76f1d61cc7b69fa9f200505f","slug":"41-Linux（安装软件）","date":"2021-09-13T15:18:32.000Z","updated":"2021-09-15T10:52:34.149Z","comments":true,"path":"api/articles/41-Linux（安装软件）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog11.jpg","text":"1、安装 jdk目前使用的一台 m1 的 macbook pro ，但是安装上也大同小异 下载 jdk：https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html 下载后使用工具将文件放到 ...","link":"","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[{"name":"Linux","slug":"Linux","count":2,"path":"api/categories/Linux.json"}],"tags":[{"name":"Linux","slug":"Linux","count":2,"path":"api/tags/Linux.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}