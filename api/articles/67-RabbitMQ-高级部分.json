{"title":"RabbitMQ 高级部分","uid":"572316d3a9d6ae4c1865a38d55232e93","slug":"67-RabbitMQ-高级部分","date":"2021-09-13T15:43:32.000Z","updated":"2021-09-15T10:46:44.360Z","comments":true,"path":"api/articles/67-RabbitMQ-高级部分.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog9.jpg","content":"<h4 id=\"01、消息的可靠性投递\"><a href=\"#01、消息的可靠性投递\" class=\"headerlink\" title=\"01、消息的可靠性投递\"></a>01、消息的可靠性投递</h4><hr>\n<h5 id=\"1-1、消息投递可靠性的简介\"><a href=\"#1-1、消息投递可靠性的简介\" class=\"headerlink\" title=\"1.1、消息投递可靠性的简介\"></a>1.1、消息投递可靠性的简介</h5><p>在使用 RabbitMQ 时，作为消息发送方希望杜绝任何消息丢失或者失败的场景。RabbitMQ 为我们提供了两种方式用来控制消息的投递可靠性模式：==① confirm 确认模式        ② return 退回模式==</p>\n<p>rabbitmq 整个消息的 投递路径为：producer —&gt; rabbitmq broker —&gt; exchange —&gt; queue —&gt; consumer</p>\n<ul>\n<li>消息从 producer —&gt; exchange 则会返回一个 confirmCallback 。</li>\n<li>消息从 exchange ––&gt; queue 投递失败则会返回一个 returnCallback 。</li>\n</ul>\n<p>:star: 我们利用这两个 callback 控制消息的可靠性传递</p>\n<h5 id=\"1-2、消息投递可靠性生产者\"><a href=\"#1-2、消息投递可靠性生产者\" class=\"headerlink\" title=\"1.2、消息投递可靠性生产者\"></a>1.2、消息投递可靠性生产者</h5><p>在 spring 的配置文件中，我们定义rabbitmq connectionFactory 时，我们需要在连接工厂的配置项中 ==保证 确认模式 / 退回模式 开启==</p>\n<ul>\n<li>publisher-confirms = “true”</li>\n<li>publisher-returns = “true”</li>\n</ul>\n<p>若我们现在有一个测试方法，那==在测试方法中，我们需要定义相关的 确认或回退 的回调方法==，如下：</p>\n<p>:chestnut: 生产者的 spring 配置</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!--加载配置文件--&gt;\n&lt;context:property-placeholder location&#x3D;&quot;classpath:rabbitmq.properties&quot;&#x2F;&gt;\n\n&lt;!-- 定义rabbitmq connectionFactory\n     确认模式开启：publisher-confirms&#x3D;&quot;true&quot;\n    --&gt;\n&lt;rabbit:connection-factory id&#x3D;&quot;connectionFactory&quot; host&#x3D;&quot;$&#123;rabbitmq.host&#125;&quot;\n                           port&#x3D;&quot;$&#123;rabbitmq.port&#125;&quot;\n                           username&#x3D;&quot;$&#123;rabbitmq.username&#125;&quot;\n                           password&#x3D;&quot;$&#123;rabbitmq.password&#125;&quot;\n                           virtual-host&#x3D;&quot;$&#123;rabbitmq.virtual-host&#125;&quot;\n                           publisher-confirms&#x3D;&quot;true&quot;\n                           publisher-returns&#x3D;&quot;true&quot;\n                           &#x2F;&gt;\n&lt;!--定义管理交换机、队列--&gt;\n&lt;rabbit:admin connection-factory&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;\n\n&lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt;\n&lt;rabbit:template id&#x3D;&quot;rabbitTemplate&quot; connection-factory&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;\n\n&lt;!--消息可靠性投递（生产端）--&gt;\n&lt;rabbit:queue id&#x3D;&quot;test_queue_confirm&quot; name&#x3D;&quot;test_queue_confirm&quot;&gt;&lt;&#x2F;rabbit:queue&gt;\n&lt;rabbit:direct-exchange name&#x3D;&quot;test_exchange_confirm&quot;&gt;\n    &lt;rabbit:bindings&gt;\n        &lt;rabbit:binding queue&#x3D;&quot;test_queue_confirm&quot; key&#x3D;&quot;confirm&quot;&gt;&lt;&#x2F;rabbit:binding&gt;\n    &lt;&#x2F;rabbit:bindings&gt;\n&lt;&#x2F;rabbit:direct-exchange&gt;</code></pre>\n\n<p>:chestnut: ​确认回调方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.amqp.AmqpException;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.core.MessagePostProcessor;\nimport org.springframework.amqp.rabbit.connection.CorrelationData;\nimport org.springframework.amqp.rabbit.core.RabbitTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\nimport org.springframework.test.context.junit4.SpringRunner;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations &#x3D; &quot;classpath:spring-rabbitmq-producer.xml&quot;)\npublic class ProducerTest &#123;\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n    &#x2F;**\n     * 确认模式：\n     * 步骤：\n     * 1. 确认模式开启：ConnectionFactory中开启publisher-confirms&#x3D;&quot;true&quot;\n     * 2. 在rabbitTemplate定义ConfirmCallBack回调函数\n     *&#x2F;\n    @Test\n    public void testConfirm() &#123;\n        &#x2F;&#x2F;2. 定义回调\n        rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() &#123;\n            @Override\n            public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123;\n                if (ack)&#123;\n                    &#x2F;&#x2F;接收成功\n                    System.out.println(&quot;接收成功消息&quot; + cause);\n                &#125;else &#123;\n                    &#x2F;&#x2F;接收失败\n                    System.out.println(&quot;接收失败消息&quot; + cause);\n                    &#x2F;&#x2F;做一些处理,让消息再次发送。\n                &#125;\n            &#125;\n        &#125;);\n\n        &#x2F;&#x2F;3. 发送消息\n        rabbitTemplate.convertAndSend(&quot;test_exchange_confirm&quot;, &quot;confirm&quot;, &quot;message confirm....&quot;);&#x2F;&#x2F;成功\n        &#x2F;&#x2F;rabbitTemplate.convertAndSend(&quot;test_exchange_confirm000&quot;, &quot;confirm&quot;, &quot;message confirm....&quot;);&#x2F;&#x2F;失败\n    &#125;\n&#125;</code></pre>\n\n<img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbit-2-callback-confirm.png\" alt=\"image-20210811193435118\" style=\"zoom:67%;\" />\n\n<p>:chestnut: ​退回回调方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.amqp.AmqpException;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.core.MessagePostProcessor;\nimport org.springframework.amqp.rabbit.connection.CorrelationData;\nimport org.springframework.amqp.rabbit.core.RabbitTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\nimport org.springframework.test.context.junit4.SpringRunner;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations &#x3D; &quot;classpath:spring-rabbitmq-producer.xml&quot;)\npublic class ProducerTest &#123;\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    &#x2F;**\n     * 回退模式： 当消息发送给Exchange后,Exchange路由到Queue失败时 才会执行 ReturnCallBack\n     * 步骤：\n     * 1. 开启回退模式：publisher-returns&#x3D;&quot;true&quot;\n     * 2. 设置ReturnCallBack\n     * 3. 设置Exchange处理消息的模式：\n     *      1). 如果消息没有路由到Queue,则丢弃消息（默认）\n     *      2). 如果消息没有路由到Queue,返回给消息发送方ReturnCallBack\n     *            rabbitTemplate.setMandatory(true);\n     *&#x2F;\n    @Test\n    public void testReturn() &#123;\n\n        &#x2F;&#x2F;设置交换机处理失败消息的模式\n        rabbitTemplate.setMandatory(true);\n\n        &#x2F;&#x2F;2.设置ReturnCallBack\n        rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() &#123;\n            &#x2F;**\n             * @param message   消息对象\n             * @param replyCode 错误码\n             * @param replyText 错误信息\n             * @param exchange  交换机\n             * @param routingKey 路由键\n             *&#x2F;\n            @Override\n            public void returnedMessage(Message message, int replyCode,String replyText,String exchange,String routingKey) &#123;\n                System.out.println(&quot;return 执行了....&quot;);\n\n                System.out.println(message);\n                System.out.println(replyCode);\n                System.out.println(replyText);\n                System.out.println(exchange);\n                System.out.println(routingKey);\n\n                &#x2F;&#x2F;处理\n            &#125;\n        &#125;);\n\n        &#x2F;&#x2F;3. 发送消息\n        rabbitTemplate.convertAndSend(&quot;test_exchange_confirm&quot;, &quot;confirm&quot;, &quot;message confirm....&quot;);\n    &#125;\n&#125;</code></pre>\n\n<img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-2-callback-return.png\" alt=\"image-20210811194350177\" style=\"zoom: 67%;\" />\n\n\n\n<h5 id=\"1-3、投递可靠性生产者小结\"><a href=\"#1-3、投递可靠性生产者小结\" class=\"headerlink\" title=\"1.3、投递可靠性生产者小结\"></a>1.3、投递可靠性生产者小结</h5><ul>\n<li>设置 ConnectionFactory的publisher-confirms=”true” 开启 确认模式。</li>\n<li>使用 rabbitTemplate.setConfirmCallback 设置回调函数。当消息发送到 exchange 后回调 confirm 方法。在方法中判断 ack，如果为true，则发送成功，如果为false，则发送失败，需要处理。</li>\n<li>设置 ConnectionFactory 的 publisher-returns=”true” 开启 退回模式。</li>\n<li>使用 rabbitTemplate.setReturnCallback 设置退回函数，当消息从exchange 路由到 queue 失败后，如果设置了 rabbitTemplate.setMandatory(true) 参数，则会将消息退回给 producer并执行回调函数returnedMessage</li>\n</ul>\n<h5 id=\"1-4、Consumer-Ack-消费者\"><a href=\"#1-4、Consumer-Ack-消费者\" class=\"headerlink\" title=\"1.4、Consumer Ack 消费者\"></a>1.4、Consumer Ack 消费者</h5><p>ack 指 Acknowledge，确认。 ==表示消费端收到消息后的确认方式==。</p>\n<p>有二种确认方式：</p>\n<ul>\n<li>自动确认：acknowledge=“none” 默认</li>\n<li>手动确认：acknowledge=“manual”</li>\n</ul>\n<p>:star: ​确认方式的概念：</p>\n<ul>\n<li>自动确认是指，当消息一旦被Consumer接收到，则自动确认收到，并将相应 message 从 RabbitMQ 的消息缓存中移除。但是在实际业务处理中，很可能==消息接收到，业务处理出现异常，那么该消息就会丢失==。</li>\n<li>手动确认方式，让监听器类实现ChannelAwareMessageListener接口，并且需要在业务处理成功后，调用channel.basicAck()，手动签收，如果出现异常，则调用channel.basicNack()方法，让其自动重新发送消息</li>\n</ul>\n<p>:star: ==如果没有确认接收，那我们的数据会进入到 Unacked 状态，也就是 未确认的==，手动确认接收后，会消失或者进入死信队列</p>\n<p>:star: ​==如果没有设置限流，并且数据较少，那么mq会一下加载全部的数据，并且全部进入 Unacked状态，然后读出一条，删除一条==</p>\n<p>:star: ==如果到最后，mq中还有数据，但是消费者不读取了，那么 Unacked状态的数据会从新变为 待读取的状态，Ready==</p>\n<p>消费者的 spring 配置</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!--加载配置文件--&gt;\n&lt;context:property-placeholder location&#x3D;&quot;classpath:rabbitmq.properties&quot;&#x2F;&gt;\n\n&lt;!-- 定义rabbitmq connectionFactory --&gt;\n&lt;rabbit:connection-factory id&#x3D;&quot;connectionFactory&quot; host&#x3D;&quot;$&#123;rabbitmq.host&#125;&quot;\n                           port&#x3D;&quot;$&#123;rabbitmq.port&#125;&quot;\n                           username&#x3D;&quot;$&#123;rabbitmq.username&#125;&quot;\n                           password&#x3D;&quot;$&#123;rabbitmq.password&#125;&quot;\n                           virtual-host&#x3D;&quot;$&#123;rabbitmq.virtual-host&#125;&quot;&#x2F;&gt;\n\n&lt;context:component-scan base-package&#x3D;&quot;com.atguigu.listener&quot; &#x2F;&gt;\n\n&lt;!--定义监听器容器\n    acknowledge&#x3D;&quot;manual&quot;：手动签收\n    --&gt;\n&lt;rabbit:listener-container connection-factory&#x3D;&quot;connectionFactory&quot; acknowledge&#x3D;&quot;manual&quot;&gt;\n    &lt;rabbit:listener ref&#x3D;&quot;ackListener&quot; queue-names&#x3D;&quot;test_queue_confirm&quot;&gt;&lt;&#x2F;rabbit:listener&gt;\n&lt;&#x2F;rabbit:listener-container&gt;</code></pre>\n\n<p>自动确认监听器代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.listener;\n\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.core.MessageListener;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class AckListener implements MessageListener &#123;\n    @Override\n    public void onMessage(Message message) &#123;\n        System.out.println(new String(message.getBody()));\n    &#125;\n&#125;</code></pre>\n\n<p>手动确认监听器代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.listener;\n\nimport com.rabbitmq.client.Channel;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener;\nimport org.springframework.stereotype.Component;\nimport java.io.IOException;\n\n&#x2F;**\n * Consumer ACK机制：\n *  1. 设置手动签收。acknowledge&#x3D;&quot;manual&quot;\n *  2. 让监听器类实现ChannelAwareMessageListener接口\n *  3. 如果消息成功处理,则调用channel的 basicAck()签收\n *  4. 如果消息处理失败,则调用channel的basicNack()拒绝签收,broker重新发送给consumer\n*&#x2F;\n@Component\npublic class AckListener implements ChannelAwareMessageListener &#123;\n    @Override\n    public void onMessage(Message message, Channel channel) throws Exception &#123;\n        Thread.sleep(1000);\n        &#x2F;&#x2F; 获取消息传递标记\n        long deliveryTag &#x3D; message.getMessageProperties().getDeliveryTag();\n        try &#123;\n            &#x2F;&#x2F; ① 接收消息\n            System.out.println(new String(message.getBody()));\n            &#x2F;&#x2F; ② 处理业务逻辑\n            System.out.println(&quot;处理业务逻辑&quot;);\n            int i &#x3D; 3&#x2F;0;&#x2F;&#x2F;出现错误\n            &#x2F;&#x2F; ③ 手动签收\n            &#x2F;**\n             * 第一个参数：表示收到的标签\n             * 第二个参数：如果为true表示可以签收所有的消息\n             *&#x2F;\n            channel.basicAck(deliveryTag,true);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            &#x2F;&#x2F; ④ 拒绝签收\n             &#x2F;*\n            第三个参数：requeue：重回队列。\n            设置为true,则消息重新回到queue,broker会重新发送该消息给消费端\n             *&#x2F;\n            channel.basicNack(deliveryTag,true,true);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>消费端测试类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations &#x3D; &quot;classpath:spring-rabbitmq-consumer.xml&quot;)\npublic class ConsumerTest &#123;\n    @Test\n    public void test()&#123;\n        while (true)&#123;\n\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h5 id=\"1-5、投递可靠性消费者小结\"><a href=\"#1-5、投递可靠性消费者小结\" class=\"headerlink\" title=\"1.5、投递可靠性消费者小结\"></a>1.5、投递可靠性消费者小结</h5><p>在rabbit:listener-container标签中设置acknowledge属性，设置ack方式 none：自动确认，manual：手动确认</p>\n<p>如果在消费端没有出现异常，则调用channel.basicAck(deliveryTag，true);方法确认签收消息</p>\n<p>如果出现异常，则在catch中调用 basicNack，拒绝消息，让MQ重新发送消息。</p>\n<h4 id=\"02、消费端限流\"><a href=\"#02、消费端限流\" class=\"headerlink\" title=\"02、消费端限流\"></a>02、消费端限流</h4><hr>\n<p>当请求很多时，限制消费端每次从 MQ 中拉取的消息数量，也就是所谓的 QPS ，每秒最大查询率</p>\n<h5 id=\"2-1、限流操作的使用\"><a href=\"#2-1、限流操作的使用\" class=\"headerlink\" title=\"2.1、限流操作的使用\"></a>2.1、限流操作的使用</h5><p>在 1 的项目中新建 QpsListener</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.listener;\n\nimport com.rabbitmq.client.Channel;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener;\n\n&#x2F;**\n * Consumer 限流机制\n *  1. 确保消息被确认。不确认是不继续处理其他消息的\n *  2. listener-container配置属性\n *      prefetch &#x3D; 1,表示消费端每次从mq拉去一条消息来消费,直到手动确认消费完毕后,才会继续拉取下一条消息。\n *&#x2F;\n@Component\npublic class QpsListener implements ChannelAwareMessageListener &#123;\n    @Override\n    public void onMessage(Message message, Channel channel) throws Exception &#123;\n        &#x2F;&#x2F;1.获取消息\n        System.out.println(new String(message.getBody()));\n    &#125;\n&#125;</code></pre>\n\n<p>修改 consumer 的 spring 配置文件</p>\n<p>在 listener-container 标签中添加 ==prefetch（预取）== 属性，1，表示准备从 mq 中一次最多取 1个</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;bean id&#x3D;&quot;QpsListener&quot; class&#x3D;&quot;com.atguigu.QpsListener&quot;&gt;&lt;&#x2F;bean&gt;\n\n&lt;rabbit:listener-container connection-factory&#x3D;&quot;connectionFactory&quot; auto-declare&#x3D;&quot;true&quot; prefetch&#x3D;&quot;1&quot;&gt;\n    &lt;rabbit:listener ref&#x3D;&quot;QpsListener&quot; queue-names&#x3D;&quot;test_qunue_confirm&quot;&#x2F;&gt;\n&lt;&#x2F;rabbit:listener-container&gt;</code></pre>\n\n<p>运行生产者的测试代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RunWith(SpringRunner.class)\n@ContextConfiguration(locations &#x3D; &quot;classpath:spring-rabbitmq-producer.xml&quot;)\npublic class ProducerTest &#123;\n\n    @Test\n    public void testSend() &#123;\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            rabbitTemplate.convertAndSend(&quot;test_exchange_confirm&quot;,&quot;confirm&quot;,&quot;message confirm&quot;);\n        &#125;\n    &#125;\n&#125; </code></pre>\n\n<p>这个不太容易观察，因为一条一条的读也非常的快，几乎眨眼之间</p>\n<h4 id=\"03、TTL\"><a href=\"#03、TTL\" class=\"headerlink\" title=\"03、TTL\"></a>03、TTL</h4><hr>\n<h5 id=\"3-1、TTL-概念\"><a href=\"#3-1、TTL-概念\" class=\"headerlink\" title=\"3.1、TTL 概念\"></a>3.1、TTL 概念</h5><p>TTL 全称 Time To Live（存活时间/过期时间）。</p>\n<p>当消息到达存活时间后，还没有被消费，会被自动清除，也有可能会变成 “死信”。</p>\n<p>RabbitMQ可以对消息设置过期时间，也可以对整个队列（Queue）设置过期时间。</p>\n<h5 id=\"3-2、设置消息-TTL的两种方法\"><a href=\"#3-2、设置消息-TTL的两种方法\" class=\"headerlink\" title=\"3.2、设置消息 TTL的两种方法\"></a>3.2、设置消息 TTL的两种方法</h5><ul>\n<li><p>第一种方法是通过<strong>队列属性</strong>设置，队列中所有消息都有相同的过期时间。</p>\n<p>默认情况下 value-type 的类型是 String 类型,但时间的类型是number类型,所以需要设置成 integer 类型</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!--TTL 队列--&gt;\n&lt;rabbit:queue name&#x3D;&quot;test_queue_ttl&quot; id&#x3D;&quot;test_queue_ttl&quot;&gt;\n    &lt;!--设置queue的参数--&gt;\n    &lt;rabbit:queue-arguments&gt;\n        &lt;!--\n              设置x-message-ttl队列的过期时间\n              默认情况下value-type的类型是String类型,但时间的类型是number类型,所以需要设置成integer类型\n            --&gt;\n        &lt;entry key&#x3D;&quot;x-message-ttl&quot; value&#x3D;&quot;10000&quot; value-type&#x3D;&quot;java.lang.Integer&quot;&#x2F;&gt;\n    &lt;&#x2F;rabbit:queue-arguments&gt;\n&lt;&#x2F;rabbit:queue&gt;</code></pre></li>\n<li><p>第二种方法是对<strong>消息本身</strong>进行单独设置，每条消息的 TTL 可以不同。如果两种方法一起使用，则消息的 TTL 以两者之间较小的那个数值为准。使用的是 ==消息的后置处理器 MessagePostProcessor==</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Test\npublic void testMessageTtl() &#123;\n    &#x2F;&#x2F; 消息后处理对象,设置一些消息的参数信息\n    MessagePostProcessor messagePostProcessor &#x3D; new MessagePostProcessor() &#123;\n\n        @Override\n        public Message postProcessMessage(Message message) throws AmqpException &#123;\n            &#x2F;&#x2F;1.设置message的信息\n            &#x2F;&#x2F; 第二个方法：消息的过期时间 ,5秒之后过期\n            message.getMessageProperties().setExpiration(&quot;5000&quot;);\n            &#x2F;&#x2F;2.返回该消息\n            return message;\n        &#125;\n    &#125;;\n\n    &#x2F;&#x2F;消息单独过期\n    rabbitTemplate.convertAndSend(&quot;test_exchange_ttl&quot;,&quot;ttl.hehe&quot;,&quot;message ttl....&quot;,messagePostProcessor);\n&#125;</code></pre></li>\n</ul>\n<p>==注意：如果设置了消息的过期时间,也设置了队列的过期时间,它<strong>以时间短的为准</strong>。==</p>\n<h5 id=\"3-3、代码实现\"><a href=\"#3-3、代码实现\" class=\"headerlink\" title=\"3.3、代码实现\"></a>3.3、代码实现</h5><h6 id=\"1、第一种：队列全部消息过期\"><a href=\"#1、第一种：队列全部消息过期\" class=\"headerlink\" title=\"1、第一种：队列全部消息过期\"></a>1、第一种：队列全部消息过期</h6><p>修改 1 的 spring 配置文件</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!--加载配置文件--&gt;\n&lt;context:property-placeholder location&#x3D;&quot;classpath:rabbitmq.properties&quot;&#x2F;&gt;\n\n&lt;!-- 定义rabbitmq connectionFactory --&gt;\n&lt;rabbit:connection-factory id&#x3D;&quot;connectionFactory&quot; host&#x3D;&quot;$&#123;rabbitmq.host&#125;&quot;\n                           port&#x3D;&quot;$&#123;rabbitmq.port&#125;&quot;\n                           username&#x3D;&quot;$&#123;rabbitmq.username&#125;&quot;\n                           password&#x3D;&quot;$&#123;rabbitmq.password&#125;&quot;\n                           virtual-host&#x3D;&quot;$&#123;rabbitmq.virtual-host&#125;&quot;\n                           publisher-confirms&#x3D;&quot;true&quot;\n                           publisher-returns&#x3D;&quot;true&quot;&#x2F;&gt;\n&lt;!--定义管理交换机、队列--&gt;\n&lt;rabbit:admin connection-factory&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;\n\n&lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt;\n&lt;rabbit:template id&#x3D;&quot;rabbitTemplate&quot; connection-factory&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;\n\n&lt;!--消息可靠性投递（生产端）--&gt;\n&lt;rabbit:queue id&#x3D;&quot;test_queue_confirm&quot; name&#x3D;&quot;test_queue_confirm&quot;&#x2F;&gt;\n&lt;rabbit:direct-exchange name&#x3D;&quot;test_exchange_confirm&quot;&gt;\n    &lt;rabbit:bindings&gt;\n        &lt;rabbit:binding queue&#x3D;&quot;test_queue_confirm&quot; key&#x3D;&quot;confirm&quot;&#x2F;&gt;\n    &lt;&#x2F;rabbit:bindings&gt;\n&lt;&#x2F;rabbit:direct-exchange&gt;\n\n&lt;!--TTL 队列--&gt;\n&lt;rabbit:queue name&#x3D;&quot;test_queue_ttl&quot; id&#x3D;&quot;test_queue_ttl&quot;&gt;\n    &lt;!--设置queue的参数--&gt;\n    &lt;rabbit:queue-arguments&gt;\n        &lt;!--\n              设置x-message-ttl队列的过期时间\n              默认情况下value-type的类型是String类型,但时间的类型是number类型,所以需要设置成integer类型\n            --&gt;\n        &lt;entry key&#x3D;&quot;x-message-ttl&quot; value&#x3D;&quot;10000&quot; value-type&#x3D;&quot;java.lang.Integer&quot;&#x2F;&gt;\n    &lt;&#x2F;rabbit:queue-arguments&gt;\n&lt;&#x2F;rabbit:queue&gt;\n\n&lt;!--设置交换机--&gt;\n&lt;rabbit:topic-exchange name&#x3D;&quot;test_exchange_ttl&quot;&gt;\n    &lt;!--交换机绑定队列--&gt;\n    &lt;rabbit:bindings&gt;\n        &lt;rabbit:binding pattern&#x3D;&quot;ttl.#&quot; queue&#x3D;&quot;test_queue_ttl&quot;&#x2F;&gt;\n    &lt;&#x2F;rabbit:bindings&gt;\n&lt;&#x2F;rabbit:topic-exchange&gt;</code></pre>\n\n<p>在测试类 ProducerTest 中,添加测试方法,发送消息</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Test\npublic void testTTL() &#123;\n     for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n       rabbitTemplate.convertAndSend(&quot;test_exchange_ttl&quot;,&quot;ttl.hehe&quot;,&quot;message ttl&quot;);\n     &#125;\n&#125;</code></pre>\n\n<p>查看控制台，10秒后自动过期</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-2-2.png\" alt=\"image-20210811203726347\"></p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-2-1%E3%80%81.png\" alt=\"image-20210811203635422\"></p>\n<h6 id=\"2、第二种，消息过期\"><a href=\"#2、第二种，消息过期\" class=\"headerlink\" title=\"2、第二种，消息过期\"></a>2、第二种，消息过期</h6><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Test\npublic void testMessageTtl() &#123;\n    &#x2F;&#x2F; 消息后处理对象,设置一些消息的参数信息\n    MessagePostProcessor messagePostProcessor &#x3D; new MessagePostProcessor() &#123;\n\n        @Override\n        public Message postProcessMessage(Message message) throws AmqpException &#123;\n            &#x2F;&#x2F;1.设置message的信息\n            &#x2F;&#x2F; 第二个方法：消息的过期时间 ,5秒之后过期\n            message.getMessageProperties().setExpiration(&quot;5000&quot;);\n            &#x2F;&#x2F;2.返回该消息\n            return message;\n        &#125;\n    &#125;;\n\n    &#x2F;&#x2F;消息单独过期\n    rabbitTemplate.convertAndSend(&quot;test_exchange_ttl&quot;,&quot;ttl.hehe&quot;,&quot;message ttl....&quot;,messagePostProcessor);\n&#125;</code></pre>\n\n\n\n<h4 id=\"04、死信队列\"><a href=\"#04、死信队列\" class=\"headerlink\" title=\"04、死信队列\"></a>04、死信队列</h4><hr>\n<p>死信队列，英文缩写：DLX 。DeadLetter Exchange（死信交换机），当消息成为Dead message后，可以被重新发送到另一个交换机，这个交换机就是DLX。</p>\n<h5 id=\"4-1、什么是死信队列\"><a href=\"#4-1、什么是死信队列\" class=\"headerlink\" title=\"4.1、什么是死信队列\"></a>4.1、什么是死信队列</h5><p>先从概念解释上搞清楚这个定义，<strong>死信，顾名思义就是无法被消费的消息</strong>，字面意思可以这样理解，一般来说，producer将消息投递到broker或者直接到queue里了，consumer从queue取出消息进行消费，但某些时候由于特定的原因导致queue中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信，自然就有了死信队列；</p>\n<p>消息变成死信一般是由于以下几种情况：</p>\n<ul>\n<li>==消息被拒绝（Reject/Nack），<strong>并且设置不把消息重新放入原目标队列 —&gt; requeue参数为false</strong>。==</li>\n<li>==消息过期（消息到达超时时间未被消费）。==</li>\n<li>==队列达到最大长度（消息数量达到最大限制）。==</li>\n</ul>\n<p>DLX也是一个正常的交换器，和一般的交换器没有区别，它能在任何的队列上被指定（实际上就是设置某个队列的属性）。当这个队列中存在死信时，RabbitMQ就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到死信队列，可以监听这个队列中的消息以进行相应的处理。</p>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-2-3.png\" alt=\"image-20210811204529223\" style=\"zoom:80%;\" />\n</div>\n\n\n\n<h5 id=\"4-2、死信的处理方式\"><a href=\"#4-2、死信的处理方式\" class=\"headerlink\" title=\"4.2、死信的处理方式\"></a>4.2、死信的处理方式</h5><p>死信的产生既然不可避免，那么就需要从实际的业务角度和场景出发，对这些死信进行后续的处理，常见的处理方式大致有下面几种，</p>\n<p>① 丢弃，如果不是很重要，可以选择丢弃</p>\n<p>② 记录死信入库，然后做后续的业务分析或处理</p>\n<p>③ 通过死信队列，由负责监听死信的应用程序进行处理</p>\n<p>综合来看，更常用的做法是第三种，即通过死信队列，将产生的死信通过程序的配置路由到指定的死信队列，然后应用监听死信队列，对接收到的死信做后续的处理，</p>\n<p><strong>队列绑定死信交换机：</strong></p>\n<p>给队列设置参数： x-dead-letter-exchange 和 x-dead-letter-routing-key</p>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-2-4.png\" alt=\"image-20210811204838103\" style=\"zoom:80%;\" />\n</div>\n\n\n\n<h5 id=\"4-3、代码实现\"><a href=\"#4-3、代码实现\" class=\"headerlink\" title=\"4.3、代码实现\"></a>4.3、代码实现</h5><p>修改生产者项目的配置文件 spring-rabbitmq-producer.xml ，增加如下代码</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!--\n       死信队列：\n           1. 声明正常的队列(test_queue_dlx)和交换机(test_exchange_dlx)\n           2. 声明死信队列(queue_dlx)和死信交换机(exchange_dlx)\n           3. 正常队列绑定死信交换机\n               设置两个参数：\n                   * x-dead-letter-exchange：死信交换机名称\n                   * x-dead-letter-routing-key：发送给死信交换机的routingkey\n--&gt;\n&lt;!--\n    1. 声明正常的队列(test_queue_dlx)和交换机(test_exchange_dlx)\n--&gt;\n&lt;rabbit:queue name&#x3D;&quot;test_queue_dlx&quot; id&#x3D;&quot;test_queue_dlx&quot;&gt;\n    &lt;!--3. 正常队列绑定死信交换机--&gt;\n    &lt;rabbit:queue-arguments&gt;\n        &lt;!--3.1 x-dead-letter-exchange：死信交换机名称--&gt;\n        &lt;entry key&#x3D;&quot;x-dead-letter-exchange&quot; value&#x3D;&quot;exchange_dlx&quot;&#x2F;&gt;\n        &lt;!--3.2 x-dead-letter-routing-key：发送给死信交换机的routingkey--&gt;\n        &lt;entry key&#x3D;&quot;x-dead-letter-routing-key&quot; value&#x3D;&quot;dlx.hehe&quot;&gt;&lt;&#x2F;entry&gt;\n        &lt;!--4.1 设置队列的过期时间 ttl--&gt;\n        &lt;entry key&#x3D;&quot;x-message-ttl&quot; value&#x3D;&quot;10000&quot; value-type&#x3D;&quot;java.lang.Integer&quot;&#x2F;&gt;\n        &lt;!--4.2 设置队列的长度限制 max-length --&gt;\n        &lt;entry key&#x3D;&quot;x-max-length&quot; value&#x3D;&quot;10&quot; value-type&#x3D;&quot;java.lang.Integer&quot;&#x2F;&gt;\n    &lt;&#x2F;rabbit:queue-arguments&gt;\n&lt;&#x2F;rabbit:queue&gt;\n&lt;!--正常交换机--&gt;\n&lt;rabbit:topic-exchange name&#x3D;&quot;test_exchange_dlx&quot;&gt;\n    &lt;rabbit:bindings&gt;\n        &lt;rabbit:binding pattern&#x3D;&quot;test.dlx.#&quot; queue&#x3D;&quot;test_queue_dlx&quot;&gt;&lt;&#x2F;rabbit:binding&gt;\n    &lt;&#x2F;rabbit:bindings&gt;\n&lt;&#x2F;rabbit:topic-exchange&gt;\n&lt;!--\n   2. 声明死信队列(queue_dlx)和死信交换机(exchange_dlx)\n--&gt;\n&lt;rabbit:queue name&#x3D;&quot;queue_dlx&quot; id&#x3D;&quot;queue_dlx&quot;&gt;&lt;&#x2F;rabbit:queue&gt;\n&lt;rabbit:topic-exchange name&#x3D;&quot;exchange_dlx&quot;&gt;\n    &lt;rabbit:bindings&gt;\n        &lt;rabbit:binding pattern&#x3D;&quot;dlx.#&quot; queue&#x3D;&quot;queue_dlx&quot;&gt;&lt;&#x2F;rabbit:binding&gt;\n    &lt;&#x2F;rabbit:bindings&gt;\n&lt;&#x2F;rabbit:topic-exchange&gt;</code></pre>\n<p>在测试类中，添加如下方法，进行测试</p>\n<h6 id=\"1、到达过期时间后，变为死信\"><a href=\"#1、到达过期时间后，变为死信\" class=\"headerlink\" title=\"1、到达过期时间后，变为死信\"></a>1、到达过期时间后，变为死信</h6><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n  * 发送测试死信消息：\n  *  1. 过期时间\n  *  2. 长度限制\n  *  3. 消息拒收\n  *&#x2F;\n@Test\npublic void testDlx()&#123;\n    &#x2F;&#x2F;1. 测试过期时间，死信消息\n    rabbitTemplate.convertAndSend(&quot;test_exchange_dlx&quot;,&quot;test.dlx.haha&quot;,&quot;我是一条消息,我会死吗？&quot;);\n&#125;</code></pre>\n\n<img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-2-5.png\" alt=\"image-20210811205545338\" style=\"zoom:80%;\" />\n\n<img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-2-6.png\" alt=\"image-20210811205633026\" style=\"zoom:80%;\" />\n\n<h6 id=\"2、到达长度限制后，变为死信\"><a href=\"#2、到达长度限制后，变为死信\" class=\"headerlink\" title=\"2、到达长度限制后，变为死信\"></a>2、到达长度限制后，变为死信</h6><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n  *  2. 长度限制\n  *&#x2F;\n@Test\npublic void testDlx()&#123;\n    &#x2F;&#x2F;1. 测试过期时间,死信消息\n    &#x2F;&#x2F;rabbitTemplate.convertAndSend(&quot;test_exchange_dlx&quot;,&quot;test.dlx.haha&quot;,&quot;我是一条消息,我会死吗？&quot;);\n\n    &#x2F;&#x2F;2. 测试长度限制后,消息死信\n    for (int i &#x3D; 0; i &lt; 20; i++) &#123;\n        rabbitTemplate.convertAndSend(&quot;test_exchange_dlx&quot;,&quot;test.dlx.haha&quot;,&quot;我是一条消息,我会死吗？&quot;);\n    &#125;\n&#125;</code></pre>\n\n<h6 id=\"3、消息经过拒收后，变为死信\"><a href=\"#3、消息经过拒收后，变为死信\" class=\"headerlink\" title=\"3、消息经过拒收后，变为死信\"></a>3、消息经过拒收后，变为死信</h6><p>在消费者工程 创建 com.atguigu.listener.DlxListener，经过错误，我们手动拒收，并且设置 rueue 为false，不重回原队列</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package com.atguigu.listener;\nimport com.rabbitmq.client.Channel;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class DlxListener implements ChannelAwareMessageListener &#123;\n\n    @Override\n    public void onMessage(Message message, Channel channel) throws Exception &#123;\n        long deliveryTag &#x3D; message.getMessageProperties().getDeliveryTag();\n\n        try &#123;\n            &#x2F;&#x2F;1.接收转换消息\n            System.out.println(new String(message.getBody()));\n\n            &#x2F;&#x2F;2. 处理业务逻辑\n            System.out.println(&quot;处理业务逻辑...&quot;);\n            int i &#x3D; 3&#x2F;0;&#x2F;&#x2F;出现错误\n            &#x2F;&#x2F;3. 手动签收\n            channel.basicAck(deliveryTag,true);\n        &#125; catch (Exception e) &#123;\n            &#x2F;&#x2F;e.printStackTrace();\n            System.out.println(&quot;出现异常,拒绝接受&quot;);\n            &#x2F;&#x2F;4.拒绝签收,不重回队列 requeue&#x3D;false\n            channel.basicNack(deliveryTag,true,false);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>修改消费者的 spring-rabbitmq.xml</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;rabbit:listener-container connection-factory&#x3D;&quot;connectionFactory&quot; acknowledge&#x3D;&quot;manual&quot;&gt;\n    &lt;!--&lt;rabbit:listener ref&#x3D;&quot;ackListener&quot; queue-names&#x3D;&quot;test_queue_confirm&quot;&gt;&lt;&#x2F;rabbit:listener&gt;--&gt;\n    &lt;!--&lt;rabbit:listener ref&#x3D;&quot;qosListener&quot; queue-names&#x3D;&quot;test_queue_confirm&quot;&gt;&lt;&#x2F;rabbit:listener&gt;--&gt;\n    &lt;!--定义监听器,监听正常队列--&gt;\n    &lt;rabbit:listener ref&#x3D;&quot;dlxListener&quot; queue-names&#x3D;&quot;test_queue_dlx&quot;&gt;&lt;&#x2F;rabbit:listener&gt;\n&lt;&#x2F;rabbit:listener-container&gt;</code></pre>\n\n<p>测试代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Test\n    public void testDlx()&#123;\n        &#x2F;&#x2F;1. 测试过期时间,死信消息\n        &#x2F;&#x2F;rabbitTemplate.convertAndSend(&quot;test_exchange_dlx&quot;,&quot;test.dlx.haha&quot;,&quot;我是一条消息,我会死吗？&quot;);\n\n        &#x2F;&#x2F;2. 测试长度限制后,消息死信\n\t\t&#x2F;&#x2F;for (int i &#x3D; 0; i &lt; 20; i++) &#123;\n\t\t&#x2F;&#x2F;    rabbitTemplate.convertAndSend(&quot;test_exchange_dlx&quot;,&quot;test.dlx.haha&quot;,&quot;我是一条消息,我会死吗？&quot;);\n\t\t&#x2F;&#x2F;&#125;\n        &#x2F;&#x2F;3. 测试消息拒收\n        rabbitTemplate.convertAndSend(&quot;test_exchange_dlx&quot;,\n                                     &quot;test.dlx.haha&quot;,\n                                         &quot;我是一条消息,我会死吗？&quot;);\n    &#125;</code></pre>\n\n\n\n<h5 id=\"4-4、死信队列小结\"><a href=\"#4-4、死信队列小结\" class=\"headerlink\" title=\"4.4、死信队列小结\"></a>4.4、死信队列小结</h5><ul>\n<li>死信交换机和死信队列和普通的没有区别</li>\n<li>当消息成为死信后，如果该队列绑定了死信交换机，则消息会被死信交换机重新路由到死信队列</li>\n<li>消息成为死信的三种情况：<ul>\n<li>队列消息长度（数量）到达限制；</li>\n<li>消费者拒接消费消息，并且不重回队列；</li>\n<li>原队列存在消息过期设置，消息到达超时时间未被消费；</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"05、延迟队列\"><a href=\"#05、延迟队列\" class=\"headerlink\" title=\"05、延迟队列\"></a>05、延迟队列</h4><hr>\n<h5 id=\"5-1、延迟队列概念\"><a href=\"#5-1、延迟队列概念\" class=\"headerlink\" title=\"5.1、延迟队列概念\"></a>5.1、延迟队列概念</h5><p>延迟队列存储的对象肯定是对应的延时消息，==所谓 ”延时消息” 是指当消息被发送以后，并不想让消费者立即拿到消息，而是等待指定时间后，消费者才拿到这个消息进行消费。==</p>\n<p>:chestnut: 场景：在订单系统中，一个用户下单之后通常有30分钟的时间进行支付，如果30分钟之内没有支付成功，那么这个订单将进行取消处理。这时就可以使用延时队列将订单信息发送到延时队列。</p>\n<p>需求：</p>\n<ol>\n<li>下单后，30分钟未支付，取消订单，回滚库存。</li>\n<li>新用户注册成功30分钟后，发送短信问候。</li>\n</ol>\n<p>很可惜，在RabbitMQ中并未提供延迟队列功能。</p>\n<p>但是可以==<strong>使用：TTL + 死信队列 组合实现延迟队列的效果。</strong>==</p>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-2-7.png\" alt=\"image-20210811210627984\" style=\"zoom:80%;\" />\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-2-8.png\" alt=\"image-20210811210704873\" style=\"zoom:80%;\" />\n</div>\n\n\n\n<h5 id=\"5-2、代码实现\"><a href=\"#5-2、代码实现\" class=\"headerlink\" title=\"5.2、代码实现\"></a>5.2、代码实现</h5><p>修改生产者配置文件</p>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-2-9.png\" alt=\"image-20210811210925890\" style=\"zoom:80%;\" />\n</div>\n\n<p>添加测试方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Test\npublic  void testDelay() throws InterruptedException &#123;\n    &#x2F;&#x2F;1.发送订单消息。 将来是在订单系统中,下单成功后,发送消息\n    rabbitTemplate.convertAndSend(&quot;order_exchange&quot;,\n                                  &quot;order.msg&quot;,&quot;订单信息：id&#x3D;1,time&#x3D;2020年10月17日11：41：47&quot;);\n    &#x2F;&#x2F;2.打印倒计时10秒\n    for (int i &#x3D; 10; i &gt; 0 ; i--) &#123;\n        System.out.println(i+&quot;...&quot;);\n        Thread.sleep(1000);\n    &#125;\n&#125;</code></pre>\n\n<p>修改消费者配置文件</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!--定义监听器容器\n    acknowledge&#x3D;&quot;manual&quot;：手动签收\n    acknowledge&#x3D;&quot;auto&quot; 自动签收\n    --&gt;\n&lt;rabbit:listener-container connection-factory&#x3D;&quot;connectionFactory&quot; acknowledge&#x3D;&quot;manual&quot;&gt;\n\n    &lt;!--&lt;rabbit:listener ref&#x3D;&quot;ackListener&quot; queue-names&#x3D;&quot;test_queue_confirm&quot;&gt;&lt;&#x2F;rabbit:listener&gt;--&gt;\n    &lt;!--&lt;rabbit:listener ref&#x3D;&quot;qosListener&quot; queue-names&#x3D;&quot;test_queue_confirm&quot;&gt;&lt;&#x2F;rabbit:listener&gt;--&gt;\n    &lt;!--定义监听器,监听正常队列--&gt;\n    &lt;!--&lt;rabbit:listener ref&#x3D;&quot;dlxListener&quot; queue-names&#x3D;&quot;test_queue_dlx&quot;&gt;&lt;&#x2F;rabbit:listener&gt;--&gt;\n    &lt;!--延迟队列效果实现：  一定要监听的是 死信队列！！！--&gt;\n    &lt;rabbit:listener ref&#x3D;&quot;orderListener&quot; queue-names&#x3D;&quot;order_queue_dlx&quot;&gt;&lt;&#x2F;rabbit:listener&gt;\n&lt;&#x2F;rabbit:listener-container&gt;</code></pre>\n\n<p>添加监听器</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\npublic class OrderListener implements ChannelAwareMessageListener &#123;\n\n    @Override\n    public void onMessage(Message message, Channel channel) throws Exception &#123;\n        long deliveryTag &#x3D; message.getMessageProperties().getDeliveryTag();\n\n        try &#123;\n            &#x2F;&#x2F;1.接收转换消息\n            System.out.println(new String(message.getBody()));\n\n            &#x2F;&#x2F;2. 处理业务逻辑\n            System.out.println(&quot;处理业务逻辑...&quot;);\n            System.out.println(&quot;根据订单id查询其状态...&quot;);\n            System.out.println(&quot;判断状态是否为支付成功&quot;);\n            System.out.println(&quot;取消订单,回滚库存....&quot;);\n            &#x2F;&#x2F;3. 手动签收\n            channel.basicAck(deliveryTag,true);\n        &#125; catch (Exception e) &#123;\n            &#x2F;&#x2F;e.printStackTrace();\n            System.out.println(&quot;出现异常,拒绝接受&quot;);\n            &#x2F;&#x2F;4.拒绝签收,不重回队列 requeue&#x3D;false\n            channel.basicNack(deliveryTag,true,false);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>运行测试类，可在后台看出结果</p>\n<h4 id=\"06、RabbitMQ-集成-SpringBoot\"><a href=\"#06、RabbitMQ-集成-SpringBoot\" class=\"headerlink\" title=\"06、RabbitMQ 集成 SpringBoot\"></a>06、RabbitMQ 集成 SpringBoot</h4><hr>\n<h5 id=\"6-1、创建-生产者和消费者-模块\"><a href=\"#6-1、创建-生产者和消费者-模块\" class=\"headerlink\" title=\"6.1、创建 生产者和消费者 模块\"></a>6.1、创建 生产者和消费者 模块</h5><p>① springboot_rabbitmq_producer        ② springboot_rabbitmq_consumer</p>\n<h5 id=\"6-2、添加依赖\"><a href=\"#6-2、添加依赖\" class=\"headerlink\" title=\"6.2、添加依赖\"></a>6.2、添加依赖</h5><p>两个模块都进行添加如下依赖</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!--1. 父工程依赖--&gt;\n&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.2.2.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;parent&gt;\n\n&lt;dependencies&gt;\n    &lt;!--2. rabbitmq--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;</code></pre>\n\n\n\n<h5 id=\"6-3、配置整合\"><a href=\"#6-3、配置整合\" class=\"headerlink\" title=\"6.3、配置整合\"></a>6.3、配置整合</h5><p>两个模块都添加 <strong>application.yml</strong></p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring: \n  rabbitmq: \n    host: 192.168.137.118\n    port: 5672\n    username: admin\n    password: 123456\n    virtual-host: &#x2F;</code></pre>\n\n<p>两个模块都添加 入口类 <strong>Application</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Application.class);\n    &#125;\n&#125;</code></pre>\n\n<p>生产者创建配置类 <strong>RabbitMQConfig</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.config;\nimport org.springframework.amqp.core.*;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class RabbitMQConfig &#123;\n    public static final String EXCHANGE_NAME &#x3D; &quot;boot_topic_exchange&quot;;\n    public static final String QUEUE_NAME &#x3D; &quot;boot_queue&quot;;\n\n    &#x2F;&#x2F; 1 交换机\n    @Bean(&quot;bootExchange&quot;)\n    public Exchange bootExchange()&#123;\n        return ExchangeBuilder.topicExchange(EXCHANGE_NAME).durable(true).build();\n    &#125;\n    &#x2F;&#x2F;2.Queue 队列\n    @Bean(&quot;bootQueue&quot;)\n    public Queue bootQueue()&#123;\n        return QueueBuilder.durable(QUEUE_NAME).build();\n    &#125;\n    &#x2F;&#x2F;3. 队列和交互机绑定关系 Binding\n    &#x2F;*\n        1. 知道哪个队列\n        2. 知道哪个交换机\n        3. routing key\n        noargs()：表示不指定参数\n     *&#x2F;\n    @Bean\n    public Binding bindQueueExchange(@Qualifier(&quot;bootQueue&quot;) Queue queue,\n                                     @Qualifier(&quot;bootExchange&quot;) Exchange exchange)&#123;\n        return BindingBuilder.bind(queue).to(exchange).with(&quot;boot.#&quot;).noargs();\n    &#125;\n&#125;</code></pre>\n\n<p>生产者创建测试文件 <strong>com.atguigu.ProducerTest.java</strong>，并运行</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu;\nimport com.atguigu.config.RabbitMQConfig;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.amqp.rabbit.core.RabbitTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\n\n@SpringBootTest\n@RunWith(SpringRunner.class)\npublic class ProducerTest &#123;\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    &#x2F;**\n * 第一个参数：交换机名字\n * 第二个参数：routingKey\n * 第三个参数：发送的消息\n *&#x2F;\n    @Test\n    public void testSend()&#123;\n        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_NAME,&quot;boot.haha&quot;,&quot;mq hello&quot;);\n    &#125;\n&#125;</code></pre>\n<p>消费者创建监听器，需要==使用 @RabbitListener 注解==，不在需要 实现某些类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.listener;\n\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class RabbimtMQListener &#123;\n    @RabbitListener(queues &#x3D; &quot;boot_queue&quot;)\n    public void listenerQueue(Message message)&#123;\n        System.out.println(new String(message.getBody()));\n    &#125;\n&#125;</code></pre>\n\n<p>最后运行消费者的 入口程序</p>\n<h5 id=\"6-4、小结\"><a href=\"#6-4、小结\" class=\"headerlink\" title=\"6.4、小结\"></a>6.4、小结</h5><ul>\n<li>SpringBoot提供了快速整合RabbitMQ的方式</li>\n<li>基本信息在yml中配置,队列交互机以及绑定关系在配置类中使用Bean的方式配置</li>\n<li>生产端直接注入RabbitTemplate完成消息发送</li>\n<li>消费端直接使用@RabbitListener完成消息接收</li>\n</ul>\n<h4 id=\"07、消息百分百成功投递\"><a href=\"#07、消息百分百成功投递\" class=\"headerlink\" title=\"07、消息百分百成功投递\"></a>07、消息百分百成功投递</h4><hr>\n<p>谈到消息的可靠性投递，无法避免的，在实际的工作中会经常碰到，比如一些核心业务需要保障消息不丢失，接下来我们看一个可靠性投递的流程图，说明可靠性投递的概念：</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-2-11.jpg\" alt=\"img\"> </p>\n<p>Step 1： 首先把消息信息(业务数据）存储到数据库中，紧接着，我们再把这个消息记录也存储到一张消息记录表里（或者另外一个同源数据库的消息记录表）</p>\n<p>Step 2：发送消息到MQ Broker节点（采用confirm方式发送，会有异步的返回结果）</p>\n<p>Step 3、4：生产者端接受MQ Broker节点返回的Confirm确认消息结果，然后进行更新消息记录表里的消息状态。比如默认Status = 0 当收到消息确认成功后，更新为1即可！</p>\n<p>Step 5：但是在消息确认这个过程中可能由于网络闪断、MQ Broker端异常等原因导致 回送消息失败或者异常。这个时候就需要发送方（生产者）对消息进行可靠性投递了，保障消息不丢失，100%的投递成功！（有一种极限情况是闪断，Broker返回的成功确认消息，但是生产端由于网络闪断没收到，这个时候重新投递可能会造成消息重复，需要消费端去做幂等处理）所以我们需要有一个定时任务，（比如每5分钟拉取一下处于中间状态的消息，当然这个消息可以设置一个超时时间，比如超过1分钟 Status = 0 ，也就说明了1分钟这个时间窗口内，我们的消息没有被确认，那么会被定时任务拉取出来）</p>\n<p>Step 6：接下来我们把中间状态的消息进行重新投递 retry send，继续发送消息到MQ ，当然也可能有多种原因导致发送失败</p>\n<p>Step 7：我们可以采用设置最大努力尝试次数，比如投递了3次，还是失败，那么我们可以将最终状态设置为Status = 2 ，最后 交由人工解决处理此类问题（或者把消息转储到失败表中）。</p>\n<p><strong>数据库文件</strong></p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- ----------------------------\n-- Table structure for broker_message_log\n-- ----------------------------\nDROP TABLE IF EXISTS &#96;broker_message_log&#96;;\nCREATE TABLE &#96;broker_message_log&#96; (\n  &#96;message_id&#96; varchar(255) NOT NULL COMMENT &#39;消息唯一ID&#39;,\n  &#96;message&#96; varchar(4000) NOT NULL COMMENT &#39;消息内容&#39;,\n  &#96;try_count&#96; int(4) DEFAULT &#39;0&#39; COMMENT &#39;重试次数&#39;,\n  &#96;status&#96; varchar(10) DEFAULT &#39;&#39; COMMENT &#39;消息投递状态 0投递中,1投递成功,2投递失败&#39;,\n  &#96;next_retry&#96; timestamp NOT NULL DEFAULT &#39;0000-00-00 00：00：00&#39; ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;下一次重试时间&#39;,\n  &#96;create_time&#96; timestamp NOT NULL DEFAULT &#39;0000-00-00 00：00：00&#39; ON UPDATE CURRENT_TIMESTAMP,\n  &#96;update_time&#96; timestamp NOT NULL DEFAULT &#39;0000-00-00 00：00：00&#39; ON UPDATE CURRENT_TIMESTAMP,\n  PRIMARY KEY (&#96;message_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;\n\n-- ----------------------------\n-- Table structure for t_order\n-- ----------------------------\nDROP TABLE IF EXISTS &#96;t_order&#96;;\nCREATE TABLE &#96;t_order&#96; (\n  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,\n  &#96;name&#96; varchar(255) DEFAULT NULL,\n  &#96;message_id&#96; varchar(255) DEFAULT NULL,\n  PRIMARY KEY (&#96;id&#96;)\n) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;2018091102 DEFAULT CHARSET&#x3D;utf8;</code></pre>\n\n\n\n<h4 id=\"08、RabbitMQ-集群搭建\"><a href=\"#08、RabbitMQ-集群搭建\" class=\"headerlink\" title=\"08、RabbitMQ 集群搭建\"></a>08、RabbitMQ 集群搭建</h4><hr>\n<p>摘要：实际生产应用中都会采用消息队列的集群方案，如果选择RabbitMQ那么有必要了解下它的集群方案原理</p>\n<p>一般来说，如果只是为了学习RabbitMQ或者验证业务工程的正确性那么在本地环境或者测试环境上使用其单实例部署就可以了，但是出于MQ中间件本身的可靠性、并发性、吞吐量和消息堆积能力等问题的考虑，在生产环境上一般都会考虑使用RabbitMQ的集群方案。</p>\n<h5 id=\"8-1、集群方案的原理\"><a href=\"#8-1、集群方案的原理\" class=\"headerlink\" title=\"8.1、集群方案的原理\"></a>8.1、集群方案的原理</h5><p>RabbitMQ这款消息队列中间件产品本身是基于Erlang编写，Erlang语言天生具备分布式特性（通过同步Erlang集群各节点的magic cookie来实现）。因此，RabbitMQ天然支持Clustering。这使得RabbitMQ本身不需要像ActiveMQ、Kafka那样通过ZooKeeper分别来实现HA方案和保存集群的元数据。集群是保证可靠性的一种方式，同时可以通过水平扩展以达到增加消息吞吐量能力的目的。</p>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-2-12.png\" alt=\"image-20210811215515010\" style=\"zoom:80%;\" />\n</div>\n\n\n\n<h5 id=\"8-2、单机多实例部署\"><a href=\"#8-2、单机多实例部署\" class=\"headerlink\" title=\"8.2、单机多实例部署\"></a>8.2、单机多实例部署</h5><p>由于某些因素的限制，有时候你不得不在一台机器上去搭建一个rabbitmq集群，这个有点类似zookeeper的单机版。真实生成环境还是要配成多机集群的。有关怎么配置多机集群的可以参考其他的资料，这里主要论述如何在单机中配置多个rabbitmq实例。</p>\n<p>主要参考官方文档：<a href=\"https://www.rabbitmq.com/clustering.html\">https://www.rabbitmq.com/clustering.html</a></p>\n<p>首先确保RabbitMQ运行没有问题</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@atguigu ~]# systemctl start rabbitmq-server.service\n[root@atguigu ~]# systemctl status rabbitmq-server.service</code></pre>\n\n<p>停止rabbitmq服务</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@atguigu ~]# systemctl stop rabbitmq-server.service</code></pre>\n\n<p>启动三个节点做集群演示：</p>\n<p>由于web管理插件端口占用,所以还要指定其web插件占用的端口号。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@atguigu ~]# RABBITMQ_NODE_PORT&#x3D;5672 RABBITMQ_NODENAME&#x3D;rabbit1 RABBITMQ_SERVER_START_ARGS&#x3D;&quot;-rabbitmq_management listener [&#123;port,15672&#125;]&quot;  rabbitmq-server -detached\n\n[root@atguigu ~]# RABBITMQ_NODE_PORT&#x3D;5673 RABBITMQ_NODENAME&#x3D;rabbit2 RABBITMQ_SERVER_START_ARGS&#x3D;&quot;-rabbitmq_management listener [&#123;port,15673&#125;]&quot;  rabbitmq-server -detached\n\n[root@atguigu ~]# RABBITMQ_NODE_PORT&#x3D;5674 RABBITMQ_NODENAME&#x3D;rabbit3 RABBITMQ_SERVER_START_ARGS&#x3D;&quot;-rabbitmq_management listener [&#123;port,15674&#125;]&quot;  rabbitmq-server -detached</code></pre>\n\n<p>启动三个节点后，分别访问三个节点，后台管理页面，看看是否OK.</p>\n<p>停止服务命令：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">rabbitmqctl -n rabbit1 stop\nrabbitmqctl -n rabbit2 stop\nrabbitmqctl -n rabbit3 stop</code></pre>\n\n<p>rabbit1操作作为主节点：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@atguigu ~]# rabbitmqctl -n rabbit1 stop_app  \nStopping node rabbit1@localhost ...\n[root@atguigu ~]# rabbitmqctl -n rabbit1 reset     \nResetting node rabbit1@localhost ...\n[root@atguigu ~]# rabbitmqctl -n rabbit1 start_app\nStarting node rabbit1@localhost ...</code></pre>\n\n<p>rabbit2操作为从节点：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@atguigu ~]# rabbitmqctl -n rabbit2 stop_app\nStopping node rabbit2@localhost ...\n[root@atguigu ~]# rabbitmqctl -n rabbit2 reset\nResetting node rabbit2@localhost ...\n[root@atguigu ~]# rabbitmqctl -n rabbit2 join_cluster rabbit1\nClustering node rabbit2@localhost with rabbit1 ...\n[root@atguigu ~]# rabbitmqctl -n rabbit2 start_app\nStarting node rabbit2@localhost ...</code></pre>\n\n<p>rabbit3操作为从节点：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@atguigu ~]# rabbitmqctl -n rabbit3 stop_app\nStopping node rabbit3@localhost ...\n[root@atguigu ~]# rabbitmqctl -n rabbit3 reset\nResetting node rabbit3@localhost ...\n[root@atguigu ~]# rabbitmqctl -n rabbit3 join_cluster rabbit1\nClustering node rabbit3@localhost with rabbit1@super ...\n[root@atguigu ~]# rabbitmqctl -n rabbit3 start_app\nStarting node rabbit3@localhost ...</code></pre>\n\n<p>查看集群状态：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@atguigu ~]# rabbitmqctl -n rabbit1 cluster_status\nCluster status of node rabbit1@localhost ...\nBasics\n \nCluster name: rabbit1@localhost\n \nDisk Nodes\n \nrabbit1@localhost\nrabbit2@localhost\nrabbit3@localhost\n \nRunning Nodes\n \nrabbit1@localhost\nrabbit2@localhost\nrabbit3@localhost\n \nVersions\n \nrabbit1@localhost: RabbitMQ 3.8.1 on Erlang 21.3.8.9\nrabbit2@localhost: RabbitMQ 3.8.1 on Erlang 21.3.8.9\nrabbit3@localhost: RabbitMQ 3.8.1 on Erlang 21.3.8.9\n \nAlarms\n \n(none)\n \nNetwork Partitions\n \n(none)\n \nListeners\n \nNode: rabbit1@localhost, interface: [::], port: 25672, protocol: clustering, purpose: inter-node and CLI tool communication\nNode: rabbit1@localhost, interface: [::], port: 5672, protocol: amqp, purpose: AMQP 0-9-1 and AMQP 1.0\nNode: rabbit1@localhost, interface: [::], port: 15672, protocol: http, purpose: HTTP API\nNode: rabbit2@localhost, interface: [::], port: 25673, protocol: clustering, purpose: inter-node and CLI tool communication\nNode: rabbit2@localhost, interface: [::], port: 5673, protocol: amqp, purpose: AMQP 0-9-1 and AMQP 1.0\nNode: rabbit2@localhost, interface: [::], port: 15673, protocol: http, purpose: HTTP API\nNode: rabbit3@localhost, interface: [::], port: 25674, protocol: clustering, purpose: inter-node and CLI tool communication\nNode: rabbit3@localhost, interface: [::], port: 5674, protocol: amqp, purpose: AMQP 0-9-1 and AMQP 1.0\nNode: rabbit3@localhost, interface: [::], port: 15674, protocol: http, purpose: HTTP API\n \nFeature flags\n \nFlag: drop_unroutable_metric, state: enabled\nFlag: empty_basic_get_metric, state: enabled\nFlag: implicit_default_bindings, state: enabled\nFlag: quorum_queue, state: enabled\nFlag: virtual_host_metadata, state: enabled</code></pre>\n\n<p>web监控：</p>\n<img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-2-1-20.png\" alt=\"image-20210812113733899\" style=\"zoom:80%;\" />\n\n\n\n<h5 id=\"8-3、集群管理\"><a href=\"#8-3、集群管理\" class=\"headerlink\" title=\"8.3、集群管理\"></a>8.3、集群管理</h5><p>rabbitmqctl join_cluster {cluster_node} [–ram]</p>\n<p>将节点加入指定集群中。在这个命令执行前需要停止RabbitMQ应用并重置节点。</p>\n<p>rabbitmqctl cluster_status</p>\n<p>显示集群的状态。</p>\n<p>rabbitmqctl change_cluster_node_type {disc|ram}</p>\n<p>修改集群节点的类型。在这个命令执行前需要停止RabbitMQ应用。</p>\n<p>rabbitmqctl forget_cluster_node [–offline]</p>\n<p>将节点从集群中删除，允许离线执行。</p>\n<p>rabbitmqctl update_cluster_nodes {clusternode}</p>\n<p>在集群中的节点应用启动前咨询clusternode节点的最新信息，并更新相应的集群信息。这个和join_cluster不同，它不加入集群。考虑这样一种情况，节点A和节点B都在集群中，当节点A离线了，节点C又和节点B组成了一个集群，然后节点B又离开了集群，当A醒来的时候，它会尝试联系节点B，但是这样会失败，因为节点B已经不在集群中了。</p>\n<p>rabbitmqctl cancel_sync_queue [-p vhost] {queue}</p>\n<p>取消队列queue同步镜像的操作。</p>\n<p>rabbitmqctl set_cluster_name {name}</p>\n<p>设置集群名称。集群名称在客户端连接时会通报给客户端。Federation和Shovel插件也会有用到集群名称的地方。集群名称默认是集群中第一个节点的名称，通过这个命令可以重新设置。</p>\n<h5 id=\"8-4、RabbitMQ-镜像集群配置\"><a href=\"#8-4、RabbitMQ-镜像集群配置\" class=\"headerlink\" title=\"8.4、RabbitMQ 镜像集群配置\"></a>8.4、RabbitMQ 镜像集群配置</h5><p>上面已经完成RabbitMQ默认集群模式，但并不保证队列的高可用性，尽管交换机、绑定这些可以复制到集群里的任何一个节点，但是队列内容不会复制。虽然该模式解决一项目组节点压力，但队列节点宕机直接导致该队列无法应用，只能等待重启，所以要想在队列节点宕机或故障也能正常应用，就要复制队列内容到集群里的每个节点，必须要创建镜像队列。</p>\n<p>镜像队列是基于普通的集群模式的，然后再添加一些策略，所以你还是得先配置普通集群，然后才能设置镜像队列，我们就以上面的集群接着做。</p>\n<p>设置的镜像队列可以通过开启的网页的管理端Admin-&gt;Policies，也可以通过命令。</p>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-2-13.png\" alt=\"image-20210811220532380\" style=\"zoom:80%;\" />\n</div>\n\n\n\n<ul>\n<li>Name:策略名称</li>\n<li>Pattern：匹配的规则，如果是匹配所有的队列，是^.</li>\n<li>Definition:使用ha-mode模式中的all，也就是同步所有匹配的队列。问号链接帮助文档。</li>\n</ul>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-2-14.png\" alt=\"image-20210811221106927\" style=\"zoom:80%;\" />\n</div>\n\n\n\n<h4 id=\"09、负载均衡-HAProxy\"><a href=\"#09、负载均衡-HAProxy\" class=\"headerlink\" title=\"09、负载均衡 HAProxy\"></a>09、负载均衡 HAProxy</h4><p>HAProxy提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案,包括Twitter，Reddit，StackOverflow，GitHub在内的多家知名互联网公司在使用。HAProxy实现了一种事件驱动、单一进程模型，此模型支持非常大的并发连接数。</p>\n<h5 id=\"9-1、centos-7-安装-HAProxy\"><a href=\"#9-1、centos-7-安装-HAProxy\" class=\"headerlink\" title=\"9.1、centos 7 安装 HAProxy\"></a>9.1、centos 7 安装 HAProxy</h5><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">&#x2F;&#x2F;下载依赖包\nyum install gcc vim wget\n&#x2F;&#x2F;上传haproxy源码包; -C解压到指定的目录\ntar -zxvf haproxy-1.6.5.tar.gz -C &#x2F;usr&#x2F;local\n&#x2F;&#x2F;进入目录、进行编译、安装\ncd &#x2F;usr&#x2F;local&#x2F;haproxy-1.6.5\n&#x2F;&#x2F; make 表示编译；TARGET&#x3D;linux31 表示CentOS7系统；PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;haproxy指定安装路径\n&#x2F;&#x2F; TARGET&#x3D;linux310，内核版本，使用uname -r查看内核，如：3.10.0-514.el7，此时该参数就为linux310；\nmake TARGET&#x3D;linux310 PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;haproxy\nmake install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;haproxy\nmkdir &#x2F;etc&#x2F;haproxy\n&#x2F;&#x2F;添加用户组：-r 创建一个系统组；-g 组ID\ngroupadd -r -g 149 haproxy\n&#x2F;&#x2F;添加用户：-g 新账户组的名称；-r 创建一个系统用户；-s 新用户的登录shell; -u 新账户的用户ID\nuseradd -g haproxy -r -s &#x2F;sbin&#x2F;nologin -u 149 haproxy\n&#x2F;&#x2F;创建haproxy配置文件\nvim &#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg</code></pre>\n\n<p>配置 HAProxy，配置文件路径：vim /etc/haproxy/haproxy.cfg</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#全局配置\nglobal\n    #日志输出配置，所有日志都记录在本机，通过local0输出\n    log 127.0.0.1 local0 info\n    #最大连接数\n    maxconn 5120\n    #改变当前的工作目录\n    chroot &#x2F;usr&#x2F;local&#x2F;haproxy\n    #以指定的UID运行haproxy进程\n    uid 99\n    #以指定的GID运行haproxy进程\n    gid 99\n    #以守护进程方式运行haproxy\n    daemon\n    quiet\n    nbproc 20\n    #当前进程PID文件\n    pidfile &#x2F;var&#x2F;run&#x2F;haproxy.pid\n#默认配置\ndefaults\n    #应用全局的日志配置\n    log global\n    #默认的模式mode&#123;tcp|http|health&#125;\n    mode tcp\n    #日志类别\n    option tcplog\n    #不记录检查检查日志信息\n    option dontlognull\n    #3次失败则认为服务不可用\n    retries 3\n    option redispatch\n    #每个进程可用的最大连接数\n    maxconn 2000\n    #连接超时\n    contimeout 5s\n    #客户端超时\n    clitimeout 60s\n    #服务端超时\n    srvtimeout 15s    \n#绑定配置\nlisten rabbitmq_cluster\n    bind *:5677\n    #配置TCP模式\n    mode tcp\n    #balance url_param userid\n    #balance url_param session_id check_post 64\n    #balance hdr(User-Agent)\n    #balance hdr(host)\n    #balance hdr(Host) use_domain_only\n    #balance rdp-cookie\n    #balance leastconn\n    #balance source &#x2F;&#x2F;ip\n    #简单的轮询\n    balance roundrobin\n    #server rabbit1 定义服务内部标识，\n    #127.0.0.1:5672 服务连接IP和端口，\n    #check inter 5000 定义每隔多少毫秒检查服务是否可用，\n    #rise 2 服务故障后需要多少次检查才能被再次确认可用，\n    #fall 2 经历多次失败的检查检查后，haproxy才会停止使用此服务\n    #weight 1 定义服务权重\n    server rabbit1 192.168.137.118:5672 check inter 5000 rise 2 fall 2 weight 1\n    server rabbit2 192.168.137.118:5673 check inter 5000 rise 2 fall 2 weight 1\n    server rabbit3 192.168.137.118:5674 check inter 5000 rise 2 fall 2 weight 1\n#haproxy监控页面地址\nlisten stats\n    bind 192.168.137.118:8100\n    mode http\n    option httplog\n    stats enable\n    stats uri &#x2F;rabbitmq-stats\n    stats refresh 5s</code></pre>\n\n<p>启动HAproxy负载</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;usr&#x2F;local&#x2F;haproxy&#x2F;sbin&#x2F;haproxy -f &#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg</code></pre>\n\n<p>查看haproxy进程状态</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ps -ef | grep haproxy</code></pre>\n\n<p>访问如下地址对mq节点进行监控</p>\n<p><a href=\"http://192.168.137.130:8100/rabbitmq-stats\">http://192.168.137.118:8100/rabbitmq-stats</a></p>\n<h5 id=\"9-2、centos-8-安装-HAProxy\"><a href=\"#9-2、centos-8-安装-HAProxy\" class=\"headerlink\" title=\"9.2、centos 8 安装 HAProxy\"></a>9.2、centos 8 安装 HAProxy</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">sudo dnf install haproxy</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">vim &#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg</code></pre>\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#---------------------------------------------------------------------\n# Example configuration for a possible web application.  See the\n# full configuration options online.\n#\n#   https:&#x2F;&#x2F;www.haproxy.org&#x2F;download&#x2F;1.8&#x2F;doc&#x2F;configuration.txt\n#\n#---------------------------------------------------------------------\n\n#---------------------------------------------------------------------\n# Global settings\n#---------------------------------------------------------------------\nglobal\n    # to have these messages end up in &#x2F;var&#x2F;log&#x2F;haproxy.log you will\n    # need to:\n    #\n    # 1) configure syslog to accept network log events.  This is done\n    #    by adding the &#39;-r&#39; option to the SYSLOGD_OPTIONS in\n    #    &#x2F;etc&#x2F;sysconfig&#x2F;syslog\n    #\n    # 2) configure local2 events to go to the &#x2F;var&#x2F;log&#x2F;haproxy.log\n    #   file. A line like the following can be added to\n    #   &#x2F;etc&#x2F;sysconfig&#x2F;syslog\n    #\n    #    local2.*                       &#x2F;var&#x2F;log&#x2F;haproxy.log\n    #\n    log         127.0.0.1 local2\n\n    chroot      &#x2F;var&#x2F;lib&#x2F;haproxy\n    pidfile     &#x2F;var&#x2F;run&#x2F;haproxy.pid\n    maxconn     4000\n    user        haproxy\n    group       haproxy\n    daemon\n\n    # turn on stats unix socket\n    stats socket &#x2F;var&#x2F;lib&#x2F;haproxy&#x2F;stats\n\n    # utilize system-wide crypto-policies\n    ssl-default-bind-ciphers PROFILE&#x3D;SYSTEM\n    ssl-default-server-ciphers PROFILE&#x3D;SYSTEM\n\n#---------------------------------------------------------------------\n# common defaults that all the &#39;listen&#39; and &#39;backend&#39; sections will\n# use if not designated in their block\n#---------------------------------------------------------------------\ndefaults\n    mode                    http\n    log                     global\n    option                  httplog\n    option                  dontlognull\n    option http-server-close\n    option forwardfor       except 127.0.0.0&#x2F;8\n    option                  redispatch\n    retries                 3\n    timeout http-request    10s\n    timeout queue           1m\n    timeout connect         10s\n    timeout client          1m\n    timeout server          1m\n    timeout http-keep-alive 10s\n    timeout check           10s\n    maxconn                 3000\n    \n    stats uri \t\t    &#x2F;admin&#x2F;stats\n#---------------------------------------------------------------------\n# main frontend which proxys to the backends\n#---------------------------------------------------------------------\nfrontend main\n    bind *:5000\n    acl url_static       path_beg       -i &#x2F;static &#x2F;images &#x2F;javascript &#x2F;stylesheets\n    acl url_static       path_end       -i .jpg .gif .png .css .js\n\n    use_backend static          if url_static\n    default_backend             app\n\n#---------------------------------------------------------------------\n# static backend for serving up images, stylesheets and such\n#---------------------------------------------------------------------\nbackend static\n    balance     roundrobin\n    server      static 127.0.0.1:4331 check\n\n#---------------------------------------------------------------------\n# round robin balancing between the various backends\n#---------------------------------------------------------------------\nbackend app\n    balance     roundrobin\n    server  app1 127.0.0.1:5001 check\n    server  app2 127.0.0.1:5002 check\n    server  app3 127.0.0.1:5003 check\n    server  app4 127.0.0.1:5004 check\n</code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">systemctl start haproxy\n\nsystemctl stop haproxy</code></pre>\n\n<p>访问地址：<a href=\"http://192.168.96.66:5000/admin/stats\">http://192.168.96.66:5000/admin/stats</a></p>\n<h5 id=\"9-3、springboot-yml文件中访问mq集群地址\"><a href=\"#9-3、springboot-yml文件中访问mq集群地址\" class=\"headerlink\" title=\"9.3、springboot yml文件中访问mq集群地址\"></a>9.3、springboot yml文件中访问mq集群地址</h5><p>==访问一个就能访问全部，往一个里写入数据，所有的mq都能获取数据==</p>\n<pre class=\"line-numbers language-yml\" data-language=\"yml\"><code class=\"language-yml\">spring: \n\trabbitmq: \n\t\thost: 192.168.137.118\n\t\tport: 5677\n\t\tusername: admin\n\t\tpassword: 123456\n\t\tvirtual-host: &#x2F;\n\t\t#addresses: 192.168.137.118:5672,192.168.137.118:5673,192.168.137.118:5674</code></pre>\n\n","text":"01、消息的可靠性投递 1.1、消息投递可靠性的简介在使用 RabbitMQ 时，作为消息发送方希望杜绝任何消息丢失或者失败的场景。RabbitMQ 为我们提供了两种方式用来控制消息的投递可靠性模式：==① confirm 确认模式 ② return 退回模式== rabbitm...","link":"","photos":[],"count_time":{"symbolsCount":"46k","symbolsTime":"42 mins."},"categories":[{"name":"消息队列","slug":"消息队列","count":2,"path":"api/categories/消息队列.json"}],"tags":[{"name":"消息队列","slug":"消息队列","count":2,"path":"api/tags/消息队列.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#01%E3%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92\"><span class=\"toc-text\">01、消息的可靠性投递</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-1%E3%80%81%E6%B6%88%E6%81%AF%E6%8A%95%E9%80%92%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">1.1、消息投递可靠性的简介</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2%E3%80%81%E6%B6%88%E6%81%AF%E6%8A%95%E9%80%92%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%94%9F%E4%BA%A7%E8%80%85\"><span class=\"toc-text\">1.2、消息投递可靠性生产者</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-3%E3%80%81%E6%8A%95%E9%80%92%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%94%9F%E4%BA%A7%E8%80%85%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">1.3、投递可靠性生产者小结</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-4%E3%80%81Consumer-Ack-%E6%B6%88%E8%B4%B9%E8%80%85\"><span class=\"toc-text\">1.4、Consumer Ack 消费者</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-5%E3%80%81%E6%8A%95%E9%80%92%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%B6%88%E8%B4%B9%E8%80%85%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">1.5、投递可靠性消费者小结</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#02%E3%80%81%E6%B6%88%E8%B4%B9%E7%AB%AF%E9%99%90%E6%B5%81\"><span class=\"toc-text\">02、消费端限流</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-1%E3%80%81%E9%99%90%E6%B5%81%E6%93%8D%E4%BD%9C%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">2.1、限流操作的使用</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#03%E3%80%81TTL\"><span class=\"toc-text\">03、TTL</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-1%E3%80%81TTL-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">3.1、TTL 概念</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-2%E3%80%81%E8%AE%BE%E7%BD%AE%E6%B6%88%E6%81%AF-TTL%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">3.2、设置消息 TTL的两种方法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-3%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">3.3、代码实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#1%E3%80%81%E7%AC%AC%E4%B8%80%E7%A7%8D%EF%BC%9A%E9%98%9F%E5%88%97%E5%85%A8%E9%83%A8%E6%B6%88%E6%81%AF%E8%BF%87%E6%9C%9F\"><span class=\"toc-text\">1、第一种：队列全部消息过期</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2%E3%80%81%E7%AC%AC%E4%BA%8C%E7%A7%8D%EF%BC%8C%E6%B6%88%E6%81%AF%E8%BF%87%E6%9C%9F\"><span class=\"toc-text\">2、第二种，消息过期</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#04%E3%80%81%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97\"><span class=\"toc-text\">04、死信队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97\"><span class=\"toc-text\">4.1、什么是死信队列</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-2%E3%80%81%E6%AD%BB%E4%BF%A1%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">4.2、死信的处理方式</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-3%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">4.3、代码实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%88%B0%E8%BE%BE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E5%90%8E%EF%BC%8C%E5%8F%98%E4%B8%BA%E6%AD%BB%E4%BF%A1\"><span class=\"toc-text\">1、到达过期时间后，变为死信</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%88%B0%E8%BE%BE%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E5%90%8E%EF%BC%8C%E5%8F%98%E4%B8%BA%E6%AD%BB%E4%BF%A1\"><span class=\"toc-text\">2、到达长度限制后，变为死信</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%B6%88%E6%81%AF%E7%BB%8F%E8%BF%87%E6%8B%92%E6%94%B6%E5%90%8E%EF%BC%8C%E5%8F%98%E4%B8%BA%E6%AD%BB%E4%BF%A1\"><span class=\"toc-text\">3、消息经过拒收后，变为死信</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-4%E3%80%81%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">4.4、死信队列小结</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#05%E3%80%81%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97\"><span class=\"toc-text\">05、延迟队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-1%E3%80%81%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">5.1、延迟队列概念</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">5.2、代码实现</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#06%E3%80%81RabbitMQ-%E9%9B%86%E6%88%90-SpringBoot\"><span class=\"toc-text\">06、RabbitMQ 集成 SpringBoot</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-1%E3%80%81%E5%88%9B%E5%BB%BA-%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85-%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">6.1、创建 生产者和消费者 模块</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-2%E3%80%81%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">6.2、添加依赖</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-3%E3%80%81%E9%85%8D%E7%BD%AE%E6%95%B4%E5%90%88\"><span class=\"toc-text\">6.3、配置整合</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-4%E3%80%81%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">6.4、小结</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#07%E3%80%81%E6%B6%88%E6%81%AF%E7%99%BE%E5%88%86%E7%99%BE%E6%88%90%E5%8A%9F%E6%8A%95%E9%80%92\"><span class=\"toc-text\">07、消息百分百成功投递</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#08%E3%80%81RabbitMQ-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA\"><span class=\"toc-text\">08、RabbitMQ 集群搭建</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-1%E3%80%81%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">8.1、集群方案的原理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-2%E3%80%81%E5%8D%95%E6%9C%BA%E5%A4%9A%E5%AE%9E%E4%BE%8B%E9%83%A8%E7%BD%B2\"><span class=\"toc-text\">8.2、单机多实例部署</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-3%E3%80%81%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">8.3、集群管理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-4%E3%80%81RabbitMQ-%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">8.4、RabbitMQ 镜像集群配置</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#09%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-HAProxy\"><span class=\"toc-text\">09、负载均衡 HAProxy</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#9-1%E3%80%81centos-7-%E5%AE%89%E8%A3%85-HAProxy\"><span class=\"toc-text\">9.1、centos 7 安装 HAProxy</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#9-2%E3%80%81centos-8-%E5%AE%89%E8%A3%85-HAProxy\"><span class=\"toc-text\">9.2、centos 8 安装 HAProxy</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#9-3%E3%80%81springboot-yml%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AE%BF%E9%97%AEmq%E9%9B%86%E7%BE%A4%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">9.3、springboot yml文件中访问mq集群地址</span></a></li></ol></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"SpringCloud 基础内容","uid":"74daf6bfc632564c16acab051038d38a","slug":"68-SpringCloud-基础内容","date":"2021-09-13T15:44:32.000Z","updated":"2021-09-15T10:46:40.017Z","comments":true,"path":"api/articles/68-SpringCloud-基础内容.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog8.jpg","text":"1、本章导读 2、微服务理论In short, the microservice architectural style [1] is an approach to developing a single application as a suite of small servi...","link":"","photos":[],"count_time":{"symbolsCount":"28k","symbolsTime":"25 mins."},"categories":[{"name":"SpringCloud","slug":"SpringCloud","count":4,"path":"api/categories/SpringCloud.json"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","count":4,"path":"api/tags/SpringCloud.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"RabbitMQ 基础内容","uid":"c45f5a44aa5e1bceb86c7aa31b1d0a34","slug":"66-RabbitMQ-基础内容","date":"2021-09-13T15:42:32.000Z","updated":"2021-09-15T10:46:48.980Z","comments":true,"path":"api/articles/66-RabbitMQ-基础内容.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog10.jpg","text":"01、什么是消息中间件MQ全称为Message Queue， 消息队列(MQ)是一种应用程序对应用程序的通信方法。 介绍：消息队列就是基础数据结构中的 “先进先出” 的一种数据机构。想一下，生活中买东西，需要排队，先排的人先买消费，就是典型的“先进先出”。 消息传递：指的是程序之...","link":"","photos":[],"count_time":{"symbolsCount":"34k","symbolsTime":"31 mins."},"categories":[{"name":"消息队列","slug":"消息队列","count":2,"path":"api/categories/消息队列.json"}],"tags":[{"name":"消息队列","slug":"消息队列","count":2,"path":"api/tags/消息队列.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}