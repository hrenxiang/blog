{"title":"反射","uid":"89dcc30b71db0004bd54ff025b96bee1","slug":"18-反射","date":"2021-09-13T14:53:32.000Z","updated":"2021-09-15T10:17:53.511Z","comments":true,"path":"api/articles/18-反射.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","content":"<h3 id=\"一、类加载\"><a href=\"#一、类加载\" class=\"headerlink\" title=\"一、类加载\"></a>一、类加载</h3><p>– 概述：类在内存中的生命周期：加载–&gt;使用–&gt;卸载</p>\n<h4 id=\"1、类的加载过程\"><a href=\"#1、类的加载过程\" class=\"headerlink\" title=\"1、类的加载过程\"></a>1、类的加载过程</h4><p>当程序主动使用某个类时，如果该类还未被加载到内存中，系统会通过加载、连接、初始化三个步骤来对该类进行初始化，如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载。</p>\n<p>类的加载又分为三个阶段：</p>\n<p>（1）加载：load</p>\n<p>就是指将类型的clas字节码数据读入内存</p>\n<p>（2）连接：link</p>\n<p>①验证：校验合法性等</p>\n<p>②准备：准备对应的内存（方法区），创建Class对象，为类变量赋默认值，为静态常量赋初始值。</p>\n<p>③解析：把字节码中的符号引用替换为对应的直接地址引用</p>\n<p>（3）初始化：initialize（类初始化）即执行<clinit>类初始化方法，大多数情况下，类的加载就完成了类的初始化，有些情况下，会延迟类的初始化。</p>\n<p><img src=\"https://gitee.com/xiuxiuai/picture/raw/master/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD.png\" alt=\"image-20210503175710174\"></p>\n<h4 id=\"2、类初始化\"><a href=\"#2、类初始化\" class=\"headerlink\" title=\"2、类初始化\"></a>2、类初始化</h4><p>1、哪些操作会导致类的初始化？</p>\n<p>（1）运行主方法所在的类，要先完成类初始化，再执行main方法</p>\n<p>（2）第一次使用某个类型就是在new它的对象，此时这个类没有初始化的话，先完成类初始化再做实例初始化</p>\n<p>（3）调用某个类的静态成员（类变量和类方法），此时这个类没有初始化的话，先完成类初始化</p>\n<p>（4）子类初始化时，发现它的父类还没有初始化的话，那么先初始化父类</p>\n<p>（5）通过反射操作某个类时，如果这个类没有初始化，也会导致该类先初始化</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>类初始化执行的是<clinit>()，该方法由（1）类变量的显式赋值代码（2）静态代码块中的代码构成</p></blockquote>\n<p>2、哪些使用类的操作，但是不会导致类的初始化？</p>\n<p>（1）使用某个类的静态的常量（static  final）</p>\n<p>（2）通过子类调用父类的静态变量，静态方法，只会导致父类初始化，不会导致子类初始化，即只有声明静态成员的类才会初始化</p>\n<p>（3）用某个类型声明数组并创建数组对象时，不会导致这个类初始化</p>\n<h4 id=\"3、类加载器\"><a href=\"#3、类加载器\" class=\"headerlink\" title=\"3、类加载器\"></a>3、类加载器</h4><p>很多开发人员都遇到过java.lang.ClassNotFoundException或java.lang.NoClassDefError，想要更好的解决这类问题，或者在一些特殊的应用场景，比如需要支持类的动态加载或需要对编译后的字节码文件进行加密解密操作，那么需要你自定义类加载器，因此了解类加载器及其类加载机制也就成了每一个Java开发人员的必备技能之一。</p>\n<p><strong>1、类加载器分为：</strong></p>\n<p>（1）引导类加载器（Bootstrap Classloader）又称为根类加载器</p>\n<pre><code>它负责加载jre/rt.jar核心库\n它本身不是Java代码实现的，也不是ClassLoader的子类，获取它的对象时往往返回null\n</code></pre>\n<p>（2）扩展类加载器（Extension ClassLoader）</p>\n<pre><code>它负责加载jre/lib/ext扩展库\n它是ClassLoader的子类\n</code></pre>\n<p>（3）应用程序类加载器（Application Classloader）</p>\n<pre><code>它负责加载项目的classpath路径下的类\n\n它是ClassLoader的子类\n</code></pre>\n<p>（4）自定义类加载器</p>\n<pre><code>当你的程序需要加载“特定”目录下的类，可以自定义类加载器；\n当你的程序的字节码文件需要加密时，那么往往会提供一个自定义类加载器对其进行解码\n后面会见到的自定义类加载器：tomcat中\n</code></pre>\n<p><strong>2、Java系统类加载器的双亲委托模式</strong></p>\n<p>简单描述：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">下一级的类加载器，如果接到任务时，会先搜索是否加载过，如果没有，会先把任务往上传，如果都没有加载过，一直到根加载器，如果根加载器在它负责的路径下没有找到，会往回传，如果一路回传到最后一级都没有找到，那么会报ClassNotFoundException或NoClassDefError，如果在某一级找到了，就直接返回Class对象。</code></pre>\n\n<p>应用程序类加载器  把  扩展类加载器视为父加载器，</p>\n<p>扩展类加载器 把 引导类加载器视为父加载器。</p>\n<p>不是继承关系，是组合的方式实现的。</p>\n<img src=\"https://gitee.com/xiuxiuai/picture/raw/master/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png\" alt=\"image-20210503185222654\" style=\"zoom: 67%;\" />\n\n<h3 id=\"二、Java反射机制\"><a href=\"#二、Java反射机制\" class=\"headerlink\" title=\"二、Java反射机制\"></a>二、Java反射机制</h3><h4 id=\"1、概述\"><a href=\"#1、概述\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h4><ul>\n<li>java反射机制是在运行状态中，对任意一个类，都能够知道这个类的所有属性和方法，对任意一个对象，都能够调用他的任意一个方法和属性，这种动态获取信息以及动态调用对象的方法被称为 java语言的反射机制。</li>\n<li>要想解剖一个类，必须先要获取到该类的Class对象。而剖析一个类或用反射解决具体的问题就是使用相关API（1）java.lang.Class（2）java.lang.reflect.*。所以，Class对象是反射的根源。</li>\n</ul>\n<h4 id=\"2、哪些类型可以获取class对象\"><a href=\"#2、哪些类型可以获取class对象\" class=\"headerlink\" title=\"2、哪些类型可以获取class对象\"></a>2、哪些类型可以获取class对象</h4><p><strong>所有Java类型</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;（1）基本数据类型和void\n例如：int.class\n\t void.class\n&#x2F;&#x2F;（2）类和接口\n例如：String.class\n\tComparable.class\n&#x2F;&#x2F;（3）枚举\n例如：ElementType.class\n&#x2F;&#x2F;（4）注解\n例如：Override.class\n&#x2F;&#x2F;（5）数组\n例如：int[].class</code></pre>\n\n<h3 id=\"三、获取Class对象的四种方式\"><a href=\"#三、获取Class对象的四种方式\" class=\"headerlink\" title=\"三、获取Class对象的四种方式\"></a>三、获取Class对象的四种方式</h3><ol>\n<li>类型名.class：任何数据类型（包括基本数据类型）都有一个 “静态” 的class属性，<u>要求编译期间已知类型</u>。</li>\n<li>对象.getClass()：object类中的getClass方法，所有类都继承Object类。<u>获取对象的运行时类型</u>。</li>\n<li>Class.forName(类型全名称)：可以获取编译期间未知的类型</li>\n<li>ClassLoader的类加载器对象.loadClass(类型全名称)：可以用系统类加载对象或自定义加载器对象加载指定路径下的类型</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestClass &#123;\n\t@Test\n\tpublic void test05() throws ClassNotFoundException&#123;\n\t\tClass c &#x3D; TestClass.class;\n\t\tClassLoader loader &#x3D; c.getClassLoader();\n\t\t\n\t\tClass c2 &#x3D; loader.loadClass(&quot;com.atguigu.test05.Employee&quot;);\n\t\tClass c3 &#x3D; Employee.class;\n\t\tSystem.out.println(c2 &#x3D;&#x3D; c3);\n\t&#125;\n\t\n\t@Test\n\tpublic void test03() throws ClassNotFoundException&#123;\n\t\tClass c2 &#x3D; String.class;\n\t\tClass c1 &#x3D; &quot;&quot;.getClass();\n\t\tClass c3 &#x3D; Class.forName(&quot;java.lang.String&quot;);\n\t\t\n\t\tSystem.out.println(c1 &#x3D;&#x3D; c2);\n\t\tSystem.out.println(c1 &#x3D;&#x3D; c3);\n\t&#125;\n&#125;</code></pre>\n\n<p>注意：</p>\n<ul>\n<li><p>在运行期间，一个类只有一个Class对象产生</p>\n</li>\n<li><p>四种方式中，最常用的是 第三种，通过Class类的静态方法获取</p>\n<p>第一种 需要导入类的包，依赖太强，不导包就会抛编译错误</p>\n<p>第二种 需要对象，对象都有了，没必要用反射了</p>\n<p>第三种 可以传入一个字符串，也可以从配置文件中获取等多种方法</p>\n</li>\n</ul>\n<h3 id=\"四、获取类型的详细信息\"><a href=\"#四、获取类型的详细信息\" class=\"headerlink\" title=\"四、获取类型的详细信息\"></a>四、获取类型的详细信息</h3><p>可以获取：包、修饰符、类型名、父类（包括泛型父类）、父接口（包括泛型父接口）、成员（属性、构造器、方法）、注解（类上的、方法上的、属性上的）</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">太多了，运用到什么查什么</code></pre>\n\n<h3 id=\"五、创建任意引用类型的对象\"><a href=\"#五、创建任意引用类型的对象\" class=\"headerlink\" title=\"五、创建任意引用类型的对象\"></a>五、创建任意引用类型的对象</h3><h4 id=\"1、两种方式：\"><a href=\"#1、两种方式：\" class=\"headerlink\" title=\"1、两种方式：\"></a>1、两种方式：</h4><ol>\n<li>直接通过Class对象来实例化（要求必须有无参构造）</li>\n<li>通过获取构造器对象来进行实例化</li>\n</ol>\n<p>注意：不推荐使用Class类中的 newInstance() 方法，jdk9 后已经废弃。推荐使用 获取相关类的Class对象后，获取他的 Constructor对象(构造方法)，使用 Constructor类 中的 newInstance()方法</p>\n<h4 id=\"2、方式一的步骤\"><a href=\"#2、方式一的步骤\" class=\"headerlink\" title=\"2、方式一的步骤\"></a>2、方式一的步骤</h4><p>（1）获取该类型的Class对象（2）创建对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\t@Test\n\tpublic void test2()throws Exception&#123;\n\t\tClass&lt;?&gt; clazz &#x3D; Class.forName(&quot;com.atguigu.test.Student&quot;);\n\t\t&#x2F;&#x2F;Caused by: java.lang.NoSuchMethodException: com.atguigu.test.Student.&lt;init&gt;()\n\t\t&#x2F;&#x2F;即说明Student没有无参构造，就没有无参实例初始化方法&lt;init&gt;\n\t\tObject stu &#x3D; clazz.newInstance();\n\t\tSystem.out.println(stu);\n\t&#125;\n\t\n\t@Test\n\tpublic void test1() throws ClassNotFoundException, InstantiationException, IllegalAccessException&#123;\n&#x2F;&#x2F;\t\tAtGuigu obj &#x3D; new AtGuigu();&#x2F;&#x2F;编译期间无法创建\n\t\t\n\t\tClass&lt;?&gt; clazz &#x3D; Class.forName(&quot;com.atguigu.test.AtGuigu&quot;);\n\t\t&#x2F;&#x2F;clazz代表com.atguigu.test.AtGuigu类型\n\t\t&#x2F;&#x2F;clazz.newInstance()创建的就是AtGuigu的对象\n\t\tObject obj &#x3D; clazz.newInstance();\n\t\tSystem.out.println(obj);\n\t&#125;</code></pre>\n\n<h4 id=\"3、方式二的步骤：\"><a href=\"#3、方式二的步骤：\" class=\"headerlink\" title=\"3、方式二的步骤：\"></a>3、方式二的步骤：</h4><p>（1）获取该类型的Class对象（2）获取构造器对象（3）创建对象</p>\n<p>  先通过Class对象获取指定的Constructor对象，再通过Constructor对象的newInstance()方法来创建</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果构造器的权限修饰符修饰的范围不可见，也可以调用setAccessible(true)</p></blockquote>\n<p>示例代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestNewInstance &#123;\n\t@Test\n\tpublic void test3()throws Exception&#123;\n\t\t&#x2F;&#x2F;(1)获取Class对象\n\t\tClass&lt;?&gt; clazz &#x3D; Class.forName(&quot;com.atguigu.test.Student&quot;);\n\t\t&#x2F;*\n\t\t * 获取Student类型中的有参构造\n\t\t * 如果构造器有多个，我们通常是根据形参【类型】列表来获取指定的一个构造器的\n\t\t * 例如：public Student(int id, String name) \n\t\t *&#x2F;\n\t\t&#x2F;&#x2F;(2)获取构造器对象\n\t\tConstructor&lt;?&gt; constructor &#x3D; clazz.getDeclaredConstructor(int.class,String.class);\n\t\t\n\t\t&#x2F;&#x2F;(3)创建实例对象\n\t\t&#x2F;&#x2F; T newInstance(Object... initargs)  这个Object...是在创建对象时，给有参构造的实参列表\n\t\tObject obj &#x3D; constructor.newInstance(2,&quot;张三&quot;);\n\t\tSystem.out.println(obj);\n\t&#125;\n&#125;</code></pre>\n\n<h3 id=\"六、通过反射获取构造方法\"><a href=\"#六、通过反射获取构造方法\" class=\"headerlink\" title=\"六、通过反射获取构造方法\"></a>六、通过反射获取构造方法</h3><h4 id=\"1、获取多个构造方法\"><a href=\"#1、获取多个构造方法\" class=\"headerlink\" title=\"1、获取多个构造方法\"></a>1、获取多个构造方法</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Constructor&lt;?&gt;[] getConstructors()：\n获取 所有的 构造方法，不包含私有的\n\npublic Constructor&lt;?&gt;[] getDeclaredConstructors()：\n获取 所有的 构造方法 ，包括私有的</code></pre>\n\n<h4 id=\"2、获取单个构造方法\"><a href=\"#2、获取单个构造方法\" class=\"headerlink\" title=\"2、获取单个构造方法\"></a>2、获取单个构造方法</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Constructor&lt; T &gt; getConstructor(Class&lt;?&gt;... paramet)\n获取单个的构造方法， 不包含私有的\n\npublic Constructor&lt; T &gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)：\n获取单个的构造方法，包含私有的</code></pre>\n\n<h4 id=\"3、注意\"><a href=\"#3、注意\" class=\"headerlink\" title=\"3、注意\"></a>3、注意</h4><p>在使用第二种方法获取单个构造方法构建实例时，getConstructor()方法的参数为：**<code>方法形参类型的class对象</code>**</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">* 示例\nstudent类中的一个构造方法：\npublic Student(String name, int age, String address) &#123;\n    this.name &#x3D; name;\n    this.age &#x3D; age;\n    this.address &#x3D; address;\n&#125;\n    \n获取次构造方法，创建实例：\nConstructor&lt;?&gt; cos3 &#x3D; c1.getConstructor(String.class,int.class,String.class);\nStudent obj2 &#x3D; (Student) cos3.newInstance(&quot;黄某人&quot;,22,&quot;新疆&quot;);   </code></pre>\n\n<h4 id=\"4、setAccessible-boolean-flag\"><a href=\"#4、setAccessible-boolean-flag\" class=\"headerlink\" title=\"4、setAccessible(boolean flag)\"></a>4、setAccessible(boolean flag)</h4><p>在<strong>获取私有的</strong> 构造犯法，成员变量，成员方法时，<strong>需要设置 使用java语言访问控制执行检查 的值为true</strong></p>\n<p><code>public void setAccessible(boolean flag)</code>：将此反射对象的accessible标志设置为指示的布尔值。</p>\n<p>值为true表示反射对象应该在使用Java语言访问控制时   抑制检查。</p>\n<p>值为false表示反射对象应该在使用Java语言访问控制时  执行检查，并在类描述中指出变体。</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public class ReflectDemo1 &#123;\n\n   public static void main(String[] args) throws Exception&#123;\n\n       Class&lt;?&gt; c1 &#x3D; Class.forName(&quot;ClassLoder.Student&quot;);\n\n       &#x2F;&#x2F; 获取私有的构造方法\n       Constructor&lt;?&gt; con5 &#x3D; c1.getDeclaredConstructor(String.class);\n       &#x2F;&#x2F;public void setAccessible(boolean flag)将此反射对象的accessible标志设置为指示的布尔值。\n       &#x2F;&#x2F;值为true表示反射对象应该在使用Java语言访问控制时抑制检查。\n       &#x2F;&#x2F;值为false表示反射对象应该在使用Java语言访问控制时执行检查，并在类描述中指出变体。\n       con5.setAccessible(true);\n       Object obj4 &#x3D; con5.newInstance(&quot;田兆鑫&quot;);\n       System.out.println(obj4);\n\n   &#125;\n&#125;</code></pre>\n\n<h3 id=\"七、通过反射获取成员变量\"><a href=\"#七、通过反射获取成员变量\" class=\"headerlink\" title=\"七、通过反射获取成员变量\"></a>七、通过反射获取成员变量</h3><h4 id=\"1、获取多个成员变量\"><a href=\"#1、获取多个成员变量\" class=\"headerlink\" title=\"1、获取多个成员变量\"></a>1、获取多个成员变量</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Field[] getFields()：\n获取所有的成员变量包含从父类继承过来的\n\npublic Field[] getDeclaredFields()：\t\n获取所有的成员变量 包含私有的 也包含从父类继承过来的成员变量</code></pre>\n\n<h4 id=\"2、获取单个成员变量\"><a href=\"#2、获取单个成员变量\" class=\"headerlink\" title=\"2、获取单个成员变量\"></a>2、获取单个成员变量</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Field getField(String name) \n     \npublic Field getDeclaredField(String name) （需要setAccessible(true)）</code></pre>\n\n<h4 id=\"3、获取后可进行值的设置\"><a href=\"#3、获取后可进行值的设置\" class=\"headerlink\" title=\"3、获取后可进行值的设置\"></a>3、获取后可进行值的设置</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">void set(Object obj, Object value) \n将指定的对象参数中由此 Field对象表示的字段设置为指定的新值。</code></pre>\n\n<h4 id=\"4、示例\"><a href=\"#4、示例\" class=\"headerlink\" title=\"4、示例\"></a>4、示例</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) throws Exception &#123;\n\n        Class&lt;?&gt; c &#x3D; Class.forName(&quot;ClassLoder.Student&quot;);\n\n        &#x2F;&#x2F;public Field[] getFields()：\n        &#x2F;&#x2F;获取所有的成员变量包含从父类继承过来的\n        Field[] f1 &#x3D; c.getFields();\n        for (Field f : f1)&#123;\n            System.out.println(f);\n        &#125;\n        System.out.println(&quot;--------&quot;);\n\n        &#x2F;&#x2F;public Field[] getDeclaredFields()：\n        &#x2F;&#x2F;获取所有的成员变量 包含私有的 也包含从父类继承过来的成员变量\n        Field[] df1 &#x3D; c.getDeclaredFields();\n        for (Field df : df1)&#123;\n            System.out.println(df);\n        &#125;\n        System.out.println(&quot;--------&quot;);\n\n        &#x2F;&#x2F;public Field getField(String name) 获取单个成员变量\n        Field fiel &#x3D; c.getField(&quot;address&quot;);\n        System.out.println(fiel);\n        System.out.println(&quot;--------&quot;);\n\n        &#x2F;&#x2F;获取单个成员变量(包括私有)：\n        &#x2F;&#x2F;public Field getDeclaredField(String name)\n        Field fiel1 &#x3D; c.getDeclaredField(&quot;name&quot;);\n        System.out.println(fiel1);\n        System.out.println(&quot;--------&quot;);\n\n        Field fiel2 &#x3D; c.getField(&quot;address&quot;);\n        Constructor&lt;?&gt; con &#x3D; c.getConstructor();\n        Object o &#x3D; con.newInstance();\n        &#x2F;&#x2F;void set​(Object obj, Object value)\n        &#x2F;&#x2F; 将指定的对象参数中由此 Field对象表示的字段设置为指定的新值。\n        fiel2.set(o,&quot;北京&quot;);&#x2F;&#x2F;给对象o的成员变量fiel2(address)赋值为北京\n        System.out.println(o);\n        System.out.println(&quot;--------&quot;);\n\n\n        Field fiel3 &#x3D; c.getDeclaredField(&quot;name&quot;);\n        Constructor&lt;?&gt; con1&#x3D; c.getConstructor();\n        Object o1 &#x3D; con1.newInstance();\n\n        fiel3.setAccessible(true);\n\n        &#x2F;&#x2F;void set​(Object obj, Object value)\n        &#x2F;&#x2F; 将指定的对象参数中由此 Field对象表示的字段设置为指定的新值。\n        fiel3.set(o1,&quot;北京&quot;);&#x2F;&#x2F;给对象o的成员变量fiel2(address)赋值为北京\n        System.out.println(o1);\n    &#125;</code></pre>\n\n\n\n<h3 id=\"八、通过反射获取成员方法\"><a href=\"#八、通过反射获取成员方法\" class=\"headerlink\" title=\"八、通过反射获取成员方法\"></a>八、通过反射获取成员方法</h3><h4 id=\"1、获取多个成员方法\"><a href=\"#1、获取多个成员方法\" class=\"headerlink\" title=\"1、获取多个成员方法\"></a>1、获取多个成员方法</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Method[] getMethods()：\n获取所有的公共的成员方法不包含私有的，包含从父类继承过来的过来的公共方法\n\npublic Method[] getDeclaredMethods()：\n获取自己的所有成员方法 包含私有的</code></pre>\n\n<h4 id=\"2、获取单个成员方法\"><a href=\"#2、获取单个成员方法\" class=\"headerlink\" title=\"2、获取单个成员方法\"></a>2、获取单个成员方法</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">参数1: 方法名称 参数2:方法行参类型的class 对象\n     \npublic Method getMethod(String name,Class&lt;?&gt;... parameterTypes)：\n获取单个的方法 不包含私有的\n\npublic Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)：\n获取单个方法包括私有的  （需要setAccessible(true)）</code></pre>\n\n<h4 id=\"3、获取方法后进行调用\"><a href=\"#3、获取方法后进行调用\" class=\"headerlink\" title=\"3、获取方法后进行调用\"></a>3、获取方法后进行调用</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Object invoke(Object obj, Object... args) \n在具有指定参数的指定对象上调用此 方法对象表示的基础方法</code></pre>\n\n<h4 id=\"4、示例-1\"><a href=\"#4、示例-1\" class=\"headerlink\" title=\"4、示例\"></a>4、示例</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) throws Exception &#123;\n\n        Class&lt;?&gt; c &#x3D; Class.forName(&quot;ClassLoder.Student&quot;);\n        &#x2F;&#x2F;Object o &#x3D; c.newInstance();\n        &#x2F;&#x2F;Class类中的newInstance()方法jdk9后已经过时，选择使用Constructor里的此方法\n        Constructor&lt;?&gt; con &#x3D; c.getConstructor();\n        Object o &#x3D; con.newInstance();\n\n        &#x2F;&#x2F;public Method[] getMethods()：\n        &#x2F;&#x2F;获取所有的公共的成员方法不包含私有的\n        &#x2F;&#x2F;包含从父类继承过来的过来的公共方法\n        Method[] met1 &#x3D; c.getMethods();\n        for (Method met : met1)&#123;\n            System.out.println(met);\n        &#125;\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n\n\n        &#x2F;&#x2F;public Method[] getDeclaredMethods()：\n        &#x2F;&#x2F;获取自己的所有成员方法 包含私有的\n        Method[] dmet1 &#x3D; c.getDeclaredMethods();\n        for (Method demt : dmet1)&#123;\n            System.out.println(demt);\n        &#125;\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n\n\n        &#x2F;&#x2F;参数1: 方法名称 参数2:方法行参的class 对象\n        &#x2F;&#x2F;public Method getMethod(String name,Class&lt;?&gt;... parameterTypes)：\n        &#x2F;&#x2F;获取单个的方法 不包含私有的\n        Method method1 &#x3D; c.getMethod(&quot;method1&quot;, String.class);\n        &#x2F;&#x2F;Object invoke​(Object obj, Object... args)\n        &#x2F;&#x2F;在具有指定参数的指定对象上调用此 方法对象表示的基础方法。\n        method1.invoke(o,&quot;黄任翔真帅！&quot;);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n\n\n        &#x2F;&#x2F;public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)：\n        &#x2F;&#x2F;获取单个方法包括私有的\n        Method function &#x3D; c.getDeclaredMethod(&quot;function&quot;);\n        function.setAccessible(true);\n        function.invoke(o);\n\n    &#125;</code></pre>\n\n<h3 id=\"九、获取泛型父类信息（可选）\"><a href=\"#九、获取泛型父类信息（可选）\" class=\"headerlink\" title=\"九、获取泛型父类信息（可选）\"></a>九、获取泛型父类信息（可选）</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;* Type：\n * （1）Class\n * （2）ParameterizedType   \n * \t\t例如：Father&lt;String,Integer&gt;\n * \t\t\tArrayList&lt;String&gt;\n * （3）TypeVariable\n * \t\t例如：T，U,E,K,V\n * （4）WildcardType\n * \t\t例如：\n * \t\tArrayList&lt;?&gt;\n * \t\tArrayList&lt;? super 下限&gt;\n * \t\tArrayList&lt;? extends 上限&gt;\n * （5）GenericArrayType\n * \t\t例如：T[]\n * \t\n *&#x2F;\npublic class TestGeneric &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t&#x2F;&#x2F;需求：在运行时，获取Son类型的泛型父类的泛型实参&lt;String,Integer&gt;\n\t\t\n\t\t&#x2F;&#x2F;（1）还是先获取Class对象\n\t\tClass clazz &#x3D; Son.class;&#x2F;&#x2F;四种形式任意一种都可以\n\t\t\n\t\t&#x2F;&#x2F;（2）获取泛型父类\n&#x2F;&#x2F;\t\tClass sc &#x3D; clazz.getSuperclass();\n&#x2F;&#x2F;\t\tSystem.out.println(sc);\n\t\t&#x2F;*\n\t\t * getSuperclass()只能得到父类名，无法得到父类的泛型实参列表\n\t\t *&#x2F;\n\t\tType type &#x3D; clazz.getGenericSuperclass();\n\t\t\n\t\t&#x2F;&#x2F; Father&lt;String,Integer&gt;属于ParameterizedType\n\t\tParameterizedType pt &#x3D; (ParameterizedType) type;\n\t\t\n\t\t&#x2F;&#x2F;（3）获取泛型父类的泛型实参列表\n\t\tType[] typeArray &#x3D; pt.getActualTypeArguments();\n\t\tfor (Type type2 : typeArray) &#123;\n\t\t\tSystem.out.println(type2);\n\t\t&#125;\n\t&#125;\n&#125;\n&#x2F;&#x2F;泛型形参：&lt;T,U&gt;\nclass Father&lt;T,U&gt;&#123;\n\t\n&#125;\n&#x2F;&#x2F;泛型实参：&lt;String,Integer&gt;\nclass Son extends Father&lt;String,Integer&gt;&#123;\n\t\n&#125;</code></pre>\n\n<h3 id=\"十、反射忽视泛型检查\"><a href=\"#十、反射忽视泛型检查\" class=\"headerlink\" title=\"十、反射忽视泛型检查\"></a>十、反射忽视泛型检查</h3><h4 id=\"1、概念\"><a href=\"#1、概念\" class=\"headerlink\" title=\"1、概念\"></a>1、概念</h4><p>泛型仅在编译期有效（编译过后泛型擦除），而反射机制是针对运行期的，所以我们可以使用反射越过泛型检查</p>\n<p>具体通俗的来讲：</p>\n<p>若我们通过反射机制调用泛型，就会读取不到相应的类型，只会读取到 Object类型，这就是我们所谓的 泛型擦除机制</p>\n<h4 id=\"2、示例\"><a href=\"#2、示例\" class=\"headerlink\" title=\"2、示例\"></a>2、示例</h4><p>定义一个 规定了内容类型 的 集合，通过反射可以添加 不同于 规定类型的 值</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) throws Exception &#123;\n\n        &#x2F;&#x2F; 规定 集合 内容类型为 Integer 类型（若正常添加，只能添加 Integer类型）\n        ArrayList&lt;Integer&gt; arr &#x3D; new ArrayList&lt;Integer&gt;();\n\n        &#x2F;&#x2F; public boolean add(E e)\n        arr.add(123);\n        arr.add(456);\n        arr.add(789);\n\n        &#x2F;&#x2F; 泛型，只在编译期有效，运行期就擦除了\n        &#x2F;&#x2F; 此时，通过反射获取 集合的 add方法时，可以看到，add方法的形参类型的class对象为 Object.class\n        Class&lt;? extends ArrayList&gt; c &#x3D; arr.getClass();\n        Method met &#x3D; c.getMethod(&quot;add&quot;, Object.class);\n       \n        &#x2F;&#x2F; 调用得到的方法发现，能够添加 String类型的值（综上，就是所谓的泛型擦除机制）\n        met.invoke(arr, &quot;abc&quot;);\n\n        System.out.println(arr);\n&#125;</code></pre>\n\n<h3 id=\"十一、运行配置文件指定内容\"><a href=\"#十一、运行配置文件指定内容\" class=\"headerlink\" title=\"十一、运行配置文件指定内容\"></a>十一、运行配置文件指定内容</h3><h4 id=\"1、概念-1\"><a href=\"#1、概念-1\" class=\"headerlink\" title=\"1、概念\"></a>1、概念</h4><ul>\n<li>Properties类可以将配置文件中的键值对读取出来。</li>\n<li>那么可以通过反射机制，将从配置文件中读取出来的值，赋给类中相应成员：</li>\n<li>如果想在一个测试类中 开始调用Student类中的方法，过会不调用Student了，开始调用Teacher类中的方法，然后再改，进行很多次，这样在测试类中写代码会很麻烦，所以就用到了运行配置文件指定内容，这样的话只需要修改配置文件中的路径名以及方法名就可以了</li>\n</ul>\n<h4 id=\"2、配置文件\"><a href=\"#2、配置文件\" class=\"headerlink\" title=\"2、配置文件\"></a>2、配置文件</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ClassName&#x3D;ClassLoder.Phone\nMethodName&#x3D;music</code></pre>\n\n<h4 id=\"3、示例读取\"><a href=\"#3、示例读取\" class=\"headerlink\" title=\"3、示例读取\"></a>3、示例读取</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package ClassLoder;\n\npublic class Phone &#123;\n\n    public Phone() &#123;\n    &#125;\n\n    public void game() &#123;\n        System.out.println(&quot;正在运行游戏&quot;);\n    &#125;\n\n    public void music() &#123;\n        System.out.println(&quot;正在播放音乐&quot;);\n    &#125;\n\n    public void call() &#123;\n        System.out.println(&quot;正在进行通话&quot;);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) throws Exception &#123;\n\n        &#x2F;&#x2F;加载配置文件\n        &#x2F;&#x2F;基于目标类开发\n        Properties pro &#x3D; new Properties();\n        &#x2F;&#x2F;pro.load(new FileReader(&quot;.&#x2F;hrx.properties&quot;));\n        InputStream is &#x3D; TestDemo4.class.getClassLoader().getResourceAsStream(&quot;hrx.properties&quot;);\n        pro.load(is);\n\n        &#x2F;&#x2F;1.获取该类的字节码文件对象\n        Class&lt;?&gt; cn &#x3D; Class.forName(pro.getProperty(&quot;ClassName&quot;));\n\n        &#x2F;&#x2F;2.通过反射来创建目标类对象\n        Object o &#x3D; cn.getDeclaredConstructor().newInstance();\n\n        &#x2F;&#x2F;3.调用目标类中的方法执行\n        Method methodName &#x3D; cn.getMethod(pro.getProperty(&quot;MethodName&quot;));\n        methodName.invoke(o);\n\n    &#125;</code></pre>\n\n<h3 id=\"十二、JDK的动态代理\"><a href=\"#十二、JDK的动态代理\" class=\"headerlink\" title=\"十二、JDK的动态代理\"></a>十二、JDK的动态代理</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">\n\njdk的动态代理调用了Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 方法。\n通过该方法生成字节码，动态的创建了一个代理类，interfaces参数是该动态类所继承的所有接口，而继承InvocationHandler 接口的类则是实现在调用代理接口方法前后的具体逻辑\n\nnewProxyInstance方法执行了以下几种操作。\n1.生成一个实现了参数interfaces里所有接口且继承了Proxy的代理类的字节码，然后用参数里的classLoader加载这个代理类。\n2.使用代理类父类的构造函数 Proxy(InvocationHandler h)来创造一个代理类的实例，将我们自定义的InvocationHandler的子类传入。\n3.返回这个代理类实例</code></pre>\n\n<h4 id=\"1、什么是代理？\"><a href=\"#1、什么是代理？\" class=\"headerlink\" title=\"1、什么是代理？\"></a>1、什么是代理？</h4><ul>\n<li>代理：代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理</li>\n<li>动态代理：在<strong>程序运行过程中</strong>，<strong>产生这个对象</strong>，其实就是通过反射来生成一个代理。</li>\n</ul>\n<h4 id=\"2、特点及作用\"><a href=\"#2、特点及作用\" class=\"headerlink\" title=\"2、特点及作用\"></a>2、特点及作用</h4><ul>\n<li>字节码随用随创建，随用随加载</li>\n<li>在不修改源码的基础上对方法进行增强</li>\n</ul>\n<h4 id=\"4、分类\"><a href=\"#4、分类\" class=\"headerlink\" title=\"4、分类\"></a>4、分类</h4><ul>\n<li>基于<strong>接口</strong>的动态代理 —— Proxy代理模式</li>\n<li>基于<strong>子类</strong>的动态代理 —— CGLib代理模式</li>\n</ul>\n<p>注意：JDK给我们提供的动态代理,只能对接口进行代理（即：Proxy代理模式）</p>\n<h4 id=\"5、Proxy代理模式\"><a href=\"#5、Proxy代理模式\" class=\"headerlink\" title=\"5、Proxy代理模式\"></a>5、Proxy代理模式</h4><ul>\n<li>如何创建代理对象：调用Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 方法。</li>\n<li><strong>参数</strong>：<ul>\n<li>loader: 类加载器</li>\n<li>interfaces: 接口对应的一个Class数组</li>\n<li>InvocationHandler: 这个其实就是要代理对象所做的事情的一个类的封装</li>\n</ul>\n</li>\n<li>创建代理对象的前提：目标对象必须要有父接口，也就是说被代理类至少实现一个接口。</li>\n</ul>\n<ul>\n<li>newProxyInstance方法执行了以下几种操作。<br>1、生成一个实现了参数interfaces里所有接口且继承了Proxy的代理类的字节码，然后用参数里的classLoader加载这个代理类。<br>2、使用代理类父类的构造函数 Proxy(InvocationHandler h)来创造一个代理类的实例，将我们自定义的InvocationHandler的子类传入。<br>3、返回这个代理类实例</li>\n<li>而这个方法，最终会调用<strong>InvocationHandler接口</strong>的方法：<br>InvocationHandler Object invoke(Object proxy,Method method,Object[] args)<br><strong>作用</strong>：执行被代理对象的任何接口方法都会经过该方法</li>\n<li><strong>参数</strong>：proxy：代理对象的引用，method：当前执行的方法，args：当前执行方法所需的参数   返回值：和被代理对象方法有相同的返回值*</li>\n</ul>\n<h4 id=\"6、两种代理模式区别\"><a href=\"#6、两种代理模式区别\" class=\"headerlink\" title=\"6、两种代理模式区别\"></a>6、两种代理模式区别</h4><ul>\n<li>Proxy代理模式:<br>产生的代理对象，其类型是<strong>目标接口</strong>的<strong>派生类类型</strong>对象<br>代理对象只能调用<strong>接口中的方法</strong><br>(可以理解为：<strong>被代理对象</strong>的 <strong>兄弟对象</strong>)</li>\n<li>CGLib代理模式：<br>产生的代理对象，是 <strong>被代理类</strong>的<strong>子类</strong>对象<br>代理对象可以调用 <strong>被代理类</strong> 中 <strong>除了final修饰</strong> 的其它 <strong>所有方法</strong><br>(可以理解为：<strong>被代理对象</strong>的 <strong>子对象</strong>)</li>\n</ul>\n","text":"一、类加载– 概述：类在内存中的生命周期：加载–&gt;使用–&gt;卸载 1、类的加载过程当程序主动使用某个类时，如果该类还未被加载到内存中，系统会通过加载、连接、初始化三个步骤来对该类进行初始化，如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载。...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/tags/JavaSE.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">一、类加载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">1、类的加载过程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">2、类初始化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8\"><span class=\"toc-text\">3、类加载器</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">二、Java反射机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1、概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96class%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">2、哪些类型可以获取class对象</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E8%8E%B7%E5%8F%96Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">三、获取Class对象的四种方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">四、获取类型的详细信息</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E5%88%9B%E5%BB%BA%E4%BB%BB%E6%84%8F%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">五、创建任意引用类型的对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">1、两种方式：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%96%B9%E5%BC%8F%E4%B8%80%E7%9A%84%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">2、方式一的步骤</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%96%B9%E5%BC%8F%E4%BA%8C%E7%9A%84%E6%AD%A5%E9%AA%A4%EF%BC%9A\"><span class=\"toc-text\">3、方式二的步骤：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">六、通过反射获取构造方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E8%8E%B7%E5%8F%96%E5%A4%9A%E4%B8%AA%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1、获取多个构造方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E4%B8%AA%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2、获取单个构造方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%B3%A8%E6%84%8F\"><span class=\"toc-text\">3、注意</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81setAccessible-boolean-flag\"><span class=\"toc-text\">4、setAccessible(boolean flag)</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%83%E3%80%81%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">七、通过反射获取成员变量</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E8%8E%B7%E5%8F%96%E5%A4%9A%E4%B8%AA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">1、获取多个成员变量</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E4%B8%AA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">2、获取单个成员变量</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E8%8E%B7%E5%8F%96%E5%90%8E%E5%8F%AF%E8%BF%9B%E8%A1%8C%E5%80%BC%E7%9A%84%E8%AE%BE%E7%BD%AE\"><span class=\"toc-text\">3、获取后可进行值的设置</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">4、示例</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AB%E3%80%81%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">八、通过反射获取成员方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E8%8E%B7%E5%8F%96%E5%A4%9A%E4%B8%AA%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1、获取多个成员方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E4%B8%AA%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2、获取单个成员方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E5%90%8E%E8%BF%9B%E8%A1%8C%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">3、获取方法后进行调用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E7%A4%BA%E4%BE%8B-1\"><span class=\"toc-text\">4、示例</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B9%9D%E3%80%81%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E7%88%B6%E7%B1%BB%E4%BF%A1%E6%81%AF%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89\"><span class=\"toc-text\">九、获取泛型父类信息（可选）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%81%E3%80%81%E5%8F%8D%E5%B0%84%E5%BF%BD%E8%A7%86%E6%B3%9B%E5%9E%8B%E6%A3%80%E6%9F%A5\"><span class=\"toc-text\">十、反射忽视泛型检查</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1、概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">2、示例</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%B8%80%E3%80%81%E8%BF%90%E8%A1%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%AE%9A%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">十一、运行配置文件指定内容</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%A6%82%E5%BF%B5-1\"><span class=\"toc-text\">1、概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">2、配置文件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E7%A4%BA%E4%BE%8B%E8%AF%BB%E5%8F%96\"><span class=\"toc-text\">3、示例读取</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%BA%8C%E3%80%81JDK%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">十二、JDK的动态代理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%A3%E7%90%86%EF%BC%9F\"><span class=\"toc-text\">1、什么是代理？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E7%89%B9%E7%82%B9%E5%8F%8A%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">2、特点及作用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">4、分类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%E3%80%81Proxy%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">5、Proxy代理模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6%E3%80%81%E4%B8%A4%E7%A7%8D%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">6、两种代理模式区别</span></a></li></ol></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"Mysql 基础语句","uid":"68a57833ae44293764c3ebaf716fccf1","slug":"19-MySql基础语句","date":"2021-09-13T14:54:32.000Z","updated":"2021-09-15T10:18:45.633Z","comments":true,"path":"api/articles/19-MySql基础语句.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"一、数据库的操作1、创建数据库普通创建 create database db_sql； 带字符集创建 create database db_sql character set utf8； 2、查询数据库查看数据库字符编码 show variables like &#39;%cha...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"MySql","slug":"MySql","count":3,"path":"api/categories/MySql.json"}],"tags":[{"name":"MySql","slug":"MySql","count":3,"path":"api/tags/MySql.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"Lambda 表达式","uid":"c7c150790ff577b4efb11f92f9e10f6d","slug":"17-Lambda","date":"2021-09-13T14:52:32.000Z","updated":"2021-09-15T10:17:28.153Z","comments":true,"path":"api/articles/17-Lambda.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"一、函数式编程思想在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。编程中的函数，也有类似的概念，你调用我的时候，给我实参为形参赋值，然后通过运行方法体，给你返回一个结果。对于调用者来做，关注这个方法具备什么样的功能。相对而言，面向对象过分强调“必...","link":"","photos":[],"count_time":{"symbolsCount":"9.6k","symbolsTime":"9 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/tags/JavaSE.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}