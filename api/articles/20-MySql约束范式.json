{"title":"Mysql 约束范式","uid":"0aff3f9d6ddb049036e17692cfc8cc4a","slug":"20-MySql约束范式","date":"2021-09-13T14:55:32.000Z","updated":"2021-09-15T10:19:07.031Z","comments":true,"path":"api/articles/20-MySql约束范式.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","content":"<h3 id=\"一、约束（Constraint）\"><a href=\"#一、约束（Constraint）\" class=\"headerlink\" title=\"一、约束（Constraint）\"></a>一、约束（Constraint）</h3><h4 id=\"1、主要内容\"><a href=\"#1、主要内容\" class=\"headerlink\" title=\"1、主要内容\"></a>1、主要内容</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">1. 非空约束\n2. 自增约束\n3. 主键约束\n4. 唯一键约束\n5. 默认值约束\n6. 外键约束\n7. 检查约束</code></pre>\n\n<h4 id=\"2-、查看某个表的约束\"><a href=\"#2-、查看某个表的约束\" class=\"headerlink\" title=\"2.、查看某个表的约束\"></a>2.、查看某个表的约束</h4><pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">SELECT * FROM information_schema.table_constraints WHERE table_name &#x3D; &#39;表名称&#39;;\n或\nSHOW CREATE TABLE 表名;</code></pre>\n\n<h4 id=\"3-、查看某个表的索引\"><a href=\"#3-、查看某个表的索引\" class=\"headerlink\" title=\"3.、查看某个表的索引\"></a>3.、查看某个表的索引</h4><pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">SHOW INDEX FROM 表名称;</code></pre>\n\n<h4 id=\"4、主键约束：primary-key\"><a href=\"#4、主键约束：primary-key\" class=\"headerlink\" title=\"4、主键约束：primary key\"></a>4、主键约束：primary key</h4><p>主键分为单列主键和复合主键：</p>\n<p><img src=\"https://gitee.com/xiuxiuai/picture/raw/master/img/%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F.png\" alt=\"1561002222421\"></p>\n<p>主键的特点：（1）唯一并且非空（2）一个表只能有一个主键约束（3）主键约束名就叫做PRIMARY（4）创建主键会自动创建对应的索引，同样删除主键对应的索引也会删除。</p>\n<p>（1）如何在建表时指定主键约束</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">create table [数据名.]表名(\n\t字段名1 数据类型  primary key ,\n\t....\n);\n或\ncreate table [数据名.]表名(\n\t字段名1 数据类型,\n\t....,\n    primary key(字段名1)\n);\n或\ncreate table [数据名.]表名(\n    字段名1 数据类型,\n    字段名2 数据类型,\n\t....,\n    primary key(复合主键字段列表)#如果是复合主键，那么就需要在所有字段列表后面使用这种形式指定，不能在字段后面直接加primary key\n);</code></pre>\n\n<p>（2）如何在建表后指定主键约束</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">alter table 表名称 add primary key (主键字段列表);</code></pre>\n\n<p>（3）如何删除主键约束</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">alter table 表名称 drop primary key;</code></pre>\n\n<h4 id=\"5、唯一键约束：unique-key\"><a href=\"#5、唯一键约束：unique-key\" class=\"headerlink\" title=\"5、唯一键约束：unique key\"></a>5、唯一键约束：unique key</h4><p>（1）唯一键约束特点</p>\n<ul>\n<li><p>唯一键约束列允许为null。</p>\n</li>\n<li><p>同一个表可以有多个唯一约束。</p>\n</li>\n<li><p>唯一约束可以是某一个列的值唯一，也可以多个列组合值的唯一。</p>\n</li>\n<li><p>MySQL会给唯一约束的列上默认创建一个唯一索引。</p>\n</li>\n</ul>\n<ul>\n<li>删除唯一键只能通过删除对应索引的方式删除，删除时需要指定唯一键索引名</li>\n</ul>\n<p>（2）如何在建表时指定唯一键约束</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">create table [数据名.]表名(\n\t字段名1 数据类型  primary key ,\n\t字段名2 数据类型 unique key,\n\t....\n);\n\ncreate table [数据名.]表名(\n    字段名1 数据类型  primary key ,\n    字段名2 数据类型,\n    字段名3 数据类型,\n\t....,\n    unique key(复合唯一字段列表)#如果是复合唯一键，那么就需要在所有字段列表后面使用这种形式指定，不能在字段后面直接加unique key\n);</code></pre>\n\n<p>（3）如何在建表后增加唯一键约束</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">alter table 表名称 add [constraint 约束名] unique [key] (字段名列表);\n#如果没有指定约束名，(字段名列表)中只有一个字段的，默认是该字段名，如果是多个字段的默认是字段名列表的第1个字段名。也可以通过show index from 表名;来查看</code></pre>\n\n<p>（4）如何删除唯一键约束</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">ALTER TABLE 表名称 DROP INDEX 唯一性约束名;\n#注意：如果忘记名称，可以通过“show index from 表名称;”查看</code></pre>\n\n<h4 id=\"6、外键约束：foreign-key\"><a href=\"#6、外键约束：foreign-key\" class=\"headerlink\" title=\"6、外键约束：foreign key\"></a>6、外键约束：foreign key</h4><p>（1）外键特点</p>\n<ul>\n<li><p>外键约束是保证一个或两个表之间的参照完整性,外键是构建于一个表的两个字段或是两个表的两个字段之间的参照关系。</p>\n</li>\n<li><p>在创建外键约束时，如果不给外键约束名称，默认名不是列名，而是自动产生一个外键名（例如 student_ibfk_1;），也可以指定外键约束名。</p>\n</li>\n<li><p>当创建外键约束时，系统默认会在所在的列上建立对应的普通索引。但是索引名是列名，不是外键的约束名。</p>\n</li>\n<li><p>删除外键时，关于外键列上的普通索引需要单独删除。</p>\n</li>\n</ul>\n<p>（2）要求</p>\n<ul>\n<li><p>在从表上建立外键，而且主表要先存在。</p>\n</li>\n<li><p>一个表可以建立多个外键约束</p>\n</li>\n<li><p>从表的外键列，在主表中引用的只能是键列（主键，唯一键，外键），推荐引用主表的主键。</p>\n</li>\n<li><p>从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样</p>\n</li>\n</ul>\n<p>（3）约束关系：约束是针对双方的</p>\n<ul>\n<li><p>添加了外键约束后，主表的修改和删除数据受约束</p>\n</li>\n<li><p>添加了外键约束后，从表的添加和修改数据受约束</p>\n</li>\n<li><p>在从表上建立外键，要求主表必须存在</p>\n</li>\n<li><p>删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除</p>\n</li>\n</ul>\n<p>（4）5个约束等级</p>\n<ul>\n<li><p>Cascade方式：在父表上update/delete记录时，同步update/delete掉子表的匹配记录 </p>\n</li>\n<li><p>Set null方式：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列是否设置了不允许为null  </p>\n</li>\n<li><p>No action方式：如果子表中有匹配的记录,则不允许对父表对应候选键进行update/delete操作  </p>\n</li>\n<li><p>Restrict方式：同no action, 都是立即检查外键约束</p>\n</li>\n<li><p>Set default方式（在可视化工具SQLyog中可能显示空白）：父表有变更时,子表将外键列设置成一个默认的值，但Innodb不能识别</p>\n</li>\n</ul>\n<p>如果没有指定等级，就相当于Restrict方式</p>\n<p>（5）如何在建表时指定外键约束</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">create table [数据名.]从表名(\n\t字段名1 数据类型  primary key ,\n\t字段名2 数据类型 [unique key],\n\t....,\n    [constraint 外键约束名] foreign key (从表字段) references 主表名(主表字段) [on update 外键约束等级][on delete 外键约束等级[\n    #外键只能在所有字段列表后面单独指定\n    #如果要自己命名外键约束名，建议 主表名_从表名_关联字段名_fk\n);\n\ncreate table [数据名.]表名(\n    字段名1 数据类型,\n    字段名2 数据类型,\n\t....,\n    primary key(复合主键字段列表),#如果是复合主键，那么就需要在所有字段列表后面使用这种形式指定，不能在字段后面直接加primary key\n    unique key(复合唯一字段列表),#如果是复合唯一键，那么就需要在所有字段列表后面使用这种形式指定，不能在字段后面直接加unique key\n    foreign key (从表字段) references 主表名(主表字段) [on update 外键约束等级][on delete 外键约束等级[\n    #外键只能在所有字段列表后面单独指定\n);</code></pre>\n\n<p>（6）如何在建表后指定外键约束</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">alter table 从表名称 add [constraint 外键约束名] foreign key (从表字段名) references 主表名(主表被参照字段名) [on update xx][on delete xx];</code></pre>\n\n<p>（7）如何删除外键约束</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">ALTER TABLE 表名称 DROP FOREIGN KEY 外键约束名;\n#查看约束名 SELECT * FROM information_schema.table_constraints WHERE table_name &#x3D; &#39;表名称&#39;;\n#删除外键约束不会删除对应的索引，如果需要删除索引，需要用ALTER TABLE 表名称 DROP INDEX 索引名;\n#查看索引名 show index from 表名称;</code></pre>\n\n<h4 id=\"7、非空约束：not-null\"><a href=\"#7、非空约束：not-null\" class=\"headerlink\" title=\"7、非空约束：not null\"></a>7、非空约束：not null</h4><p>NOT NULL 非空约束，规定某个字段不能为空</p>\n<p>（1）如何在建表时给某个字段指定非空约束</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">create table [数据名.]表名(\n\t字段名1 数据类型  primary key ,\n\t字段名2 数据类型 [unique key] [not null],\n\t....,\n    foreign key (从表字段) references 主表名(主表字段) [on update 外键约束等级][on delete 外键约束等级[\n    #外键只能在所有字段列表后面单独指定\n);\n\ncreate table [数据名.]表名(\n    字段名1 数据类型 [not null],\n    字段名2 数据类型 [not null],\n\t....,\n    primary key(复合主键字段列表),#如果是复合主键，那么就需要在所有字段列表后面使用这种形式指定，不能在字段后面直接加primary key\n    unique key(复合唯一字段列表),#如果是复合唯一键，那么就需要在所有字段列表后面使用这种形式指定，不能在字段后面直接加unique key\n    foreign key (从表字段) references 主表名(主表字段) [on update 外键约束等级][on delete 外键约束等级[\n    #外键只能在所有字段列表后面单独指定\n);</code></pre>\n\n<p>（2）如何在建表后指定某个字段非空</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">ALTER TABLE 表名称 MODIFY 字段名 数据类型 NOT NULL [default 默认值];\n#如果该字段原来设置了默认值约束，要跟着一起再写一遍，否则默认值约束会丢失</code></pre>\n\n<p>（3）如何在建表后取消某个字段非空</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">ALTER TABLE 表名称 MODIFY 字段名 数据类型 [default 默认值];\n#如果该字段原来设置了默认值约束，要跟着一起再写一遍，否则默认值约束会丢失</code></pre>\n\n<h4 id=\"8、默认值约束：default\"><a href=\"#8、默认值约束：default\" class=\"headerlink\" title=\"8、默认值约束：default\"></a>8、默认值约束：default</h4><p>（1）如何在建表时给某个字段指定默认约束</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">create table [数据名.]表名(\n\t字段名1 数据类型  primary key ,\n\t字段名2 数据类型 [unique key] [not null] [default 默认值],\n\t....,\n    foreign key (从表字段) references 主表名(主表字段) [on update 外键约束等级][on delete 外键约束等级[\n    #外键只能在所有字段列表后面单独指定\n);\n\ncreate table [数据名.]表名(\n    字段名1 数据类型 [not null] [default 默认值],\n    字段名2 数据类型 [not null] [default 默认值],\n\t....,\n    primary key(复合主键字段列表),#如果是复合主键，那么就需要在所有字段列表后面使用这种形式指定，不能在字段后面直接加primary key\n    unique key(复合唯一字段列表),#如果是复合唯一键，那么就需要在所有字段列表后面使用这种形式指定，不能在字段后面直接加unique key\n    foreign key (从表字段) references 主表名(主表字段) [on update 外键约束等级][on delete 外键约束等级[\n    #外键只能在所有字段列表后面单独指定\n);</code></pre>\n\n<p>（2）如何在建表后指定某个字段的默认值约束</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">ALTER TABLE 表名称 MODIFY 字段名 数据类型  [default 默认值] [NOT NULL];\n#如果该字段原来设置了非空约束，要跟着一起再写一遍，否则非空约束会丢失</code></pre>\n\n<p>（3）如何在建表后取消某个字段的默认值约束</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">ALTER TABLE 表名称 MODIFY 字段名 数据类型 [NOT NULL];\n#如果该字段原来设置了非空约束，要跟着一起再写一遍，否则非空约束会丢失</code></pre>\n\n<h4 id=\"9、检查约束：check\"><a href=\"#9、检查约束：check\" class=\"headerlink\" title=\"9、检查约束：check\"></a>9、检查约束：check</h4><p>检查约束，mysql暂不支持</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">create table stu(\n\tsid int primary key,\n\tsname varchar(20),\n\tgender char check (&#39;男&#39;or&#39;女&#39;)\n);\ninsert into stu values(1,&#39;张三&#39;,&#39;男&#39;);\ninsert into stu values(2,&#39;李四&#39;,&#39;妖&#39;);\n\n使用枚举类型解决如上问题：\ncreate table stu(\n\tsid int primary key,\n\tsname varchar(20),\n\tgender enum (&#39;男&#39;,&#39;女&#39;)\n);</code></pre>\n\n<h4 id=\"10、自增约束：auto-increment\"><a href=\"#10、自增约束：auto-increment\" class=\"headerlink\" title=\"10、自增约束：auto_increment\"></a>10、自增约束：auto_increment</h4><p>（1）关于自增长auto_increment：</p>\n<ul>\n<li>一个表最多只能有一个自增长列</li>\n<li>自增长列必须是键列（主键列，唯一键列，外键列），并且要求非空。</li>\n<li>自增列必须是整数类型</li>\n<li>InnoDB表的自动增长列可以手动插入，但是插入的值如果是空或者0，则实际插入的将是自动增长后的值。</li>\n</ul>\n<p>（2）如何在建表时指定自增长列</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">create table [数据名.]表名(\n\t字段名1 数据类型  primary key auto_increment,\n\t字段名2 数据类型 [unique key] [not null] [default 默认值],\n\t....\n);\n\n或\ncreate table [数据名.]表名(\n\t字段名1 数据类型  primary key ,\n\t字段名2 数据类型 [unique key  not null] auto_increment,\n\t....\n);</code></pre>\n\n<p>（3）如何在建表后指定自增长列</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">alter table [数据名.]表名 modify 自增字段名 数据类型 auto_increment;</code></pre>\n\n<p>（4）如何删除自增约束</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">alter table [数据名.]表名 modify 自增字段名 数据类型;</code></pre>\n\n<h4 id=\"11、DML-v2-0\"><a href=\"#11、DML-v2-0\" class=\"headerlink\" title=\"11、DML(v2.0)\"></a>11、DML(v2.0)</h4><p>1、如果某列有自增约束，怎么添加该字段的值</p>\n<p>添加数据时，对于自增列</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">insert into [数据库名.]表名称 values(值列表)；#在值列表中，对应自增列可以赋值为null和0\n\ninsert into [数据库名.]表名称(部分字段列表) values(值列表)；#自增列在(部分字段列表)中不写就可以</code></pre>\n\n<p>2、如果某列有默认值约束，怎么添加、修改该字段的值</p>\n<p>添加数据时，对于有默认值列</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">insert into [数据库名.]表名称 values(值列表)；#在值列表中，对应默认值列，如果想用默认值，用default\n\ninsert into [数据库名.]表名称(部分字段列表) values(值列表)；#对应默认值列，如果想用默认值，在(部分字段列表)中不写就可以</code></pre>\n\n<p>修改数据</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">update [数据库名.]表名称 set 字段名1 &#x3D; 值1, 字段名2 &#x3D; 值2 。。。 [where 条件]; #对应默认值列，如果想用默认值，写字段名 &#x3D; default就可以</code></pre>\n\n<h3 id=\"二、数据库的设计\"><a href=\"#二、数据库的设计\" class=\"headerlink\" title=\"二、数据库的设计\"></a>二、数据库的设计</h3><h4 id=\"1、表间的关系\"><a href=\"#1、表间的关系\" class=\"headerlink\" title=\"1、表间的关系\"></a>1、表间的关系</h4><ul>\n<li>一对一（了解）<ul>\n<li>如：身份证和人</li>\n<li>分析：一个人只能有一个身份证，一个身份证只能对应一个人</li>\n</ul>\n</li>\n<li>一对多（多对一）<ul>\n<li>如：部门和员工</li>\n<li>分析：一个部门有很多员工，一个员工只能对应一个部门</li>\n</ul>\n</li>\n<li>多对多<ul>\n<li>如：学生和课程</li>\n<li>分析：一个学生可惜选修多门课程，一个课程也有很多学生</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2、实现方式\"><a href=\"#2、实现方式\" class=\"headerlink\" title=\"2、实现方式\"></a>2、实现方式</h4><ul>\n<li>一对一<ul>\n<li>主键共享，其中一张表中的主键，既是主键又是外键，外键参考的是一对一的另外一张表的主键</li>\n<li>外键唯一：也可以在任意一方添加外键，然后让外键唯一，即添加约束-unique</li>\n</ul>\n</li>\n<li>一对多（多对一）<ul>\n<li>实现：在多的一方建立外键，指向一的一方的主键</li>\n</ul>\n</li>\n<li>多对多<ul>\n<li>多对多关系实现需要借助第三张中间表</li>\n<li><strong>中间表至少含有两个字段</strong>，这两个字段作为第三张表的外键，<strong>分别指向两个表的主键</strong></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3、数据库三大设计范式\"><a href=\"#3、数据库三大设计范式\" class=\"headerlink\" title=\"3、数据库三大设计范式\"></a>3、<strong>数据库三大设计<a href=\"%5Bhttps://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/7309898?fr=aladdin%5D(https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/7309898?fr=aladdin)\">范式</a></strong></h4><ol>\n<li><p>概念：设计关系<a href=\"https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93\">数据库</a>时，遵从不同的规范<a href=\"https://baike.baidu.com/item/%E8%A6%81%E6%B1%82/3598753\">要求</a>，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。</p>\n</li>\n<li><p>目前<a href=\"https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/1237340\">关系数据库</a>有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、<a href=\"https://baike.baidu.com/item/%E7%AC%AC%E5%9B%9B%E8%8C%83%E5%BC%8F/3193985\">第四范式</a>(4NF）和<a href=\"https://baike.baidu.com/item/%E7%AC%AC%E4%BA%94%E8%8C%83%E5%BC%8F/5025271\">第五范式</a>（5NF，又称完美范式）。</p>\n</li>\n<li><p><strong>主要学习</strong>：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）</p>\n</li>\n<li><p>基础知识：</p>\n<ul>\n<li>码：表中可以唯一确定一个元组的某个属性（或者属性组），如果这样的码有不止一个，那么大家都叫候选码，我们从候选码中挑一个出来做老大，它就叫主码。</li>\n<li>元组：表中的一行就是一个元组</li>\n<li>非主属性：与上面相反，没有在任何候选码中出现过，这个属性就是非主属性。</li>\n<li>外码：一个属性（或属性组），它不是码，但是它别的表的码，它就是外码。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"4、第一范式（1NF）\"><a href=\"#4、第一范式（1NF）\" class=\"headerlink\" title=\"4、第一范式（1NF）\"></a>4、第一范式（1NF）</h4><ul>\n<li><p>概念：数据库表的每一列都是不可分割的原子数据项</p>\n</li>\n<li><p>范例：</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">学号\t姓名\t系名\t\t 系主任 课程名\t分数\n10010\thh\t经济\t\t张三丰\t数学\t    100\n10010\thh\t经济\t\t张三丰\t计算机\t    98\n10010\thh\t经济\t\t张三丰\t英语\t     99\n10011\tgg\t法律\t\t任我行\t法理\t     58\n10011\tgg\t法律\t\t任我行\t法律社会    35\n10012\tff\t法律\t\t任我行\t法理\t     12\n10012\tff\t法律\t\t任我行\t英语 \t     38\n\t\t    计算机系   殷天正\t\t\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n存在问题：\n1.存在非常严重的冗余(重复): 姓名，系名，系主任\n2.数据添加问题：如果现实中添加了一个新的系，殷天正为系主任，但是因为没有招生，所以没有学生\n\t\t\t 由上表可知，这在数据库中是无法添加的，数据不合法\n3.数据删除问题：如果现实中hh毕业了，那他的数据就可以删除了，但是随着他的删除，系名，系主任也被删除了\n\t\t\t 这显然也是不合法的\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</code></pre></li>\n</ul>\n<h4 id=\"5、第二范式（2NF）\"><a href=\"#5、第二范式（2NF）\" class=\"headerlink\" title=\"5、第二范式（2NF）\"></a>5、第二范式（2NF）</h4><ul>\n<li><p>概念：第二范式依赖第一范式，所以第二范式必须符合第一范式，然后 每个非主属性完全依赖于主键，而不是仅依赖于其中一部分属性（除主键外的每一列都必须和主键相关），而不能只和主键的某一部分相关（只可能发生在联合主键的情况下）</p>\n</li>\n<li><p>解决了第一个问题，消除了严重的冗余</p>\n<p><img src=\"https://gitee.com/CharonXiu/tuku/raw/master/%E5%9B%BE%E5%BA%93/20190319235848803.png\" alt=\"img\"></p>\n<p>图片来源：<a href=\"https://blog.csdn.net/weixin_43971764\">Spr Chan</a></p>\n</li>\n</ul>\n<h4 id=\"6、第三范式（3NF）\"><a href=\"#6、第三范式（3NF）\" class=\"headerlink\" title=\"6、第三范式（3NF）\"></a>6、第三范式（3NF）</h4><ul>\n<li><p>概念：必须先满足第二范式，除开主键的其他列之间不能有传递依赖关系，目标是确保每列都和主键直接相关，而不是间接相关</p>\n</li>\n<li><p>传递依赖：非主键列m既依赖于全部主键，又依赖于非主键列n的情况。</p>\n</li>\n<li><p>解决了增加，删除的问题，因为遵循了三大范式，所以上述三个问题完全解决</p>\n</li>\n<li><p>假设存在关系模式<code>主键1: 课程编号; 列1: 教师名; 列2: 教师家庭地址</code>。显然满足第一范式和第二范式，但是<code>教师家庭地址</code>传递依赖于<code>教师名</code>，所以不满足第三范式。</p>\n</li>\n</ul>\n<h3 id=\"三、事务\"><a href=\"#三、事务\" class=\"headerlink\" title=\"三、事务\"></a>三、事务</h3><h4 id=\"1、概述\"><a href=\"#1、概述\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h4><p> mysql中，事务其实是最小的不可分割的工作单元，事务能保证一个业务的完整性，是构成单一逻辑工作单元的操作集和</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">比如我们的银行转账\n\na -&gt; -100\nupdate user set money&#x3D;money-100 where name&#x3D;&#39;a&#39;;\n\nb -&gt; +100\nupdate user set money&#x3D;money+100 where name&#x3D;&#39;b&#39;;\n\n实际的程序中，如果只有一条语句执行成功了，而另外一条没执行成功就会出现数据前后不一致\n\nupdate user set money&#x3D;money-100 where name&#x3D;&#39;a&#39;;\nupdate user set money&#x3D;money+100 where name&#x3D;&#39;b&#39;;\n\n事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行</code></pre>\n\n<p>事务处理</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)到最初状态。</code></pre>\n\n<h4 id=\"2、事务四大特征（ACID）\"><a href=\"#2、事务四大特征（ACID）\" class=\"headerlink\" title=\"2、事务四大特征（ACID）\"></a>2、事务四大特征（ACID）</h4><ul>\n<li><p><strong>原子性：</strong>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">事务是最小的单位，不可以分割，同一事务中的 sql 语句必须保证同时成功或者同时失败</code></pre></li>\n<li><p><strong>一致性：</strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">事务必须使得数据库从一个一致性状态转变到另一个一致性状态。比如银行转账，A账户转到B账户，不管转几次，A和B账户的总额不能变。</code></pre></li>\n<li><p><strong>隔离性：</strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</code></pre></li>\n<li><p><strong>持久性：</strong>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">数据库数据存放到硬盘中，并有redo log 和 binlog 一起保证的。</code></pre></li>\n</ul>\n<h4 id=\"3、事务基本语句\"><a href=\"#3、事务基本语句\" class=\"headerlink\" title=\"3、事务基本语句\"></a>3、事务基本语句</h4><ul>\n<li><p><strong>如果 不开启事务，mysql会自动提交事务的</strong></p>\n</li>\n<li><p>修改默认提交：set  autocommit = 0；（等于1代表自动提交，0为手动）set autocommit=false;（接下来都要手动提交） </p>\n<p>begin；   |     start transaction；</p>\n</li>\n<li><p>手动提交：commit；使已对数据库进行的所有修改成为永久性的</p>\n</li>\n<li><p>手动回滚：rollback；回滚会结束用户的事务，并撤销正在进行的所有未提交的修改</p>\n</li>\n<li><p>如何查看数据库的隔离级别（下方详解）</p>\n</li>\n<li><p>如何修改隔离级别（下方详解）</p>\n</li>\n</ul>\n<h4 id=\"4、故障\"><a href=\"#4、故障\" class=\"headerlink\" title=\"4、故障\"></a>4、故障</h4><ul>\n<li><p>在事务的ACID特性中,C即一致性是事务的根本追求,而对数据一致性的破坏主要来自两个方面</p>\n<p>1.事务的并发执行</p>\n<p>2.事务故障或系统故障</p>\n<p>数据库系统是通过并发控制技术和日志恢复技术来避免这种情况发生的。</p>\n</li>\n<li><p><strong>并发控制</strong>技术保证了事务的隔离性,使数据库的一致性状态不会因为并发执行的操作被破坏。<br><strong>日志恢复</strong>技术保证了事务的原子性,使一致性状态不会因事务或系统故障被破坏。同时使已</p>\n<p>提交的对数据库的修改不会因系统崩溃而丢失,保证了事务的持久性。</p>\n</li>\n</ul>\n<h3 id=\"四、事务之隔离性\"><a href=\"#四、事务之隔离性\" class=\"headerlink\" title=\"四、事务之隔离性\"></a>四、事务之隔离性</h3><h4 id=\"1、概述-1\"><a href=\"#1、概述-1\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h4><p>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</p>\n<h4 id=\"2、并发操作存在问题\"><a href=\"#2、并发操作存在问题\" class=\"headerlink\" title=\"2、并发操作存在问题\"></a>2、并发操作存在问题</h4><ul>\n<li><p>脏读：一个事务读取到另外一个事务没有提交的数据</p>\n</li>\n<li><p>不可重复读（虚读）：在同一个事务中，两次读取到的数据不一样</p>\n</li>\n<li><p>幻读：一个事务操做（DML）数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的的修改</p>\n<p>​           即：事务在插入已经检查过不存在的记录时，发现这些数据已经存在了</p>\n</li>\n</ul>\n<h4 id=\"3、四大隔离级别\"><a href=\"#3、四大隔离级别\" class=\"headerlink\" title=\"3、四大隔离级别\"></a>3、四大隔离级别</h4><p><strong>数据库事务的隔离性</strong>：数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p>\n<p><strong>一个事务与其他事务隔离的程度称为隔离级别。</strong>数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, <strong>隔离级别越高, 数据一致性（安全性）就越好, 但并发性越弱。</strong></p>\n<p>数据库提供的 4 种事务隔离级别：</p>\n<table>\n<thead>\n<tr>\n<th>隔离级别</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>read-uncommitted</td>\n<td>允许A事务读取其他事务未提交和已提交的数据。会出现脏读、不可重复读、幻读问题</td>\n</tr>\n<tr>\n<td>read-committed</td>\n<td>只允许A事务读取其他事务已提交的数据。可以避免脏读，但仍然会出现不可重复读、幻读问题</td>\n</tr>\n<tr>\n<td>repeatable-read</td>\n<td>确保事务可以多次从一个字段中读取相同的值。在这个事务持续期间，禁止其他事务对这个字段进行更新。可以避免脏读和不可重复读。但是幻读问题仍然存在。注意：mysql中使用了MVCC多版本控制技术，在这个级别也可以避免幻读。</td>\n</tr>\n<tr>\n<td>serializable</td>\n<td>确保事务可以从一个表中读取相同的行，相同的记录。在这个事务持续期间，禁止其他事务对该表执行插入、更新、删除操作。所有并发问题都可以避免，但性能十分低下。</td>\n</tr>\n</tbody></table>\n<ul>\n<li>Oracle 支持的 2 种事务隔离级别：<strong>READ-COMMITED</strong>, SERIALIZABLE。 Oracle 默认的事务隔离级别为: READ COMMITED 。</li>\n<li>Mysql 支持 4 种事务隔离级别。 Mysql 默认的事务隔离级别为: <strong>REPEATABLE-READ</strong>。在mysql中REPEATABLE READ的隔离级别也可以避免幻读了。</li>\n</ul>\n<h4 id=\"4、隔离级别的查看-设置\"><a href=\"#4、隔离级别的查看-设置\" class=\"headerlink\" title=\"4、隔离级别的查看 | 设置\"></a>4、隔离级别的查看 | 设置</h4><ul>\n<li><p>查看隔离级别</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">mysql 8.0\n——系统级别\nselect @@global.transaction_isolation;\n——会话级别\nselect @@transaction_isolation;\n\nmysql 5.x\n——系统级别\nselect @@global.tx_isolation;\n——会话级别\nselect @@tx_isolation;</code></pre></li>\n<li><p>设置当前 mysql连接的隔离级别:  </p>\n</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">set tx_isolation &#x3D;&#39;repeatable-read&#39;;</code></pre>\n\n<ul>\n<li>设置数据库系统的全局的隔离级别:</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">set global tx_isolation &#x3D;&#39;read-committed&#39;;</code></pre>\n\n<h3 id=\"五、隔离级别范例\"><a href=\"#五、隔离级别范例\" class=\"headerlink\" title=\"五、隔离级别范例\"></a>五、隔离级别范例</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">create table user (\nid int primary key,\nname varchar(20),\nmoney int\n);\n\ninsert into user values(1,&#39;A&#39;,1000);\n\ninsert into user values(2,&#39;B&#39;,1000);\n\nselect * from user;\n\n-- 查询提交方式，1自动提交，0手动提交\nselect @@autocommit;\n\n-- 设置手动提交，也就是开启事务\nset @@autocommit&#x3D;0;\n-- 当然也可以使用 begin; 或者 start transaction;\n\n-- 此时a花了500块\nupdate  user  set money&#x3D;money-500 where id&#x3D;1; \n\n-- 换一个界面2查询，发现表中的值并未改变\n\n-- 此时进行回滚操作\nrollback;\n\n-- 在页面1查询发现表中的值并未改变\n\n-- 这是因开启事务，需要手动提交才会生效\nupdate  user  set money&#x3D;money-500 where id&#x3D;1; \ncommit;\n\n-- 再次两个页面查询发现，a的值改变了。\n\ninsert into user values(3,&#39;小明&#39;,1000);\ninsert into user values(4,&#39;淘宝店&#39;,1000);\n\n-- 查询数据库的隔离级别\nselect @tx_isolation;\nselect @@global.tx_isolation;\n\n-- 修改数据库的隔离级别\nset transaction isolation level read uncommitted; \n\n-- 小明淘宝买双鞋（500块），于是开启转账（事务）\nstart transaction;\nupdate user set money&#x3D;money-500 where name&#x3D;&#39;小明&#39;;\nupdate user set money&#x3D;money+500 where name&#x3D;&#39;淘宝店&#39;;\n\n-- 查询状况\nselect * from user;\n\n-- 小明给淘宝店打电话，让店主查账\n-- 店主在广州查账后发现到账了账目正确\n-- 给小明发货，然后晚上请女朋友吃饭\n-- 此时小明发现钱不够，就撤销了汇款（rollback;）\nrollback;\ncommit;\n\n-- 饭钱1500，付账发现钱不够了，这就属于账读\n\n——脏读：一个事务读到了另外一事务没有提交的数据，     ——就叫做脏读 实际开发是不允许的\n\n\n-- 读已经提交的\nset transaction isolation level read committed;\n\n-- 小张：银行的会计(开始统计报表)\nstart transaction;\nselect * from user;\nselect avg(money) from user;\n\n\n-- 小张去上厕所，并且在厕所抽烟\n\n-- 小王（用其他的电脑，开了一个户，添加一个数据）：\nstart transaction;\ninsert into user values(5,&#39;C&#39;,100);\ncommit;\n\n-- 小张回来，算钱的平均数(发现和之前不一样了)\nselect avg(money) from user;\n\n——虽然我只能读到已经提交的数据，但是还会出现问题，就是读取同一个表的数据，前后结果不一致。\n——不可重复读现象：read committed;\n\n\n-- 修改隔离级别\nset  global transaction isolation level repeatable read;\nselect @@global.tx_isolation;\n\n—— 张全蛋-成都-开户（两边同时开启事务）\nstart transaction;\ninsert into user values(7,&#39;f&#39;,1000);\ncommit;\n张全蛋这边还进行了 commit; 提交\n\n—— 王尼玛-北京-查询（用另外一个页面）\nstart transaction;\nselect * from user;\n\ninsert into user values(7,&#39;f&#39;,1000)\n&gt; 1062 - Duplicate entry &#39;7&#39; for key &#39;PRIMARY&#39;\n-- 王尼玛发现没有7，但是不能添加7，这种现象就叫  幻读\n\n\n-- 修改隔离级别\nset  global transaction isolation level serializable;\nselect @@global.tx_isolation;\n\n—— 张全蛋-成都\nstart transaction;\n\n—— 王尼玛-北京\nstart transaction;\ninsert into user values(8,&#39;i&#39;,1000);\n\n—— 张全蛋-成都\ninsert into user values(9,&#39;h&#39;,1000);\n插入语句卡着不能动了\n\n—— 王尼玛-北京\n输入了提交：commit；\n\n—— 张全蛋-成都  插入成功了\n\n——当user表被另一个事务操作时，其他事务里面的写操作，是不可以进行的。\n——进入排队状态（串行化），直到王尼玛那边事情结束，张全蛋这个写入操作才会执行  操作执行的前提是，等待没有超时的情况下\n</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>做了一个实验 </p>\n<p>create table t (id number, mount number);</p>\n<p>insert into t value(1,1);</p></blockquote>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>A</th>\n<th>B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>begin;</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>select * from t;</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td></td>\n<td>begin;</td>\n</tr>\n<tr>\n<td>4</td>\n<td></td>\n<td>select * from t;</td>\n</tr>\n<tr>\n<td>5</td>\n<td>update t set mount=mount+1 where id = 1;</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>commit;</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td></td>\n<td>select * from t where id = 1;</td>\n</tr>\n<tr>\n<td>8</td>\n<td></td>\n<td>update t set mount=mount+2 where id = 1;</td>\n</tr>\n<tr>\n<td>9</td>\n<td></td>\n<td>commit;</td>\n</tr>\n<tr>\n<td>10</td>\n<td></td>\n<td>select * from t where id = 1;</td>\n</tr>\n<tr>\n<td>11</td>\n<td></td>\n<td>commit;</td>\n</tr>\n<tr>\n<td>12</td>\n<td>select * from t where id = 1;</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>commit;</td>\n<td></td>\n</tr>\n<tr>\n<td>result</td>\n<td>12步mount为2</td>\n<td>7步mount为1，10步mount为4</td>\n</tr>\n</tbody></table>\n<p>这里事务B的两次结果容让人困惑，从mysql的隔离机制入手就不难理解了</p>\n<p>首先7步是为了解决不可重复读，尽管事务A已经修改并提交，但对于事务B不知情，4与7的查询结果应一致，这也是repeatable-read算法，查询时会去寻找事务开始时的snapshot。</p>\n<p>那为什么10步会查询为4呢？因为做了update操作，事务的起始点变化为8的位置，寻找到的那时的snapshot.</p>\n<p>同样12步只能寻找到事务A最后一次事务操作udpate的shpshot，获得值为2。</p>\n<hr>\n<h3 id=\"六、DCL操作\"><a href=\"#六、DCL操作\" class=\"headerlink\" title=\"六、DCL操作\"></a>六、DCL操作</h3><h4 id=\"1、SQL分类回忆\"><a href=\"#1、SQL分类回忆\" class=\"headerlink\" title=\"1、SQL分类回忆\"></a>1、SQL分类回忆</h4><ul>\n<li>DDL DML DQL DCL</li>\n</ul>\n<h4 id=\"2、概念\"><a href=\"#2、概念\" class=\"headerlink\" title=\"2、概念\"></a>2、概念</h4><ul>\n<li><p>DCL(Data Control Language)，即数据控制语言，用来定义数据库的访问权限和安全级别，及创建用户。</p>\n<p>主要包括创建用户、给用户授权、对用户撤销授权、查询用户授权和删除用户等。</p>\n</li>\n</ul>\n<h4 id=\"3、查询创建删除\"><a href=\"#3、查询创建删除\" class=\"headerlink\" title=\"3、查询创建删除\"></a>3、查询创建删除</h4><ol>\n<li><p>切换到 mysql 数据库：use mysql;</p>\n</li>\n<li><p>查询用户：select *  from user;</p>\n</li>\n<li><p>创建用户</p>\n<ul>\n<li><p>create user ‘用户名’@’localhost’  identified  by  ‘密码’;</p>\n</li>\n<li><p>创建当前主机用户</p>\n<p>create user ‘123’@’localhost’  identified  by  ‘root’;</p>\n</li>\n<li><p>创建远程可访问用户（用通配符 %）</p>\n<p>create user ‘123’@’ % ‘  identified  by  ‘root’;</p>\n</li>\n</ul>\n</li>\n<li><p>删除用户</p>\n<ul>\n<li>drop user  ‘用户名’@‘主机名’;</li>\n<li>drop user ‘123‘@’localhost’;</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"4、用户密码问题\"><a href=\"#4、用户密码问题\" class=\"headerlink\" title=\"4、用户密码问题\"></a>4、用户密码问题</h4><ol>\n<li>修改用户名密码<ul>\n<li>update user  set password = password(‘新密码’)  where  user = ‘用户名’;</li>\n<li>update user  set password = password(‘456’)  where  user = ‘123’;</li>\n<li>mysql 给出的简化方式：set password for ‘用户名’@‘主机名’ = password(‘新密码’);</li>\n</ul>\n</li>\n<li>MySql 忘记root用户密码<ul>\n<li>cmd —&gt; net stop mysql   停止mysql服务</li>\n<li>需要以管理员身份运行cmd</li>\n<li>使用无验证方式启动mysql服务：musqld –skip-grant-tables</li>\n<li>回车，光标卡着不动了，此时服务启动成功</li>\n<li>再打开一个新的cmd窗口 直接输入 mysql 回车就直接登录进去了</li>\n<li>use mysql;</li>\n<li>修改密码：update user  set password = password(‘新密码’)  where  user = ‘root’;</li>\n<li>关闭两个窗口</li>\n<li>打开任务管理器，手动结束musqld.exe的进程</li>\n<li>启动mysql服务</li>\n<li>使用新密码登录</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"5、权限的授予回收\"><a href=\"#5、权限的授予回收\" class=\"headerlink\" title=\"5、权限的授予回收\"></a>5、权限的授予回收</h4><ol>\n<li>授予权限<ul>\n<li>grant  权限列表  on  数据库名.表名  to  ‘用户名‘@’主机名’;</li>\n<li>grant  select  on db_school to  ‘123‘@’%’;</li>\n<li>给某个用户所有库的所有表的所有权限</li>\n<li>grant  all  on  * . *   to  ‘用户名‘@’主机名’;</li>\n</ul>\n</li>\n<li>查询权限<ul>\n<li>show grants  for  ‘用户名‘@’主机名’;</li>\n<li>show grants  for  ‘123‘@’%’;</li>\n</ul>\n</li>\n<li>撤销权限<ul>\n<li>revoke 权限列表  on 数据库名.表名  from  ‘用户名‘@’主机名’;</li>\n</ul>\n</li>\n</ol>\n","text":"一、约束（Constraint）1、主要内容1. 非空约束 2. 自增约束 3. 主键约束 4. 唯一键约束 5. 默认值约束 6. 外键约束 7. 检查约束 2.、查看某个表的约束SELECT * FROM information_schema.table_constraint...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"MySql","slug":"MySql","count":3,"path":"api/categories/MySql.json"}],"tags":[{"name":"MySql","slug":"MySql","count":3,"path":"api/tags/MySql.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E7%BA%A6%E6%9D%9F%EF%BC%88Constraint%EF%BC%89\"><span class=\"toc-text\">一、约束（Constraint）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">1、主要内容</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E3%80%81%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E8%A1%A8%E7%9A%84%E7%BA%A6%E6%9D%9F\"><span class=\"toc-text\">2.、查看某个表的约束</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E3%80%81%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E8%A1%A8%E7%9A%84%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">3.、查看某个表的索引</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F%EF%BC%9Aprimary-key\"><span class=\"toc-text\">4、主键约束：primary key</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%E3%80%81%E5%94%AF%E4%B8%80%E9%94%AE%E7%BA%A6%E6%9D%9F%EF%BC%9Aunique-key\"><span class=\"toc-text\">5、唯一键约束：unique key</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6%E3%80%81%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F%EF%BC%9Aforeign-key\"><span class=\"toc-text\">6、外键约束：foreign key</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7%E3%80%81%E9%9D%9E%E7%A9%BA%E7%BA%A6%E6%9D%9F%EF%BC%9Anot-null\"><span class=\"toc-text\">7、非空约束：not null</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8%E3%80%81%E9%BB%98%E8%AE%A4%E5%80%BC%E7%BA%A6%E6%9D%9F%EF%BC%9Adefault\"><span class=\"toc-text\">8、默认值约束：default</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9%E3%80%81%E6%A3%80%E6%9F%A5%E7%BA%A6%E6%9D%9F%EF%BC%9Acheck\"><span class=\"toc-text\">9、检查约束：check</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10%E3%80%81%E8%87%AA%E5%A2%9E%E7%BA%A6%E6%9D%9F%EF%BC%9Aauto-increment\"><span class=\"toc-text\">10、自增约束：auto_increment</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#11%E3%80%81DML-v2-0\"><span class=\"toc-text\">11、DML(v2.0)</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">二、数据库的设计</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E8%A1%A8%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">1、表间的关系</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">2、实现方式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F\"><span class=\"toc-text\">3、数据库三大设计范式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F%EF%BC%881NF%EF%BC%89\"><span class=\"toc-text\">4、第一范式（1NF）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%E3%80%81%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F%EF%BC%882NF%EF%BC%89\"><span class=\"toc-text\">5、第二范式（2NF）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6%E3%80%81%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%883NF%EF%BC%89\"><span class=\"toc-text\">6、第三范式（3NF）</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E4%BA%8B%E5%8A%A1\"><span class=\"toc-text\">三、事务</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1、概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E4%BA%8B%E5%8A%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E5%BE%81%EF%BC%88ACID%EF%BC%89\"><span class=\"toc-text\">2、事务四大特征（ACID）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E4%BA%8B%E5%8A%A1%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">3、事务基本语句</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E6%95%85%E9%9A%9C\"><span class=\"toc-text\">4、故障</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E4%BA%8B%E5%8A%A1%E4%B9%8B%E9%9A%94%E7%A6%BB%E6%80%A7\"><span class=\"toc-text\">四、事务之隔离性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%A6%82%E8%BF%B0-1\"><span class=\"toc-text\">1、概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">2、并发操作存在问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%9B%9B%E5%A4%A7%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB\"><span class=\"toc-text\">3、四大隔离级别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9F%A5%E7%9C%8B-%E8%AE%BE%E7%BD%AE\"><span class=\"toc-text\">4、隔离级别的查看 | 设置</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%8C%83%E4%BE%8B\"><span class=\"toc-text\">五、隔离级别范例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81DCL%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">六、DCL操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81SQL%E5%88%86%E7%B1%BB%E5%9B%9E%E5%BF%86\"><span class=\"toc-text\">1、SQL分类回忆</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">2、概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%9F%A5%E8%AF%A2%E5%88%9B%E5%BB%BA%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">3、查询创建删除</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">4、用户密码问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%E3%80%81%E6%9D%83%E9%99%90%E7%9A%84%E6%8E%88%E4%BA%88%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">5、权限的授予回收</span></a></li></ol></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"Mysql 索引视图备份","uid":"a725910a1add8e5328c32e2fb97b8db8","slug":"21-MySql索引视图备份","date":"2021-09-13T14:56:32.000Z","updated":"2021-09-15T10:19:38.689Z","comments":true,"path":"api/articles/21-MySql索引视图备份.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"一、索引1、什么是索引？索引就相当于一-本书的目录，通过目录可以快速的找到对应的资源. 2、查询表的两种方式第一种方式:全表扫描 第二种方式:根据索引检索(效率很高) 3、索引为何能提高检索效率?其实最根本的原理是缩小了扫描的范围. 索引虽然可以提高检索效率，但是不能随意的添加索...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"MySql","slug":"MySql","count":3,"path":"api/categories/MySql.json"}],"tags":[{"name":"MySql","slug":"MySql","count":3,"path":"api/tags/MySql.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"Mysql 基础语句","uid":"68a57833ae44293764c3ebaf716fccf1","slug":"19-MySql基础语句","date":"2021-09-13T14:54:32.000Z","updated":"2021-09-15T10:18:45.633Z","comments":true,"path":"api/articles/19-MySql基础语句.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"一、数据库的操作1、创建数据库普通创建 create database db_sql； 带字符集创建 create database db_sql character set utf8； 2、查询数据库查看数据库字符编码 show variables like &#39;%cha...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"MySql","slug":"MySql","count":3,"path":"api/categories/MySql.json"}],"tags":[{"name":"MySql","slug":"MySql","count":3,"path":"api/tags/MySql.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}