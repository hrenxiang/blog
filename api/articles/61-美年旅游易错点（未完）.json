{"title":"Spring项目（1）","uid":"a35ab763af39963a3c8e8b221affe22c","slug":"61-美年旅游易错点（未完）","date":"2021-09-13T15:38:32.000Z","updated":"2021-09-15T10:47:10.962Z","comments":true,"path":"api/articles/61-美年旅游易错点（未完）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog3.jpg","content":"<h4 id=\"one-spring整合mybatis时\"><a href=\"#one-spring整合mybatis时\" class=\"headerlink\" title=\":one: spring整合mybatis时\"></a>:one: spring整合mybatis时</h4><p>如果只使用<code>&lt;mybatis:scan base-package=&quot;&quot;/&gt;</code>时，mapper（dao）接口的 路径名 及 接口名 都要（必须）与mapper映射文件的 路径名 及 接口名 一样</p>\n<p>如果在整合的bean中（即<code>org.mybatis.spring.SqlSessionFactoryBean</code>中）使用了<code>&lt;property name=&quot;mapperLocations&quot; value=&quot;mappers&quot;/&gt;</code>无论下面使用的是<code>&lt;mybatis:scan base-package=&quot;&quot;/&gt;</code>，还是</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;bean id&#x3D;&quot;mapperScannerConfigurer&quot; class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;\n    &lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;com.atguigu.mapper&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;</code></pre>\n\n<p>路径名和接口名可以一样也可以不一样</p>\n<h4 id=\"two-scope-row\"><a href=\"#two-scope-row\" class=\"headerlink\" title=\":two: scope.row\"></a>:two: scope.row</h4><p>传递给new的vue中时，row中包含了基本上所有的元素，即使没有显示id，也包含的有id</p>\n<h4 id=\"three-常识性逻辑\"><a href=\"#three-常识性逻辑\" class=\"headerlink\" title=\":three: 常识性逻辑\"></a>:three: 常识性逻辑</h4><p>添加信息或者修改信息后，要将添加页面或者修改页面隐藏</p>\n<p>无论是否添加成功，我们都应该将页面中的数据重置为空（这个根据具体业务需求，登录时就可以有回显）</p>\n<p>无论添加，修改，删除，成功后我们都应该刷新数据</p>\n<p>无论是传递给前端还是发送给后端的数据，我们可以使用工具类对其进行归类，这样我们在返回数据的时候，能够做到统一</p>\n<p>我们在添加和修改时，肯定都是要在数据规则验证通过后进行，</p>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">this.$refs[&quot;dataEditForm&quot;].validate((valid) &#x3D;&gt; &#123;\n    if (valid) &#123;\n\n    &#125;else&#123;\n\n&#125;</code></pre>\n\n<h4 id=\"four-使用动态sql判断传入值\"><a href=\"#four-使用动态sql判断传入值\" class=\"headerlink\" title=\":four: 使用动态sql判断传入值\"></a>:four: 使用动态sql判断传入值</h4><p>要么使用value代替，要么使用@param进行别名设置</p>\n<p>==想清楚每一步，不要盲目的去写，对待键值对应这种的时候，一定要仔细，不要前后不一，前面写的，后面用的时候就变成了另外一种==</p>\n<p>==需要去了解的技术，elementUI，七牛云的上传下载==</p>\n<h4 id=\"five-分页\"><a href=\"#five-分页\" class=\"headerlink\" title=\":five: 分页\"></a>:five: 分页</h4><p>分页时，我们一般需要三个数据，当前页，每页显示条数，查询条件</p>\n<ul>\n<li><p>当前页：在前端可以直接获取</p>\n</li>\n<li><p>每页显示条数：看情况，我们可以在前端进行设置，我们也可以在其他地方进行设置</p>\n</li>\n<li><p>查询条件：不使用条件查询时，默认为空，就不在进行条件匹配，这里使用的技术是，动态sql </p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;select id&#x3D;&quot;findPage&quot; resultType&#x3D;&quot;setmeal&quot;&gt;\n    select * from t_setmeal\n    &lt;where&gt;\n        &lt;if test&#x3D;&quot;queryString!&#x3D;null and queryString.length&gt;0&quot;&gt;\n            code&#x3D;#&#123;queryString&#125; or name like concat(&#39;%&#39;,#&#123;queryString&#125;,&#39;%&#39;)\n        &lt;&#x2F;if&gt;\n    &lt;&#x2F;where&gt;\n&lt;&#x2F;select&gt;</code></pre></li>\n</ul>\n<p>后端进行返回时</p>\n<ul>\n<li>从数据库获取到的数据，使用 <code>Page&lt;E&gt; extends ArrayList&lt;E&gt;</code> (Page<E>)进行接收，泛型是返回数据的具体类型</li>\n<li>service实现类中，将接收到的数据进一步解析分装，使用我们的工具类 PageResult 进行接收<ul>\n<li>两个参数，total – 总行数，rows – 查询到的当前页的数据集合</li>\n</ul>\n</li>\n<li>controller控制器中，直接将得到的PageResult进行返回</li>\n<li>在前端页面上的axios的then()中，进行数据挂载，因为数据是双向绑定的，是异步的，所以挂载后页面可以直接显示</li>\n</ul>\n<h4 id=\"six-自由行的添加，修改，删除\"><a href=\"#six-自由行的添加，修改，删除\" class=\"headerlink\" title=\":six: 自由行的添加，修改，删除\"></a>:six: 自由行的添加，修改，删除</h4><ul>\n<li>添加<ol>\n<li>在弹出窗口前，我们应该重置弹出的表单，因为用户添加数据时，看到的表单应该为空，<code>this.formData=&#123;&#125;;</code></li>\n<li>弹出添加窗口，使用的elementUI中的设置，在vue的data中维护了一个弹出开关 this.dialogFormVisible=false<ul>\n<li>true为开，false为关 </li>\n</ul>\n</li>\n<li>弹出添加窗口后我们应该去进行添加的操作，使用axios向后端发送请求，并发送表单中的数据（json数据）</li>\n<li>在controller中我们进行添加操作（接收数据时，记得使用@RequestBody），因为业务较为单一，到数据库都是层层调用就行，在mapper映射文件中写好sql语句</li>\n<li>在controller中调用添加方法完成后，我们应该返回 成功或者失败的结果，使用工具类Result进行封装<ul>\n<li>三个参数</li>\n<li>flag – 是否成功(true或false)  </li>\n<li>message – 使用定义的常量(成功或失败的消息提示)  </li>\n<li>data – 封装object类型数据（可写可不写）</li>\n</ul>\n</li>\n<li>然后我们在前端进行数据的挂载，因为是添加，那我们只需进行判断flag是否为ture，进行相关消息提示即可</li>\n</ol>\n</li>\n<li>修改<ol>\n<li>弹出窗口（弹出前重置，重置也没有问题，因为我们后面会进行数据的查询，进行数据回显）</li>\n<li>根据id（ scope.row包含所有数据，虽然页面上没有显示id，但是包含的有id）查询相关自由行数据，大体方法也是层层调用，到数据库中查询</li>\n<li>在controller中得到数据后进行封装(Result) ，在前端页面上进行回显，在axios中给formData赋值 this.formData=res.data.data</li>\n<li>进行修改操作，将修改的数据使用axios传递给后端，使用后端代码对其数据库进行修改，修改成功后，在前端进行消息提示</li>\n</ol>\n</li>\n<li>删除<ol>\n<li>删除操作和添加操作大体一样</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"seven-跟团游的添加，修改删除\"><a href=\"#seven-跟团游的添加，修改删除\" class=\"headerlink\" title=\":seven: 跟团游的添加，修改删除\"></a>:seven: 跟团游的添加，修改删除</h4><p>跟团游中有 自由行列表可以选择，所以我们不仅要关注跟团游的操作，还要关注自由行的操作</p>\n<ul>\n<li>添加<ol>\n<li>弹出添加表单，表单由两部分组成，添加跟团游的选项卡一，选择自由行的选项卡二</li>\n<li>弹出前要进行重置操作，以免数据回显，跟团游需要重置的数据较多<ul>\n<li>this.dataForm={}; 重置表单</li>\n<li>this.activeName=”first”; 重置为第一个选项卡</li>\n<li>this.travelItemIds=[];重置自由行复选框</li>\n</ul>\n</li>\n<li>弹出后，进行添加操作，此添加要密切关注自由行，因为我们需要把添加的跟团游的 id 和选中的有联系的自由行的 id添加到两者的关系表中</li>\n<li>在controller中我们应该接收 选中的自由行的id数组，以及添加的跟团游的formData，使用跟团游的类进行接收（不要忘记@RequestBody）</li>\n<li>将之传递给service中，我们在service的实现类中，先进行跟团游的添加，因为这样我们可以使用mybatis的自增id返回（keyProperty=“id”）进行id赋值，这样我们在service的实现类中就可以 获取到 添加进去的跟团游的id</li>\n<li>获取到后我们在service的实现类中添加一个方法，参数为 自由行的id数组，以及跟团游的id，将自由行的数据进行遍历，在遍历的内部，维护一个map集合，添加一个自由行的id键值对，就添加一个跟团游的id的键值对（从始至终就同一个），然后调用添加到数据库中的方法，map集合在mapper映射文件中，使用key得到值，这样就将每一个与之对应的自由行的id添加到了关系表中，还避免了在mapper映射文件使用foreach循环</li>\n<li>最后在前端进行返回数据的判断，返回相对应的消息通知</li>\n</ol>\n</li>\n<li>修改<ol>\n<li>修改与添加大概一样，先重置表单</li>\n<li>弹出表单后，获取所有的自由行，进行回显，紧接着根据id获取相关跟团游数据，并根据跟团游id获取关联的自由行id封装为list集合</li>\n<li>在service中将跟团游和id的list集合封装到map集合中，使用键对应值的方式（两个），然后controller封装为Result返回给前端</li>\n<li>前端拿到数据后，进行相关回显</li>\n<li>进行修改操作</li>\n<li>将修改的数据返回给后端，此时和添加的操作差不多，不过，我们应该先修改跟团游，然后根据跟团游的id删除之前与之有关联的自由行的数据</li>\n<li>将我们从前端拿到的新的自由行的id数组，使用添加操作时再service的实现类中添加的方法，将之再添加进去</li>\n<li>然后我们在controller中将成功还是失败封装为result返回给前端，在前端进行修改成功还是失败的消息通知</li>\n</ol>\n</li>\n<li>删除<ol>\n<li>删除操作，我们先根据id获取是否有与之关联的自由行，如果有自由行，那就不能删除，如果没有则进行删除操作</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"eight-套餐的添加\"><a href=\"#eight-套餐的添加\" class=\"headerlink\" title=\":eight: 套餐的添加\"></a>:eight: 套餐的添加</h4><p>整体来说和跟团游的添加一样，但是套餐的添加涉及到了图片的上传，所以我们又多了一个关注点</p>\n<p>首先我们解决图片的上传问题</p>\n<ul>\n<li>我们使用七牛云进行上传</li>\n<li>在七牛云上添加工作空间，将仓库的公钥私钥复制到工具类qiniu的变量中，并把仓库名指定为自己的仓库名</li>\n<li>因为前端页面上传图片的html代码模块中，指定了访问后端的路径，所以我们要使用指定的路径，或者更改前端指定的路径用其他的</li>\n<li>在后端controller与之匹配的路径方法中，我们先获取文件的原始名，然后获取图片后缀名（.jpg 或 .png等，带点）</li>\n<li>我们进行上传后的文件名设置，一般使用UUID.randomUUID.toString+System.CurrtentMills+后缀名</li>\n<li>我们将上传的图片 解析为字节数组，然后使用QINIU工具类中参数为（ 文件字节数组，上传文件名）的上传方法进行上传</li>\n<li>在前端的上传成功后的方法中，已经有人给我们提供了返回数据response（上传文件名）</li>\n<li>所以我们直接 将imgUrl 设置为 this.imgUrl=”七牛云提供的测试域名/“+上传文件名，这样我们就可以让上传的文件在上传框中回显</li>\n<li>提示上传成功，然后将formData中的img属性的值设置为imgUrl，以便提交表单时，添加到数据库中</li>\n</ul>\n<p>添加套餐</p>\n<ul>\n<li>弹出添加表单，弹出前，重置表单，这里我们要多重置一个数据，那就是imgUrl，不然我们之前上传的图片可能还会在表单中显示</li>\n<li>然后的步骤就和</li>\n</ul>\n","text":":one: spring整合mybatis时如果只使用&lt;mybatis:scan base-package=&quot;&quot;/&gt;时，mapper（dao）接口的 路径名 及 接口名 都要（必须）与mapper映射文件的 路径名 及 接口名 一样 如果在整合的b...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"Project","slug":"Project","count":1,"path":"api/categories/Project.json"}],"tags":[{"name":"Project","slug":"Project","count":1,"path":"api/tags/Project.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#one-spring%E6%95%B4%E5%90%88mybatis%E6%97%B6\"><span class=\"toc-text\">:one: spring整合mybatis时</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#two-scope-row\"><span class=\"toc-text\">:two: scope.row</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#three-%E5%B8%B8%E8%AF%86%E6%80%A7%E9%80%BB%E8%BE%91\"><span class=\"toc-text\">:three: 常识性逻辑</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#four-%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81sql%E5%88%A4%E6%96%AD%E4%BC%A0%E5%85%A5%E5%80%BC\"><span class=\"toc-text\">:four: 使用动态sql判断传入值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#five-%E5%88%86%E9%A1%B5\"><span class=\"toc-text\">:five: 分页</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#six-%E8%87%AA%E7%94%B1%E8%A1%8C%E7%9A%84%E6%B7%BB%E5%8A%A0%EF%BC%8C%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">:six: 自由行的添加，修改，删除</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#seven-%E8%B7%9F%E5%9B%A2%E6%B8%B8%E7%9A%84%E6%B7%BB%E5%8A%A0%EF%BC%8C%E4%BF%AE%E6%94%B9%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">:seven: 跟团游的添加，修改删除</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#eight-%E5%A5%97%E9%A4%90%E7%9A%84%E6%B7%BB%E5%8A%A0\"><span class=\"toc-text\">:eight: 套餐的添加</span></a></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"Git","uid":"221a7ad001c03569112f684b2dfdc120","slug":"62-Git","date":"2021-09-13T15:39:32.000Z","updated":"2021-09-15T10:47:06.475Z","comments":true,"path":"api/articles/62-Git.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog2.jpg","text":"1、版本控制 1.1、什么是版本控制版本控制 (Revision control)：是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。 ① 本地版本控制系统：RCS 记录文件每次的更新，可以对每个版本做...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"Project Manager","slug":"Project-Manager","count":3,"path":"api/categories/Project-Manager.json"}],"tags":[{"name":"Project Manager","slug":"Project-Manager","count":3,"path":"api/tags/Project-Manager.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"Spring 整合","uid":"173956e689406289f575044308a994ef","slug":"60-Spring 整合各个模块","date":"2021-09-13T15:37:32.000Z","updated":"2021-09-15T10:47:26.939Z","comments":true,"path":"api/articles/60-Spring 整合各个模块.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog4.jpg","text":"meinian — daojdbc.properties jdbc.driverClassName&#x3D;com.mysql.jdbc.Driver jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;meinia...","link":"","photos":[],"count_time":{"symbolsCount":"34k","symbolsTime":"31 mins."},"categories":[{"name":"Spring","slug":"Spring","count":6,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":6,"path":"api/tags/Spring.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}