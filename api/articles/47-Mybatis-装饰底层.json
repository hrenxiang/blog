{"title":"Mybatis 装饰底层","uid":"14472dd3b23cbe4f0d4e64f3f2df1f1f","slug":"47-Mybatis-装饰底层","date":"2021-09-13T15:24:32.000Z","updated":"2021-09-15T10:51:27.987Z","comments":true,"path":"api/articles/47-Mybatis-装饰底层.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog8.jpg","content":"<h3 id=\"1-装饰器模式\"><a href=\"#1-装饰器模式\" class=\"headerlink\" title=\"1. 装饰器模式\"></a>1. 装饰器模式</h3><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p>\n<p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p>\n<p>我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。</p>\n<h4 id=\"1-1-介绍\"><a href=\"#1-1-介绍\" class=\"headerlink\" title=\"1.1 介绍\"></a>1.1 介绍</h4><p><strong>意图：</strong>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p>\n<p><strong>主要解决：</strong>一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p>\n<p><strong>何时使用：</strong>在不想增加很多子类的情况下扩展类。</p>\n<p><strong>优点：</strong>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>\n<p><strong>缺点：</strong>多层装饰比较复杂。</p>\n<p><strong>使用场景：</strong> 1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p>\n<p><strong>注意事项：</strong>可代替继承。</p>\n<h4 id=\"1-2-案例演示\"><a href=\"#1-2-案例演示\" class=\"headerlink\" title=\"1.2 案例演示\"></a>1.2 案例演示</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">准备环境\n    1. 编写一个Star接口, 提供sing 和 dance抽象方法\n    2. 编写一个LiuDeHua类,实现Star接口,重写抽象方法</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Star &#123;\n    public void sing();\n    public void dance();\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LiuDeHua implements Star &#123;\n    @Override\n    public void sing() &#123;\n        System.out.println(&quot;刘德华在唱忘情水...&quot;);\n    &#125;\n    @Override\n    public void dance() &#123;\n        System.out.println(&quot;刘德华在跳街舞...&quot;);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">需求\n\n\t在不改变原类的基础上对LiuDeHua类的sing方法进行扩展\n\n实现步骤\n\n    1. 编写一个LiuDeHuaWarpper类, 实现Star接口,重写抽象方法\n    2. 提供LiuDeHuaWarpper类的有参构造, 传入LiuDeHua类对象\n    3. 在LiuDeHuaWarpper类中对需要增强的sing方法进行增强\n    4. 在LiuDeHuaWarpper类对不需要增强的方法调用LiuDeHua类中的同名方法</code></pre>\n\n<h4 id=\"1-3-实现代码\"><a href=\"#1-3-实现代码\" class=\"headerlink\" title=\"1.3 实现代码\"></a>1.3 实现代码</h4><p>LiuDeHua类: 被装饰类。</p>\n<p>LiuDeHuaWarpper类: 我们称之为装饰类。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n\t装饰模式遵循原则:\n\t\t装饰类和被装饰类必须实现相同的接口\n\t\t在装饰类中必须传入被装饰类的引用\n\t\t在装饰类中对需要扩展的方法进行扩展\n\t\t在装饰类中对不需要扩展的方法调用被装饰类中的同名方法\n*&#x2F;\npublic class LiuDeHuaWarpper implements Star &#123;\n    &#x2F;&#x2F; 存放被装饰类的引用\n    private LiuDeHua liuDeHua;\n    &#x2F;&#x2F; 通过构造器传入被装饰类对象\n    public LiuDeHuaWarpper(LiuDeHua liuDeHua)&#123;\n        this.liuDeHua &#x3D; liuDeHua;\n    &#125;\n    @Override\n    public void sing() &#123;\n        &#x2F;&#x2F; 对需要扩展的方法进行扩展增强\n        System.out.println(&quot;刘德华在鸟巢的舞台上演唱忘情水.&quot;);\n    &#125;\n    @Override\n    public void dance() &#123;\n        &#x2F;&#x2F; 不需要增强的方法调用被装饰类中的同名方法\n        liuDeHua.dance();\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"1-4-测试结果\"><a href=\"#1-4-测试结果\" class=\"headerlink\" title=\"1.4 测试结果\"></a>1.4 测试结果</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    &#x2F;&#x2F; 创建被装饰类对象\n    LiuDeHua liuDeHua &#x3D; new LiuDeHua();\n    &#x2F;&#x2F; 创建装饰类对象,被传入被装饰类\n    LiuDeHuaWarpper liuDeHuaWarpper &#x3D; new LiuDeHuaWarpper(liuDeHua);\n    &#x2F;&#x2F; 调用装饰类的相关方法,完成方法扩展\n    liuDeHuaWarpper.sing();\n    liuDeHuaWarpper.dance();\n&#125;</code></pre>\n\n<h3 id=\"2-装饰模式小结\"><a href=\"#2-装饰模式小结\" class=\"headerlink\" title=\"2. 装饰模式小结\"></a>2. 装饰模式小结</h3><p>装饰模式可以在不改变原类的基础上对类中的方法进行扩展增强,实现原则为:</p>\n<ol>\n<li>装饰类和被装饰类必须实现相同的接口</li>\n<li>在装饰类中必须传入被装饰类的引用</li>\n<li>在装饰类中对需要扩展的方法进行扩展</li>\n<li>在装饰类中对不需要扩展的方法调用被装饰类中的同名方法</li>\n</ol>\n<h3 id=\"3-Mybatis四大对象\"><a href=\"#3-Mybatis四大对象\" class=\"headerlink\" title=\"3. Mybatis四大对象\"></a>3. Mybatis四大对象</h3><h4 id=\"3-1-概述\"><a href=\"#3-1-概述\" class=\"headerlink\" title=\"3.1 概述\"></a>3.1 概述</h4><ol>\n<li>StatementHandler：处理sql语句预编译，设置参数等相关工作</li>\n<li>ParameterHandler：设置预编译参数用的</li>\n<li>ResultSetHandler：处理结果集 </li>\n<li>Executor：它是一个执行器，真正进行java与数据库交互的对象</li>\n</ol>\n<h4 id=\"3-2-具体\"><a href=\"#3-2-具体\" class=\"headerlink\" title=\"3.2 具体\"></a>3.2 具体</h4><p>Executor对象在创建Configuration对象的时候创建，并且缓存在Configuration对象里，负责管理一级缓存和二级缓存，并提供是事务管理的相关操作。</p>\n<p>Executor对象的主要功能是调用StatementHandler访问数据库，并将查询结果存入缓存中（如果配置了缓存的话)。</p>\n<p>StatementHandler首先通过ParammeterHandler完成SQL的实参绑定，然后通过java.sql.Statement对象执行sql语句并得到结果集ResultSet，最后通过ResultSetHandler完成结果集的映射，得到对象并返回</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/mybatis-four-object.png\" alt=\"image-20210712014131119\"></p>\n<h4 id=\"3-3-Executor\"><a href=\"#3-3-Executor\" class=\"headerlink\" title=\"3.3 Executor\"></a>3.3 Executor</h4><p>每一个 <code>SqlSession</code> 都会拥有一个<code>Executor</code> 对象，这个对象负责增删改查的具体操作，简单的将它理解为 JDBC 中 Statement 的封装版</p>\n<p>位于继承体系最顶层的是<code>Executor</code>执行器，它有两个实现类，分别是和<code>BaseExecutor</code>和<code>CachingExecutor</code></p>\n<p><strong>BaseExecutor</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">BaseExecutor是一个抽象类，这种通过抽象的实现接口的方式是的体现，是Executor 的默认实现，实现了大部分 Executor 接口定义的功能，关于查询更新的具体实现由其子类实现。️BaseExecutor 的子类有四个，分别是 SimpleExecutor、ReuseExecutor 、CloseExecutor 和 BatchExecutor\n\n\nSimpleExecutor\n  简单执行器，是 MyBatis 中默认使用的执行器，每执行一次 update 或 select，就开启一个Statement 对象，用完就直接关闭 Statement 对象(可以是 Statement 或者是 PreparedStatment 对象)\n\n\nReuseExecutor\n  可重用执行器，这里的重用指的是重复使用Statement，它会在内部使用一个 Map 把创建的Statement 都缓存起来，每次执行 SQL 命令的时候，都会去判断是否存在基于该 SQL 的 Statement 对象，如果存在Statement 对象并且对应的 connection 还没有关闭的情况下就继续使用之前的 Statement 对象，并将其缓存起来。因为每一个 SqlSession都有一个新的 Executor对象，所以我们缓存在 ReuseExecutor 上的 Statement作用域是同一个 SqlSession。</code></pre>\n\n<p><strong>CachingExecutor</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">缓存执行器，先从缓存中查询结果，如果存在就返回之前的结果；如果不存在，再委托给&#96;Executor delegate&#96; 去数据库中取，delegate 可以是上面任何一个执行器。</code></pre>\n\n<p><strong>Executor执行流程</strong></p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/executor-liucheng.png\" alt=\"img\"></p>\n<h4 id=\"3-4-StatementHandler\"><a href=\"#3-4-StatementHandler\" class=\"headerlink\" title=\"3.4 StatementHandler\"></a>3.4 StatementHandler</h4><p>StatementHandler主要负责操作Statement对象与数据库进行交互</p>\n<p>顶层负接口分别有两个实现 <code>BaseStatementHandler</code> 和 <code>RoutingStatementHandler</code>，而BaseStatementHandler分别有三个实现类<code>SimpleStatementHandler</code>、<code>PreparedStatementHandler</code>、<code>CallableStatementHandler</code></p>\n<p><strong><code>BaseStatementHandler</code></strong></p>\n<p>它本身是一个抽象类，用于简化StatementHandler 接口实现的难度，属于适配器设计模式体现，它主要有三个实现类：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#96;SimpleStatementHandler&#96;\n\n  java.sql.Statement对象创建处理器，管理 Statement 对象并向数据库中推送不需要预编译的SQL语句。\n\n\n&#96;PreparedStatementHandler&#96;\n\n  java.sql.PrepareStatement对象的创建处理器，管理Statement对象并向数据中推送需要预编译的SQL语句。\n  \n  \n&#96;CallableStatementHandler&#96;\n\n  java.sql.CallableStatement对象的创建处理器，管理 Statement 对象并调用数据库中的存储过程。</code></pre>\n\n<p>  <strong>注意</strong>：<code>SimpleStatementHandler</code> 和 <code>PreparedStatementHandler</code> 的区别是 SQL 语句是否包含变量。是否通过外部进行参数传入。<code>SimpleStatementHandler</code> 用于执行没有任何参数传入的 SQL，<code>PreparedStatementHandler</code> 需要对外部传入的变量和参数进行提前参数绑定和赋值。</p>\n<h4 id=\"3-5-ParameterHandler\"><a href=\"#3-5-ParameterHandler\" class=\"headerlink\" title=\"3.5 ParameterHandler\"></a>3.5 ParameterHandler</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">相比于其他的组件就简单很多了，ParameterHandler 译为参数处理器，负责为 PreparedStatement 的 sql 语句参数动态赋值，这个接口很简单只有两个方法：\n\ngetParameterObject：用于读取参数\n\nsetParameters: 用于对 PreparedStatement 的参数赋值</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) &#123;\n    ParameterHandler parameterHandler &#x3D; mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);\n    parameterHandler &#x3D; (ParameterHandler) interceptorChain.pluginAll(parameterHandler);\n    return parameterHandler;\n  &#125;</code></pre>\n\n<h4 id=\"3-6-ResultSetHandler\"><a href=\"#3-6-ResultSetHandler\" class=\"headerlink\" title=\"3.6 ResultSetHandler\"></a>3.6 ResultSetHandler</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#96;ResultSetHandler&#96; 也很简单，它只有一个实现类&#96;DefaultResultSetHandler&#96;，主要负责处理两件事\n\n* 处理 Statement 执行后产生的结果集，生成结果列表。\n* 处理存储过程执行后的输出参数</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,\n      ResultHandler resultHandler, BoundSql boundSql) &#123;\n    ResultSetHandler resultSetHandler &#x3D; new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);\n    resultSetHandler &#x3D; (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);\n    return resultSetHandler;\n  &#125;</code></pre>\n\n\n\n<h3 id=\"4-Mybatis查询过程\"><a href=\"#4-Mybatis查询过程\" class=\"headerlink\" title=\"4. Mybatis查询过程\"></a>4. Mybatis查询过程</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">1.根据配置文件(全局，sql映射)初始化出Configuration对象\n\n2.创建一个DefaultSqlSession对象，它里面包含Configuration以及Executor(根据全局配置文件的defaultExecutorType创建出对应的Executor)\n\n3.DefaultSqlSession.getMapper()拿到Mapper接口对应的MapperProxy\n\n4.MapperProxy里面有DefaultSqlSession\n\n5.执行增删改查方法：\n    (代理对象)调用DefaultSqlSession的增删改查(Executor)\n    创建一个StatementHandler对象，同时也创建ParameterHandler和ResultSetHandler\n    调用StatementHandler的预编译参数（使用ParameterHandler设置参数值）\n    调用StatementHandler的增删改查方法\n    ResultSetHandler封装结果</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意</p>\n<p>四大对象每个创建的时候都有一个interceptorChain.pluginAll(parameterHandler),每个对象不是直接返回的，而是调用</p>\n<p>interceptorChain.pluginAll()，获取到所有的Interceptor，调用interceptor.plugin(target)，返回target包装后的对象</p></blockquote>\n<p>插件机制：可以使用插件为目标对象创建一个代理对象，代理对象会拦截每一个对象的执行。</p>\n<h3 id=\"5-Mybatis插件机制\"><a href=\"#5-Mybatis插件机制\" class=\"headerlink\" title=\"5. Mybatis插件机制\"></a>5. Mybatis插件机制</h3><h4 id=\"5-1-Mybatis插件原理\"><a href=\"#5-1-Mybatis插件原理\" class=\"headerlink\" title=\"5.1 Mybatis插件原理\"></a>5.1 Mybatis插件原理</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">1.Mybatis的插件借助于责任链的模式进行对拦截的处理\n\n2.使用动态代理对目标对象进行包装，达到拦截的目的\n\n3.作用于Mybatis的作用域对象之上</code></pre>\n\n<p>以ParameterHandler 来说</p>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object object, BoundSql sql, InterceptorChain interceptorChain)&#123;\n       ParameterHandler parameterHandler &#x3D; mappedStatement.getLang().createParameterHandler(mappedStatement,object,sql);\n       parameterHandler &#x3D; (ParameterHandler) interceptorChain.pluginAll(parameterHandler);\n       return parameterHandler;\n   &#125;</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public Object pluginAll(Object target) &#123;\n    for (Interceptor interceptor : interceptors) &#123;\n      target &#x3D; interceptor.plugin(target);\n    &#125;\n    return target;\n  &#125;</code></pre>\n\n<p>interceptorChain 保存了所有的拦截器(interceptors)，是mybatis初始化的时候创建的。调用拦截器链中的拦截器依次的对目标进行拦截或增强。interceptor.plugin(target)中的target就可以理解为mybatis中的四大对象。返回的target是被重重代理后的对象。</p>\n<h4 id=\"5-2-Mybatis插件接口-Interceptor\"><a href=\"#5-2-Mybatis插件接口-Interceptor\" class=\"headerlink\" title=\"5.2 Mybatis插件接口-Interceptor\"></a>5.2 Mybatis插件接口-Interceptor</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">1.Intercept方法，插件的核心方法\n\n2.使plugin方法，生成target的代理对象\n\n3.setProperties方法，传递插件所需参数</code></pre>\n\n<h4 id=\"5-3-总结\"><a href=\"#5-3-总结\" class=\"headerlink\" title=\"5.3 总结\"></a>5.3 总结</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">1.遵循插件尽量不使用的原则，因为会修改底层设计\n\n2.插件是生成的层层代理对象的责任链模式，使用反射机制实现\n\n3.插件的编写要考虑全面，特别是多个插件层层代理的时候</code></pre>\n\n\n\n<h3 id=\"6-Mybatis总结\"><a href=\"#6-Mybatis总结\" class=\"headerlink\" title=\"6. Mybatis总结\"></a>6. Mybatis总结</h3><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/mybatis-all.png\" alt=\"iamges\"></p>\n<ul>\n<li>Mybatis环境所需依赖 ★</li>\n<li>配置<ul>\n<li>Mybatis全局配置</li>\n<li>Mapper配置 ★</li>\n</ul>\n</li>\n<li>Mapper接口 ★</li>\n<li>API<ul>\n<li>SqlSessionFactory</li>\n<li>SqlSession</li>\n</ul>\n</li>\n<li>MBG ★</li>\n<li>缓存<ul>\n<li>一级缓存</li>\n<li>二级缓存<ul>\n<li>自带</li>\n<li>EHCache ☆</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>原理<ul>\n<li>把配置文件信息封装到Java对象中</li>\n<li>缓存底层机制</li>\n<li>四大接口</li>\n<li>Mybatis底层是JDBC</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"7-Mybatis思维导图\"><a href=\"#7-Mybatis思维导图\" class=\"headerlink\" title=\"7. Mybatis思维导图\"></a>7. Mybatis思维导图</h3><p><a href=\"../6_xmind/Mybatis.xmind\">总结的xmind思维导图</a></p>\n","text":"1. 装饰器模式装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。 ...","link":"","photos":[],"count_time":{"symbolsCount":"7.7k","symbolsTime":"7 mins."},"categories":[{"name":"Mybatis","slug":"Mybatis","count":6,"path":"api/categories/Mybatis.json"}],"tags":[{"name":"Mybatis","slug":"Mybatis","count":6,"path":"api/tags/Mybatis.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">1. 装饰器模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">1.1 介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA\"><span class=\"toc-text\">1.2 案例演示</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">1.3 实现代码</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-4-%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">1.4 测试结果</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">2. 装饰模式小结</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-Mybatis%E5%9B%9B%E5%A4%A7%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">3. Mybatis四大对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">3.1 概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-%E5%85%B7%E4%BD%93\"><span class=\"toc-text\">3.2 具体</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-3-Executor\"><span class=\"toc-text\">3.3 Executor</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-4-StatementHandler\"><span class=\"toc-text\">3.4 StatementHandler</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-5-ParameterHandler\"><span class=\"toc-text\">3.5 ParameterHandler</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-6-ResultSetHandler\"><span class=\"toc-text\">3.6 ResultSetHandler</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-Mybatis%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">4. Mybatis查询过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-Mybatis%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">5. Mybatis插件机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-Mybatis%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">5.1 Mybatis插件原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-2-Mybatis%E6%8F%92%E4%BB%B6%E6%8E%A5%E5%8F%A3-Interceptor\"><span class=\"toc-text\">5.2 Mybatis插件接口-Interceptor</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-3-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">5.3 总结</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-Mybatis%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">6. Mybatis总结</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-Mybatis%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE\"><span class=\"toc-text\">7. Mybatis思维导图</span></a></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"Mybatis 逆向工程","uid":"cd7729b360a46c66a0dd34df45ad5b41","slug":"48-Mybatis-逆向工程","date":"2021-09-13T15:25:32.000Z","updated":"2021-09-15T10:51:17.974Z","comments":true,"path":"api/articles/48-Mybatis-逆向工程.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog9.jpg","text":"8. 补充（逆向工程）8.1 概念概念 正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的。 逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源： Java实体类 Mapper接口 Mapper配置文件 8.2 基...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"Mybatis","slug":"Mybatis","count":6,"path":"api/categories/Mybatis.json"}],"tags":[{"name":"Mybatis","slug":"Mybatis","count":6,"path":"api/tags/Mybatis.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"Mybatis 延迟缓存","uid":"381bed42b31a39fe0a5eda0244c8a085","slug":"46-Mybatis-延迟缓存","date":"2021-09-13T15:23:32.000Z","updated":"2021-09-15T10:51:42.422Z","comments":true,"path":"api/articles/46-Mybatis-延迟缓存.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"1. 延迟加载延迟加载：先从单表查询、需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。也叫懒加载。 resultMap可以实现高级映射（使用&#96;association&#96;、&#96;collection&#96;实现一对一及一对...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"Mybatis","slug":"Mybatis","count":6,"path":"api/categories/Mybatis.json"}],"tags":[{"name":"Mybatis","slug":"Mybatis","count":6,"path":"api/tags/Mybatis.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}