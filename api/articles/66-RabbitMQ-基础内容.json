{"title":"RabbitMQ 基础内容","uid":"c45f5a44aa5e1bceb86c7aa31b1d0a34","slug":"66-RabbitMQ-基础内容","date":"2021-09-13T15:42:32.000Z","updated":"2021-09-15T10:46:48.980Z","comments":true,"path":"api/articles/66-RabbitMQ-基础内容.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog10.jpg","content":"<h4 id=\"01、什么是消息中间件\"><a href=\"#01、什么是消息中间件\" class=\"headerlink\" title=\"01、什么是消息中间件\"></a>01、什么是消息中间件</h4><p>MQ全称为Message Queue， 消息队列(MQ)是一种应用程序对应用程序的通信方法。</p>\n<p>介绍：消息队列就是基础数据结构中的 “先进先出” 的一种数据机构。想一下，生活中买东西，需要排队，先排的人先买消费，就是典型的“先进先出”。</p>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/RabbitMQ-1.png\" alt=\"image-20210810092149258\" style=\"zoom:80%;\" />\n</div>\n\n<ul>\n<li>消息传递：指的是程序之间通过消息发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。</li>\n<li>排队：指的是应用程序通过队列来通信。队列 的主要作用是 ==消除高并发访问高峰，加快网站的响应速度==。</li>\n<li>业务场景说明：为什么会产生消息队列？<ul>\n<li>在不使用消息队列的情况下，用户的请求数据直接写入数据库，在高并发的情况下，会对数据库造成巨大的压力，同时也使得系统响应延迟加剧</li>\n<li>不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个；</li>\n<li>不同进程（process）之间传递消息时，为了实现标准化，将消息的格式规范化了，并且，某一个进程接受的消息太多，一下子无法处理完，并且也有先后顺序，必须对收到的消息进行排队，因此诞生了事实上的消息队列；</li>\n</ul>\n</li>\n</ul>\n<p>:star: 在项目中，可将一些无需即时返回且耗时的操作提取出来，进行<strong>异步处理</strong>，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而<strong>提高</strong>了<strong>系统</strong>的<strong>吞吐量</strong>。</p>\n<p>:star: ==“消息队列(Message Queue)” 是在消息的传输过程中保存消息的容器==。在消息队列中，通常有生产者和消费者两个角色。生产者只负责发送数据到消息队列，谁从消息队列中取出数据处理，他不管。消费者只负责从消息队列中取出数据处理，他不管这是谁发送的数据。</p>\n<h4 id=\"02、为什么使用消息队列\"><a href=\"#02、为什么使用消息队列\" class=\"headerlink\" title=\"02、为什么使用消息队列\"></a>02、为什么使用消息队列</h4><p>:star: 解耦</p>\n<p>如图所示。假设有系统B、C、D都需要系统A的数据，于是系统A调用三个方法发送数据到B、C、D。这时，系统D不需要了，那就需要在系统A把相关的代码删掉。假设这时有个新的系统E需要数据，这时系统A又要增加调用系统E的代码。为了降低这种强耦合，就可以使用MQ，<strong>系统A只需要把数据发送到MQ，其他系统如果需要数据，则从MQ中获取即可</strong>。</p>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-2.png\" alt=\"image-20210810101110433\" style=\"zoom:55%;\" />\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-3.png\" alt=\"image-20210810101543252\" style=\"zoom: 55%;\" />\n</div>\n\n\n\n<p>:star: 异步</p>\n<p>如图所示。一个客户端请求发送进来，系统A会调用系统B、C、D三个系统，同步请求的话，响应时间就是系统A、B、C、D的总和，也就是 500ms。<strong>如果使用MQ，系统A发送数据到MQ，然后就可以返回响应给客户端，不需要再等待系统B、C、D的响应，可以大大地提高性能</strong>。对于一些非必要的业务，比如发送短信，发送邮件等等，就可以采用MQ。</p>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-24.png\" alt=\"image-20210810163453782\" style=\"zoom:80%;\" />\n</div>\n\n\n\n\n<p>:star: 削峰</p>\n<p>如图所示。这其实是MQ一个很重要的应用。假设系统A在某一段时间请求数暴增，有5000个请求发送过来，系统A这时就会发送5000条SQL进入MySQL进行执行，MySQL对于如此庞大的请求当然处理不过来，MySQL就会崩溃，导致系统瘫痪。<strong>如果使用MQ，系统A不再是直接发送SQL到数据库，而是把数据发送到MQ，MQ短时间积压数据是可以接受的，然后由消费者每次拉取2000条进行处理，防止在请求峰值时期大量的请求直接发送到MySQL导致系统崩溃</strong>。</p>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-17.png\" alt=\"image-20210810162309646\" style=\"zoom:59%;\" />\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-23.png\" alt=\"image-20210810162843379\" style=\"zoom:59%;\" />\n</div>\n\n\n\n<h4 id=\"03、什么是QPS-PV-UV-PR\"><a href=\"#03、什么是QPS-PV-UV-PR\" class=\"headerlink\" title=\"03、什么是QPS PV UV PR\"></a>03、什么是QPS PV UV PR</h4><p>QPS即每秒查询率，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。</p>\n<ul>\n<li><p>每秒查询率</p>\n<p>因特网上，经常用每秒查询率来衡量域名系统服务器的机器的性能，即为QPS。</p>\n<p>或者理解：每秒的响应请求数，也即是最大吞吐能力。</p>\n</li>\n<li><p>计算关系</p>\n<p>QPS = 并发量 / 平均响应时间</p>\n<p>并发量 = QPS * 平均响应时间</p>\n</li>\n</ul>\n<p>原理：每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间。</p>\n<p>公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS) 。</p>\n<p>机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器 </p>\n<p>① 什么是pv　　</p>\n<p>PV(page view)，即页面浏览量，或点击量；通常是衡量一个网络新闻频道或网站甚至一条网络新闻的主要指标。</p>\n<p>对pv的解释是，一个访问者在24小时(0点到24点)内到底看了你网站几个页面。这里需要强调：同一个人浏览你网站同一个页面，不重复计算pv量，点100次也算1次。说白了，pv就是一个访问者打开了你的几个页面。</p>\n<p>PV之于网站，就像收视率之于电视，从某种程度上已成为投资者衡量商业网站表现的最重要尺度。</p>\n<p>pv的计算：当一个访问者访问的时候，记录他所访问的页面和对应的IP，然后确定这个IP今天访问了这个页面没有。如果你的网站到了23点，单纯IP有60万条的话，每个访问者平均访问了3个页面，那么pv表的记录就要有180万条。</p>\n<p>② 什么是uv</p>\n<p>uv(unique visitor)，指访问某个站点或点击某条新闻的不同IP地址的人数。</p>\n<p>在同一天内，uv只记录第一次进入网站的具有独立IP的访问者，在同一天内再次访问该网站则不计数。独立IP访问者提供了一定时间内不同观众数量的统计指标，而没有反应出网站的全面活动。</p>\n<p>③ 什么是ＰＲ值</p>\n<p>PageRank，网页的级别技术，用来标识网页的等级/重要性。级别从1到10级，10级为满分。PR值越高说明该网页越受欢迎（越重要）。</p>\n<p>例如：一个PR值为1的网站表明这个网站不太具有流行度，而PR值为7到10则表明这个网站非常受欢迎（或者说极其重要）。</p>\n<h4 id=\"04、AMQP-和-JMS\"><a href=\"#04、AMQP-和-JMS\" class=\"headerlink\" title=\"04、AMQP 和 JMS\"></a>04、AMQP 和 JMS</h4><p>MQ是消息通信的模型；实现MQ的大致有两种主流方式：AMQP、JMS。</p>\n<ul>\n<li><p>什么是 AMQP？</p>\n<p>AMQP是一种高级消息队列协议（Advanced Message Queuing Protocol），更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。</p>\n</li>\n<li><p>什么是 JMS？</p>\n<p>JMS即Java消息服务（JavaMessage Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p>\n</li>\n<li><p>AMQP 和 JMS 的区别</p>\n<ul>\n<li> JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式</li>\n<li>JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。</li>\n<li>JMS规定了两种消息模式；而AMQP的消息模式更加丰富</li>\n</ul>\n</li>\n</ul>\n<p>消息队列的产品</p>\n<ul>\n<li>ActiveMQ：基于JMS</li>\n<li>ZeroMQ：基于C语言开发</li>\n<li>RabbitMQ:基于AMQP协议，erlang语言开发，稳定性好</li>\n<li>RocketMQ：基于JMS，阿里巴巴产品</li>\n<li>Kafka：类似MQ的产品；分布式消息系统，高吞吐量</li>\n</ul>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbimq-7.png\" alt=\"img\" style=\"zoom: 33%;\" />\n</div>\n\n\n\n<h4 id=\"05、RabbitMQ-简介\"><a href=\"#05、RabbitMQ-简介\" class=\"headerlink\" title=\"05、RabbitMQ 简介\"></a>05、RabbitMQ 简介</h4><p>RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列</p>\n<p>Advanced Message Queue 高级消息队列协议</p>\n<ul>\n<li><p>是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。</p>\n</li>\n<li><p>是一个网络协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。2006年，AMQP 规范发布。类比HTTP。</p>\n</li>\n</ul>\n<p>RabbitMQ官方地址：<a href=\"http://www.rabbitmq.com/\">http://www.rabbitmq.com/</a> </p>\n<p>RabbitMQ提供了<strong>6种模式</strong>：简单模式，work模式，Publish/Subscribe发布与订阅模式，Routing路由模式，Topics主题模式，RPC远程调用模式（远程调用，不太算MQ；暂不作介绍）；</p>\n<p>官网对应模式介绍：<a href=\"https://www.rabbitmq.com/getstarted.html\">https://www.rabbitmq.com/getstarted.html</a> </p>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-8.png\" alt=\"image-20210810134821019\" style=\"zoom: 68%;\" />\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-9.png\" alt=\"image-20210810134922564\" style=\"zoom:68%;\" />\n</div>\n\n\n\n<h4 id=\"06、RabbitMQ-的特点\"><a href=\"#06、RabbitMQ-的特点\" class=\"headerlink\" title=\"06、RabbitMQ 的特点\"></a>06、RabbitMQ 的特点</h4><p>RabbitMQ是一款使用Erlang语言开发的，实现AMQP(高级消息队列协议)的开源消息中间件。首先要知道一些RabbitMQ的特点，<a href=\"https://link.juejin.cn/?target=https://www.rabbitmq.com\">官网</a>可查：</p>\n<ul>\n<li>可靠性。支持持久化，传输确认，发布确认等保证了MQ的可靠性。</li>\n<li>灵活的分发消息策略。这应该是RabbitMQ的一大特点。在消息进入MQ前由Exchange(交换机)进行路由消息。分发消息策略有：简单模式、工作队列模式、发布订阅模式、路由模式、通配符模式。</li>\n<li>支持集群。多台RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker。</li>\n<li>多种协议。RabbitMQ支持多种消息队列协议，比如 STOMP、MQTT 等等。</li>\n<li>支持多种语言客户端。RabbitMQ几乎支持所有常用编程语言，包括 Java、.NET、Ruby 等等。</li>\n<li>可视化管理界面。RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker。</li>\n<li>插件机制。RabbitMQ提供了许多插件，可以通过插件进行扩展，也可以编写自己的插件。</li>\n</ul>\n<h4 id=\"07、RabbitMQ-的基础结构\"><a href=\"#07、RabbitMQ-的基础结构\" class=\"headerlink\" title=\"07、RabbitMQ 的基础结构\"></a>07、RabbitMQ 的基础结构</h4><div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-10.png\" alt=\"image-20210810135212111\" style=\"zoom:80%;\" />\n</div>\n\n<p>:star: RabbitMQ 中的消息发送引入了 Exchange（交换机）的概念，消息的发送首先到达交换机上，然后再根据既定的路由规则，由交换机将消息路由到不同的 Queue（队列）中，再由不同的消费者去消费。</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>组件</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Publisher</td>\n<td>生产者，应用客户端用于向服务端发送消息</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Connection</td>\n<td>连接，生产者与消费者客户端都需要Connection连接消息应用服务端。Connection连接创建、销毁成本太高，衍生轻量级逻辑连接Channel<br/>publisher／consumer 和 broker 之间的 TCP 连接</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Channel</td>\n<td>轻量级逻辑连接，也称之为信道。Channel之间完全隔离，线程安全</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Broker</td>\n<td>消息应用服务主体，客户端写代码不会涉及，相当于一个逻辑上的概念<br/>接收和分发消息的应用，RabbitMQ Server就是 Message Broker</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Virtual Host</td>\n<td>相当于namespace，多用户时每个用户可以在自己分配的Virtual Host区域操作</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Exchange</td>\n<td>消息交换器，生产者不直接与队列耦合，通过交换器进行消息转发</td>\n</tr>\n<tr>\n<td>7</td>\n<td>Binding</td>\n<td>绑定关系，消息交换器与队列之间绑定的关系，通过与生产者传递消息携带的RoutingKey比较得知消息路由转发到哪个绑定队列  <br/>exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据</td>\n</tr>\n<tr>\n<td>8</td>\n<td>Queue</td>\n<td>队列，消息最后储存的位置，等待consumer取走</td>\n</tr>\n<tr>\n<td>9</td>\n<td>Consumer</td>\n<td>消费者，直接通过与队列耦合进行消费，这与生产者具备一定区别</td>\n</tr>\n</tbody></table>\n<h4 id=\"08、RabbitMQ-的安装\"><a href=\"#08、RabbitMQ-的安装\" class=\"headerlink\" title=\"08、RabbitMQ 的安装\"></a>08、RabbitMQ 的安装</h4><p>Centos8，安装Erlang 23、rabbitmq 3.8.9，如果版本不一致的最好绕行，不然会有问题导致安装成功，但不能正常启动，尤其是Erlang版本与Rabbitmq的版本一定要匹配，查看版本匹配情况看这里 <a href=\"https://www.rabbitmq.com/which-erlang.html\">https://www.rabbitmq.com/which-erlang.html</a></p>\n<p>erlang下载地址：<a href=\"https://packagecloud.io/rabbitmq/\">https://packagecloud.io/rabbitmq/</a> （这个里面有erlang，rabbitmq）</p>\n<p>rabbitmq下载地址：<a href=\"https://github.com/rabbitmq/rabbitmq-server/releases?after=v3.8.10\">https://github.com/rabbitmq/rabbitmq-server/releases?after=v3.8.10</a></p>\n<p>下载完成后，将之发送到 Linux 中的 /opt/install 安装程序（自定义的）目录下</p>\n<p>在 Linux 的 /opt/install 目录下，开始安装</p>\n<p><strong>安装 erlang：</strong>[root@localhost install]# yum install erlang-23.3.4-1.el7.x86_64.rpm</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-13.png\" alt=\"image-20210810152454744\"></p>\n<p><strong>安装 rabbitmq：</strong>[root@localhost install]# yum install rabbitmq-server-3.8.9-1.el8.noarch.rpm</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-14.png\" alt=\"image-20210810152624113\"></p>\n<p><strong>安装 web 管理插件</strong>：rabbitmq-plugins enable rabbitmq_management</p>\n<p><strong>启动 rabbitmq：</strong>① service rabbitmq-server start       ② systemctl start rabbitmq-server</p>\n<p><strong>查看 rabbitmq 服务状态：</strong>① service rabbitmq-server status    ② systemctl status rabbitmq-server</p>\n<p><strong>关闭 rabbitmq：</strong>① service rabbitmq-server stop    ② systemctl stoprabbitmq-server</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-15.png\" alt=\"image-20210810153228890\"></p>\n<p><strong>关闭防火墙，外部浏览器访问：</strong><a href=\"http://192.168.96.66:15672/\">http://192.168.96.66:15672</a></p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-16.png\" alt=\"image-20210810153417717\"></p>\n<p><strong>增加自定义账号</strong></p>\n<ul>\n<li>添加管理员账号密码：rabbitmqctl add_user admin admin</li>\n<li>分配账号角色：rabbitmqctl set_user_tags admin administrator</li>\n<li>修改密码：rabbitmqctl change_password admin 123456</li>\n<li>查看用户列表：rabbitmqctl list_users</li>\n</ul>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-18.png\" alt=\"image-20210810153919657\"></p>\n<p><strong>rabbitmq 端口表示</strong></p>\n<ul>\n<li>5672：rabbitMq 的编程语言客户端连接端口</li>\n<li>15672：rabbitMq 管理界面端口</li>\n<li>25672：rabbitMq 集群的端口</li>\n</ul>\n<p><strong>rabbitmq 卸载</strong></p>\n<ul>\n<li>rpm -qa | grep rabbitmq</li>\n<li>rpm -e rabbitmq-server</li>\n</ul>\n<h4 id=\"09、RabbitMQ-浏览器界面\"><a href=\"#09、RabbitMQ-浏览器界面\" class=\"headerlink\" title=\"09、RabbitMQ 浏览器界面\"></a>09、RabbitMQ 浏览器界面</h4><h5 id=\"9-1、rabbitmq-客户端登录成功页面\"><a href=\"#9-1、rabbitmq-客户端登录成功页面\" class=\"headerlink\" title=\"9.1、rabbitmq 客户端登录成功页面\"></a>9.1、rabbitmq 客户端登录成功页面</h5><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbit-19.png\" alt=\"image-20210810154045499\"></p>\n<h5 id=\"9-2、rabbitmq-客户端页面信息解析\"><a href=\"#9-2、rabbitmq-客户端页面信息解析\" class=\"headerlink\" title=\"9.2、rabbitmq 客户端页面信息解析\"></a>9.2、rabbitmq 客户端页面信息解析</h5><ul>\n<li>overview：概览</li>\n<li>connections：无论生产者还是消费者，都需要与RabbitMQ建立连接后才可以完成消息的生产和消费，在这里可以查看连接情况</li>\n<li>channels：通道，建立连接后，会形成通道，消息的投递获取依赖通道。</li>\n<li>Exchanges：交换机，用来实现消息的路由</li>\n<li>Queues：队列，即消息队列，消息存放在队列中，等待消费，消费后被移除队列。</li>\n</ul>\n<h5 id=\"9-3、rabbitmq-浏览器中的管理界面\"><a href=\"#9-3、rabbitmq-浏览器中的管理界面\" class=\"headerlink\" title=\"9.3、rabbitmq 浏览器中的管理界面\"></a>9.3、rabbitmq 浏览器中的管理界面</h5><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-20.png\" alt=\"image-20210810155049872\"></p>\n<p>上述添加用户时，需要添加 Tags，右侧是他的几种类型</p>\n<p>1、 超级管理员(administrator)：可登录管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</p>\n<p>2、 监控者(monitoring)：可登录管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</p>\n<p>3、 策略制定者(policymaker)：可登录管理控制台， 同时可以对policy进行管理。但无法查看节点的相关信息。</p>\n<p>4、 普通管理者(management)：仅可登录管理控制台，无法看到节点信息，也无法对策略进行管理。</p>\n<p>5、 其他：无法登录管理控制台，通常就是普通的生产者和消费者。</p>\n<p>==上述途中最右侧圈红的地方，分别是另外几种管理界面，我们讲一讲 virtual hosts==</p>\n<p>1、virtual hosts：虚拟主机，类似于mysql中的database。他们的 名字 都是以 “/” 开头</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-21.png\" alt=\"image-20210810155852725\"></p>\n<p>2、给用户分配虚拟主机的相关权限，点击表格中虚拟主机的名字，可以进入管理界面</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-22.png\" alt=\"image-20210810160229263\"></p>\n<h4 id=\"10、RabbitMQ-入门案例\"><a href=\"#10、RabbitMQ-入门案例\" class=\"headerlink\" title=\"10、RabbitMQ 入门案例\"></a>10、RabbitMQ 入门案例</h4><h5 id=\"1、创建项目\"><a href=\"#1、创建项目\" class=\"headerlink\" title=\"1、创建项目\"></a>1、创建项目</h5><p>① rabbitmq0.1（producer）    ② rabbitmq0.2（consumer）</p>\n<h5 id=\"2、两个项目的-pom-文件中添加依赖\"><a href=\"#2、两个项目的-pom-文件中添加依赖\" class=\"headerlink\" title=\"2、两个项目的 pom 文件中添加依赖\"></a>2、两个项目的 pom 文件中添加依赖</h5><pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.rabbitmq&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;amqp-client&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;5.6.0&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;3.8.0&lt;&#x2F;version&gt;\n            &lt;configuration&gt;\n                &lt;source&gt;1.8&lt;&#x2F;source&gt;\n                &lt;target&gt;1.8&lt;&#x2F;target&gt;\n            &lt;&#x2F;configuration&gt;\n        &lt;&#x2F;plugin&gt;\n    &lt;&#x2F;plugins&gt;\n&lt;&#x2F;build&gt;</code></pre>\n\n<h5 id=\"3、编写生产者\"><a href=\"#3、编写生产者\" class=\"headerlink\" title=\"3、编写生产者\"></a>3、编写生产者</h5><p>com.atguigu.rabbitmq.simple.Producer</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.rabbitmq.simple;\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\nimport java.util.Map;\n\npublic class Producer &#123;\n\n    public static void main(String[] args) throws Exception &#123;\n        &#x2F;&#x2F;创建连接工厂\n        ConnectionFactory connectionFactory &#x3D; new ConnectionFactory();\n        &#x2F;&#x2F;主机地址\n        connectionFactory.setHost(&quot;192.168.137.118&quot;);\n        &#x2F;&#x2F;连接端口;默认为 5672\n        connectionFactory.setPort(5672);\n        &#x2F;&#x2F;虚拟主机名称;默认为 &#x2F;\n        connectionFactory.setVirtualHost(&quot;&#x2F;&quot;);\n        &#x2F;&#x2F;连接用户名；默认为guest\n        connectionFactory.setUsername(&quot;admin&quot;);\n        &#x2F;&#x2F;连接密码；默认为guest\n        connectionFactory.setPassword(&quot;123456&quot;);\n\n        &#x2F;&#x2F;创建连接\n        Connection connection &#x3D; connectionFactory.newConnection();\n\n        &#x2F;&#x2F;创建频道\n        Channel channel &#x3D; connection.createChannel();\n\n        &#x2F;&#x2F; 声明（创建）队列\n        &#x2F;**\n         * queue      参数1：队列名称\n         * durable    参数2：是否定义持久化队列,当mq重启之后,还在\n         * exclusive  参数3：是否独占本次连接\n         *            ① 是否独占,只能有一个消费者监听这个队列\n         *            ② 当connection关闭时,是否删除队列\n         * autoDelete 参数4：是否在不使用的时候自动删除队列,当没有consumer时,自动删除\n         * arguments  参数5：队列其它参数\n         *&#x2F;\n        channel.queueDeclare(&quot;simple_queue&quot;, true, false, false, null);\n\n        &#x2F;&#x2F; 要发送的信息\n        String message &#x3D; &quot;你好；小兔子！&quot;;\n        &#x2F;**\n         * 参数1：交换机名称,如果没有指定则使用默认Default Exchage\n         * 参数2：路由key,简单模式可以传递队列名称\n         * 参数3：配置信息\n         * 参数4：消息内容\n         *&#x2F;\n        channel.basicPublish(&quot;&quot;, &quot;simple_queue&quot;, null, message.getBytes());\n        System.out.println(&quot;已发送消息：&quot; + message);\n\n        &#x2F;&#x2F; 关闭资源\n        channel.close();\n        connection.close();\n    &#125;\n&#125;</code></pre>\n\n<p>运行程序：<a href=\"http://127.0.0.1:15672/\">http://192.168.137.118:15672</a> </p>\n<p>在执行上述的消息发送之后；可以登录rabbitMQ的管理控制台,可以发现队列和其消息：</p>\n<img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-25.png\" alt=\"image-20210810174104905\" style=\"zoom:80%;\" />\n\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-26.png\" alt=\"image-20210810175136549\"></p>\n<h5 id=\"4、编写消费者\"><a href=\"#4、编写消费者\" class=\"headerlink\" title=\"4、编写消费者\"></a>4、编写消费者</h5><p>com.atguigu.rabbitmq.simple.Consumer</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.rabbitmq.simple;\nimport com.rabbitmq.client.*;\nimport java.io.IOException;\nimport java.util.concurrent.TimeoutException;\n\n&#x2F;&#x2F;消费者\npublic class Consumer &#123;\n\n    public static void main(String[] args) throws IOException, TimeoutException &#123;\n        &#x2F;&#x2F;1.创建连接工厂\n        ConnectionFactory connectionFactory &#x3D; new ConnectionFactory();\n\n        &#x2F;&#x2F;2. 设置参数\n        connectionFactory.setHost(&quot;192.168.96.66&quot;);\n        connectionFactory.setPort(5672);\n        connectionFactory.setVirtualHost(&quot;&#x2F;&quot;);\n        connectionFactory.setUsername(&quot;admin&quot;);\n        connectionFactory.setPassword(&quot;admin&quot;);\n\n        &#x2F;&#x2F;3. 创建连接 Connection\n        Connection connection &#x3D; connectionFactory.newConnection();\n\n        &#x2F;&#x2F;4. 创建Channel\n        Channel channel &#x3D; connection.createChannel();\n\n        &#x2F;&#x2F;5. 创建队列Queue\n        &#x2F;*\n        queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)\n        参数：\n            1. queue：队列名称\n            2. durable：是否持久化,当mq重启之后,还在\n            3. exclusive：\n                * 是否独占。只能有一个消费者监听这队列\n                * 当Connection关闭时,是否删除队列\n            4. autoDelete：是否自动删除。当没有Consumer时,自动删除掉\n            5. arguments：参数。\n         *&#x2F;\n        &#x2F;&#x2F;如果没有一个名字叫simple_queue的队列,则会创建该队列,如果有则不会创建\n        channel.queueDeclare(&quot;simple_queue&quot;, true, false, false, null);\n\n        &#x2F;&#x2F; 接收消息\n        DefaultConsumer consumer &#x3D; new DefaultConsumer(channel) &#123;\n            &#x2F;*\n               回调方法,当收到消息后,会自动执行该方法\n               1. consumerTag：标识\n               2. envelope：获取一些信息,交换机,路由key...\n               3. properties：配置信息\n               4. body：数据\n            *&#x2F;\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;\n                System.out.println(&quot;consumerTag：&quot; + consumerTag);\n                System.out.println(&quot;Exchange：&quot; + envelope.getExchange());\n                System.out.println(&quot;RoutingKey：&quot; + envelope.getRoutingKey());\n                System.out.println(&quot;properties：&quot; + properties);\n                System.out.println(&quot;body：&quot; + new String(body));\n                ;\n            &#125;\n        &#125;;\n\n\n        &#x2F;*\n        basicConsume(String queue, boolean autoAck, Consumer callback)\n        参数：\n            1. queue：队列名称\n            2. autoAck：是否自动确认 ,类似咱们发短信,发送成功会收到一个确认消息\n            3. callback：回调对象\n         *&#x2F;\n        &#x2F;&#x2F; 消费者类似一个监听程序,主要是用来监听消息\n        channel.basicConsume(&quot;simple_queue&quot;, true, consumer);\n\n    &#125;\n&#125;</code></pre>\n\n<p>运行程序</p>\n<img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-27.png\" alt=\"image-20210810180419367\" style=\"zoom: 67%;\" />\n\n<h5 id=\"5、小结\"><a href=\"#5、小结\" class=\"headerlink\" title=\"5、小结\"></a>5、小结</h5><p>上述案例使用的是以下简单的模式</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-28.png\" alt=\"image-20210810180521977\"></p>\n<p>在上图的模型中，有以下概念：</p>\n<ul>\n<li>P：生产者，也就是要发送消息的程序</li>\n<li>C：消费者：消息的接受者，会一直等待消息到来。</li>\n<li>queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。</li>\n</ul>\n<h4 id=\"11、AMQP-详解\"><a href=\"#11、AMQP-详解\" class=\"headerlink\" title=\"11、AMQP 详解\"></a>11、AMQP 详解</h4><p>AMQP 一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。</p>\n<p>RabbitMQ 是 AMQP 协议的 Erlang 的实现。（RabbitMQ 的基础结构就是基于 AMQP 协议模型建立的）</p>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>连接Connection</td>\n<td>一个网络连接，比如TCP/IP套接字连接。</td>\n</tr>\n<tr>\n<td>信道Channel</td>\n<td>多路复用连接中的一条独立的双向数据流通道。为会话提供物理传输介质。</td>\n</tr>\n<tr>\n<td>客户端Client</td>\n<td>AMQP连接或者会话的发起者。AMQP是非对称的，客户端生产和消费消息，服务器存储和路由这些消息。</td>\n</tr>\n<tr>\n<td>服务节点Broker</td>\n<td>消息中间件的服务节点；一般情况下可以将一个RabbitMQ Broker看作一台RabbitMQ 服务器。</td>\n</tr>\n<tr>\n<td>端点</td>\n<td>AMQP对话的任意一方。一个AMQP连接包括两个端点（一个是客户端，一个是服务器）。</td>\n</tr>\n<tr>\n<td>消费者Consumer</td>\n<td>一个从消息队列里请求消息的客户端程序。</td>\n</tr>\n<tr>\n<td>生产者Producer</td>\n<td>一个向交换机发布消息的客户端应用程序。</td>\n</tr>\n</tbody></table>\n<h4 id=\"12、RabbitMQ-运转流程\"><a href=\"#12、RabbitMQ-运转流程\" class=\"headerlink\" title=\"12、RabbitMQ 运转流程\"></a>12、RabbitMQ 运转流程</h4><p>在入门案例中：</p>\n<ul>\n<li>生产者发送消息<ul>\n<li>生产者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker；</li>\n<li>声明队列并设置属性；如是否排它，是否持久化，是否自动删除；</li>\n<li>将路由键（空字符串）与队列绑定起来；</li>\n<li>发送消息至RabbitMQ Broker；</li>\n<li>关闭信道；</li>\n<li>关闭连接；</li>\n</ul>\n</li>\n<li>消费者接收消息<ul>\n<li>消费者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker</li>\n<li>向Broker 请求消费相应队列中的消息，设置相应的回调函数；</li>\n<li>等待Broker投递响应队列中的消息，消费者接收消息；</li>\n<li>确认（ack，自动确认）接收到的消息；</li>\n<li>RabbitMQ从队列中删除相应已经被确认的消息；</li>\n<li>关闭信道；</li>\n<li>关闭连接；</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"13、RabbitMQ-工作模式\"><a href=\"#13、RabbitMQ-工作模式\" class=\"headerlink\" title=\"13、RabbitMQ 工作模式\"></a>13、RabbitMQ 工作模式</h4><h5 id=\"13-1、相关概念\"><a href=\"#13-1、相关概念\" class=\"headerlink\" title=\"13.1、相关概念\"></a>13.1、相关概念</h5><table>\n<thead>\n<tr>\n<th>标志</th>\n<th>中文名</th>\n<th>英文名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>P</td>\n<td>生产者</td>\n<td>Producer</td>\n<td>消息的发送者，可以将消息发送到交换机</td>\n</tr>\n<tr>\n<td>C</td>\n<td>消费者</td>\n<td>Consumer</td>\n<td>消息的接收者，从队列中获取消息并进行消费</td>\n</tr>\n<tr>\n<td>X</td>\n<td>交换机</td>\n<td>Exchange</td>\n<td>接收生产者发送的消息，并根据路由键发送给指定队列</td>\n</tr>\n<tr>\n<td>Q</td>\n<td>队列</td>\n<td>Queue</td>\n<td>存储从交换机发来的消息</td>\n</tr>\n<tr>\n<td>type</td>\n<td>交换机类型</td>\n<td>type</td>\n<td>不同类型的交换机转发消息方式不同</td>\n</tr>\n<tr>\n<td>fanout</td>\n<td>发布/订阅模式</td>\n<td>fanout</td>\n<td>广播消息给所有绑定交换机的队列</td>\n</tr>\n<tr>\n<td>direct</td>\n<td>路由模式</td>\n<td>direct</td>\n<td>根据路由键发送消息</td>\n</tr>\n<tr>\n<td>topic</td>\n<td>通配符模式</td>\n<td>topic</td>\n<td>根据路由键的匹配规则发送消息</td>\n</tr>\n</tbody></table>\n<h5 id=\"13-2、simple模式-最简单收发模式\"><a href=\"#13-2、simple模式-最简单收发模式\" class=\"headerlink\" title=\"13.2、simple模式 (最简单收发模式)\"></a>13.2、simple模式 (最简单收发模式)</h5><div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-29.png\" alt=\"(P) - [|||] -> (C)\" style=\"zoom:80%;\" />\n</div>\n\n<p>生产者产生消息，将消息放入队列，使用信道进行发布</p>\n<p>消息的消费者(consumer) 监听 消息队列，如果队列中有消息，就消费，<strong>消息被拿走后，自动从队列中删除</strong>（隐患 消息可能没有被消费者正确处理，已经从队列中消失了，造成消息的丢失，这里可以设置成手动的 ack，但如果设置成手动 ack，处理完后要及时发送ack消息给队列，否则会造成内存溢出）。</p>\n<h5 id=\"13-3、work-queues-工作队列模式\"><a href=\"#13-3、work-queues-工作队列模式\" class=\"headerlink\" title=\"13.3、work queues 工作队列模式\"></a>13.3、work queues 工作队列模式</h5><div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-30.png\" alt=\"img\" style=\"zoom:80%;\" />\n</div>\n\n<p>Work Queues与入门程序的简单模式相比，<strong>多了一个或一些消费端</strong>，多个消费端 共同消费同一个队列中 的消息。C1 C2共同争抢当前的消息队列内容,谁先拿到谁负责消费消息(隐患：高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关(syncronize) 保证一条消息只能被一个消费者使用)。</p>\n<p><strong>应用场景</strong>：对于 任务过重或任务较多情况使用工作队列可以 提高任务处理的速度。例如：短信服务部署多个，只需要有一个节点成功发送即可。</p>\n<h5 id=\"13-4、Publish-Subscribe-模式\"><a href=\"#13-4、Publish-Subscribe-模式\" class=\"headerlink\" title=\"13.4、Publish/Subscribe 模式\"></a>13.4、Publish/Subscribe 模式</h5><p>中文为，发布订阅模式</p>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-31.png\" alt=\"img\" style=\"zoom:80%;\" />\n</div>\n\n<p>而在订阅模型中，多了一个 exchange 角色，而且过程略有变化：</p>\n<ul>\n<li>P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li>\n<li>C：消费者，消息的接受者，会一直等待消息到来。</li>\n<li>Queue：消息队列，接收消息、缓存消息。</li>\n<li>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</li>\n</ul>\n<p><strong>Exchange有常见以下3种类型：</strong></p>\n<ul>\n<li>Fanout：广播，将消息交给所有绑定到交换机的队列</li>\n<li>Direct：定向，把消息交给符合指定routing key 的队列</li>\n<li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li>\n</ul>\n<p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p>\n<p><strong>总结：</strong></p>\n<ul>\n<li>每个消费者监听自己的队列；</li>\n<li>生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，<strong>每个绑定交换机的队列都将接收到消息</strong>。</li>\n<li>而每个消费者读取不同队列的信息，就可以读取到一样的信息或不一样的</li>\n</ul>\n<p><strong>发布订阅模式与工作队列模式的区别</strong></p>\n<ul>\n<li>工作队列模式不用定义交换机，而发布/订阅模式需要定义交换机。</li>\n<li>发布/订阅模式的生产方是面向交换机发送消息，工作队列模式的生产方是面向队列发送消息(底层使用默认交换机)。</li>\n<li>发布/订阅模式需要设置队列和交换机的绑定，工作队列模式不需要设置，实际上工作队列模式会将队列绑 定到默认的交换机 。</li>\n</ul>\n<h5 id=\"13-5、Routing-路由模式\"><a href=\"#13-5、Routing-路由模式\" class=\"headerlink\" title=\"13.5、Routing 路由模式\"></a>13.5、Routing 路由模式</h5><div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-32.png\" alt=\"img\" style=\"zoom:80%;\" />\n</div>\n\n<p>图解：</p>\n<ul>\n<li>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</li>\n<li>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</li>\n<li>C1：消费者，其所在队列指定了需要routing key 为 error 的消息</li>\n<li>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</li>\n</ul>\n<p>1、消息生产者将消息发送给交换机按照路由判断，路由是字符串 (info) 当前产生的消息携带路由字符 (对象的方法)，交换机根据路由的key，只能匹配上路由key对应的消息队列，对应的消费者才能消费消息；(Routing模式要求队列在绑定交换机时要指定routing key，消息会转发到<strong>符合routing key的队列</strong>。)</p>\n<p>2、根据业务功能定义路由字符串</p>\n<p>3、从系统的代码逻辑中获取对应的功能字符串,将消息任务扔到对应的队列中。</p>\n<p>4、业务场景：error 通知；EXCEPTION；错误通知的功能；传统意义的错误通知；客户通知；利用key路由,可以将程序中的错误封装成消息传入到消息队列中,开发者可以自定义消费者,实时接收错误;</p>\n<h5 id=\"13-6、Topic-通配符模式\"><a href=\"#13-6、Topic-通配符模式\" class=\"headerlink\" title=\"13.6、Topic 通配符模式\"></a>13.6、Topic 通配符模式</h5><div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-33.png\" alt=\"img\" style=\"zoom:80%;\" />\n</div>\n\n<p>Topic类型与Direct相比，都是可以根据 RoutingKey 把消息路由转发到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候<strong>使用通配符</strong>！==(相当于路由功能添加模糊匹配)==</p>\n<p>Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert</p>\n<p>通配符规则：</p>\n<ul>\n<li><p>#：匹配一个或多个词</p>\n</li>\n<li><p><em>：匹配不多不少*<em>恰好1个词</em></em></p>\n</li>\n</ul>\n<p>举例：</p>\n<ul>\n<li><p>item.#：能够匹配item.insert.abc 或者 item.insert</p>\n</li>\n<li><p>item.*：只能匹配item.insert</p>\n</li>\n</ul>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-34.png\" alt=\"image-20210810185945439\" style=\"zoom:80%;\" />\n</div>\n\n<p>图解：</p>\n<ul>\n<li>红色Queue：绑定的是usa.# ，因此凡是以 usa.开头的routing key 都会被匹配到</li>\n<li>黄色Queue：绑定的是#.news ，因此凡是以 .news结尾的 routing key 都会被匹配</li>\n</ul>\n<h5 id=\"13-7、总结\"><a href=\"#13-7、总结\" class=\"headerlink\" title=\"13.7、总结\"></a>13.7、总结</h5><p><strong>简单收发模式</strong>：一个生产者、一个消费者，不需要设置交换机（使用默认的交换机）</p>\n<p><strong>工作队列模式</strong>：一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机）</p>\n<p><strong>发布订阅模式</strong>：需要设置类型为fanout的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息发送到绑定的队列</p>\n<p><strong>路由模式</strong>：需要设置类型为direct的交换机，交换机和队列进行绑定，并且指定routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列</p>\n<p><strong>通配符模式</strong>：需要设置类型为topic的交换机，交换机和队列进行绑定，并且指定通配符方式的routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列</p>\n<h4 id=\"14、Spring-整合-RabbitMQ\"><a href=\"#14、Spring-整合-RabbitMQ\" class=\"headerlink\" title=\"14、Spring 整合 RabbitMQ\"></a>14、Spring 整合 RabbitMQ</h4><h5 id=\"1、创建生产者，消费者模块\"><a href=\"#1、创建生产者，消费者模块\" class=\"headerlink\" title=\"1、创建生产者，消费者模块\"></a>1、创建生产者，消费者模块</h5><p>① rabbitmq0.6_spring_producer        ② rabbitmq0.6_spring_consumer</p>\n<h5 id=\"2、给两个模块添加依赖\"><a href=\"#2、给两个模块添加依赖\" class=\"headerlink\" title=\"2、给两个模块添加依赖\"></a>2、给两个模块添加依赖</h5><p>==这里是一样的依赖==</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;5.1.7.RELEASE&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.amqp&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-rabbit&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.1.8.RELEASE&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;4.12&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;5.1.7.RELEASE&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;3.8.0&lt;&#x2F;version&gt;\n            &lt;configuration&gt;\n                &lt;source&gt;1.8&lt;&#x2F;source&gt;\n                &lt;target&gt;1.8&lt;&#x2F;target&gt;\n            &lt;&#x2F;configuration&gt;\n        &lt;&#x2F;plugin&gt;\n    &lt;&#x2F;plugins&gt;\n&lt;&#x2F;build&gt;</code></pre>\n\n<h5 id=\"3、添加-rabbitmq-properties\"><a href=\"#3、添加-rabbitmq-properties\" class=\"headerlink\" title=\"3、添加 rabbitmq.properties\"></a>3、添加 rabbitmq.properties</h5><p>==两个模块都添加==，主要是提取的是创建 ConnectionFactory 的配置信息</p>\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\">rabbitmq.host&#x3D;192.168.96.66\nrabbitmq.port&#x3D;5672\nrabbitmq.username&#x3D;admin\nrabbitmq.password&#x3D;admin\nrabbitmq.virtual-host&#x3D;&#x2F;</code></pre>\n\n<h5 id=\"4、生产者的-spring整合配置\"><a href=\"#4、生产者的-spring整合配置\" class=\"headerlink\" title=\"4、生产者的 spring整合配置\"></a>4、生产者的 spring整合配置</h5><pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:rabbit&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;rabbit&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context\n       https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;rabbit\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;rabbit&#x2F;spring-rabbit.xsd&quot;&gt;\n    &lt;!--加载配置文件--&gt;\n    &lt;context:property-placeholder location&#x3D;&quot;classpath:rabbitmq.properties&quot;&#x2F;&gt;\n\n    &lt;!-- 定义rabbitmq connectionFactory --&gt;\n    &lt;rabbit:connection-factory id&#x3D;&quot;connectionFactory&quot; host&#x3D;&quot;$&#123;rabbitmq.host&#125;&quot;\n                               port&#x3D;&quot;$&#123;rabbitmq.port&#125;&quot;\n                               username&#x3D;&quot;$&#123;rabbitmq.username&#125;&quot;\n                               password&#x3D;&quot;$&#123;rabbitmq.password&#125;&quot;\n                               virtual-host&#x3D;&quot;$&#123;rabbitmq.virtual-host&#125;&quot;&#x2F;&gt;\n    &lt;!--定义管理交换机、队列--&gt;\n    &lt;rabbit:admin connection-factory&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;\n\n    &lt;!--定义持久化队列,不存在则自动创建；不绑定到交换机则绑定到默认交换机\n    默认交换机类型为direct,名字为：&quot;&quot;,路由键为队列的名称\n    --&gt;\n    &lt;rabbit:queue id&#x3D;&quot;spring_queue&quot; name&#x3D;&quot;spring_queue&quot; auto-declare&#x3D;&quot;true&quot;&#x2F;&gt;\n\n    &lt;!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~广播；所有队列都能收到消息~~~~~~~~~~~~~~~~~~~~~~~~~~~~ --&gt;\n    &lt;!--定义广播交换机中的持久化队列,不存在则自动创建--&gt;\n    &lt;rabbit:queue id&#x3D;&quot;spring_fanout_queue_1&quot; name&#x3D;&quot;spring_fanout_queue_1&quot; auto-declare&#x3D;&quot;true&quot;&#x2F;&gt;\n\n    &lt;!--定义广播交换机中的持久化队列,不存在则自动创建--&gt;\n    &lt;rabbit:queue id&#x3D;&quot;spring_fanout_queue_2&quot; name&#x3D;&quot;spring_fanout_queue_2&quot; auto-declare&#x3D;&quot;true&quot;&#x2F;&gt;\n\n    &lt;!--定义广播类型交换机；并绑定上述两个队列--&gt;\n    &lt;rabbit:fanout-exchange id&#x3D;&quot;spring_fanout_exchange&quot; name&#x3D;&quot;spring_fanout_exchange&quot; auto-declare&#x3D;&quot;true&quot;&gt;\n        &lt;rabbit:bindings&gt;\n            &lt;rabbit:binding queue&#x3D;&quot;spring_fanout_queue_1&quot;&#x2F;&gt;\n            &lt;rabbit:binding queue&#x3D;&quot;spring_fanout_queue_2&quot;&#x2F;&gt;\n        &lt;&#x2F;rabbit:bindings&gt;\n    &lt;&#x2F;rabbit:fanout-exchange&gt;\n\n    &lt;!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~通配符；*匹配一个单词,#匹配多个单词 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ --&gt;\n    &lt;!--定义广播交换机中的持久化队列,不存在则自动创建--&gt;\n    &lt;rabbit:queue id&#x3D;&quot;spring_topic_queue_star&quot; name&#x3D;&quot;spring_topic_queue_star&quot; auto-declare&#x3D;&quot;true&quot;&#x2F;&gt;\n    &lt;!--定义广播交换机中的持久化队列,不存在则自动创建--&gt;\n    &lt;rabbit:queue id&#x3D;&quot;spring_topic_queue_well&quot; name&#x3D;&quot;spring_topic_queue_well&quot; auto-declare&#x3D;&quot;true&quot;&#x2F;&gt;\n    &lt;!--定义广播交换机中的持久化队列,不存在则自动创建--&gt;\n    &lt;rabbit:queue id&#x3D;&quot;spring_topic_queue_well2&quot; name&#x3D;&quot;spring_topic_queue_well2&quot; auto-declare&#x3D;&quot;true&quot;&#x2F;&gt;\n\n    &lt;rabbit:topic-exchange id&#x3D;&quot;spring_topic_exchange&quot; name&#x3D;&quot;spring_topic_exchange&quot; auto-declare&#x3D;&quot;true&quot;&gt;\n        &lt;rabbit:bindings&gt;\n            &lt;rabbit:binding pattern&#x3D;&quot;atguigu.*&quot; queue&#x3D;&quot;spring_topic_queue_star&quot;&#x2F;&gt;\n            &lt;rabbit:binding pattern&#x3D;&quot;atguigu.#&quot; queue&#x3D;&quot;spring_topic_queue_well&quot;&#x2F;&gt;\n            &lt;rabbit:binding pattern&#x3D;&quot;guigu.#&quot; queue&#x3D;&quot;spring_topic_queue_well2&quot;&#x2F;&gt;\n        &lt;&#x2F;rabbit:bindings&gt;\n    &lt;&#x2F;rabbit:topic-exchange&gt;\n\n    &lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt;\n    &lt;rabbit:template id&#x3D;&quot;rabbitTemplate&quot; connection-factory&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;\n&lt;&#x2F;beans&gt;</code></pre>\n\n<h5 id=\"5、消费者的-spring整合配置\"><a href=\"#5、消费者的-spring整合配置\" class=\"headerlink\" title=\"5、消费者的 spring整合配置\"></a>5、消费者的 spring整合配置</h5><pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:rabbit&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;rabbit&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;rabbit http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;rabbit&#x2F;spring-rabbit.xsd&quot;&gt;\n    &lt;context:property-placeholder location&#x3D;&quot;classpath:rabbitmq.properties&quot;&#x2F;&gt;\n\n    &lt;rabbit:connection-factory id&#x3D;&quot;connectionFactory&quot;  host&#x3D;&quot;$&#123;rabbitmq.host&#125;&quot;\n                               port&#x3D;&quot;$&#123;rabbitmq.port&#125;&quot;\n                               virtual-host&#x3D;&quot;$&#123;rabbitmq.virtual-host&#125;&quot;\n                               username&#x3D;&quot;$&#123;rabbitmq.username&#125;&quot;\n                               password&#x3D;&quot;$&#123;rabbitmq.password&#125;&quot;&#x2F;&gt;\n\n    &lt;!--如果mq中有了下面监听容器中的队列，则会根据这些bean对象，调用相关类中的方法，对消息进行消费--&gt;\n    &lt;bean id&#x3D;&quot;springQueueListener&quot; class&#x3D;&quot;com.atguigu.rabbitmq.listener.SpringQueueListener&quot;&#x2F;&gt;\n    &lt;bean id&#x3D;&quot;fanoutListener1&quot; class&#x3D;&quot;com.atguigu.rabbitmq.listener.FanoutListener1&quot;&#x2F;&gt;\n    &lt;bean id&#x3D;&quot;fanoutListener2&quot; class&#x3D;&quot;com.atguigu.rabbitmq.listener.FanoutListener2&quot;&#x2F;&gt;\n    &lt;bean id&#x3D;&quot;topicListenerStar&quot; class&#x3D;&quot;com.atguigu.rabbitmq.listener.TopicListenerStar&quot;&#x2F;&gt;\n    &lt;bean id&#x3D;&quot;topicListenerWell&quot; class&#x3D;&quot;com.atguigu.rabbitmq.listener.TopicListenerWell&quot;&#x2F;&gt;\n    &lt;bean id&#x3D;&quot;topicListenerWell2&quot; class&#x3D;&quot;com.atguigu.rabbitmq.listener.TopicListenerWell2&quot;&#x2F;&gt;\n\n    &lt;!--创建消息监听容器，监听所有的队列，并进行相关队列的消息消费代码--&gt;\n    &lt;rabbit:listener-container connection-factory&#x3D;&quot;connectionFactory&quot; auto-declare&#x3D;&quot;true&quot;&gt;\n        &lt;rabbit:listener ref&#x3D;&quot;springQueueListener&quot; queue-names&#x3D;&quot;spring_queue&quot;&#x2F;&gt;\n        &lt;rabbit:listener ref&#x3D;&quot;fanoutListener1&quot; queue-names&#x3D;&quot;spring_fanout_queue_1&quot;&#x2F;&gt;\n        &lt;rabbit:listener ref&#x3D;&quot;fanoutListener2&quot; queue-names&#x3D;&quot;spring_fanout_queue_2&quot;&#x2F;&gt;\n        &lt;rabbit:listener ref&#x3D;&quot;topicListenerStar&quot; queue-names&#x3D;&quot;spring_topic_queue_star&quot;&#x2F;&gt;\n        &lt;rabbit:listener ref&#x3D;&quot;topicListenerWell&quot; queue-names&#x3D;&quot;spring_topic_queue_well&quot;&#x2F;&gt;\n        &lt;rabbit:listener ref&#x3D;&quot;topicListenerWell2&quot; queue-names&#x3D;&quot;spring_topic_queue_well2&quot;&#x2F;&gt;\n    &lt;&#x2F;rabbit:listener-container&gt;\n&lt;&#x2F;beans&gt;</code></pre>\n\n<h5 id=\"6、创建各个-消息监听器\"><a href=\"#6、创建各个-消息监听器\" class=\"headerlink\" title=\"6、创建各个 消息监听器\"></a>6、创建各个 消息监听器</h5><h6 id=\"6-1、队列监听器\"><a href=\"#6-1、队列监听器\" class=\"headerlink\" title=\"6.1、队列监听器\"></a>6.1、队列监听器</h6><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.rabbitmq.listener;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.core.MessageListener;\n\npublic class SpringQueueListener implements MessageListener &#123;\n    public void onMessage(Message message) &#123;\n        try &#123;\n            String msg &#x3D; new String(message.getBody(), &quot;utf-8&quot;);\n\n            System.out.printf(&quot;接收路由名称为：%s,路由键为：%s,队列名为：%s的消息：%s \\n&quot;,\n                    message.getMessageProperties().getReceivedExchange(),\n                    message.getMessageProperties().getReceivedRoutingKey(),\n                    message.getMessageProperties().getConsumerQueue(),\n                    msg);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h6 id=\"6-2、广播监听器-1\"><a href=\"#6-2、广播监听器-1\" class=\"headerlink\" title=\"6.2、广播监听器 1\"></a>6.2、广播监听器 1</h6><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class FanoutListener1 implements MessageListener &#123;\n    public void onMessage(Message message) &#123;\n        try &#123;\n            String msg &#x3D; new String(message.getBody(), &quot;utf-8&quot;);\n\n            System.out.printf(&quot;广播监听器1：接收路由名称为：%s,路由键为：%s,队列名为：%s的消息：%s \\n&quot;,\n                    message.getMessageProperties().getReceivedExchange(),\n                    message.getMessageProperties().getReceivedRoutingKey(),\n                    message.getMessageProperties().getConsumerQueue(),\n                    msg);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h6 id=\"6-3、广播监听器-2\"><a href=\"#6-3、广播监听器-2\" class=\"headerlink\" title=\"6.3、广播监听器 2\"></a>6.3、广播监听器 2</h6><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class FanoutListener2 implements MessageListener &#123;\n    public void onMessage(Message message) &#123;\n        try &#123;\n            String msg &#x3D; new String(message.getBody(), &quot;utf-8&quot;);\n\n            System.out.printf(&quot;广播监听器2：接收路由名称为：%s,路由键为：%s,队列名为：%s的消息：%s \\n&quot;,\n                    message.getMessageProperties().getReceivedExchange(),\n                    message.getMessageProperties().getReceivedRoutingKey(),\n                    message.getMessageProperties().getConsumerQueue(),\n                    msg);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h6 id=\"6-4、-号通配符监听器\"><a href=\"#6-4、-号通配符监听器\" class=\"headerlink\" title=\"6.4、* 号通配符监听器\"></a>6.4、* 号通配符监听器</h6><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TopicListenerStar implements MessageListener &#123;\n    public void onMessage(Message message) &#123;\n        try &#123;\n            String msg &#x3D; new String(message.getBody(), &quot;utf-8&quot;);\n\n            System.out.printf(&quot;通配符*监听器：接收路由名称为：%s,路由键为：%s,队列名为：%s的消息：%s \\n&quot;,\n                    message.getMessageProperties().getReceivedExchange(),\n                    message.getMessageProperties().getReceivedRoutingKey(),\n                    message.getMessageProperties().getConsumerQueue(),\n                    msg);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h6 id=\"6-5、-号通配符监听器-1\"><a href=\"#6-5、-号通配符监听器-1\" class=\"headerlink\" title=\"6.5、# 号通配符监听器 1\"></a>6.5、# 号通配符监听器 1</h6><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TopicListenerWell implements MessageListener &#123;\n    public void onMessage(Message message) &#123;\n        try &#123;\n            String msg &#x3D; new String(message.getBody(), &quot;utf-8&quot;);\n\n            System.out.printf(&quot;通配符#监听器：接收路由名称为：%s,路由键为：%s,队列名为：%s的消息：%s \\n&quot;,\n                    message.getMessageProperties().getReceivedExchange(),\n                    message.getMessageProperties().getReceivedRoutingKey(),\n                    message.getMessageProperties().getConsumerQueue(),\n                    msg);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h6 id=\"6-6、-号通配符监听器-2\"><a href=\"#6-6、-号通配符监听器-2\" class=\"headerlink\" title=\"6.6、# 号通配符监听器 2\"></a>6.6、# 号通配符监听器 2</h6><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TopicListenerWell2 implements MessageListener &#123;\n    public void onMessage(Message message) &#123;\n        try &#123;\n            String msg &#x3D; new String(message.getBody(), &quot;utf-8&quot;);\n\n            System.out.printf(&quot;通配符#监听器2：接收路由名称为：%s,路由键为：%s,队列名为：%s的消息：%s \\n&quot;,\n                    message.getMessageProperties().getReceivedExchange(),\n                    message.getMessageProperties().getReceivedRoutingKey(),\n                    message.getMessageProperties().getConsumerQueue(),\n                    msg);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h5 id=\"7、创建-生产者测试方法\"><a href=\"#7、创建-生产者测试方法\" class=\"headerlink\" title=\"7、创建 生产者测试方法\"></a>7、创建 生产者测试方法</h5><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.amqp.rabbit.core.RabbitTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringRunner;\n\n&#x2F;**\n * @author hrenxiang\n * @create 2021&#x2F;8&#x2F;10 20:20\n *&#x2F;\n@RunWith(SpringRunner.class)\n@ContextConfiguration(locations &#x3D; &quot;classpath:spring-rabbit.xml&quot;)\npublic class ProducerTest &#123;\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    &#x2F;**\n     * 只发队列消息\n     * 默认交换机类型为 direct\n     * 交换机的名称为空,路由键为队列的名称\n     *&#x2F;\n    @Test\n    public void queueTest() &#123;\n        &#x2F;&#x2F;路由键与队列同名\n        rabbitTemplate.convertAndSend(&quot;spring_queue&quot;, &quot;只发队列spring_queue的消息。&quot;);\n    &#125;\n\n    &#x2F;**\n     * 发送广播\n     * 交换机类型为 fanout\n     * 绑定到该交换机的所有队列都能够收到消息\n     *&#x2F;\n    @Test\n    public void fanoutTest() &#123;\n        &#x2F;**\n         * 参数1：交换机名称\n         * 参数2：路由键名（广播设置为空）\n         * 参数3：发送的消息内容\n         *&#x2F;\n        rabbitTemplate.convertAndSend(&quot;spring_fanout_exchange&quot;, &quot;&quot;, &quot;发送到spring_fanout_exchange交换机的广播消息&quot;);\n    &#125;\n\n    &#x2F;**\n     * 通配符\n     * 交换机类型为 topic\n     * 匹配路由键的通配符,*表示一个单词,#表示多个单词\n     * 绑定到该交换机的匹配队列能够收到对应消息\n     *&#x2F;\n    @Test\n    public void topicTest() &#123;\n        &#x2F;**\n         * 参数1：交换机名称\n         * 参数2：路由键名\n         * 参数3：发送的消息内容\n         *&#x2F;\n        rabbitTemplate.convertAndSend(&quot;spring_topic_exchange&quot;, &quot;atguigu.bj&quot;, &quot;发送到spring_topic_exchange交换机atguigu.bj的消息&quot;);\n        rabbitTemplate.convertAndSend(&quot;spring_topic_exchange&quot;, &quot;atguigu.bj.1&quot;, &quot;发送到spring_topic_exchange交换机atguigu.bj.1的消息&quot;);\n        rabbitTemplate.convertAndSend(&quot;spring_topic_exchange&quot;, &quot;atguigu.bj.2&quot;, &quot;发送到spring_topic_exchange交换机atguigu.bj.2的消息&quot;);\n        rabbitTemplate.convertAndSend(&quot;spring_topic_exchange&quot;, &quot;guigu.cn&quot;, &quot;发送到spring_topic_exchange交换机guigu.cn的消息&quot;);\n    &#125;\n&#125;\n</code></pre>\n\n<p>我们编写 生产者的测试类完成后，我们直接运行第一个测试方法，我们发现运行完成后，管理界面具有我们配置文件中所有的 队列信息</p>\n<p>并且也只有 一个方法中有信息，因为我们只给spring_queue队列发送了信息</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/rabbitmq-35.png\" alt=\"image-20210810212142449\"></p>\n<h5 id=\"8、创建-消费者的测试方法\"><a href=\"#8、创建-消费者的测试方法\" class=\"headerlink\" title=\"8、创建 消费者的测试方法\"></a>8、创建 消费者的测试方法</h5><p>消费者的测试方法，并没有进行相关的调用，这是因为 我们已经监听了消息队列，如果队列中有值存在，那我们的监听类中的方法会立即运行，根本不需要我们自己去调用</p>\n<p>:chestnut: 举个例子：我们注册账号，注册成功后需要发送短信告知我们成功，而我们使用了 mq技术，在注册成功的同时，把消息发送给了mq，然后我们能想到的是 mq肯定自己找到对应的消费者的方法（也就是监听此队列的监听器中的方法）进行调用，然后发送信息</p>\n<p>所以我们只需将这个项目启动，加载配置文件就可以达到测试的目的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import com.atguigu.rabbitmq.listener.SpringQueueListener;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.core.MessageProperties;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport java.nio.charset.StandardCharsets;\n\n&#x2F;**\n * @author hrenxiang\n * @create 2021&#x2F;8&#x2F;10 20:33\n *&#x2F;\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations &#x3D; &quot;classpath:spring-rabbit.xml&quot;)\npublic class ConsumerTeest &#123;\n\n    @Autowired\n    private SpringQueueListener springQueueListener;\n\n    @Test\n    public void testSpringQueueListener()&#123;\n        System.out.println(&quot;直接接收消息：&quot;);\n    &#125;\n\n&#125;</code></pre>\n\n","text":"01、什么是消息中间件MQ全称为Message Queue， 消息队列(MQ)是一种应用程序对应用程序的通信方法。 介绍：消息队列就是基础数据结构中的 “先进先出” 的一种数据机构。想一下，生活中买东西，需要排队，先排的人先买消费，就是典型的“先进先出”。 消息传递：指的是程序之...","link":"","photos":[],"count_time":{"symbolsCount":"34k","symbolsTime":"31 mins."},"categories":[{"name":"消息队列","slug":"消息队列","count":2,"path":"api/categories/消息队列.json"}],"tags":[{"name":"消息队列","slug":"消息队列","count":2,"path":"api/tags/消息队列.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#01%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6\"><span class=\"toc-text\">01、什么是消息中间件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#02%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">02、为什么使用消息队列</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#03%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFQPS-PV-UV-PR\"><span class=\"toc-text\">03、什么是QPS PV UV PR</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#04%E3%80%81AMQP-%E5%92%8C-JMS\"><span class=\"toc-text\">04、AMQP 和 JMS</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#05%E3%80%81RabbitMQ-%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">05、RabbitMQ 简介</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#06%E3%80%81RabbitMQ-%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">06、RabbitMQ 的特点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#07%E3%80%81RabbitMQ-%E7%9A%84%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">07、RabbitMQ 的基础结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#08%E3%80%81RabbitMQ-%E7%9A%84%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">08、RabbitMQ 的安装</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#09%E3%80%81RabbitMQ-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%95%8C%E9%9D%A2\"><span class=\"toc-text\">09、RabbitMQ 浏览器界面</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#9-1%E3%80%81rabbitmq-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%99%BB%E5%BD%95%E6%88%90%E5%8A%9F%E9%A1%B5%E9%9D%A2\"><span class=\"toc-text\">9.1、rabbitmq 客户端登录成功页面</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#9-2%E3%80%81rabbitmq-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%A1%B5%E9%9D%A2%E4%BF%A1%E6%81%AF%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">9.2、rabbitmq 客户端页面信息解析</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#9-3%E3%80%81rabbitmq-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2\"><span class=\"toc-text\">9.3、rabbitmq 浏览器中的管理界面</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10%E3%80%81RabbitMQ-%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">10、RabbitMQ 入门案例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE\"><span class=\"toc-text\">1、创建项目</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2%E3%80%81%E4%B8%A4%E4%B8%AA%E9%A1%B9%E7%9B%AE%E7%9A%84-pom-%E6%96%87%E4%BB%B6%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">2、两个项目的 pom 文件中添加依赖</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3%E3%80%81%E7%BC%96%E5%86%99%E7%94%9F%E4%BA%A7%E8%80%85\"><span class=\"toc-text\">3、编写生产者</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4%E3%80%81%E7%BC%96%E5%86%99%E6%B6%88%E8%B4%B9%E8%80%85\"><span class=\"toc-text\">4、编写消费者</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5%E3%80%81%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">5、小结</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#11%E3%80%81AMQP-%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">11、AMQP 详解</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#12%E3%80%81RabbitMQ-%E8%BF%90%E8%BD%AC%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">12、RabbitMQ 运转流程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#13%E3%80%81RabbitMQ-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">13、RabbitMQ 工作模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#13-1%E3%80%81%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">13.1、相关概念</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#13-2%E3%80%81simple%E6%A8%A1%E5%BC%8F-%E6%9C%80%E7%AE%80%E5%8D%95%E6%94%B6%E5%8F%91%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">13.2、simple模式 (最简单收发模式)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#13-3%E3%80%81work-queues-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">13.3、work queues 工作队列模式</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#13-4%E3%80%81Publish-Subscribe-%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">13.4、Publish&#x2F;Subscribe 模式</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#13-5%E3%80%81Routing-%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">13.5、Routing 路由模式</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#13-6%E3%80%81Topic-%E9%80%9A%E9%85%8D%E7%AC%A6%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">13.6、Topic 通配符模式</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#13-7%E3%80%81%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">13.7、总结</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#14%E3%80%81Spring-%E6%95%B4%E5%90%88-RabbitMQ\"><span class=\"toc-text\">14、Spring 整合 RabbitMQ</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%88%9B%E5%BB%BA%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">1、创建生产者，消费者模块</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2%E3%80%81%E7%BB%99%E4%B8%A4%E4%B8%AA%E6%A8%A1%E5%9D%97%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">2、给两个模块添加依赖</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%B7%BB%E5%8A%A0-rabbitmq-properties\"><span class=\"toc-text\">3、添加 rabbitmq.properties</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E7%9A%84-spring%E6%95%B4%E5%90%88%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">4、生产者的 spring整合配置</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84-spring%E6%95%B4%E5%90%88%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">5、消费者的 spring整合配置</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6%E3%80%81%E5%88%9B%E5%BB%BA%E5%90%84%E4%B8%AA-%E6%B6%88%E6%81%AF%E7%9B%91%E5%90%AC%E5%99%A8\"><span class=\"toc-text\">6、创建各个 消息监听器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#6-1%E3%80%81%E9%98%9F%E5%88%97%E7%9B%91%E5%90%AC%E5%99%A8\"><span class=\"toc-text\">6.1、队列监听器</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#6-2%E3%80%81%E5%B9%BF%E6%92%AD%E7%9B%91%E5%90%AC%E5%99%A8-1\"><span class=\"toc-text\">6.2、广播监听器 1</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#6-3%E3%80%81%E5%B9%BF%E6%92%AD%E7%9B%91%E5%90%AC%E5%99%A8-2\"><span class=\"toc-text\">6.3、广播监听器 2</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#6-4%E3%80%81-%E5%8F%B7%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9B%91%E5%90%AC%E5%99%A8\"><span class=\"toc-text\">6.4、* 号通配符监听器</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#6-5%E3%80%81-%E5%8F%B7%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9B%91%E5%90%AC%E5%99%A8-1\"><span class=\"toc-text\">6.5、# 号通配符监听器 1</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#6-6%E3%80%81-%E5%8F%B7%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9B%91%E5%90%AC%E5%99%A8-2\"><span class=\"toc-text\">6.6、# 号通配符监听器 2</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7%E3%80%81%E5%88%9B%E5%BB%BA-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">7、创建 生产者测试方法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8%E3%80%81%E5%88%9B%E5%BB%BA-%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">8、创建 消费者的测试方法</span></a></li></ol></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"RabbitMQ 高级部分","uid":"572316d3a9d6ae4c1865a38d55232e93","slug":"67-RabbitMQ-高级部分","date":"2021-09-13T15:43:32.000Z","updated":"2021-09-15T10:46:44.360Z","comments":true,"path":"api/articles/67-RabbitMQ-高级部分.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog9.jpg","text":"01、消息的可靠性投递 1.1、消息投递可靠性的简介在使用 RabbitMQ 时，作为消息发送方希望杜绝任何消息丢失或者失败的场景。RabbitMQ 为我们提供了两种方式用来控制消息的投递可靠性模式：==① confirm 确认模式 ② return 退回模式== rabbitm...","link":"","photos":[],"count_time":{"symbolsCount":"46k","symbolsTime":"42 mins."},"categories":[{"name":"消息队列","slug":"消息队列","count":2,"path":"api/categories/消息队列.json"}],"tags":[{"name":"消息队列","slug":"消息队列","count":2,"path":"api/tags/消息队列.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"SpringBoot 基础内容","uid":"1622936a4b6ba96f2723411bb290759b","slug":"65-SpringBoot-基础内容","date":"2021-09-13T15:41:32.000Z","updated":"2021-09-15T10:46:54.437Z","comments":true,"path":"api/articles/65-SpringBoot-基础内容.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog11.jpg","text":"1、Spirng Boot 概念① Spring 框架 最核心的特性就是依赖注入DI（Dependency Injecttion）和控制反转IOC（Inversion Of Control）。如果你能够合理的使用DI和IOC，可以开发出松耦合、扩展性好的的应用程序。 ② Spri...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"SpringBoot","slug":"SpringBoot","count":1,"path":"api/categories/SpringBoot.json"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","count":1,"path":"api/tags/SpringBoot.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}