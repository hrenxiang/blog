{"title":"JDBC 连接池及项目结构","uid":"bb5bc50a09711181a6e48f61d586b1e3","slug":"23-三层架构、项目结构、连接池","date":"2021-09-13T14:58:32.000Z","updated":"2021-09-15T10:21:18.315Z","comments":true,"path":"api/articles/23-三层架构、项目结构、连接池.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","content":"<h3 id=\"1、三层架构\"><a href=\"#1、三层架构\" class=\"headerlink\" title=\"1、三层架构\"></a>1、三层架构</h3><p><strong>UI(表现层):</strong> 主要是指与用户交互的界面。用于接收用户输入的数据和显示处理后用户需要的数据。</p>\n<p><strong>BLL(业务逻辑层):</strong> UI层和DAL层之间的桥梁。实现业务逻辑。业务逻辑具体包含：验证、计算、业务规则等等。</p>\n<p><strong>DAL(数据访问层):</strong> 与数据库打交道。主要实现对数据的增、删、改、查。将存储在数据库中的数据提交给业务层，同时将业务层处理的数据保存到数据库。（当然这些操作都是基于UI层的。用户的需求反映给界面（UI），UI反映给BLL，BLL反映给DAL，DAL进行数据的操作，操作后再一一返回，直到将用户所需数据反馈给用户）</p>\n<p>Entity(实体层)：它不属于三层中的任何一层，但是它是必不可少的一层。</p>\n<p><strong>三层架构与MVC的区别</strong>：MVC（模型Model-视图View-控制器Controller）是一种架构模式，可以用它来创建在域对象和UI表示层对象之间的区 分。</p>\n<h3 id=\"2、为什么使用三层？\"><a href=\"#2、为什么使用三层？\" class=\"headerlink\" title=\"2、为什么使用三层？\"></a>2、为什么使用三层？</h3><p>使用三层架构的目的：解耦！！！|||||   <strong>层次清晰，分工明确，每层之间耦合度低——提高了效率，适应需求变化，可维护性高，可扩展性高</strong>   ||||</p>\n<p>同样拿上面饭店的例子来讲：</p>\n<p>（1）服务员（UI层）请假——另找服务员；厨师（BLL层）辞职——招聘另一个厨师；采购员（DAL）辞职——招聘另一个采购员； （2）顾客反映：</p>\n<ul>\n<li>1、你们店服务态度不好——服务员的问题。开除服务员；</li>\n<li>2、你们店菜里有虫子——厨师的问题。换厨师；</li>\n</ul>\n<p>任何一层发生变化都不会影响到另外一层！！！</p>\n<h3 id=\"3、标准的项目结构\"><a href=\"#3、标准的项目结构\" class=\"headerlink\" title=\"3、标准的项目结构\"></a>3、标准的项目结构</h3><ul>\n<li><p>web层                                      web/servlet/controller         </p>\n</li>\n<li><p>service层（业务逻辑层）         service Service                 接口包 </p>\n<p>​                                                service.impl Service           接口实现类 </p>\n</li>\n<li><p>dao层    （数据持久层）        dao Dao                         接口包</p>\n<pre><code>                                                                                   dao.impl Dao                   接口实现类\n</code></pre>\n</li>\n<li><p>pojo层   （实体层）              pojo/entity/domain/bean    JavaBean 类 </p>\n</li>\n<li><p>测试包                                test/junit </p>\n</li>\n<li><p>工具类                                utils</p>\n</li>\n</ul>\n<h3 id=\"4、连接池\"><a href=\"#4、连接池\" class=\"headerlink\" title=\"4、连接池\"></a>4、连接池</h3><h4 id=\"4-1、连接池简介\"><a href=\"#4-1、连接池简介\" class=\"headerlink\" title=\"4.1、连接池简介\"></a>4.1、连接池简介</h4><h5 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1.概念\"></a>1.概念</h5><ul>\n<li>其实就是一个容器（集合），存储数据库连接的容器</li>\n<li>当容器初始化好后，容器被创建，容器中会申请一些连接对象，当用户访问数据库时，从容器中获取连接对象，用户访问完后，会将连接对象归还给容器。</li>\n</ul>\n<h5 id=\"2-好处\"><a href=\"#2-好处\" class=\"headerlink\" title=\"2.好处\"></a>2.好处</h5><ul>\n<li>节约资源</li>\n<li>用户访问高效</li>\n</ul>\n<h5 id=\"3-实现\"><a href=\"#3-实现\" class=\"headerlink\" title=\"3.实现\"></a>3.实现</h5><ul>\n<li><p>实现接口：javax.sql.DataSource</p>\n</li>\n<li><p>方法：</p>\n<p>1）获取连接：getConnection()</p>\n<p>2）归还连接：close()</p>\n<p>​        如果连接对象是从连接池中获取，那么close()方法不再是关闭连接，而是归还连接</p>\n</li>\n</ul>\n<h5 id=\"4-连接池技术\"><a href=\"#4-连接池技术\" class=\"headerlink\" title=\"4.连接池技术\"></a>4.连接池技术</h5><ul>\n<li>c3p0</li>\n<li>DBCP：它与Druid非常像，都是properties作为配置文件，然后加载配置文件</li>\n<li>Druid：阿里巴巴提供，被认为世界最好的数据库连接池技术之一</li>\n</ul>\n<h4 id=\"4-2、C3P0的使用（不用）\"><a href=\"#4-2、C3P0的使用（不用）\" class=\"headerlink\" title=\"4.2、C3P0的使用（不用）\"></a>4.2、C3P0的使用（不用）</h4><h5 id=\"1-步骤\"><a href=\"#1-步骤\" class=\"headerlink\" title=\"1.步骤\"></a>1.步骤</h5><ul>\n<li><p>导入jar包（两个包）</p>\n<p>1）c3p0-0.9.5.5.jar        2）mchange-commons-java-0.2.19.jar</p>\n</li>\n<li><p>定义配置文件</p>\n<p>1）名称：c3p0.properties 或者 c3p0.xml</p>\n<p>2）路径 ：直接放在src目录下即可</p>\n</li>\n<li><p>创建核心对象</p>\n<p>数据库连接池对象，new ComboPooledDataSource();</p>\n</li>\n<li><p>获取连接</p>\n<p>getConnection()</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">* 获取连接\n&#x2F;*1.导入jar包*&#x2F;\n&#x2F;*2.创建数据库连接池对象*&#x2F;\nComboPooledDataSource dataSource &#x3D; new ComboPooledDataSource();\n&#x2F;*3.获取连接对象*&#x2F;\nConnection conn &#x3D; dataSource.getConnection();</code></pre></li>\n</ul>\n<h5 id=\"2-配置文件\"><a href=\"#2-配置文件\" class=\"headerlink\" title=\"2.配置文件\"></a>2.配置文件</h5><pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!-- 自定义的c3p0-config.xml --&gt;\n&lt;c3p0-config&gt;\n    &lt;default-config&gt;\n        &lt;property name&#x3D;&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;jdbcUrl&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;xscj&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;user&quot;&gt;root&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;password&quot;&gt;hhhh&lt;&#x2F;property&gt;\n\n        &lt;!--初始化申请连接数量--&gt;\n        &lt;property name&#x3D;&quot;initialPoolSize&quot;&gt;10&lt;&#x2F;property&gt;\n        &lt;!--最大空闲时间，0表示永不丢弃--&gt;\n        &lt;property name&#x3D;&quot;maxIdleTime&quot;&gt;30&lt;&#x2F;property&gt;\n        &lt;!-- 连接超时时间, default: 0。如果是0，表示无限等待 --&gt;\n        &lt;property name&#x3D;&quot;checkoutTimeout&quot;&gt;3000&lt;&#x2F;property&gt;\n        &lt;!--连接池最大的连接数量--&gt;\n        &lt;property name&#x3D;&quot;maxPoolSize&quot;&gt;10&lt;&#x2F;property&gt;\n        &lt;!--连接池最小的连接数量--&gt;\n        &lt;property name&#x3D;&quot;minPoolSize&quot;&gt;2&lt;&#x2F;property&gt;\n    &lt;&#x2F;default-config&gt;\n\n    &lt;named-config name&#x3D;&quot;mySource&quot;&gt;\n        &lt;property name&#x3D;&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;jdbcUrl&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;xscj&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;user&quot;&gt;root&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;password&quot;&gt;hhhh&lt;&#x2F;property&gt;\n\n        &lt;property name&#x3D;&quot;initialPoolSize&quot;&gt;10&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;maxIdleTime&quot;&gt;30&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;maxPoolSize&quot;&gt;100&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;minPoolSize&quot;&gt;10&lt;&#x2F;property&gt;\n    &lt;&#x2F;named-config&gt;\n&lt;&#x2F;c3p0-config&gt;</code></pre>\n\n<h5 id=\"3-最大连接数测试\"><a href=\"#3-最大连接数测试\" class=\"headerlink\" title=\"3.最大连接数测试\"></a>3.最大连接数测试</h5><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * @author Charon\n * @date 2020&#x2F;6&#x2F;22\n * @maxPoolSize 验证连接池最大连接数量\n **&#x2F;\npublic class c3p0Demo_02 &#123;\n\n    public static void main(String[] args) throws SQLException &#123;\n\n        &#x2F;*1.导入jar包*&#x2F;\n        &#x2F;*2.创建数据库连接池对象*&#x2F;\n        ComboPooledDataSource dataSource &#x3D; new ComboPooledDataSource();\n        &#x2F;*3.获取连接对象*&#x2F;\n        for (int i&#x3D;0; i&lt;10;i++)&#123;\n            Connection conn &#x3D; dataSource.getConnection();\n            &#x2F;*4.打印*&#x2F;\n            System.out.println(i+&quot;:&quot;+conn);\n        &#125;\n    &#125;\n\n&#125;</code></pre>\n\n<h5 id=\"4-归还方法及ComboPooledDataSource-是否传参\"><a href=\"#4-归还方法及ComboPooledDataSource-是否传参\" class=\"headerlink\" title=\"4.归还方法及ComboPooledDataSource()是否传参\"></a>4.归还方法及ComboPooledDataSource()是否传参</h5><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * @author Charon\n * @date 2020&#x2F;6&#x2F;22\n * @close() 验证连接池中 归还方法：close()\n *          不归还，因最大连接条数原因，只有10条结果\n *          归还后，发现有11条结果，且5和9的连接对象是同一个（这个调用时随机的，不一定和后面的哪一个一样）\n *          5：[wrapping: com.mysql.jdbc.Connection@4590c9c3]\n *          9：[wrapping: com.mysql.jdbc.Connection@4590c9c3]\n * @ new ComboPooledDataSource(); 括号内不传参数表示使用xml中的默认参数，传值表示使用的是xml中相应名字的参数\n **&#x2F;\npublic class c3p0Demo_03 &#123;\n\n    @Test\n    public void test_Close() throws SQLException &#123;\n\n        &#x2F;*1.获取数据库连接池对象*&#x2F;\n        DataSource dataSource &#x3D; new ComboPooledDataSource();\n        &#x2F;*2.获取连接 因为归还了一个，所以说可以有11次*&#x2F;\n        for (int i&#x3D;0; i&lt;&#x3D;10; i++)&#123;\n            Connection conn &#x3D; dataSource.getConnection();\n        &#x2F;*3.打印*&#x2F;\n            System.out.println(i+&quot;:&quot;+conn);\n        &#x2F;*4.归还连接*&#x2F;\n            if (i&#x3D;&#x3D;5)&#123;\n                conn.close();\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"4-3、DBCP连接池（不用）\"><a href=\"#4-3、DBCP连接池（不用）\" class=\"headerlink\" title=\"4.3、DBCP连接池（不用）\"></a>4.3、DBCP连接池（不用）</h4><ul>\n<li>DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：<ul>\n<li>Commons-dbcp.jar：连接池的实现</li>\n<li>Commons-pool.jar：连接池实现的依赖库</li>\n</ul>\n</li>\n<li><strong>Tomcat 的连接池正是采用该连接池来实现的。</strong>该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。</li>\n</ul>\n<ul>\n<li><p>它与Druid非常像，都是properties作为配置文件，然后加载配置文件</p>\n</li>\n<li><p>加载配置的方法也相同</p>\n</li>\n<li><p>然后创建DataSource ，使用的是 BasicDataSourceFactory.creatDataSource();</p>\n</li>\n</ul>\n<h4 id=\"4-4、Druid的使用\"><a href=\"#4-4、Druid的使用\" class=\"headerlink\" title=\"4.4、Druid的使用\"></a>4.4、Druid的使用</h4><h5 id=\"1-步骤-1\"><a href=\"#1-步骤-1\" class=\"headerlink\" title=\"1.步骤\"></a>1.步骤</h5><ul>\n<li><p>导入jar包</p>\n<p>druid-1.1.22.jar</p>\n</li>\n<li><p>定义配置文件</p>\n<p>1）形式：是properties形式的</p>\n<p>2）名称：可以叫任何名字 </p>\n<p>3）路径 ：可以放在任意的目录下</p>\n<p>4）不会自动加载了，需要手动加载</p>\n</li>\n<li><p>获取数据库连接池对象</p>\n<p>通过工厂来获取，DruidDataSourceFactory</p>\n</li>\n<li><p>获取连接</p>\n<p>getConnection()</p>\n</li>\n<li><p>关闭资源</p>\n<p>close();（德鲁伊中关闭资源并不是真的关闭，而是将连接的状态设置为休眠，当有人再次申请时，可能会激活他（也可能申请到其他的））</p>\n</li>\n</ul>\n<h5 id=\"2-详细配置参数\"><a href=\"#2-详细配置参数\" class=\"headerlink\" title=\"2.详细配置参数\"></a>2.详细配置参数</h5><table>\n<thead>\n<tr>\n<th><strong>配置</strong></th>\n<th><strong>缺省</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>name</td>\n<td></td>\n<td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。   如果没有配置，将会生成一个名字，格式是：”DataSource-” +   System.identityHashCode(this)</td>\n</tr>\n<tr>\n<td>url</td>\n<td></td>\n<td>连接数据库的url，不同数据库不一样。例如：mysql :   jdbc:mysql://10.20.153.104:3306/druid2      oracle :   jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td>\n</tr>\n<tr>\n<td>username</td>\n<td></td>\n<td>连接数据库的用户名</td>\n</tr>\n<tr>\n<td>password</td>\n<td></td>\n<td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a href=\"https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter\">https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter</a></td>\n</tr>\n<tr>\n<td>driverClassName</td>\n<td></td>\n<td>根据url自动识别   这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)</td>\n</tr>\n<tr>\n<td>initialSize</td>\n<td>0</td>\n<td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td>\n</tr>\n<tr>\n<td>maxActive</td>\n<td>8</td>\n<td>最大连接池数量</td>\n</tr>\n<tr>\n<td>maxIdle</td>\n<td>8</td>\n<td>已经不再使用，配置了也没效果</td>\n</tr>\n<tr>\n<td>minIdle</td>\n<td></td>\n<td>最小连接池数量</td>\n</tr>\n<tr>\n<td>maxWait</td>\n<td></td>\n<td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td>\n</tr>\n<tr>\n<td>poolPreparedStatements</td>\n<td>false</td>\n<td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td>\n</tr>\n<tr>\n<td>maxOpenPreparedStatements</td>\n<td>-1</td>\n<td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td>\n</tr>\n<tr>\n<td>validationQuery</td>\n<td></td>\n<td>用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。</td>\n</tr>\n<tr>\n<td>testOnBorrow</td>\n<td>true</td>\n<td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td>\n</tr>\n<tr>\n<td>testOnReturn</td>\n<td>false</td>\n<td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</td>\n</tr>\n<tr>\n<td>testWhileIdle</td>\n<td>false</td>\n<td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td>\n</tr>\n<tr>\n<td>timeBetweenEvictionRunsMillis</td>\n<td></td>\n<td>有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td>\n</tr>\n<tr>\n<td>numTestsPerEvictionRun</td>\n<td></td>\n<td>不再使用，一个DruidDataSource只支持一个EvictionRun</td>\n</tr>\n<tr>\n<td>minEvictableIdleTimeMillis</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>connectionInitSqls</td>\n<td></td>\n<td>物理连接初始化的时候执行的sql</td>\n</tr>\n<tr>\n<td>exceptionSorter</td>\n<td></td>\n<td>根据dbType自动识别   当数据库抛出一些不可恢复的异常时，抛弃连接</td>\n</tr>\n<tr>\n<td>filters</td>\n<td></td>\n<td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：   监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</td>\n</tr>\n<tr>\n<td>proxyFilters</td>\n<td></td>\n<td>类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td>\n</tr>\n</tbody></table>\n<h5 id=\"3-连接操作\"><a href=\"#3-连接操作\" class=\"headerlink\" title=\"3.连接操作\"></a>3.连接操作</h5><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Test\npublic void test_connection() throws Exception &#123;\n\n    &#x2F;*1.导入jar包*&#x2F;\n    &#x2F;*2.定义配置文件 druid.properties*&#x2F;\n    &#x2F;*3.加载配置文件*&#x2F;\n    InputStream is &#x3D; druidDemo_01.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);\n    Properties pro &#x3D; new Properties();\n    pro.load(is);\n\n    &#x2F;*4.获取数据库连接池对象*&#x2F;\n    DataSource ds &#x3D; DruidDataSourceFactory.createDataSource(pro);\n    &#x2F;*5.获取连接*&#x2F;\n    Connection conn &#x3D; ds.getConnection();\n    System.out.println(conn);\n\n&#125;</code></pre>\n\n<h5 id=\"4-Durid-工具类\"><a href=\"#4-Durid-工具类\" class=\"headerlink\" title=\"4.Durid 工具类\"></a>4.Durid 工具类</h5><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * @author Charon\n * @date 2020&#x2F;6&#x2F;23\n * druid 连接池工具类\n **&#x2F;\npublic class DruidUtil &#123;\n\n    private static DataSource ds;\n\n    public DruidUtil()&#123;&#125;\n\n    static &#123;\n\n        try &#123;\n            &#x2F;*1.导包，写配置文件*&#x2F;\n            &#x2F;*2.加载配置文件*&#x2F;\n            InputStream is &#x3D; DruidUtil.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);\n            Properties pro &#x3D; new Properties();\n            pro.load(is);\n\n            &#x2F;*3.获取数据库连接池对象*&#x2F;\n            ds &#x3D; DruidDataSourceFactory.createDataSource(pro);\n\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n\n    &#125;\n\n\n    &#x2F;**\n     *获取连接\n     *&#x2F;\n    public static Connection getConnection() throws SQLException &#123;\n        return ds.getConnection();\n    &#125;\n\n    &#x2F;**\n     * 关闭资源\n     * *&#x2F;\n\n    &#x2F;*获取ds对象（jdbcTemplate中使用）*&#x2F;\n    public static DataSource getDataSource()&#123;\n        return ds;\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"4-5、JdbcTemplate入门\"><a href=\"#4-5、JdbcTemplate入门\" class=\"headerlink\" title=\"4.5、JdbcTemplate入门\"></a>4.5、JdbcTemplate入门</h4><h5 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1.概述\"></a>1.概述</h5><ul>\n<li><p>JDBCTemplate就是Spring对JDBC的封装,通俗点说就是Spring对jdbc的封装的模板。</p>\n<p>使用spring的注入功能，可以把DataSource注册到JdbcTemplate之中,</p>\n<p>相比较于传统的JDBC,大大简化了数据库的操作。</p>\n</li>\n</ul>\n<h5 id=\"2-步骤\"><a href=\"#2-步骤\" class=\"headerlink\" title=\"2.步骤\"></a>2.步骤</h5><ul>\n<li><p>导入jar包（5个包）</p>\n<p>spring-tx-5.1.10.RELEASE.jar        spring-core-5.1.10.RELEASE.jar</p>\n<p>spring-jdbc-5.1.10.RELEASE.jar   spring-beans-5.1.10.RELEASE.jar</p>\n<p>commons-logging-1.2.jar</p>\n</li>\n<li><p>定义配置文件</p>\n</li>\n<li><p>获取JdbcTemplate对象</p>\n<p>JdbcTemplate template = new JdbcTemplate(ds);</p>\n</li>\n<li><p>常用方法</p>\n<ul>\n<li><p>update()                        </p>\n<p>返回的是一个int值，影响的行数， 用于执行INSERT、UPDATE、DELETE等DML语句。        </p>\n</li>\n<li><p>queryForMap()            </p>\n<p>将查询结果封装为map集合，列名作为key，值作为value</p>\n</li>\n</ul>\n<p>​         <span style=\"color:red;\">注意：查询单个对象，这个方法查询的结果集长度为  1</span></p>\n<ul>\n<li><p>queryForList()       </p>\n<p>查询多个对象，返回一个List对象，List对象存储是Map对象</p>\n<p><span style=\"color:red;\">注意：将每一条记录封装为一个map集合，再讲map集合封装到List集合中</span></p>\n</li>\n<li><p>queryForObject( sql , 聚合函数类型的class文件)      </p>\n<p>查询单个对象,将结果封装为对象，返回单个实体类对象</p>\n<p><span style=\"color:red;\">注意：一般用于聚合函数的查询</span></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String sql &#x3D; &quot;select count(学号) from xs_kc&quot;;\nLong aLong &#x3D; template.queryForObject(sql, Long.class);</code></pre></li>\n<li><p>query( sql , RowMapper )                         </p>\n<p>查询多个对象，返回的是一个List对象，List对象存储是实体类（javaBean对象）</p>\n<p><span style=\"color:red;\">注意：query的参数RowMapper</span></p>\n<p>​                <span style=\"color:red;\">一般我们使用的是BeanPropertyRowMapper实现类，可以完成数据到javabean的自动封装</span></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;xskc&gt; list &#x3D; template.query(sql,new BeanPropertyRowMapper&lt;xskc&gt;(xskc.class));</code></pre></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"3-操作\"><a href=\"#3-操作\" class=\"headerlink\" title=\"3.操作\"></a>3.操作</h5><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * @author Charon\n * @date 2020&#x2F;6&#x2F;23\n *\n * JDBCTemplate 入门\n **&#x2F;\npublic class JDBCTemplate_01 &#123;\n\n    public static void main(String[] args) &#123;\n\n        &#x2F;*1.导入jar包（5个）*&#x2F;\n        &#x2F;*2.创建Template对象*&#x2F;\n        JdbcTemplate template &#x3D; new JdbcTemplate(DruidUtil.getDataSource());\n        &#x2F;*3.调用方法*&#x2F;\n        String sql &#x3D; &quot;update xs_kc set 学分&#x3D;? where 学号&#x3D;?&quot;;\n        int count &#x3D; template.update(sql, 5, &quot;081260&quot;);\n        System.out.println(count);\n\n\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"4-6、DBUtils\"><a href=\"#4-6、DBUtils\" class=\"headerlink\" title=\"4.6、DBUtils\"></a>4.6、DBUtils</h4><p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</p>\n<p>其中QueryRunner类封装了SQL的执行，是线程安全的。</p>\n<p>（1）可以实现增、删、改、查、批处理、</p>\n<p>（2）考虑了事务处理需要共用Connection。</p>\n<p>（3）该类最主要的就是简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。</p>\n<p><strong>（1）更新</strong></p>\n<p>public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。</p>\n<p>……</p>\n<p><strong>（2）插入</strong></p>\n<p>public <T> T insert(Connection conn,String sql,ResultSetHandler<T> rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值</p>\n<p>….</p>\n<p><strong>（3）批处理</strong></p>\n<p>public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句</p>\n<p>public <T> T insertBatch(Connection conn,String sql,ResultSetHandler<T> rsh,Object[][] params)throws SQLException：只支持INSERT语句</p>\n<p>…..</p>\n<p><strong>（4）使用QueryRunner类实现查询</strong></p>\n<p>public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。</p>\n<p>….</p>\n<p>ResultSetHandler接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet  rs)该方法的返回值将作为QueryRunner类的query()方法的返回值。</p>\n<p>该接口有如下实现类可以使用：</p>\n<ul>\n<li><strong>BeanHandler</strong>：将结果集中的第一行数据封装到一个对应的JavaBean实例中。</li>\n<li><strong>BeanListHandler</strong>：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，<strong>存放到List里</strong>。</li>\n<li><strong>ScalarHandler</strong>：查询单个值对象（<strong>聚合函数</strong>）</li>\n<li><strong>MapHandler</strong>：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</li>\n<li><strong>MapListHandler</strong>：将结果集中的每一行数据都封装到一个Map里，然后再存放到List</li>\n<li>ColumnListHandler：将结果集中某一列的数据存放到List中。</li>\n<li>KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</li>\n<li>ArrayHandler：把结果集中的第一行数据转成对象数组。</li>\n<li>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</li>\n</ul>\n","text":"1、三层架构UI(表现层): 主要是指与用户交互的界面。用于接收用户输入的数据和显示处理后用户需要的数据。 BLL(业务逻辑层): UI层和DAL层之间的桥梁。实现业务逻辑。业务逻辑具体包含：验证、计算、业务规则等等。 DAL(数据访问层): 与数据库打交道。主要实现对数据的增、...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"JDBC","slug":"JDBC","count":4,"path":"api/categories/JDBC.json"}],"tags":[{"name":"JDBC","slug":"JDBC","count":4,"path":"api/tags/JDBC.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%E3%80%81%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">1、三层架构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E4%B8%89%E5%B1%82%EF%BC%9F\"><span class=\"toc-text\">2、为什么使用三层？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%A0%87%E5%87%86%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">3、标准的项目结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%E3%80%81%E8%BF%9E%E6%8E%A5%E6%B1%A0\"><span class=\"toc-text\">4、连接池</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-1%E3%80%81%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">4.1、连接池简介</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.概念</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E5%A5%BD%E5%A4%84\"><span class=\"toc-text\">2.好处</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">3.实现</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">4.连接池技术</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-2%E3%80%81C3P0%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8D%E7%94%A8%EF%BC%89\"><span class=\"toc-text\">4.2、C3P0的使用（不用）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">1.步骤</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">2.配置文件</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">3.最大连接数测试</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E5%BD%92%E8%BF%98%E6%96%B9%E6%B3%95%E5%8F%8AComboPooledDataSource-%E6%98%AF%E5%90%A6%E4%BC%A0%E5%8F%82\"><span class=\"toc-text\">4.归还方法及ComboPooledDataSource()是否传参</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-3%E3%80%81DBCP%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%88%E4%B8%8D%E7%94%A8%EF%BC%89\"><span class=\"toc-text\">4.3、DBCP连接池（不用）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-4%E3%80%81Druid%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">4.4、Druid的使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E6%AD%A5%E9%AA%A4-1\"><span class=\"toc-text\">1.步骤</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">2.详细配置参数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">3.连接操作</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-Durid-%E5%B7%A5%E5%85%B7%E7%B1%BB\"><span class=\"toc-text\">4.Durid 工具类</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-5%E3%80%81JdbcTemplate%E5%85%A5%E9%97%A8\"><span class=\"toc-text\">4.5、JdbcTemplate入门</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.概述</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">2.步骤</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">3.操作</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-6%E3%80%81DBUtils\"><span class=\"toc-text\">4.6、DBUtils</span></a></li></ol></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"JDBC 事务，工具类，行级锁","uid":"55745060491eb4938fdbbffa36e92659","slug":"24-JDBC事务、工具类、行级锁","date":"2021-09-13T15:01:32.000Z","updated":"2021-09-15T10:21:51.879Z","comments":true,"path":"api/articles/24-JDBC事务、工具类、行级锁.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"一、JDBC事务机制 Jdbc中的事务是自动提交的。 只要执行任意一条DML语句，则自动提交一次，这是JDBC的默认事务提交行为。但是实际业务中，很多情况是 需要N条DML语句联合才能完成的，必须保证他们同时成功或者同事失败。 conn表示一个连接，与数据库的连接，不为空表示还连...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"JDBC","slug":"JDBC","count":4,"path":"api/categories/JDBC.json"}],"tags":[{"name":"JDBC","slug":"JDBC","count":4,"path":"api/tags/JDBC.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"JDBC 基础总结","uid":"43229a92952aad915ea9d7e4fe26c570","slug":"22-JDBC总结","date":"2021-09-13T14:57:32.000Z","updated":"2021-09-15T10:20:24.388Z","comments":true,"path":"api/articles/22-JDBC总结.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"一、JDBC的本质1、JDBC是什么？Java Database Connectuvity（java语言数据库） 使用java语言操作数据库 2、JDBC的本质是什么？ JDBC是SUN公司指定的一套接口(interface)：java.sql.*; (这个软件包下有很多接口) ...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"JDBC","slug":"JDBC","count":4,"path":"api/categories/JDBC.json"}],"tags":[{"name":"JDBC","slug":"JDBC","count":4,"path":"api/tags/JDBC.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}