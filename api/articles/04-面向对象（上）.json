{"title":"面向对象（上）","uid":"0959816aacb592f211c0dd883a8ef3db","slug":"04-面向对象（上）","date":"2021-09-13T14:36:32.000Z","updated":"2021-09-14T15:53:13.090Z","comments":true,"path":"api/articles/04-面向对象（上）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog4.jpg","content":"<h3 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h3><ol>\n<li><p>Java语言是面向对象的程序设计语言，而面向对象思想（Object Oriented Programming）是一种程序设计思想。</p>\n</li>\n<li><p>这里的<strong>对象</strong>泛指现实中的一切事物，而每种事物都具有自己的<strong>属性</strong>和<strong>行为</strong></p>\n</li>\n<li><p>而面向对象编程就是参照现实中的事物，将其属性和行为抽象出来，描述成计算机事件的思想</p>\n</li>\n<li><p>面向对象有以下特征：</p>\n<p>比较符合人们的思考习惯</p>\n<p>可以将复杂的逻辑简单化，易维护，易复用，易扩展</p>\n<p>具有封装，继承，多态的特性，可以设计出低耦合的系统，使之更加灵活</p>\n<p>性能比面向过程低</p>\n</li>\n<li><p>面向对象的编程语言主要有：C++，Java，C# 等</p>\n</li>\n</ol>\n<h3 id=\"二、类和对象\"><a href=\"#二、类和对象\" class=\"headerlink\" title=\"二、类和对象\"></a>二、类和对象</h3><h4 id=\"2-1-什么是类\"><a href=\"#2-1-什么是类\" class=\"headerlink\" title=\"2.1    什么是类\"></a>2.1    什么是类</h4><p>类：是一类具有相同特性的事物的抽象描述，是一组相关属性和行为的集合</p>\n<h4 id=\"2-2-什么是对象\"><a href=\"#2-2-什么是对象\" class=\"headerlink\" title=\"2.2    什么是对象\"></a>2.2    什么是对象</h4><p>对象：是一类事物的具体体现，对象是类的一个实例，必然具有该类事物的属性和行为</p>\n<h4 id=\"2-3-定义类\"><a href=\"#2-3-定义类\" class=\"headerlink\" title=\"2.3    定义类\"></a>2.3    定义类</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class className&#123;\n\t&#x2F;&#x2F; 成员变量\n\t&#x2F;&#x2F; 方法\n&#125;</code></pre>\n\n<ul>\n<li>一般，类的命名遵循大驼峰原则，每个首字母都要大写</li>\n<li>成员变量，和以前定义变量的方法一样，不过成员变量在类中方法外</li>\n<li>方法，有构造方法，各个成员方法，功能更加丰富，也更加灵活</li>\n</ul>\n<h4 id=\"2-4-定义对象\"><a href=\"#2-4-定义对象\" class=\"headerlink\" title=\"2.4    定义对象\"></a>2.4    定义对象</h4><p>在Java中，万事万物都是对象，虽然一切可以看做对象，但是我们操纵的却是一个对象的    <strong>引用（reference）</strong> 也就是，我们有一个对象引用，但是不一定需要对象与之关联，如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Person p;</code></pre>\n\n<p>这里创建的只是 引用，而并非对象，但是若想使用这个引用时，会返回异常，高数我们需要一个 对象 来进行关联。安全的做法是，在创建引用的同时吧对象赋给他。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Person p &#x3D; new Person();</code></pre>\n\n<p>直接打印对象名和数组名都是显示“类型@对象的hashCode值”<br>所以说类、数组都是引用数据类型，引用数据类型的变量中存储的是对象的地址，或者说指向堆中对象的首地址。</p>\n<p>那么像“Student@4e25154f”是对象的地址吗？<br>不是，因为Java是对程序员隐藏内存地址的，不暴露内存地址信息，所以打印对象时不直接显示内存地址，而是JVM提取了对象描述信息给你现在，默认提取的是对象的运行时类型@代表对象唯一编码的hashCode值。</p>\n<h4 id=\"2-5-属性和方法\"><a href=\"#2-5-属性和方法\" class=\"headerlink\" title=\"2.5    属性和方法\"></a>2.5    属性和方法</h4><ul>\n<li>属性，也被称为字段，属性可以是任意类型的对象，可以是基本数据类型，也可以是引用数据类型；</li>\n<li>方法，表示的是  做某些事情的方式，方法其实就是函数</li>\n<li>方法的基本组成包括：权限修饰符，返回值类型，方法名，参数，方法体</li>\n</ul>\n<h4 id=\"2-6-构造方法\"><a href=\"#2-6-构造方法\" class=\"headerlink\" title=\"2.6    构造方法\"></a>2.6    构造方法</h4><ul>\n<li>是一种特殊的方法，也被称为构造函数，构造器。</li>\n<li>在JAVA中，通过这种方法确保每个对象都被初始化。</li>\n<li>构造方法只能在对象的创建时期调用一次。</li>\n<li><strong>没有返回值类型</strong>，他的名称要和类名保持一致，并且构造方法可以有多个。**(可以重载，不可以重写)**</li>\n<li>没有参数的称为 默认构造方法，如果没有定义其它构造方法，那JVM 会自动生成一个构造方法但是若手动定义了任何一个构造方法，JVM都不会再提供默认构造方法，必须手动指定。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test&#123;\n\t\n\tint a;\n\tint b;\n\n\tpublic Test()&#123;\n\t\t&#x2F;&#x2F;无参构造、默认构造\n\t&#125;\n\t\n\tpublic Test(int a,int b)&#123;\n\t\t&#x2F;&#x2F; 满参构造\n\t&#125;\n&#125;</code></pre>\n\n<h4 id=\"2-8-成员和局部变量的区别\"><a href=\"#2-8-成员和局部变量的区别\" class=\"headerlink\" title=\"2.8    成员和局部变量的区别\"></a>2.8    成员和局部变量的区别</h4><table>\n<thead>\n<tr>\n<th>区别</th>\n<th>成员变量</th>\n<th>局部变量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>类中位置不同</td>\n<td>类中方法外</td>\n<td>方法内或者方法声明上</td>\n</tr>\n<tr>\n<td>内存中位置不同</td>\n<td>堆内存</td>\n<td>栈内存</td>\n</tr>\n<tr>\n<td>生命周期不同</td>\n<td>随着对象的存在而存在，随着对象的消失而消失</td>\n<td>随着方法的调用而存在，随着方法的调用完毕而消失</td>\n</tr>\n<tr>\n<td>初始化值不同</td>\n<td>有默认的初始化值（默认的值在下方的成员初始化中）<br />一种情况例外:被 final 修饰的成员变量也必须显式地赋值</td>\n<td>没有默认的初始化值</td>\n</tr>\n<tr>\n<td>作用域不同</td>\n<td>整个类中</td>\n<td>方法中</td>\n</tr>\n</tbody></table>\n<p>成员变量如果被 ==static== 修饰，那么这个成员变量是属于这个类的（<strong>不会再存储到堆中，会和类一起到方法区中</strong>），如果没有，则是属于==实例==的</p>\n<h4 id=\"2-9-对象的销毁\"><a href=\"#2-9-对象的销毁\" class=\"headerlink\" title=\"2.9    对象的销毁\"></a>2.9    对象的销毁</h4><p>Java 虚拟机进行管理和销毁</p>\n<h4 id=\"2-10-作用域\"><a href=\"#2-10-作用域\" class=\"headerlink\" title=\"2.10    作用域\"></a>2.10    作用域</h4><p>作用域定义了其内部定义的变量名的可见性和生命周期。作用域通常有 { } 的位置来决定</p>\n<h3 id=\"三、重载和重写\"><a href=\"#三、重载和重写\" class=\"headerlink\" title=\"三、重载和重写\"></a>三、重载和重写</h3><h4 id=\"3-1-方法重载\"><a href=\"#3-1-方法重载\" class=\"headerlink\" title=\"3.1    方法重载\"></a>3.1    方法重载</h4><p>方法名相同，参数列表不同。构造函数，也是重载的一种</p>\n<p>每个重载方法都有<strong>独一无二的参数列表</strong>，其中包括参数的类型，顺序，数量等，满足一种因素就构成了重载。</p>\n<p>重载的条件：</p>\n<ul>\n<li>方法名必须相同</li>\n<li>参数列表必须不同（个数不同，类型不同，参数类型排列顺序不同）</li>\n<li>方法的返回值类型可以相同也可以不同</li>\n<li>仅仅返回值类型不足矣成为方法的重载</li>\n<li>重载发生在编译时，因为编译器可以根据参数类型选择使用哪个方法</li>\n</ul>\n<h4 id=\"3-2-方法重写\"><a href=\"#3-2-方法重写\" class=\"headerlink\" title=\"3.2    方法重写\"></a>3.2    方法重写</h4><p>重写描述的是  <strong>父类和子类</strong>  之间；而重载是同一类中。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">方法的声明： 权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型&#123;\n\n\t\t\t\t&#x2F;&#x2F;方法体\n\n\t\t   &#125;</code></pre>\n\n<p>约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法</p>\n<p>① 子类重写的方法的方法名和形参列表与父类被重写的方法的<strong>方法名和形参列表相同</strong></p>\n<p>② 子类重写的方法的<strong>权限修饰符不小于父类</strong>被重写的方法的权限修饰符</p>\n<ul>\n<li><pre><code>     特殊情况：子类**不能重写**父类中声明为**private权限的方法**\n</code></pre>\n</li>\n</ul>\n<p>③ 返回值类型：</p>\n<ul>\n<li><pre><code>     父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void\n</code></pre>\n</li>\n<li><pre><code>     父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是**A类或A类的子类**\n</code></pre>\n</li>\n<li><pre><code>     父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是**相同的基本数据类型**(必须也是double)\n</code></pre>\n</li>\n</ul>\n<p>④ 子类重写的方法<strong>抛出的异常类型不大于父类被重写的方法抛出的异常类型</strong>（具体放到异常处理时候讲）</p>\n<ul>\n<li>   子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写，要么都声明为static的（不是重写)。</li>\n</ul>\n<h3 id=\"四、this-和-super\"><a href=\"#四、this-和-super\" class=\"headerlink\" title=\"四、this 和 super\"></a>四、this 和 super</h3><p>this：代表<strong>本类对象的引用</strong></p>\n<p>super：代表父类存储空间的标识（可以理解为<strong>父类对象引用</strong>）</p>\n<table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>this</th>\n<th>super</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>调用方式</td>\n<td>调用本类中的属性，构造函数，方法</td>\n<td>调用父类中的属性，构造函数，方法</td>\n</tr>\n<tr>\n<td>调用位置</td>\n<td>构造函数第一行，其他自行指定</td>\n<td><strong>构造函数第一行</strong>，其他自行指定</td>\n</tr>\n<tr>\n<td>调用次数</td>\n<td>一个构造函数只能调用一次</td>\n<td>一个构造函数只能调用一次</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>访问成员变量</th>\n<th>访问构造方法</th>\n<th>访问成员方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>this</td>\n<td>this.成员变量</td>\n<td>this(…)</td>\n<td>this.成员方法(…)</td>\n</tr>\n<tr>\n<td>super</td>\n<td>super.成员变量</td>\n<td>super(…)</td>\n<td>super.成员方法(…)</td>\n</tr>\n</tbody></table>\n<h3 id=\"五、访问控制权限\"><a href=\"#五、访问控制权限\" class=\"headerlink\" title=\"五、访问控制权限\"></a>五、访问控制权限</h3><table>\n<thead>\n<tr>\n<th></th>\n<th><strong>同一类中</strong></th>\n<th><strong>同一包中（子类与无关类）</strong></th>\n<th><strong>不同包中的子类</strong></th>\n<th><strong>不同包中的无关类</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>public</strong></td>\n<td><strong>可以</strong></td>\n<td><strong>可以</strong></td>\n<td><strong>可以</strong></td>\n<td><strong>可以</strong></td>\n</tr>\n<tr>\n<td><strong>protected</strong></td>\n<td><strong>可以</strong></td>\n<td><strong>可以</strong></td>\n<td><strong>可以</strong></td>\n<td><strong>不可以</strong></td>\n</tr>\n<tr>\n<td><strong>默认（friendly/default/没有）</strong></td>\n<td><strong>可以</strong></td>\n<td><strong>可以</strong></td>\n<td><strong>不可以</strong></td>\n<td><strong>不可以</strong></td>\n</tr>\n<tr>\n<td><strong>private</strong></td>\n<td><strong>可以</strong></td>\n<td><strong>不可以</strong></td>\n<td><strong>不可以</strong></td>\n<td><strong>不可以</strong></td>\n</tr>\n</tbody></table>\n<p>public：用于类，需要别人调用的方法，构造方法</p>\n<p>protected：通常用于继承，只想让子类使用</p>\n<p>缺省（默认）：包内使用</p>\n<p>private：用于成员变量，实现封装</p>\n<ul>\n<li>private是一个权限修饰符，代表最小权限，可以修饰实例变量和实例方法。</li>\n<li>被private修饰后的实例变量和实例方法，只在本类中才能访问。</li>\n<li>父类中的成员，无论是公有(public)还是私有(private)，均会被子类继承（private被继承有歧义）。</li>\n<li><strong>子类虽会继承父类私有(private)的成员</strong>，但子类不能对继承的私有成员直接进行访问，可通过继承的公有方法进行访问</li>\n</ul>\n","text":"一、概述 Java语言是面向对象的程序设计语言，而面向对象思想（Object Oriented Programming）是一种程序设计思想。 这里的对象泛指现实中的一切事物，而每种事物都具有自己的属性和行为 而面向对象编程就是参照现实中的事物，将其属性和行为抽象出来，描述成计算机...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/tags/JavaSE.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">一、概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">二、类和对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB\"><span class=\"toc-text\">2.1    什么是类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">2.2    什么是对象</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-%E5%AE%9A%E4%B9%89%E7%B1%BB\"><span class=\"toc-text\">2.3    定义类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-4-%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">2.4    定义对象</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-5-%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.5    属性和方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-6-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.6    构造方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-8-%E6%88%90%E5%91%98%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">2.8    成员和局部变量的区别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-9-%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%80%E6%AF%81\"><span class=\"toc-text\">2.9    对象的销毁</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-10-%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">2.10    作用域</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99\"><span class=\"toc-text\">三、重载和重写</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">3.1    方法重载</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99\"><span class=\"toc-text\">3.2    方法重写</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81this-%E5%92%8C-super\"><span class=\"toc-text\">四、this 和 super</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90\"><span class=\"toc-text\">五、访问控制权限</span></a></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"面向对象（中）","uid":"6a12650511ac8438957ec15fcbb76cbc","slug":"05-面向对象（中）","date":"2021-09-13T14:37:32.000Z","updated":"2021-09-14T15:53:23.833Z","comments":true,"path":"api/articles/05-面向对象（中）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog5.jpg","text":"一、封装1.1 概述 面向对象编程语言是对客观世界的模拟，客观世界里实例变量都是隐藏在对象内部的，外界无法直接操作和修改。 封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。 1.2 原则 将类的某些信息隐藏在类内部，不允许...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/tags/JavaSE.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"数组","uid":"e16187d7a3c490f96b788338bdd79d24","slug":"03-数组","date":"2021-09-13T14:35:32.000Z","updated":"2021-09-14T15:52:56.160Z","comments":true,"path":"api/articles/03-数组.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog3.jpg","text":"一、容器 如果使用很多个变量来逐一保存数据，这样操作起来会非常的不便。把这80个数据想象成为80个鸡蛋，如果让你一个个的操作这些鸡蛋，你会非常的慌乱，此时我们可以使用一个篮子，将所有的鸡蛋(数据)全部存储到一个容器中，统一操作。 装鸡蛋用到的篮子我们可以称之为容器，容器里的一个个...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/tags/JavaSE.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}