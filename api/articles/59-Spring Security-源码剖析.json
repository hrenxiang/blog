{"title":"SpringSecurity 源码剖析","uid":"29737e157e321f39ed60992860349925","slug":"59-Spring Security-源码剖析","date":"2021-09-13T15:36:32.000Z","updated":"2021-09-15T10:47:39.755Z","comments":true,"path":"api/articles/59-Spring Security-源码剖析.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog5.jpg","content":"<p>我们在 spring_security.xml 中配置过后，为什么权限框架就能做到这些权限管理的事情呢，背后的执行流程到底又是什么呢？</p>\n<p>==Spring Security Filter 并不是直接嵌入到 Web Filter 中的，而是通过 FilterChainProxy 来统一管理 Spring Security Filter，FilterChainProxy 本身则通过 Spring 提供的 DelegatingFilterProxy 代理过滤器嵌入到 Web Filter 之中。==</p>\n<p>我们从 web.xml 中配置的 spring security的过滤器 org.springframework.web.filter.DelegatingFilterProxy 开始说起</p>\n<h4 id=\"1、DelegatingFilterProxy\"><a href=\"#1、DelegatingFilterProxy\" class=\"headerlink\" title=\"1、DelegatingFilterProxy\"></a>1、DelegatingFilterProxy</h4><p>==其实 DelegatingFilterProxy类主要作用就是一个代理模式的应用,可以把servlet 容器中的filter同spring容器中的bean关联起来。==</p>\n<p>使用过springSecurity，首先需要在web.xml进行以下配置，</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;filter&gt;\n    &lt;filter-name&gt;springSecurityFilterChain&lt;&#x2F;filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;&#x2F;filter-class&gt; \n\n    &lt;init-param&gt;\n        &lt;param-name&gt;targetFilterLifecycle&lt;&#x2F;param-name&gt;\n        &lt;param-value&gt;true&lt;&#x2F;param-value&gt;  &lt;!-- 默认是false --&gt;\n    &lt;&#x2F;init-param&gt;\n\n&lt;&#x2F;filter&gt;\n\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;springSecurityFilterChain&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;filter-mapping&gt;</code></pre>\n\n<p>从这个配置中，可能会给我们造成一个错觉，以为 DelegatingFilterProxy 类就是 springSecurity 的入口，但其实这个类位于 spring-web-3.0.5.RELEASE.jar这个jar下面，说明这个类<strong>本身是和 springSecurity 无关</strong>。</p>\n<p>DelegatingFilterProxy类继承于抽象类 GenericFilterBean，间接地 implement 了 javax.servlet.Filter 接口，Servlet 容器在启动时，首先会调用Filter的init方法,<strong>GenericFilterBean的作用主要是可以把Filter的初始化参数自动地set到继承于GenericFilterBean类的Filter中去。</strong>在 GenericFilterBean 中的 init 方法的就是做了这个事：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"> public final void init(FilterConfig filterConfig) throws ServletException &#123;   \n  ...         \n  PropertyValues pvs &#x3D; new .FilterConfigPropertyValues(filterConfig, this.requiredProperties);\n  ...\n  BeanWrapper bw &#x3D; PropertyAccessorFactory.forBeanPropertyAccess(this);\n  ResourceLoader resourceLoader &#x3D; new ServletContextResourceLoader(filterConfig.getServletContext());\n  ...\n  bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, (PropertyResolver)env));\n  this.initBeanWrapper(bw);\n  bw.setPropertyValues(pvs, true);\n  ...\n  this.initFilterBean();\n&#125;</code></pre>\n\n<p> 另外在init方法中调用了initFilterBean()方法，该方法是GenericFilterBean类是特地留给子类扩展用的，下面是DelegatingFilterProxy中重写的方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void initFilterBean() throws ServletException &#123;\n        synchronized(this.delegateMonitor) &#123;\n            if (this.delegate &#x3D;&#x3D; null) &#123;\n                if (this.targetBeanName &#x3D;&#x3D; null) &#123;\n                    this.targetBeanName &#x3D; this.getFilterName();\n                &#125;\n\n                WebApplicationContext wac &#x3D; this.findWebApplicationContext();\n                if (wac !&#x3D; null) &#123;\n                    this.delegate &#x3D; this.initDelegate(wac);\n                &#125;\n            &#125;\n        &#125;\n    &#125;</code></pre>\n\n<p> 可以看出上述代码首先看Filter是否提供了targetBeanName初始化参数，<strong>如果没有提供则直接使用filter的name做为beanName</strong></p>\n<p>产生了beanName后，由于我们在web.xml的filter的name是<strong>springSecurityFilterChain</strong>，从spring的IOC容器中取出bean的代码是initDelegate方法，下面是该方法代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected Filter initDelegate(WebApplicationContext wac) throws ServletException &#123;\n    String targetBeanName &#x3D; this.getTargetBeanName();\n    Assert.state(targetBeanName !&#x3D; null, &quot;No target bean name set&quot;);\n    \n    &lt;!--取出的bean--&gt;\n    Filter delegate &#x3D; (Filter)wac.getBean(targetBeanName, Filter.class);\n    if (this.isTargetFilterLifecycle()) &#123;\n        delegate.init(this.getFilterConfig());\n    &#125;\n\n    return delegate;\n&#125;</code></pre>\n\n<p> 通过跟踪代码，发现取出的bean是<strong>org.springframework.security.FilterChainProxy</strong>，该类也是继承于<strong>GenericFilterBean,<strong>取出bean后，判断</strong>targetFilterLifecycle</strong>属性是false还是true，决定是否调用该类的init方法。这个FilterChainProxy bean实例最终被保存在<strong>DelegatingFilterProxy类的 delegate</strong>  属性里</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/spring-security-yuanma-1.png\" alt=\"image-20210804151504118\"></p>\n<p>下面看一下<strong>DelegatingFilterProxy类的doFilter方法</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;\n    Filter delegateToUse &#x3D; this.delegate;\n    if (delegateToUse &#x3D;&#x3D; null) &#123;\n        synchronized(this.delegateMonitor) &#123;\n            delegateToUse &#x3D; this.delegate;\n            if (delegateToUse &#x3D;&#x3D; null) &#123;\n                WebApplicationContext wac &#x3D; this.findWebApplicationContext();\n                if (wac &#x3D;&#x3D; null) &#123;\n                    throw new IllegalStateException(&quot;No WebApplicationContext found: no ContextLoaderListener or DispatcherServlet registered?&quot;);\n                &#125;\n\n                delegateToUse &#x3D; this.initDelegate(wac);\n            &#125;\n\n            this.delegate &#x3D; delegateToUse;\n        &#125;\n    &#125;\n\n    this.invokeDelegate(delegateToUse, request, response, filterChain);\n&#125;</code></pre>\n\n<p> 真正要关注invokeDelegate(delegateToUse, request, response, filterChain);这句代码,在下面可以看出<strong>DelegatingFilterProxy类实际</strong>是用其delegate属性即<strong>org.springframework.security.FilterChainProxy</strong>实例的doFilter方法来响应请求。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void invokeDelegate(Filter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;\n    delegate.doFilter(request, response, filterChain);\n&#125;</code></pre>\n\n<p>此外还要注意一个DelegatingFilterProxy的一个初始化参数：targetFilterLifecycle ，其默认值为false 。 但如果被其代理的filter的init()方法和destry()方法需要被调用时，需要设置targetFilterLifecycle为true。具体可见DelegatingFilterProxy中的如下代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected Filter initDelegate(WebApplicationContext wac)throws ServletException &#123;\n    Filter delegate &#x3D; wac.getBean(getTargetBeanName(), Filter.class);\n    if (isTargetFilterLifecycle()) &#123;   &#x2F;&#x2F;注意这行\n        delegate.init(getFilterConfig());\n    &#125;\n    return delegate;\n&#125;</code></pre>\n\n\n\n<h4 id=\"2、FilterChainProxy\"><a href=\"#2、FilterChainProxy\" class=\"headerlink\" title=\"2、FilterChainProxy\"></a>2、FilterChainProxy</h4><p>FilterChainProxy 中可以<strong>存在多个过滤器链</strong>，当请求到达 FilterChainProxy 之后，FilterChainProxy <strong>会根据请求的路径，将请求转发到不同的</strong> Spring Security Filters 上面去，不同的 Spring Security Filters 对应了不同的过滤器，也就是不同的请求将经过不同的过滤器。</p>\n<p>先把 FilterChainProxy 源码亮出来，这个源码比较上，我们一部分一部分来，先从它声明的全局属性上开始：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private final static String FILTER_APPLIED &#x3D; FilterChainProxy.class.getName().concat(\n        &quot;.APPLIED&quot;);\nprivate List&lt;SecurityFilterChain&gt; filterChains;\nprivate FilterChainValidator filterChainValidator &#x3D; new NullFilterChainValidator();\nprivate HttpFirewall firewall &#x3D; new StrictHttpFirewall();</code></pre>\n\n<ul>\n<li>FILTER_APPLIED 变量是一个标记，用来标记过滤器是否已经执行过了。这个标记在 Spring Security 中很常见，松哥这里就不多说了。</li>\n<li>filterChains 是过滤器链，注意，这个是过滤器链，而不是一个个的过滤器，配置多个过滤器链就保存在 filterChains 变量中，也就是，如果你有一个过滤器链，这个集合中就保存一条记录，你有两个过滤器链，这个记录中就保存两条记录，每一条记录又对应了过滤器链中的一个个过滤器。</li>\n<li>filterChainValidator 是 FilterChainProxy 配置完成后的校验方法，默认使用的 NullFilterChainValidator 实际上对应了一个空方法，也就是不做任何校验。</li>\n<li>firewall (<a href=\"https://links.jianshu.com/go?to=https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ\">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a>)</li>\n</ul>\n<p>最重要的 doFilter 方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic void doFilter(ServletRequest request, ServletResponse response,\n        FilterChain chain) throws IOException, ServletException &#123;\n    boolean clearContext &#x3D; request.getAttribute(FILTER_APPLIED) &#x3D;&#x3D; null;\n    if (clearContext) &#123;\n        try &#123;\n            request.setAttribute(FILTER_APPLIED, Boolean.TRUE);\n            doFilterInternal(request, response, chain);\n        &#125;\n        finally &#123;\n            SecurityContextHolder.clearContext();\n            request.removeAttribute(FILTER_APPLIED);\n        &#125;\n    &#125;\n    else &#123;\n        doFilterInternal(request, response, chain);\n    &#125;\n&#125;</code></pre>\n\n<p>在 doFilter 方法中，正常来说，clearContext 参数每次都是 true，于是每次都先给 request 标记上 FILTER_APPLIED 属性，然后执行 doFilterInternal 方法去走过滤器，执行完毕后，最后在 finally 代码块中清除 SecurityContextHolder 中保存的用户信息，同时移除 request 中的标记。</p>\n<p>按着这个顺序，doFilterInternal 方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private void doFilterInternal(ServletRequest request, ServletResponse response,\n        FilterChain chain) throws IOException, ServletException &#123;\n    FirewalledRequest fwRequest &#x3D; firewall\n            .getFirewalledRequest((HttpServletRequest) request);\n    HttpServletResponse fwResponse &#x3D; firewall\n            .getFirewalledResponse((HttpServletResponse) response);\n    List&lt;Filter&gt; filters &#x3D; getFilters(fwRequest);\n    if (filters &#x3D;&#x3D; null || filters.size() &#x3D;&#x3D; 0) &#123;\n        if (logger.isDebugEnabled()) &#123;\n            logger.debug(UrlUtils.buildRequestUrl(fwRequest)\n                    + (filters &#x3D;&#x3D; null ? &quot; has no matching filters&quot;\n                            : &quot; has an empty filter list&quot;));\n        &#125;\n        fwRequest.reset();\n        chain.doFilter(fwRequest, fwResponse);\n        return;\n    &#125;\n    VirtualFilterChain vfc &#x3D; new VirtualFilterChain(fwRequest, chain, filters);\n    vfc.doFilter(fwRequest, fwResponse);\n&#125;\nprivate List&lt;Filter&gt; getFilters(HttpServletRequest request) &#123;\n    for (SecurityFilterChain chain : filterChains) &#123;\n        if (chain.matches(request)) &#123;\n            return chain.getFilters();\n        &#125;\n    &#125;\n    return null;\n&#125;</code></pre>\n\n<p>doFilterInternal 方法就比较重要了：</p>\n<ol>\n<li>首先将请求封装为一个 FirewalledRequest 对象，在这个封装的过程中，也会判断请求是否合法。</li>\n<li>对响应进行封装。</li>\n<li>调用 getFilters 方法找到过滤器链。该方法根据当前请求，从 filterChains 中找到对应的过滤器链，然后由该过滤器链去处理请求。</li>\n<li>如果找出来的 filters 为 null，或者集合中没有元素，那就是说明当前请求不需要经过过滤器。直接执行 chain.doFilter ，这个就又回到原生过滤器中去了。那么什么时候会发生这种情况呢？那就是针对项目中的静态资源，如果我们配置了资源放行，那么当你请求 这些资源时就会走到这里来，也就是说这个不经过 Spring Security Filter。</li>\n<li>如果查询到的 filters 中是有值的，那么这个 filters 集合中存放的就是我们要经过的过滤器链了。此时它会构造出一个虚拟的过滤器链 VirtualFilterChain 出来，并执行其中的 doFilter 方法。</li>\n</ol>\n<div>\n   <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/spring-security-yuanma-2.png\" alt=\"image-20210804161121775\" style=\"zoom:67%;\" />\n</div>\n\n<p>那么接下来我们就来看看 VirtualFilterChain：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;\n&#x2F;&#x2F; Source code recreated from a .class file by IntelliJ IDEA\n&#x2F;&#x2F; (powered by FernFlower decompiler)\n&#x2F;&#x2F;\n\npackage org.springframework.security.web;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.web.firewall.FirewalledRequest;\nimport org.springframework.security.web.firewall.HttpFirewall;\nimport org.springframework.security.web.firewall.StrictHttpFirewall;\nimport org.springframework.security.web.util.UrlUtils;\nimport org.springframework.web.filter.GenericFilterBean;\n\npublic class FilterChainProxy extends GenericFilterBean &#123;\n    private static final Log logger &#x3D; LogFactory.getLog(FilterChainProxy.class);\n    private static final String FILTER_APPLIED &#x3D; FilterChainProxy.class.getName().concat(&quot;.APPLIED&quot;);\n    private List&lt;SecurityFilterChain&gt; filterChains;\n    private FilterChainProxy.FilterChainValidator filterChainValidator;\n    private HttpFirewall firewall;\n\n    ...\n\n        public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException &#123;\n            if (this.currentPosition &#x3D;&#x3D; this.size) &#123;\n                if (FilterChainProxy.logger.isDebugEnabled()) &#123;\n                    FilterChainProxy.logger.debug(UrlUtils.buildRequestUrl(this.firewalledRequest) + &quot; reached end of additional filter chain; proceeding with original chain&quot;);\n                &#125;\n\n                this.firewalledRequest.reset();\n                this.originalChain.doFilter(request, response);\n            &#125; else &#123;\n                ++this.currentPosition;\n                Filter nextFilter &#x3D; (Filter)this.additionalFilters.get(this.currentPosition - 1);\n                if (FilterChainProxy.logger.isDebugEnabled()) &#123;\n                    FilterChainProxy.logger.debug(UrlUtils.buildRequestUrl(this.firewalledRequest) + &quot; at position &quot; + this.currentPosition + &quot; of &quot; + this.size + &quot; in additional filter chain; firing Filter: &#39;&quot; + nextFilter.getClass().getSimpleName() + &quot;&#39;&quot;);\n                &#125;\n\n                nextFilter.doFilter(request, response, this);\n            &#125;\n\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n\n<ol>\n<li>VirtualFilterChain 类中首先声明了 5 个全局属性，originalChain 表示原生的过滤器链，也就是 Web Filter；additionalFilters 表示 Spring Security 中的过滤器链；firewalledRequest 表示当前请求；size 表示过滤器链中过滤器的个数；currentPosition 则是过滤器链遍历时候的下标。</li>\n<li>doFilter 方法就是 Spring Security 中过滤器挨个执行的过程，如果 <code>currentPosition == size</code>，表示过滤器链已经执行完毕，此时通过调用 originalChain.doFilter 进入到原生过滤链方法中，同时也退出了 Spring Security 过滤器链。否则就从 additionalFilters 取出 Spring Security 过滤器链中的一个个过滤器，挨个调用 doFilter 方法。</li>\n</ol>\n<p>最后，FilterChainProxy 中还定义了 FilterChainValidator 接口及其实现：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface FilterChainValidator &#123;\n    void validate(FilterChainProxy filterChainProxy);\n&#125;\nprivate static class NullFilterChainValidator implements FilterChainValidator &#123;\n    @Override\n    public void validate(FilterChainProxy filterChainProxy) &#123;\n    &#125;\n&#125;</code></pre>\n\n<p>实际上这个实现并未做任何事情。</p>\n<p>（下面介绍的是FilterChainProxy 中12个过滤器的部分）</p>\n<h4 id=\"3、用户名密码认证过滤器\"><a href=\"#3、用户名密码认证过滤器\" class=\"headerlink\" title=\"3、用户名密码认证过滤器\"></a>3、用户名密码认证过滤器</h4><p><strong>UsernamePasswordAuthenticationFilter</strong></p>\n<p>username中会加载数据库中的数据进行比较</p>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/spring-security-yuanma-4.png\" alt=\"image-20210804161244877\" style=\"zoom: 50%;\" />\n</div>\n\n<p>加载数据库中的数据时，<strong>DaoAuthenticationProvider</strong> 中 retrieveUser（检索用户）方法会被调用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123;\n    this.prepareTimingAttackProtection();\n\n    try &#123;\n        &lt;!--注意这里，获取用户--&gt;\n        UserDetails loadedUser &#x3D; this.getUserDetailsService().loadUserByUsername(username);\n        if (loadedUser &#x3D;&#x3D; null) &#123;\n            throw new InternalAuthenticationServiceException(&quot;UserDetailsService returned null, which is an interface contract violation&quot;);\n        &#125; else &#123;\n            return loadedUser;\n        &#125;\n    &#125; catch (UsernameNotFoundException var4) &#123;\n        this.mitigateAgainstTimingAttack(authentication);\n        throw var4;\n    &#125; catch (InternalAuthenticationServiceException var5) &#123;\n        throw var5;\n    &#125; catch (Exception var6) &#123;\n        throw new InternalAuthenticationServiceException(var6.getMessage(), var6);\n    &#125;\n&#125;</code></pre>\n\n<p>它调用了自身的getUserDetailsService方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected UserDetailsService getUserDetailsService() &#123;\n    return this.userDetailsService;\n&#125;</code></pre>\n\n<p>返回的userDetailsService是DaoAuthenticationProvider自身定义的UserDetailsService的对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static final String USER_NOT_FOUND_PASSWORD &#x3D; &quot;userNotFoundPassword&quot;;\nprivate PasswordEncoder passwordEncoder;\nprivate volatile String userNotFoundEncodedPassword;\n&lt;!--这里--&gt;\nprivate UserDetailsService userDetailsService;</code></pre>\n\n<p>而UserDetailsService，是一个接口，有一个抽象的方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface UserDetailsService &#123;\n    UserDetails loadUserByUsername(String var1) throws UsernameNotFoundException;\n&#125;</code></pre>\n\n<p>在我们的web中，我们实现了这个接口，因为我们在xml提供了认证者，也就是下面的类，所以说security会拿到认证者，然后进行调用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\npublic class SecurityUserServiceImpl implements UserDetailsService &#123;\n\n    @Reference\n    private UserService userService;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        &#x2F;&#x2F;根据名字获取用户信息\n        User user &#x3D; userService.getUserByName(username);\n\n        if (user &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n\n        &#x2F;&#x2F;新建用户权限集合\n        List&lt;GrantedAuthority&gt; authorityList &#x3D; new ArrayList&lt;&gt;();\n\n        &#x2F;&#x2F;查询用户相应权限\n        Set&lt;Role&gt; roles &#x3D; user.getRoles();\n        for (Role role : roles) &#123;\n            Set&lt;Permission&gt; permissions &#x3D; role.getPermissions();\n            for (Permission permission : permissions) &#123;\n                authorityList.add(new SimpleGrantedAuthority(permission.getKeyword()));\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F;将数据返回给权限框架，在内部进行比较\n        return new org.springframework.security.core.userdetails.User(username, user.getPassword(), authorityList);\n    &#125;\n&#125;\n</code></pre>\n\n\n\n<h4 id=\"4、LogoutFilter\"><a href=\"#4、LogoutFilter\" class=\"headerlink\" title=\"4、LogoutFilter\"></a>4、LogoutFilter</h4><div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/spring-security-yuanma-3.png\"/>\n</div>\n\n\n\n","text":"我们在 spring_security.xml 中配置过后，为什么权限框架就能做到这些权限管理的事情呢，背后的执行流程到底又是什么呢？ ==Spring Security Filter 并不是直接嵌入到 Web Filter 中的，而是通过 FilterChainProxy 来统...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"Spring","slug":"Spring","count":6,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":6,"path":"api/tags/Spring.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81DelegatingFilterProxy\"><span class=\"toc-text\">1、DelegatingFilterProxy</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81FilterChainProxy\"><span class=\"toc-text\">2、FilterChainProxy</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E8%AE%A4%E8%AF%81%E8%BF%87%E6%BB%A4%E5%99%A8\"><span class=\"toc-text\">3、用户名密码认证过滤器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81LogoutFilter\"><span class=\"toc-text\">4、LogoutFilter</span></a></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"Spring 整合","uid":"173956e689406289f575044308a994ef","slug":"60-Spring 整合各个模块","date":"2021-09-13T15:37:32.000Z","updated":"2021-09-15T10:47:26.939Z","comments":true,"path":"api/articles/60-Spring 整合各个模块.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog4.jpg","text":"meinian — daojdbc.properties jdbc.driverClassName&#x3D;com.mysql.jdbc.Driver jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;meinia...","link":"","photos":[],"count_time":{"symbolsCount":"34k","symbolsTime":"31 mins."},"categories":[{"name":"Spring","slug":"Spring","count":6,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":6,"path":"api/tags/Spring.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"SpringSecurity 权限管理","uid":"57895ac4a5b71846b764434fcb138119","slug":"58-Spring Security-权限管理","date":"2021-09-13T15:35:32.000Z","updated":"2021-09-15T10:47:49.376Z","comments":true,"path":"api/articles/58-Spring Security-权限管理.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog6.jpg","text":":open_umbrella: 权限控制 1、认证和授权的概念前面我们已经完成了旅游后台管理系统的部分功能，例如自由行管理、跟团游管理、套餐管理、预约设置等。接下来我们需要思考2个问题： 问题1：在生产环境下我们如果不登录后台系统就可以完成这些功能操作吗？ 答案显然是否定的，要操...","link":"","photos":[],"count_time":{"symbolsCount":"41k","symbolsTime":"37 mins."},"categories":[{"name":"Spring","slug":"Spring","count":6,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":6,"path":"api/tags/Spring.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}