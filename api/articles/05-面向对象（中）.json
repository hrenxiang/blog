{"title":"面向对象（中）","uid":"6a12650511ac8438957ec15fcbb76cbc","slug":"05-面向对象（中）","date":"2021-09-13T14:37:32.000Z","updated":"2021-09-14T15:53:23.833Z","comments":true,"path":"api/articles/05-面向对象（中）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog5.jpg","content":"<h3 id=\"一、封装\"><a href=\"#一、封装\" class=\"headerlink\" title=\"一、封装\"></a>一、封装</h3><h4 id=\"1-1-概述\"><a href=\"#1-1-概述\" class=\"headerlink\" title=\"1.1    概述\"></a>1.1    概述</h4><ul>\n<li>面向对象编程语言是对客观世界的模拟，客观世界里实例变量都是隐藏在对象内部的，外界无法直接操作和修改。</li>\n<li>封装可以被认为是一个保护屏障，<strong>防止</strong>该类的代码和数据被其他类<strong>随意访问</strong>。要访问该类的数据，必须通过指定的方式。</li>\n</ul>\n<h4 id=\"1-2-原则\"><a href=\"#1-2-原则\" class=\"headerlink\" title=\"1.2    原则\"></a>1.2    原则</h4><ul>\n<li>将类的某些信息隐藏在类内部，不允许外部程序直接访问</li>\n<li>通过该类提供的方法来实现对隐藏信息的操作和访问</li>\n<li><strong>成员变量private</strong>，提供对应的  get / set  方法</li>\n</ul>\n<h4 id=\"1-3-好处\"><a href=\"#1-3-好处\" class=\"headerlink\" title=\"1.3    好处\"></a>1.3    好处</h4><ul>\n<li><p>通过方法来控制成员量的操作，提高了代码的<strong>安全性</strong></p>\n</li>\n<li><p>把代码用方法进行封装，提高了代码的<strong>复用性</strong></p>\n</li>\n</ul>\n<h3 id=\"二、继承\"><a href=\"#二、继承\" class=\"headerlink\" title=\"二、继承\"></a>二、继承</h3><h4 id=\"2-1-概述\"><a href=\"#2-1-概述\" class=\"headerlink\" title=\"2.1    概述\"></a>2.1    概述</h4><ul>\n<li><p>继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。</p>\n</li>\n<li><p>猫狗类都可以称为<strong>子类</strong>，也叫<strong>派生类</strong>；多个类抽取出来的这个动物类称为<strong>父类</strong>、<strong>超类（superclass）</strong>或者<strong>基类</strong>。</p>\n</li>\n<li><p>继承描述的是事物之间的所属关系，父类更通用，子类更具体。</p>\n</li>\n<li><p>extends 用在 class 或 interface声明中，用于指示所声明的类或接口是其名称后跟有 extends关键字的类或接口的子类</p>\n</li>\n<li><p>子类继承父类的所有 public 和 protected 变量和方法。 </p>\n</li>\n<li><p>子类可以重写父类的任何非 final 方法。</p>\n</li>\n<li><p>一个类只能扩展一个其他类。</p>\n</li>\n</ul>\n<h4 id=\"2-2-好处\"><a href=\"#2-2-好处\" class=\"headerlink\" title=\"2.2    好处\"></a>2.2    好处</h4><p>子类继承父类，就使得子类对象具有与父类相同的属性，可以调用父类相同的行为。</p>\n<ul>\n<li>提高<strong>代码的复用性</strong>。</li>\n<li>提高<strong>代码的扩展性</strong>。</li>\n<li>类与类之间产生了关系，是学习<strong>多态的前提</strong>。</li>\n</ul>\n<h4 id=\"2-3-注意事项\"><a href=\"#2-3-注意事项\" class=\"headerlink\" title=\"2.3    注意事项\"></a>2.3    注意事项</h4><ul>\n<li>Java中类只支持<strong>单继承</strong>， 不支持多继承</li>\n<li>Java中类支持<strong>多层继承</strong></li>\n</ul>\n<h4 id=\"2-4-常见写法\"><a href=\"#2-4-常见写法\" class=\"headerlink\" title=\"2.4    常见写法\"></a>2.4    常见写法</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Animal &#123;\n    private String name;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n\n    Animal(String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n&#125;\n\nclass Dog extends Animal &#123;\n    Dog(String name) &#123;\n        super(name);\n    &#125;\n&#125;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        Dog dog &#x3D; new Dog(&quot;jerry&quot;);\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"2-5-继承中变量的访问特点\"><a href=\"#2-5-继承中变量的访问特点\" class=\"headerlink\" title=\"2.5    继承中变量的访问特点\"></a>2.5    继承中变量的访问特点</h4><h5 id=\"2-5-1-成员变量不重名\"><a href=\"#2-5-1-成员变量不重名\" class=\"headerlink\" title=\"2.5.1    成员变量不重名\"></a>2.5.1    成员变量不重名</h5><ul>\n<li>子类局部范围找</li>\n<li>子类成员范围找</li>\n<li>父类成员范围找</li>\n<li>如果都没有就报错(不考虑父亲的父亲.)（保持疑问）</li>\n</ul>\n<h5 id=\"2-5-2-成员变量重名\"><a href=\"#2-5-2-成员变量重名\" class=\"headerlink\" title=\"2.5.2    成员变量重名\"></a>2.5.2    成员变量重名</h5><p>同不重名，但重名时，访问不了父类的成员变量</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Fu &#123;\n    &#x2F;&#x2F; Fu中的成员变量。\n    int num &#x3D; 3;\n&#125;\n\nclass Zi extends Fu &#123;\n    &#x2F;&#x2F; Zi中的成员变量\n    int num &#x3D; 4;\n    public void show() &#123;\n        &#x2F;&#x2F; 访问的num到底是子类还是父类？\n        System.out.println(&quot;num &#x3D; &quot; + num);\n    &#125;\n&#125;\nclass ExtendsDemo03 &#123;\n    public static void main(String[] args) &#123;\n          &#x2F;&#x2F; 创建子类对象\n        Zi z &#x3D; new Zi(); \n          &#x2F;&#x2F; 调用子类中的show方法\n        z.show(); \n    &#125;\n&#125;\n演示结果：\nnum &#x3D; 4</code></pre>\n\n<p>子父类中出现了同名的成员变量时，在子类中<strong>需要访问父类中非私有成员变量</strong>时，需要使用  <strong>super</strong> 关键字，修饰父类成员变量，类似于之前学过的  this 。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Zi extends Fu &#123;\n    &#x2F;&#x2F; Zi中的成员变量\n    int num &#x3D; 6;\n    public void show() &#123;\n        &#x2F;&#x2F;访问父类中的num\n        System.out.println(&quot;Fu num&#x3D;&quot; + super.num);\n        &#x2F;&#x2F;访问子类中的num\n        System.out.println(&quot;Zi num&#x3D;&quot; + this.num);\n    &#125;\n&#125;\n演示结果：\nFu num &#x3D; 5\nZi num &#x3D; 6</code></pre>\n\n<p>小贴士：</p>\n<ul>\n<li>Fu 类中的成员变量是非私有的，子类中可以直接访问。</li>\n<li><strong>若Fu 类中的成员变量私有了，子类是不能直接访问的</strong>。</li>\n<li>通常编码时，遵循封装的原则，使用private修饰成员变量。可以在父类中提供公共的getXxx方法和setXxx方法。</li>\n</ul>\n<h4 id=\"2-6-继承中方法访问特点\"><a href=\"#2-6-继承中方法访问特点\" class=\"headerlink\" title=\"2.6    继承中方法访问特点\"></a>2.6    继承中方法访问特点</h4><h5 id=\"2-6-1-构造方法\"><a href=\"#2-6-1-构造方法\" class=\"headerlink\" title=\"2.6.1    构造方法\"></a>2.6.1    构造方法</h5><ol>\n<li><font color=\"#ee3f4d\">子类中所有的构造方法默认都会访问父类中无参的构造方法</font>。<ul>\n<li>因为子类会继承父类中的数据，可能使用父类数据。所以，子类初始化之前，一定要先完成父类的初始化</li>\n<li>每一个子类构造方法的第一 条语句默认都是: super()</li>\n<li>即便在子类的构造方法里没有手动使用<code>super</code>调用父类构造函数，子类也是会自动调用父类的空参数构造函数</li>\n</ul>\n</li>\n<li>如果父类中没有无参构造方法，只有带参构造方法，该怎么办呢?<ul>\n<li>通过使用super关键字 去显示的调用父类的带参构造方法</li>\n<li>在父类中自 己提供一个无参构造方法</li>\n<li>子类中也不要无参构造方法</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"2-6-2-成员方法不重名\"><a href=\"#2-6-2-成员方法不重名\" class=\"headerlink\" title=\"2.6.2    成员方法不重名\"></a>2.6.2    成员方法不重名</h5><p>会先在<strong>子类中查找</strong>有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中<strong>不存在就会执行父类中相应的方法</strong>。</p>\n<h5 id=\"2-6-3-成员方法重名（重写）\"><a href=\"#2-6-3-成员方法重名（重写）\" class=\"headerlink\" title=\"2.6.3    成员方法重名（重写）\"></a>2.6.3    成员方法重名（重写）</h5><p>就是重写，直接覆盖。</p>\n<p>方法的覆盖重写特点：<strong>创建的是子类对象，则优先用子类方法</strong>。</p>\n<p>注意事项：</p>\n<ol>\n<li>必须保证父子类之间方法的名称相同，参数列表也相同。 @Override：写在方法前面，用来检测是不是有效的正确覆盖重写。<br>这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。</li>\n<li>子类方法的返回值类型必须【小于等于】父类方法的返回值类型（小于其实就是是它的子类）。</li>\n<li>子类方法的权限必须【大于等于】父类方法的权限修饰符。 小扩展提示：public &gt; protected &gt; 缺省 &gt; private 备注：缺省不是汉字缺省，而是什么都不写，留空。</li>\n</ol>\n<h3 id=\"三、static\"><a href=\"#三、static\" class=\"headerlink\" title=\"三、static\"></a>三、static</h3><h4 id=\"3-1-概述\"><a href=\"#3-1-概述\" class=\"headerlink\" title=\"3.1    概述\"></a>3.1    概述</h4><p>static 关键字可以应用于内部类（在另一个类中定义的类）、方法或字段（类的成员变量）。<br>通常，static 关键字意味着应用它的实体在声明该实体的类的任何特定实例外部可用。<br>static（内部）类可以被其他类实例化和引用（即使它是顶级类）<br>static 字段（类的成员变量）在类的所有实例中只存在一次</p>\n<h4 id=\"3-2-static修饰的特点\"><a href=\"#3-2-static修饰的特点\" class=\"headerlink\" title=\"3.2    static修饰的特点\"></a>3.2    static修饰的特点</h4><ul>\n<li>被类的所有对象共享<br>这也是我们判断是否使用静态关键字的条件</li>\n<li>静态修饰的优先于对象存在，所以可以<strong>直接被类名调用</strong><br>当然，也可以通过<strong>对象名调用</strong>，推荐使用类名调用</li>\n</ul>\n<h4 id=\"3-3-static访问特点\"><a href=\"#3-3-static访问特点\" class=\"headerlink\" title=\"3.3    static访问特点\"></a>3.3    static访问特点</h4><ul>\n<li><strong>非静态的成员方法</strong><pre><code>• 能访问静态的成员变量\n• 能访问非静态的成员变量\n• 能访问静态的成员方法\n• 能访问非静态的成员方法\n</code></pre>\n</li>\n<li><strong>静态的成员方法</strong><pre><code>• 能访问静态的成员变量\n• 能访问静态的成员方法\n总结成一句话就是：**静态成员方法只能访问静态成员**\n</code></pre>\n</li>\n</ul>\n<p><img src=\"https://gitee.com/xiuxiuai/picture/raw/master/img/static%E5%86%85%E5%AD%98%E5%9B%BE.jpg\" alt=\"img\"></p>\n<h3 id=\"四、final\"><a href=\"#四、final\" class=\"headerlink\" title=\"四、final\"></a>四、final</h3><p>1、可以用来修饰：类、方法、变量</p>\n<p>2、具体的：final 用来修饰一个类、此<strong>类不能被其他类所继承</strong>。</p>\n<ul>\n<li><pre><code>     比如：String类、System类、StringBuffer类\n</code></pre>\n</li>\n</ul>\n<p>3、final 用来修饰方法：表明此<strong>方法不可以被重写</strong></p>\n<ul>\n<li><pre><code>        比如：Object类中getClass();\n</code></pre>\n</li>\n</ul>\n<p>4、 final 用来修饰变量：此时的”变量”就称为是一个常量</p>\n<ul>\n<li><p>final修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化</p>\n</li>\n<li><p>final修饰局部变量：</p>\n<p>尤其是使用final修饰形参时，表明此形参是一个常量。</p>\n<p>当我们调用此方法时，给常量形参赋一个实参。</p>\n<p>一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</p>\n</li>\n<li><pre><code>      static final 用来修饰属性：全局常量\n</code></pre>\n</li>\n</ul>\n<p>5、一个类不能同时是 abstract 又是 final。abstract 意味着必须扩展类，final 意味着不能扩展类</p>\n<h3 id=\"五、抽象类\"><a href=\"#五、抽象类\" class=\"headerlink\" title=\"五、抽象类\"></a>五、抽象类</h3><p>abstract修饰类：抽象类</p>\n<ul>\n<li><pre><code> 此类**不能实例化**\n</code></pre>\n</li>\n<li><pre><code> 抽象类中一定有构造器（默认也会有无参构造），便于子类实例化时调用（涉及：子类对象实例化的全过程）\n</code></pre>\n</li>\n<li><pre><code> 开发中，都会提供抽象类的子类，**让子类对象实例化**，完成相关的操作 ---&gt;抽象的**使用前提：继承性**\n</code></pre>\n</li>\n</ul>\n<p>abstract修饰方法：抽象方法</p>\n<ul>\n<li><pre><code>    抽象方法只方法的声明，**没方法体**\n</code></pre>\n</li>\n<li><pre><code>    包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。\n</code></pre>\n</li>\n<li><pre><code>   若子类重写了父类中的所的抽象方法后，此子类方可实例化\n</code></pre>\n</li>\n<li><pre><code>     若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰\n</code></pre>\n</li>\n</ul>\n<p>注意点：</p>\n<ul>\n<li>1.abstract不能用来修饰：属性、构造器等结构</li>\n<li>2.abstract不能用来修饰私方法、静态方法、final的方法、final的类</li>\n<li>抽象类可以有构造器、静态方法。构造器能<strong>被子类继承并完成初始化</strong>，但<strong>不会创建抽象类的实例对象</strong>。<br>静态方法的好处是不实例化就可<strong>由子类类名直接调用</strong></li>\n</ul>\n<h3 id=\"六、接口\"><a href=\"#六、接口\" class=\"headerlink\" title=\"六、接口\"></a>六、接口</h3><p>1.接口使用interface来定义</p>\n<p>2.Java中，接口和类是并列的两个结构</p>\n<p>3.如何定义接口：定义接口中的成员</p>\n<p>4.JDK7及以前：只能定义<strong>全局常量</strong>和<strong>抽象方法</strong></p>\n<ul>\n<li><pre><code>        全局常量：public static final的.但是书写时，可以省略不写\n</code></pre>\n</li>\n<li><pre><code>        抽象方法：public abstract的\n</code></pre>\n</li>\n</ul>\n<p>5.JDK8：除了定义全局常量和抽象方法之外，还可以定义<strong>静态方法</strong>、<strong>默认方法</strong></p>\n<p>   JDK9以后可以定义<strong>私有方法</strong></p>\n<p>6.接口中不能定义构造器的！意味着接口不可以实例化</p>\n<p>7.Java开发中，接口通过让类去实现**(implements)**的方式来使用.</p>\n<ul>\n<li>如果实现类覆盖了接口中的所抽象方法，则此实现类就可以实例化</li>\n<li>如果实现类没覆盖接口中所的抽象方法，则此实现类仍为一个抽象类</li>\n</ul>\n<p>8.Java类可以<strong>实现多个接口</strong>   —&gt;弥补了Java单继承性的局限性</p>\n<ul>\n<li>格式：class AA extends BB implements CC,DD,EE</li>\n</ul>\n<p>9.接口与接口之间可以继承，而且可以多继承</p>\n<ul>\n<li>接口的具体使用，体现多态性</li>\n<li>接口，实际上可以<strong>看做是一种规范</strong></li>\n</ul>\n<h4 id=\"10-知识点\"><a href=\"#10-知识点\" class=\"headerlink\" title=\"10.知识点\"></a>10.知识点</h4><ul>\n<li><p>接口中定义的静态方法，只能通过接口来调用。</p>\n</li>\n<li><p>通过实现类的对象，可以调用接口中的默认方法。</p>\n<p>如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</p>\n</li>\n<li><p>如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法</p>\n<p>那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。–&gt;类优先原则</p>\n</li>\n<li><p>如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，</p>\n<p>那么在实现类没重写此方法的情况下，报错。–&gt;接口冲突。</p>\n<p>这就需要我们必须在实现类中重写此方法</p>\n</li>\n<li><p>如何在子类(或实现类)的方法中调用父类、接口中被重写的方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void myMethod()&#123;\n    method3();&#x2F;&#x2F;调用自己定义的重写的方法\n    super.method3();&#x2F;&#x2F;调用的是父类中声明的\n    &#x2F;&#x2F;调用接口中的默认方法\n    CompareA.super.method3();\n    CompareB.super.method3();\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"七、多态\"><a href=\"#七、多态\" class=\"headerlink\" title=\"七、多态\"></a>七、多态</h3><p>1.<strong>多态</strong>： 就是指同一事物，具有多个不同表现形式。</p>\n<p>2.前提</p>\n<ul>\n<li>继承或者实现【二选一】</li>\n<li>方法的重写【意义体现：不重写，无意义】</li>\n<li>父类引用指向子类对象【格式体现】</li>\n</ul>\n<p>3.大大的提高了代码的灵活性，便于代码后期的扩展</p>\n<p>4.成员方法，编译看左边，运行看右边</p>\n<p>5.成员变量，<strong>等号左边是谁，优先用谁</strong></p>\n<h3 id=\"八、引用类型转换\"><a href=\"#八、引用类型转换\" class=\"headerlink\" title=\"八、引用类型转换\"></a>八、引用类型转换</h3><h4 id=\"1-向上转型\"><a href=\"#1-向上转型\" class=\"headerlink\" title=\"1.向上转型\"></a>1.向上转型</h4><p>多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。当父类引用指向一个子类对象时，便是向上转型。</p>\n<p>使用格式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">父类类型  变量名 &#x3D; new 子类类型();\n如：Animal a &#x3D; new Cat();</code></pre>\n\n<h4 id=\"2-向下转型\"><a href=\"#2-向下转型\" class=\"headerlink\" title=\"2.向下转型\"></a>2.向下转型</h4><p>父类类型向子类类型向下转换的过程，这个过程是强制的。一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。</p>\n<p>使用格式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">子类类型 变量名 &#x3D; (子类类型) 父类变量名;\n如:Cat c &#x3D;(Cat) a; </code></pre>\n\n<h4 id=\"3-类型转换的意义\"><a href=\"#3-类型转换的意义\" class=\"headerlink\" title=\"3.类型转换的意义\"></a>3.类型转换的意义</h4><p>调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，<strong>不能调用</strong>子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。</p>\n<h4 id=\"4-转型的异常\"><a href=\"#4-转型的异常\" class=\"headerlink\" title=\"4.转型的异常\"></a>4.转型的异常</h4><p>为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验，格式如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">变量名 instanceof 数据类型 \n如果变量属于该数据类型，返回true。\n如果变量不属于该数据类型，返回false。</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 向上转型  \n        Animal a &#x3D; new Cat();  \n        a.eat();               &#x2F;&#x2F; 调用的是 Cat 的 eat\n\n        &#x2F;&#x2F; 向下转型  \n        if (a instanceof Cat)&#123;\n            Cat c &#x3D; (Cat)a;       \n            c.catchMouse();        &#x2F;&#x2F; 调用的是 Cat 的 catchMouse\n        &#125; else if (a instanceof Dog)&#123;\n            Dog d &#x3D; (Dog)a;       \n            d.watchHouse();       &#x2F;&#x2F; 调用的是 Dog 的 watchHouse\n        &#125;\n    &#125;  \n&#125;</code></pre>\n\n","text":"一、封装1.1 概述 面向对象编程语言是对客观世界的模拟，客观世界里实例变量都是隐藏在对象内部的，外界无法直接操作和修改。 封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。 1.2 原则 将类的某些信息隐藏在类内部，不允许...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/tags/JavaSE.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%B0%81%E8%A3%85\"><span class=\"toc-text\">一、封装</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.1    概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">1.2    原则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-%E5%A5%BD%E5%A4%84\"><span class=\"toc-text\">1.3    好处</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">二、继承</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">2.1    概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-%E5%A5%BD%E5%A4%84\"><span class=\"toc-text\">2.2    好处</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">2.3    注意事项</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-4-%E5%B8%B8%E8%A7%81%E5%86%99%E6%B3%95\"><span class=\"toc-text\">2.4    常见写法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-5-%E7%BB%A7%E6%89%BF%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">2.5    继承中变量的访问特点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-5-1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8D%E9%87%8D%E5%90%8D\"><span class=\"toc-text\">2.5.1    成员变量不重名</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-5-2-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E9%87%8D%E5%90%8D\"><span class=\"toc-text\">2.5.2    成员变量重名</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-6-%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%96%B9%E6%B3%95%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">2.6    继承中方法访问特点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-6-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.6.1    构造方法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-6-2-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E4%B8%8D%E9%87%8D%E5%90%8D\"><span class=\"toc-text\">2.6.2    成员方法不重名</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-6-3-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E9%87%8D%E5%90%8D%EF%BC%88%E9%87%8D%E5%86%99%EF%BC%89\"><span class=\"toc-text\">2.6.3    成员方法重名（重写）</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81static\"><span class=\"toc-text\">三、static</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">3.1    概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-static%E4%BF%AE%E9%A5%B0%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">3.2    static修饰的特点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-3-static%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">3.3    static访问特点</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81final\"><span class=\"toc-text\">四、final</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB\"><span class=\"toc-text\">五、抽象类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">六、接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-%E7%9F%A5%E8%AF%86%E7%82%B9\"><span class=\"toc-text\">10.知识点</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%83%E3%80%81%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">七、多态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AB%E3%80%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">八、引用类型转换</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B\"><span class=\"toc-text\">1.向上转型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B\"><span class=\"toc-text\">2.向下转型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%84%8F%E4%B9%89\"><span class=\"toc-text\">3.类型转换的意义</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E8%BD%AC%E5%9E%8B%E7%9A%84%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">4.转型的异常</span></a></li></ol></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"面向对象（下）","uid":"5a1c4f03caf8f9ffac125f63d3a94727","slug":"06-面向对象（下）","date":"2021-09-13T14:38:32.000Z","updated":"2021-09-14T15:53:58.076Z","comments":true,"path":"api/articles/06-面向对象（下）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog6.jpg","text":"一、内部类1.成员内部类1.1 概念在成员位置定义的类（定义在另一个类的内部，最普通的内部类），称之为成员内部类 1.2 成员内部类特点: 不能使用 static关键字，但是可以使用static final关键字定义常量。 成员内部类 可以无条件的访问外部类的 成员属性 和 成员...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/tags/JavaSE.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"面向对象（上）","uid":"0959816aacb592f211c0dd883a8ef3db","slug":"04-面向对象（上）","date":"2021-09-13T14:36:32.000Z","updated":"2021-09-14T15:53:13.090Z","comments":true,"path":"api/articles/04-面向对象（上）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog4.jpg","text":"一、概述 Java语言是面向对象的程序设计语言，而面向对象思想（Object Oriented Programming）是一种程序设计思想。 这里的对象泛指现实中的一切事物，而每种事物都具有自己的属性和行为 而面向对象编程就是参照现实中的事物，将其属性和行为抽象出来，描述成计算机...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":12,"path":"api/tags/JavaSE.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}