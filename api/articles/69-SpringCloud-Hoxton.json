{"title":"SpringCloud Hoxton","uid":"7782f77d73b91eb2c8a016712795b746","slug":"69-SpringCloud-Hoxton","date":"2021-09-13T15:45:32.000Z","updated":"2021-09-15T10:46:34.911Z","comments":true,"path":"api/articles/69-SpringCloud-Hoxton.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog7.jpg","content":"<h4 id=\"01、Eureka-基本内容\"><a href=\"#01、Eureka-基本内容\" class=\"headerlink\" title=\"01、Eureka 基本内容\"></a>01、Eureka 基本内容</h4><hr/>\n\n<p>在微服务架构中，<strong>服务注册与发现是核心组件</strong>之一，手动指定每个服务是很低效的，Spring cloud提供了多种服务注册与发现的实现方式,例如: Eureka、Consu、 Zookeeper</p>\n<p>SringCloud支持得最好的是 Eureka,其次是 Consul,再次是 Zookeeper。</p>\n<h5 id=\"1-1、什么是服务治理\"><a href=\"#1-1、什么是服务治理\" class=\"headerlink\" title=\"1.1、什么是服务治理\"></a>1.1、什么是服务治理</h5><p>在传统rpc远程调用中，服务与服务依赖关系，管理比较复杂，所以需要使用服务治理，管理服务与服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。</p>\n<h5 id=\"1-2、什么是服务注册\"><a href=\"#1-2、什么是服务注册\" class=\"headerlink\" title=\"1.2、什么是服务注册\"></a>1.2、什么是服务注册</h5><p>Eureka采用了 CS 的设计架构，==Eureka Server作为服务注册功能的服务器，它是服务注册中心。==</p>\n<p>而系统中的其他微服务，使用Eureka的客户端连接到Eureka Server并维持心跳连接。这样系统的维护人员可以通过Eureka Server来监控系统中各个微服务是否正常运行。</p>\n<p>在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息，比如：服务通讯地址等以别名方式注册到注册中心上。</p>\n<p>另一方（消费者服务），以该别名的方式去注册中心上获取到实际的服务通讯地址，然后，再实现本地RPC远程调用。</p>\n<p><strong>RPC远程调用框架核心设计思想：</strong>在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系（服务治理概念）。</p>\n<p>在任何RPC远程框架中，都会有一个注册中心（存放服务地址相关信息（接口地址））。</p>\n<img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/springcloud-2-1%E3%80%81.png\" alt=\"image-20210813205518171\" style=\"zoom:80%;\" />\n\n\n\n<h5 id=\"1-3、服务注册与发现\"><a href=\"#1-3、服务注册与发现\" class=\"headerlink\" title=\"1.3、服务注册与发现\"></a>1.3、服务注册与发现</h5><p>在服务注册与发现中，有一个注册中心，当服务器启动的时候，会把当前自己服务器的信息 比如 服务地址通讯地址等以别名方式注册到注册中心上。</p>\n<p>另一方（消费者|服务提供者），以该别名的方式去注册中心上获取到实际的服务通讯地址，让后在实现本地 rpc 调用远程。</p>\n<p><strong>Eureka Server提供服务注册服务</strong></p>\n<p>各个微服务节点通过配置启动后，会在Eureka Server中进行注册，这样Eureka Server中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。</p>\n<p><strong>Eureka Client通过注册中心进行访问</strong></p>\n<p>是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询（round-robin）负载算法的负载均衡器。在应用启动后，将会在Eureka Server发送心跳（默认周期30秒）。如果Eureka Server在多个心跳周期内没有收到某个节点的心跳，Eureka Server将会从服务注册表中把这个服务节点移出（默认90秒）</p>\n<h5 id=\"1-4、Eureka是什么\"><a href=\"#1-4、Eureka是什么\" class=\"headerlink\" title=\"1.4、Eureka是什么\"></a>1.4、Eureka是什么</h5><p>Eureka是一个服务治理组件，它主要包括服务注册和服务发现,主要用来搭建服务注册中心。</p>\n<p>Eureka是一个<strong>基于REST的服务,用来定位服务</strong>，进行中间层服务器的负载均衡和故障转移。（根据 要调用的服务的网址加端口，加上方法路径）</p>\n<p>Eureka是 Netflix公司开发的, Spring Cloud封装了Neix公司开发的Eureka模块来实现服务注册和发现也就是说 Spring Cloud对Netflix eureka做了二次封装</p>\n<p>Eureka采用了C-S(客户端/服务端)的设计架构,也就是Eureka由两个组件组成：Eureka服务端 和 Eureka客户端。Eureka server作为服务注册的服务端,它是服务注册中心,而系统中的其他微服务,使用 Eureka的客户端连接到 Eureka server服务端,并维持心跳连接, Eureka客户端是一个Java客户端,用来简化与服务器的交互、负载均衡,服务的故障切换等。</p>\n<p>有了 Eureka注册中心,系统的维护人员就可以通过 Eureka server来监控系统中各个微服务是否正常运行。</p>\n<h5 id=\"1-5、Eureka和Zookeeper对比\"><a href=\"#1-5、Eureka和Zookeeper对比\" class=\"headerlink\" title=\"1.5、Eureka和Zookeeper对比\"></a>1.5、Eureka和Zookeeper对比</h5><p>著名的CAP理论指出,一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)</p>\n<p>由于分区容错性在是分布式系统中必须要保证的,因此我们只能在A和C之间进行权衡,在此 Zookeeper保证的是CP而 Eureka则是AP</p>\n<ul>\n<li>Consistency(一致性), 数据一致更新，所有数据变动都是同步的</li>\n<li>Availability(可用性), 好的响应性能</li>\n<li>Partition tolerance(分区容忍性) 可靠性</li>\n</ul>\n<ol>\n<li>“C”是指一致性，即当一个Process（过程）修改了某个数据后，其他Process读取这是数据是，得到的是更新后的数据，但并不是所有系统都 可以做到这一点。例如，在一些并非严格要求一致性的系统中，后来的Process得到的数据可能还是修改之前的数据，或者需要等待一定时间后才能得到修改 之后的数据，这被成为“弱一致性”，最经典的应用就是DNS系统。当用户修改了DNS配置后，往往不会马上在全网更新，必定会有一个延迟，这个延迟被称为 “不一致窗口”，它的长度取决于系统的负载、冗余的个数等因素。但对于某些系统而言，一旦写入，后面读取的一定是修改后的数据，如银行账户信息，这被称为 “强一致性”。</li>\n<li>“A”是指可用性。即系统总是能够为用户提供连续的服务能力。当用户发出请求是，系统能给出响应（成功或者失败），而且是立即给出响应，而不是等待其他事情完成才响应。如果需要等待某件事情完成才响应，那么“可用性”就不存在了。</li>\n<li>“P”是指容错性。任何一个分布式计算系统都是由多个节点组成的。在正常情况下，节点与节点之间的通信是正常的。但是在某些情况下，节点之间的通信会 断开，这种断开成为“Partition”。在分布式计算的实现中，Partition是很常见的，因为节点不可能永远不出故障，尤其是对于跨物理地区的 海量存储系统而言，而容错性则可以保证如果只是系统中的部分节点不可用，那么相关的操作仍旧能够正常完成。</li>\n<li>Zookeeper保证CP，在 ZooKeeper中,当 master节点因为网络故障与其他节点失去联系时,剩余节点会重新进行 leader选举,但是问题在于,选举 leader需要一定时间,且选举期间整个 ZooKeeper集群都是不可用的,这就导致在选举期间注册服务瘫痪。在云部署的环境下,因网络问题使得 ZooKeeper集群失去 master节点是大概率事件,虽然服务最终能够恢复,但是在选举时间内导致服务注册长期不可用是难以容忍的。</li>\n<li>Eureka保证AP，Eureka优先保证可用性, Eureka各个节点是平等的,某几个节点挂掉不会影响正常节点的工作,剩余的节点依然可以提供注册和查询服务。而 Eureka的客户端在向某个 Eureka注册或时如果发现连接失败,则会自动切换至其它节点,只要有一台 Eureka还在,就能保证注册服务可用(保证可用性),只不过查到的信息可能不是最新的(不保证强一致性)</li>\n</ol>\n<p>所以 Eureka在网络故障导致部分节点失去联系的情况下,只要有一个节点可用,那么注册和查询服务就可以正常使用,而不会像 zookeeper那样使整个注册服务瘫痪, Eureka优先保证了可用性。</p>\n<h4 id=\"02、Eureka-入门程序\"><a href=\"#02、Eureka-入门程序\" class=\"headerlink\" title=\"02、Eureka 入门程序\"></a>02、Eureka 入门程序</h4><h5 id=\"2-1、服务注册中心建Module\"><a href=\"#2-1、服务注册中心建Module\" class=\"headerlink\" title=\"2.1、服务注册中心建Module\"></a>2.1、服务注册中心建Module</h5><p>cloud-eureka-server7001</p>\n<h5 id=\"2-2、改POM\"><a href=\"#2-2、改POM\" class=\"headerlink\" title=\"2.2、改POM\"></a>2.2、改POM</h5><pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;?xmversion&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;cloud2020&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n    &lt;artifactId&gt;cloud-eureka-server7001&lt;&#x2F;artifactId&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;cloud-api-commons&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;$&#123;project.version&#125;&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;</code></pre>\n<h5 id=\"2-3、Eureka版本对比\"><a href=\"#2-3、Eureka版本对比\" class=\"headerlink\" title=\"2.3、Eureka版本对比\"></a>2.3、Eureka版本对比</h5><pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">1.X版本\n&lt;dependency&gt;\n&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n&lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n2.X版本\n&lt;dependency&gt;\n&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<h5 id=\"2-4、写YML\"><a href=\"#2-4、写YML\" class=\"headerlink\" title=\"2.4、写YML\"></a>2.4、写YML</h5><p>注册拉取都是false，因为本模块相当于服务注册中心</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">server:\n  port: 7001\n\neureka:\n  instance:\n    hostname: localhost\n\n  client:\n  \t#由于我们目前创建的应用是一个服务注册中心，而不是一个普通的应用，默认情况下，这个应用会向注册中心（也是它自己）注册它自己，设置为false表示禁止这种自己向自己注册的默认行为\n    register-with-eureka: false\n    #表示是否从Eureka Server获取注册信息，默认为true。如果这是一个单点的 Eureka Server，不需要同步其他节点的数据，可以设为false。\n    fetchRegistry: false\n    #如果是集群，Eureka集群相互指向注册中心\n    service-url:\n      defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka</code></pre>\n\n<h5 id=\"2-5、主启动\"><a href=\"#2-5、主启动\" class=\"headerlink\" title=\"2.5、主启动\"></a>2.5、主启动</h5><p>@EnableEurekaServer</p>\n<h5 id=\"2-6、测试\"><a href=\"#2-6、测试\" class=\"headerlink\" title=\"2.6、测试\"></a>2.6、测试</h5><p><a href=\"http://localhost:7001/\">http://localhost:7001/</a></p>\n<h5 id=\"2-7、服务提供者\"><a href=\"#2-7、服务提供者\" class=\"headerlink\" title=\"2.7、服务提供者\"></a>2.7、服务提供者</h5><p>EurekaClient端 cloud-provider-payment8001将注册进 EurekaServer 成为服务提供者provider</p>\n<h5 id=\"2-8、建Module\"><a href=\"#2-8、建Module\" class=\"headerlink\" title=\"2.8、建Module\"></a>2.8、建Module</h5><p>cloud-provider-payment8001</p>\n<h5 id=\"2-9、改POM\"><a href=\"#2-9、改POM\" class=\"headerlink\" title=\"2.9、改POM\"></a>2.9、改POM</h5><pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<h5 id=\"3-0、写YML\"><a href=\"#3-0、写YML\" class=\"headerlink\" title=\"3.0、写YML\"></a>3.0、写YML</h5><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">eureka:\n  client:\n    register-with-eureka: true\n    fetchRegistry: true\n    service-url:\n      defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka</code></pre>\n\n<h5 id=\"3-1、主启动\"><a href=\"#3-1、主启动\" class=\"headerlink\" title=\"3.1、主启动\"></a>3.1、主启动</h5><p>加上==@EnableEurekaClient==</p>\n<h5 id=\"3-2、测试\"><a href=\"#3-2、测试\" class=\"headerlink\" title=\"3.2、测试\"></a>3.2、测试</h5><p>先启动EurekaServer<br><a href=\"http://localhost:7001/\">http://localhost:7001/</a></p>\n<h5 id=\"3-3、服务消费者\"><a href=\"#3-3、服务消费者\" class=\"headerlink\" title=\"3.3、服务消费者\"></a>3.3、服务消费者</h5><p>EurekaClient端cloud-consumer-order80将注册进EurekaServer成为服务消费者consumer</p>\n<h5 id=\"3-4、建Module\"><a href=\"#3-4、建Module\" class=\"headerlink\" title=\"3.4、建Module\"></a>3.4、建Module</h5><p>cloud-consumer-order80</p>\n<h5 id=\"3-5、POM\"><a href=\"#3-5、POM\" class=\"headerlink\" title=\"3.5、POM\"></a>3.5、POM</h5><pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<h5 id=\"3-6、写YML\"><a href=\"#3-6、写YML\" class=\"headerlink\" title=\"3.6、写YML\"></a>3.6、写YML</h5><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">eureka:\n  client:\n    register-with-eureka: true\n    fetchRegistry: true\n    service-url:\n      defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka</code></pre>\n\n<h5 id=\"3-7、主启动\"><a href=\"#3-7、主启动\" class=\"headerlink\" title=\"3.7、主启动\"></a>3.7、主启动</h5><p>加上==@EnableEurekaClient==</p>\n<h5 id=\"3-8、测试\"><a href=\"#3-8、测试\" class=\"headerlink\" title=\"3.8、测试\"></a>3.8、测试</h5><p>先要启动EurekaServer，7001服务</p>\n<p>再要启动服务提供者8001服务和服务消费者80服务</p>\n<p>eureka服务器</p>\n<h4 id=\"03、Eureka-注册中心高可用集群概述\"><a href=\"#03、Eureka-注册中心高可用集群概述\" class=\"headerlink\" title=\"03、Eureka 注册中心高可用集群概述\"></a>03、Eureka 注册中心高可用集群概述</h4><p>在微服务架构的这种分布式系统中,我们要充分考虑各个微服务组件的高可用性问题,不能有单点故障,由于注册中心Eureka本身也是一个服务,如果它只有一个节点,那么它有可能发生故障,这样我们就不能注册与查询服务了,所以我们需要—个高可用的服务注册中心,这就需要通过注册中心集群来解决。Eureka服务注册中心它本身也是一个服务,它也可以看做是一个提供者,又可以看做是一个消费者,我们之前通过配置eureka.client.register-with-eureka= false让注册中心不注册自己,但是我们可以向其他注册中心注册自己。</p>\n<p>Eureka server的高可用实际上就是将自己作为服务向其他服务注册中心注册自己,这样就会形成一组互相注册的服务注册中心,进而实现服务清单的互相同步,往注册中心A上注册的服务,可以被复制同步到注册中心B上,所以从任何一台注册中心上都能查询到已经注册的服务,从而达到高可用的效果。</p>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/springcloud-2-2\" alt=\"图片\" style=\"zoom:80%;\" />\n</div>\n\n\n\n<h4 id=\"04、Eureka-详解\"><a href=\"#04、Eureka-详解\" class=\"headerlink\" title=\"04、Eureka 详解\"></a>04、Eureka 详解</h4><hr/>\n\n<h5 id=\"1、服务消费者模式\"><a href=\"#1、服务消费者模式\" class=\"headerlink\" title=\"1、服务消费者模式\"></a>1、服务消费者模式</h5><p>1-1、获取服务</p>\n<p> 消费者启动的时候，使用服务别名，会发送一个rest请求到服务注册中心获取对应的服务信息，然后会缓存到本地jvm客户端中，同时客户端每隔30秒从服务器上更新一次。</p>\n<p>可以通过eureka.client.registry-fetch-interval-seconds=30参数进行修改，该配置默认值为30， 单位为秒。</p>\n<p>1-2、服务下线</p>\n<p>在系统运行过程中必然会面临关闭或重启服务的某个实例的情况，在服务关闭期间我们自然不希望客户端会继续调用关闭了的实例。所以在客户端程序中，当服务实例正常的关闭操作时，它会触发一个服务下线的REST请求给Eureka Server, 告诉服务中心:“我要下线了”。服务端在接收到请求之后，将该服务状态置为下线(DOWN)，并将该下线事件传播出去。</p>\n<h5 id=\"2、服务注册模式\"><a href=\"#2、服务注册模式\" class=\"headerlink\" title=\"2、服务注册模式\"></a>2、服务注册模式</h5><p>2-1、失效剔除</p>\n<p>有些时候，我们的服务实例并不一定会正常下线，可能由于内存溢出、网络故障原因使得服务不能正常工作，而服务注册中心并未收到“服务下线”的请求。为了从服务表中将这些无法提供服务的实例剔除，Eureka Server 在启动的时候会创建一个定时任务默认每隔一段时间(默认为60秒eureka.server.eviction-interval-timer-in-ms=6000L)将当前清单中超时(默认为90秒eureka.instance.lease-expiration-duration-in-seconds= 90)没有续约的服务踢除出去</p>\n<p>2-2、Eureka服务注册中心自我保护机制</p>\n<p>当我们在本地调试基于Eureka的程序时，基本上都会碰到这样一个问题， 在服务主中心的信息面板中出现类似下面的红色警告信息，在开发测试时，需要频繁地重启微服务实例，但是我们很少会把eureka server一起重启（因为在开发过程中不会修改eureka注册中心），当一分钟内收到的心跳数大量减少时，会触发该保护机制。可以在eureka管理界面看到Renews threshold和Renews(last min)，当后者（最后一分钟收到的心跳数）小于前者（心跳阈值）的时候，触发保护机制，会出现红色的警告：</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/springcloud-2-3\" alt=\"图片\"></p>\n<p>实际上，该警告就是触发了Eureka Server的自我保护机制，服务注册到Eureka Server之后，会维护个心跳连接， 告诉Eureka Server自己还活着。Eureka Server在运行期间，会统计客户端节点的心跳失败的比例在15分钟之内是否低于85%如果出现低于的情况，如果低于85%，那就触发自我保护机制，单机调试的时候很容易满足，实际在生产环境上通常是由于网络不稳定导致)，Eureka Server会将当前的实例注册信息保护起来，让这些实例不会过期，尽可能保护这些注册信息。但是，在这段保护期间内实例若出现问题，那么客户端很容易拿到实际已经不存服务实例，会出现调用失败的情况，所以客户端必须要有容错机制，比如可以使用请使用重试、断路器等机制。</p>\n<p>在没有Eureka自我保护的情况下,如果 Eureka Server在一定时间内没有接收到某个微服务实例的心跳, Eureka Server将会注销该实例,但是当发生网络分区故障时,那么微服务与 Eureka Server之间将无法正常通信,以上行为可能变非常危险了，因为微服务本身其实是正常的,此时不应该注销这个微服务，如果没有自我保护机制，那么Eureka Server就会将此服务注销掉。</p>\n<p>Eureka通过“自我保护模式”来解决这个问题——当 Eureka Server节点在短时间内丢失过多客户端时(可能发生了网络分区故障),那么就会把这个微服务节点进行保护。一旦进入自我保护模式, Eureka server就会保护服务注册表中的信息,不删除服务注册表中的数据(也就是不会注销任何微服务)。当网络故障恢复后,该 Eureka Server节点会再自动退出自我保护模式。所以,自我保护模式是一种应对网络异常的安全保护措施,它的架构哲学是宁可同时保留所有微服务(健康的微服务和不健康的微服务都会保留),也不盲目注销任何健康的微服务,使用自我保护模式,可以让Eureka集群更加的健壮、稳定当然也可以使用配置项: eureka.server.enable-self-preservation=fase禁用自我保护模式。</p>\n<p>但是Eureka Server自我保护模式也会给我们带来一些困扰,如果在保护期内某个服务提供者刚好非正常下线了,此时服务消费者就会拿到一个无效的服务实例,此时会调用失败,对于这个问题需要服务消费者端具有一些容错机制,如重试,断路器等。</p>\n<p>Eureka的自我保护模式是有意义的,该模式被激活后,它不会从注册列表中剔除因长时间没收到心跳导致注册过期的服务,而是等待修复,直到心跳恢复正常之后,它自动退出自我保护模式。这种模式旨在避免因网络分区故障导致服务不可用的问题。</p>\n<p>例如,两个微服务客户端实例A和B之间有调用的关系,A是消费者,B是提供者,但是由于网络故障,B未能及时向Eureka发送心跳续约,这时候 Eureka不能简单的将B从注册表中剔除,因为如果剔除了,A就无法从Eureka服务器中获取B注册的服务,但是这时候B服务是可用的;所以, Eureka的自我保护模式最好还是开启它。</p>\n<h4 id=\"05、Ribbon-是什么\"><a href=\"#05、Ribbon-是什么\" class=\"headerlink\" title=\"05、Ribbon 是什么\"></a>05、Ribbon 是什么</h4><hr/>\n\n<p>==Ribbon是一个基于HTTP和TCP的 客户端 负载均衡器==</p>\n<h5 id=\"5-2、Ribbon能干什么\"><a href=\"#5-2、Ribbon能干什么\" class=\"headerlink\" title=\"5.2、Ribbon能干什么\"></a>5.2、Ribbon能干什么</h5><p>当使用Ribbon对服务进行访问的时候，他会扩展Eureka客户端的服务发现功能，实现从Eureka注册中心获取服务端列表，并通过Eureka客户端来确定服务端是否已经启动。==(服务调用)==</p>\n<p>Ribbon在Eureka客户端服务发现的基础上，实现对服务实例的选择策略，从而实现对服务的负载均衡消费。==（负载均衡）==</p>\n<h5 id=\"5-3、负载均衡简述\"><a href=\"#5-3、负载均衡简述\" class=\"headerlink\" title=\"5.3、负载均衡简述\"></a>5.3、负载均衡简述</h5><p>负载均衡在系统架构中是一个非常重要的内容，因为负载均衡是对系统的高可用、网络的压力的缓冲和处理能力扩容的重要手段之一，我们通常说的负载均衡都是指的是服务端的负载均衡，其中分为硬件负载均衡和软件负载均衡。</p>\n<ul>\n<li>硬件负载均衡：主要通过服务器节点之间安装专门用于负载均衡的设备，比如F5，深信服，Array等。</li>\n<li>软件负载均衡：则是通过服务器上安装一些具有负载功能或模块的软件来完成请求分发工作，比如Nginx、LVS、HAProxy等。</li>\n</ul>\n<p>硬件负载均衡的设备或是软件负载均衡的软件模块都会维护一个下挂可用的服务端清单，通过心跳检测来剔除故障的服务端节点保证清单中都是可以正常访问的服务端节点。当客户端发送请求到负载均衡的设备时候，该设备按某种算法（比如线性轮询、按权重负载、按流量负载等）从维护的可用服务端清单中取出一台服务端地址，然后进行转发。</p>\n<p>Ribbon是Netflix发布的开源项目,主要功能是提供客户端的软件负载均衡算法,是一个基于HTTP和TCP的客户端负载均衡工具。Spring Cloud对Ribbon做了二次封装,可以让我们使用 RestTemplate的服务请求,自动转换成客户端负载均衡的服务调用。Ribbon支持多种负载均衡算法,还支持自定义的负载均衡算法。Ribbon只是一个工具类框架,比较小巧, Spring Cloud对它封装后使用也非 常方便,它不像服务注册中心、配置中心、AP网关那样需要独立部署, Ribbon 只需要在代码直接使用即可。</p>\n<h5 id=\"5-4、Ribbon与-Nginx的区别\"><a href=\"#5-4、Ribbon与-Nginx的区别\" class=\"headerlink\" title=\"5.4、Ribbon与 Nginx的区别\"></a>5.4、Ribbon与 Nginx的区别</h5><ul>\n<li>都是软负载</li>\n<li>Ribbon是客户端负载均衡</li>\n<li>Nginx是服务器段负载均衡</li>\n</ul>\n<p>区别在于：</p>\n<p>服务清单所存储的位置不同，在客户端负载均衡中，所有客户端节点下的服务端清单，需要自己从服务注册中心上获取，比如Eureka服务注册中心。同服务端负载均衡的架构类似，在客户端负载均衡中也需要心跳去维护服务端清单的健康性，只是这个步骤需要与服务注册中心配合完成，在SpringCloud实现的服务治理框架中，默认会创建针对各个服务治理框架到的Ribbon自动化整合配置，比如Eureka中的org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration,在实际使用的时候，我们可以通过查看这个类的实现，以找到他们的配置详情来帮助我们更好的使用它。</p>\n<h5 id=\"5-5、Spring-Cloud如何调用Ribbon\"><a href=\"#5-5、Spring-Cloud如何调用Ribbon\" class=\"headerlink\" title=\"5.5、Spring Cloud如何调用Ribbon\"></a>5.5、Spring Cloud如何调用Ribbon</h5><p>通过Spring Cloud Ribbon的封装，我们在微服务架构中使用客户端负载均衡调用非常的简单，只需要如下两步：</p>\n<ol>\n<li>服务提供者只需要启动多个服务实例并注册到一个注册中心或是多个相关联的服务注册中心上</li>\n<li>==服务消费者直接通过调用被@LoadBalanced注解修饰过的RestTemplate来实现面向服务的接口调用。==</li>\n</ol>\n<p>这样我们就可以将服务提供者的高可用以及服务消费者的负载均衡用一起实现了。</p>\n<ul>\n<li>服务端的负载均衡是提前配置好的：Nginx</li>\n<li>客户端的负载均衡是从注册中心找的：Ribbon</li>\n</ul>\n<p>在SpringCloud中，Ribbon主要与RestTemplate对象配合使用，Ribbon会自动化配置RestTemplate对象，通过@LoadBalance开启RestTemplate对象调用时的负载均衡，Ribbon所处的作用如图：</p>\n<div>\n    <img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/springcloud-2-5\" alt=\"图片\" style=\"zoom:80%;\" />\n</div>\n\n\n\n<h4 id=\"06、Ribbon-实现客户端负载均衡\"><a href=\"#06、Ribbon-实现客户端负载均衡\" class=\"headerlink\" title=\"06、Ribbon 实现客户端负载均衡\"></a>06、Ribbon 实现客户端负载均衡</h4><p>前面提到过，通过Spring Cloud Ribbon的封装，我们在微服务架构中使用客户端负载均衡调用非常的简单，只需要如下两步：</p>\n<ol>\n<li>服务提供者只需要启动多个服务实例并注册到一个注册中心或是多个相关联的服务注册中心上</li>\n<li>服务消费者直接通过调用被@LoadBalanced注解修饰过的RestTemplate来实现面向服务的接口调用。</li>\n</ol>\n<ul>\n<li>复制服务提供者 并且命名后面加2，表示第二个服务提供者</li>\n<li>修改第二个提供者的端口</li>\n<li>修改第二个提供者的controller中的 uri路径</li>\n<li>修改pom文件中此模块的名字</li>\n</ul>\n<p>在消费者的RestTemplate中添加如下代码：使用Ribbon实现负载均衡调用,默认是轮询 </p>\n<pre class=\"line-numbers language-JAVA\" data-language=\"JAVA\"><code class=\"language-JAVA\">&#x2F;&#x2F;使用Ribbon实现负载均衡调用,默认是轮询    @LoadBalanced \n&#x2F;&#x2F;加入ribbon的支持，那么在调用时，即可改为使用服务名称来访问    \n@Bean    \n@LoadBalanced \npublic RestTemplate restTemplate()&#123;        \n    return new RestTemplate();    \n&#125;</code></pre>\n\n<p><strong>Rest请求模板类解读</strong></p>\n<p>当我们从服务消费端去调用服务提供者的服务的时候,使用了一个极其方便的对象叫RestTemplate,当时我们只使用了RestTemplate中最简单的一个功能getForEntity发起了一个get请求去调用服务端的数据,同时,我们还通过配置@Loadbalanced注解开启客户端负载均衡, RestTemplate的功能非常强大, 那么接下来就来详细的看一下RestTemplate中几种常见请求方法的使用。在日常操作中,基于Rest的方式通常是四种情况,它们分表是</p>\n<ul>\n<li>GET请求-查询数据</li>\n<li>POST请求-添加数据</li>\n<li>PUT请求-修改数据</li>\n<li>DELETE-删除数据</li>\n</ul>\n<h4 id=\"07、Ribbon-定义负载均衡策略\"><a href=\"#07、Ribbon-定义负载均衡策略\" class=\"headerlink\" title=\"07、Ribbon 定义负载均衡策略\"></a>07、Ribbon 定义负载均衡策略</h4><hr/>\n\n<h5 id=\"7-1、Ribbon-负载均衡策略类\"><a href=\"#7-1、Ribbon-负载均衡策略类\" class=\"headerlink\" title=\"7.1、Ribbon 负载均衡策略类\"></a>7.1、Ribbon 负载均衡策略类</h5><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/img/springcloud-2-7.png\" alt=\"image-20210813212935553\"></p>\n<table>\n<thead>\n<tr>\n<th>RandomRule</th>\n<th>随机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>RoundRobinRule</td>\n<td>轮询</td>\n</tr>\n<tr>\n<td>AvailabilityFilteringRule</td>\n<td>先过滤掉由于多次访问故障的服务，以及并发连接数超过阀值的服务，然后对剩下的服务按照轮询策略进行访问</td>\n</tr>\n<tr>\n<td>WeightedResponseTimeRule</td>\n<td>根据平均响应时间计算所有服务的权重，响应时间越快服务权重就越大被选中的概率即越高，如果服务刚启动时间统计信息不足，，则使用RoundRobinRule策略，待统计信息足够，会切换到该WeightedResponseTimeRule策略</td>\n</tr>\n<tr>\n<td>RetryRule</td>\n<td>先按照RoundRobinRule策略分发，如果分发到的服务不能访问，则在指定的时间内重试，如果不行的话，则分发到其他可用的服务</td>\n</tr>\n<tr>\n<td>BestAvailableRule</td>\n<td>先过滤掉由于多次访问的故障的服务，然后选择一个并发量最小的服务</td>\n</tr>\n<tr>\n<td>ZoneAvoidanceRule</td>\n<td>综合判断服务节点所在区域的性能和服务节点的可用性，来决定选择哪个服务</td>\n</tr>\n</tbody></table>\n<p>==TIP：结合Ribbon负载均衡，默认的是轮询，重新注入IRule可以实现负载均衡的其他策略==</p>\n<h5 id=\"7-2、Ribbon-指定策略\"><a href=\"#7-2、Ribbon-指定策略\" class=\"headerlink\" title=\"7.2、Ribbon 指定策略\"></a>7.2、Ribbon 指定策略</h5><p>Ribbon在工作时分成两步：</p>\n<p>第一步，先选择EurekaServer，它优先选择在同一个区域内负载较少的server。</p>\n<p>第二步，再根据用户指定的策略（<strong>需要自定义配置类</strong>），在从server取到的服务注册列表中选择一个地址。其中Ribbon提供了多种策略。比如：轮询、随机和根据响应时间加权。</p>\n<p>总结：Ribbon其实就是一个软负载均衡的客户端组件，他可以和其他所需请求的客户端结合使用，和eureka结合只是其中的一个实例。</p>\n<p>==TIP：这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达不到特殊化订制的目的了。==</p>\n<p><strong>==自定义类中指定 负载均衡策略时，return的是各种策略的对象，但是方法上要用 IRule 接收==</strong></p>\n<p>缺个图片</p>\n<h4 id=\"08、Feign-是什么\"><a href=\"#08、Feign-是什么\" class=\"headerlink\" title=\"08、Feign 是什么\"></a>08、Feign 是什么</h4><p>Feign是Netflix公司开发的一个声明式的REST调用客户端; Ribbon负载均衡、 Hystrⅸ服务熔断是我们Spring Cloud中进行微服务开发非常基础的组件，在使用的过程中我们也发现它们一般都是同时出现的，而且配置也都非常相似，每次开发都有很多相同的代码，因此Spring Cloud基于Netflix Feign整合了Ribbon和Hystrix两个组件，让我们的开发工作变得更加简单，就像Spring boot是对Spring + SpringMVC 的简化，Spring Cloud Feign对Ribbon负载均衡、 Hystrⅸ服务熔断进行简化，在其基础上进行了进一步的封装，不仅在配置上大大简化了开发工作，同时还提供了一种声明式的Web服务客户端定义方式。使用方式类似Dubbo的使用方式。</p>\n<h4 id=\"09、Feign-实现消费者\"><a href=\"#09、Feign-实现消费者\" class=\"headerlink\" title=\"09、Feign 实现消费者\"></a>09、Feign 实现消费者</h4><p>1、创建消费者服务命名为(springcloud-service-feign)</p>\n<p>2、添加依赖</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n<p>3、在==启动类上添加注解==</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@EnableFeignClients</code></pre>\n\n<p>4、声明服务</p>\n<p>定义一个HelloService接口，通过@FeignClient注解来指定服务名称进而绑定服务，然后在通过Spring  MVC中提供的注解来绑定服务提供者的接口，如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;使用feign的客户端注解绑定远程的名称，名称可以是大写，也可以小写\n@FeignClient(value &#x3D; &quot;springcloud-service-provider&quot;)\npublic interface HelloService &#123;\n    &#x2F;&#x2F;声明一个方法，这个方法就是远程的服务提供者提供的方法\n    @RequestMapping(&quot;&#x2F;provider&#x2F;hello&quot;)\n    public String hello();   \n&#125;</code></pre>\n\n<p>5、使用Controller中调用服务，代码如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Autowired\nprivate HelloService helloService;\n\n@RequestMapping(&quot;&#x2F;hello&quot;)\npublic String hello()&#123;\n    &#x2F;&#x2F;调用声明式接口方法,实现对远程服务的调用\n    return helloService.hello();\n&#125;</code></pre>\n<p>6、application.yml配置如下</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring:\n  application:\n    name: springcloud-service-feign\nserver:\n  port: 9091\neureka:\n  client:\n    service-url:\n      defaultZone: http:&#x2F;&#x2F;localhost:8700&#x2F;eureka\n    #客户端每隔30秒从Eureka服务上更新一次服务信息\n    registry-fetch-interval-seconds: 30\n    #需要将我的服务注册到eureka上\n    register-with-eureka: true</code></pre>\n\n<p>7、启动测试，访问地址<a href=\"http://localhost:9091/feign/hello\">http://localhost:9091/feign/hello</a></p>\n<h4 id=\"10、使用Feign支持的特性\"><a href=\"#10、使用Feign支持的特性\" class=\"headerlink\" title=\"10、使用Feign支持的特性\"></a>10、使用Feign支持的特性</h4><p>1、负载均衡</p>\n<p>Spring Cloud提供了Ribbon来实现负载均衡，使用Ribbon直接注入一个RestTemplate对象即可，RestTemplate已经做好了负载均衡的配置在Spring Cloud下，使用 Feign也是直接可以实现负载均衡的，定义一个有 @FeignClient 注解的接口，然后使用 @RequestMappin注解到方法上映射远程的REST服务，此方法也是做好负责均衡配置的。</p>\n<p>2、服务熔断</p>\n<p>在 application.yml文件开启hystrix功能</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">#开启hystrix熔断机制\nfeign:\n  hystrix:\n    enabled: true</code></pre>\n\n<p>指定熔断回调逻辑</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@FeignClient(value &#x3D; &quot;springcloud-service-provider&quot;, fallback &#x3D; MyFallback.class)\npublic interface HelloService &#123;\n    @RequestMapping(&quot;&#x2F;provider&#x2F;hello&quot;)\n    public String hello();   \n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\npublic class MyFallback implements HelloService &#123;\n    @Override\n    public String hello() &#123;\n        return &quot;远程服务不可用，暂时采用本地逻辑代替。。。。。&quot;;\n    &#125;\n&#125;</code></pre>\n\n<p>3、测试，让服务提供者超时就行了</p>\n<p>如果需要捕获提供者抛出的异常可以用：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@FeignClient(value &#x3D; &quot;springcloud-service-provider&quot;, fallbackFactory &#x3D; MyFallbackFactory.class)\n@Component\npublic class MyFallbackFactory implements FallbackFactory&lt;HelloService&gt; &#123;\n    @Override\n    public HelloService create(Throwable throwable) &#123;\n        return new HelloService() &#123;\n            @Override\n            public String hello() &#123;\n                return throwable.getMessage();\n            &#125;\n        &#125;;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h4 id=\"11、Feign-默认超时时长1秒\"><a href=\"#11、Feign-默认超时时长1秒\" class=\"headerlink\" title=\"11、Feign 默认超时时长1秒\"></a>11、Feign 默认超时时长1秒</h4><p>默认Feign客户端只等待一秒钟，但是，服务端处理需要超过1秒钟，导致Feign客户端不想等待了，直接报错。</p>\n<p>为了避免这样的情况，有时候我们需要设置Feign客户端的超时控制，也即Ribbon的超时时间，因为Feign集成了Ribbon进行负载均衡。</p>\n<p>YML中需要开启OpenFeign客户端超时控制，Feign设置超时时间</p>\n<p>使用Feign调用接口分两层，ribbon 的调用和 hystrix 的调用，所以 ribbon 的超时时间和 Hystrix 的超时时间的 <strong>结合</strong> 就是Feign的超时时间</p>\n<p>#设置Feign客户端超时时间（openfeign默认支持ribbon）</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">ribbon: \n  ReadTimeout:  3000 \n  ConnectTimeout: 3000</code></pre>\n\n\n\n<h4 id=\"12、分布式面临的问题\"><a href=\"#12、分布式面临的问题\" class=\"headerlink\" title=\"12、分布式面临的问题\"></a>12、分布式面临的问题</h4><p>复杂分布式体系结构中的应用程序有数十个依赖关系，每一个依赖关系在某些时候将不可避免的失败。</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:08:25-10:28:52.jpg\" alt=\"img\"> </p>\n<p>服务雪崩</p>\n<p>多个微服务之间调用的时候，假如微服务A调用微服务B和微服务C，微服务B和微服务C又调用其他的微服务，这就是所谓的”扇出”。</p>\n<p>如果扇出的链路上某个微服务的调用响应的时间过长或者不可用，对微服A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的”雪崩效应”。</p>\n<p>对于高流量的应用来说，单一的后端依赖可能会导致所有的服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行****隔离和管理****，以便单个依赖关系的失败，不能取消整个应用程序或系统。</p>\n<p>所以，通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。</p>\n<h4 id=\"13、什么是Hystrix\"><a href=\"#13、什么是Hystrix\" class=\"headerlink\" title=\"13、什么是Hystrix\"></a>13、什么是Hystrix</h4><p>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（Fallback），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p>\n<p>Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统中，每个服务都可能会调用很多其他服务，被调用的那些服务就是<strong>依赖服务</strong>，有的时候某些依赖服务出现故障（超时，异常）也是很正常的。</p>\n<p>Hystrix 可以让我们在分布式系统中对服务间的调用进行控制，加入一些<strong>调用延迟</strong>或者<strong>依赖故障</strong>的<strong>容错机制</strong>。避免级联故障，以提高分布式系统的弹性。</p>\n<p>Hystrix 通过将依赖服务进行<strong>资源隔离</strong>，进而阻止某个依赖服务出现故障时在整个系统所有的依赖服务调用中进行蔓延；同时Hystrix 还提供故障时的 fallback 降级机制。</p>\n<p>总而言之，Hystrix 通过这些方法帮助我们提升分布式系统的可用性和稳定性。</p>\n<h4 id=\"14、Hystrix的作用\"><a href=\"#14、Hystrix的作用\" class=\"headerlink\" title=\"14、Hystrix的作用\"></a>14、Hystrix的作用</h4><ul>\n<li>保护和控制底层服务的高延迟和失效对上层服务的影响。        </li>\n<li>避免复杂分布式中服务失效的雪崩效应。在大型的分布式系统中，存在各种复杂的依赖关系。如果某个服务失效，很可能会对其他服务造成影响，形成连锁反应。        </li>\n<li>==快速失效和迅速恢复。== 以Spring为例，一般在实现controller的时候，都会以同步的逻辑调用依赖的服务。如果服务时效，而且没有客户端失效机制，就好导致请求长时间的阻塞。如果不能快速的发现失效，而就很难通过高可用机制或者负载均衡实现迅速的恢复。        </li>\n<li>==优雅地实现服务降级和熔断。== 个人理解，这一点是从用户体验来考虑的，一个预定义默认返回会比请求卡死或者500好很多。        </li>\n<li>==实现了服务监控、报警和运维控制。== Hystrix Dashboard和Turbine可以配合Hystrix完成这些功能。</li>\n</ul>\n<h4 id=\"15、Hystrix重要概念\"><a href=\"#15、Hystrix重要概念\" class=\"headerlink\" title=\"15、Hystrix重要概念\"></a>15、Hystrix重要概念</h4><p>1、服务降级Fallback</p>\n<ul>\n<li>服务器忙，请稍候再试，不让客户端等待并立刻返回一个友好提示</li>\n<li>哪些情况会触发降级</li>\n<li>程序运行异常</li>\n<li>超时自动降级</li>\n<li>服务熔断触发服务降级</li>\n<li>线程池/信号量打满也会导致服务降级</li>\n<li>人工降级</li>\n</ul>\n<p>2、服务熔断Breaker</p>\n<ul>\n<li>类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示</li>\n<li>就是保险丝</li>\n<li>服务的降级-&gt;进而熔断-&gt;恢复调用链路</li>\n</ul>\n<p>3、服务限流Flowlimit</p>\n<ul>\n<li>秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行</li>\n</ul>\n<h4 id=\"16、Hystrix-案例创建-支付服务端\"><a href=\"#16、Hystrix-案例创建-支付服务端\" class=\"headerlink\" title=\"16、Hystrix 案例创建 支付服务端\"></a>16、Hystrix 案例创建 支付服务端</h4><p>新建Module：cloud-provider-hystrix-payment8001</p>\n<p>pom文件</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;?xmversion&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;cloud2020&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n\n    &lt;artifactId&gt;cloud-provider-hystrix-payment8001&lt;&#x2F;artifactId&gt;\n\n    &lt;dependencies&gt;\n        &lt;!--新增hystrix--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;cloud-api-commons&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;$&#123;project.version&#125;&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;</code></pre>\n\n<p>yml</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">server:\n  port: 8001\n\nspring:\n  application:\n    name: cloud-hystrix-payment-service\n\neureka:\n  client:\n    register-with-eureka: true\n    fetch-registry: true\n    service-url:\n      defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka&#x2F;</code></pre>\n\n<p>主启动</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.EnableEurekaClient;\n\n@SpringBootApplication\n@EnableEurekaClient\npublic class PaymentHystrixMain8001 &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(PaymentHystrixMain8001.class,args);\n    &#125;\n&#125;</code></pre>\n\n<p>service/serviceImpl</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.springcloud.service;\n\npublic interface PaymentService &#123;\n    public String paymentInfo_OK(Integer id);\n    public String payment_Timeout(Integer id);\n&#125;\npackage com.atguigu.springcloud.service.impl;\n\nimport org.springframework.stereotype.Service;\nimport java.util.concurrent.TimeUnit;\n\n@Service\npublic class PaymentServiceImpimplements PaymentService &#123;\n\n    &#x2F;&#x2F;成功\n    public String paymentInfo_OK(Integer id)&#123;\n        return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot;   paymentInfo_OK,id：  &quot;+id+&quot;\\t&quot;+&quot;哈哈哈&quot;  ;\n    &#125;\n\n    &#x2F;&#x2F;失败\n    public String payment_Timeout(Integer id)&#123;\n        int timeNumber &#x3D; 3;\n        try &#123; TimeUnit.SECONDS.sleep(timeNumber); &#125;catch (Exception e) &#123;e.printStackTrace();&#125;\n        return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot;   paymentInfo_TimeOut,id：  &quot;+id+&quot;\\t&quot;+&quot;呜呜呜&quot;+&quot; 耗时(秒)&quot;+timeNumber;\n    &#125;\n&#125;</code></pre>\n\n<p>controller</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.springcloud.controller;\n\nimport com.atguigu.springcloud.service.PaymentService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\nimport javax.annotation.Resource;\n\n@RestController\n@Slf4j\npublic class PaymentController &#123;\n\n    @Resource\n    private PaymentService paymentService;\n\n    @Value(&quot;$&#123;server.port&#125;&quot;)\n    private String serverPort;\n\n    @GetMapping(&quot;&#x2F;payment&#x2F;hystrix&#x2F;ok&#x2F;&#123;id&#125;&quot;)\n    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id)&#123;\n        String result &#x3D; paymentService.paymentInfo_OK(id);\n        log.info(&quot;*******result:&quot;+result);\n        return result;\n    &#125;\n    @GetMapping(&quot;&#x2F;payment&#x2F;hystrix&#x2F;timeout&#x2F;&#123;id&#125;&quot;)\n    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123;\n        String result &#x3D; paymentService.paymentInfo_TimeOut(id);\n        log.info(&quot;*******result:&quot;+result);\n        return result;\n    &#125;\n&#125;</code></pre>\n\n<p>正常测试</p>\n<p>启动eureka7001</p>\n<p>启动cloud-provider-hystrix-payment8001</p>\n<p>访问： <a href=\"http://localhost:8001/payment/hystrix/ok/31\">http://localhost:8001/payment/hystrix/ok/31</a></p>\n<p>每次调用耗费3秒钟： <a href=\"http://localhost:8001/payment/hystrix/timeout/31\">http://localhost:8001/payment/hystrix/timeout/31</a></p>\n<p>上述module均OK，以上述为根基平台，从正确-&gt;错误-&gt;降级熔断-&gt;恢复</p>\n<h4 id=\"17、高并发测试\"><a href=\"#17、高并发测试\" class=\"headerlink\" title=\"17、高并发测试\"></a>17、高并发测试</h4><p>上述在非高并发情形下，还能勉强满足   but…..</p>\n<p>Jmeter压测测试，下载地址：<a href=\"https://archive.apache.org/dist/jmeter/binaries/\">https://archive.apache.org/dist/jmeter/binaries/</a></p>\n<p>开启Jmeter，来20000个并发压死8001，20000个请求都去访问paymentInfo_TimeOut服务</p>\n<p>压测的过程中再来访问一下微服务<br><a href=\"http://localhost:8001/payment/hystrix/ok/31\">http://localhost:8001/payment/hystrix/ok/31</a><br><a href=\"http://localhost:8001/payment/hystrix/timeout/31\">http://localhost:8001/payment/hystrix/timeout/31</a></p>\n<p>演示结果，两个都在自己转圈圈，为什么会被卡死，tomcat的默认的工作线程数被打满了，没有多余的线程来分解压力和处理。</p>\n<p>Jmeter压测结论，上面还是服务提供者8001自己测试，假如此时外部的消费者80也来访问，那消费者只能干等，最终导致消费端80不满意，服务端8001直接被拖死</p>\n<p>看热闹不嫌事大，我们新建加入：cloud-consumer-feign-hystrix-order80</p>\n<h4 id=\"18、Hystrix-案例创建-订单消费端\"><a href=\"#18、Hystrix-案例创建-订单消费端\" class=\"headerlink\" title=\"18、Hystrix 案例创建 订单消费端\"></a>18、Hystrix 案例创建 <strong>订单消费端</strong></h4><p>新建：cloud-consumer-feign-hystrix-order80</p>\n<p>pom</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;?xmversion&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;cloud2020&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n    &lt;artifactId&gt;cloud-consumer-feign-hystrix-order80&lt;&#x2F;artifactId&gt;\n\n    &lt;dependencies&gt;\n        &lt;!--新增hystrix--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;cloud-api-commons&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;$&#123;project.version&#125;&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;</code></pre>\n\n<p>yml</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">server:\n  port: 80\n\nspring:\n  application:\n    name: cloud-provider-hystrix-payment-service\n\neureka:\n  client:\n    register-with-eureka: true    #表识不向注册中心注册自己\n    fetch-registry: true   #表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务\n    service-url:\n      defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka&#x2F;</code></pre>\n\n<p>主启动</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.openfeign.EnableFeignClients;\n\n@SpringBootApplication\n@EnableEurekaClient\n@EnableFeignClients\npublic class OrderHystrixMain80 &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(OrderHystrixMain80.class,args);\n    &#125;\n&#125;</code></pre>\n\n<p>业务类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.springcloud.service;\n\nimport org.springframework.cloud.openfeign.FeignClient;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\n\n@FeignClient(&quot;CLOUD-HYSTRIX-PAYMENT-SERVICE&quot;)\npublic interface PaymentHystrixService &#123;\n    @GetMapping(&quot;&#x2F;payment&#x2F;hystrix&#x2F;ok&#x2F;&#123;id&#125;&quot;)\n    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id);\n\n    @GetMapping(&quot;&#x2F;payment&#x2F;hystrix&#x2F;timeout&#x2F;&#123;id&#125;&quot;)\n    public String payment_Timeout(@PathVariable(&quot;id&quot;) Integer id);\n&#125;</code></pre>\n\n<p>controller</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.springcloud.controller;\n\nimport com.atguigu.springcloud.service.PaymentHystrixService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\nimport javax.annotation.Resource;\n\n@RestController\n@Slf4j\npublic class OrderHystrixController &#123;\n    @Resource\n    private PaymentHystrixService paymentHystrixService;\n\n    @GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;hystrix&#x2F;ok&#x2F;&#123;id&#125;&quot;)\n    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id)&#123;\n        String result &#x3D; paymentHystrixService.paymentInfo_OK(id);\n        log.info(&quot;*******result:&quot;+result);\n        return result;\n    &#125;\n    @GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;hystrix&#x2F;timeout&#x2F;&#123;id&#125;&quot;)\n    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123;\n        String result &#x3D; paymentHystrixService.payment_Timeout(id);\n        log.info(&quot;*******result:&quot;+result);\n        return result;\n    &#125;\n\n&#125;</code></pre>\n\n<p>正常测试：<a href=\"http://localhost/consumer/payment/hystrix/ok/32\">http://localhost/consumer/payment/hystrix/ok/32</a></p>\n<p>高并发测试：</p>\n<ul>\n<li>2W个线程压8001</li>\n<li>消费端80微服务再去访问正常的OK微服务8001地址</li>\n<li><a href=\"http://localhost/consumer/payment/hystrix/timeout/32\">http://localhost/consumer/payment/hystrix/timeout/32</a></li>\n<li>消费者80，呜呜呜<ul>\n<li>要么转圈圈等待</li>\n<li>要么消费端报超时错误</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:08:25-10:25:53.png\" alt=\"image-20210824231246598\"></p>\n<h4 id=\"19、故障现象和原因及解决办法\"><a href=\"#19、故障现象和原因及解决办法\" class=\"headerlink\" title=\"19、故障现象和原因及解决办法\"></a>19、故障现象和原因及解决办法</h4><p>8001同一层次的其他接口服务被困死，因为tomcat线程里面的工作线程已经被挤占完毕</p>\n<p>80此时调用8001，客户端访问响应缓慢，转圈圈</p>\n<p>正因为有上述故障或不佳表现，才有我们的降级/容错/限流等技术诞生</p>\n<ul>\n<li>超时导致服务器变慢（转圈）<ul>\n<li>超时不再等待</li>\n</ul>\n</li>\n<li>出错（宕机或程序运行出错）<ul>\n<li>出错要有兜底</li>\n</ul>\n</li>\n<li>解决<ul>\n<li>对方服务（8001）超时了，调用者（80）不能一直卡死等待，必须有服务降级</li>\n<li>对方服务（8001）down机了，调用者（80）不能一直卡死等待，必须有服务降级</li>\n<li>对方服务（8001）OK，调用者（80）自己出故障或有自我要求（自己的等待时间小于服务提供者），自己处理降级</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"20、服务降级\"><a href=\"#20、服务降级\" class=\"headerlink\" title=\"20、服务降级\"></a>20、服务降级</h4><p>1、降低配置</p>\n<pre class=\"line-numbers language-javaj\" data-language=\"javaj\"><div class=\"caption\"><span>a</span></div><code class=\"language-javaj\">使用注解：@HystrixCommand</code></pre>\n\n<p>2、8001 从自身寻找问题：设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处理，作服务降级fallback</p>\n<p>3、8001 fallback：业务类启用阶级处理：使用@HystrixCommand注解来干活。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.springcloud.service.impl;\n\nimport com.atguigu.springcloud.service.PaymentService;\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;\nimport org.springframework.stereotype.Service;\nimport java.util.concurrent.TimeUnit;\n\n@Service\npublic class PaymentServiceImpl implements PaymentService &#123;\n\n    @Override\n    public String paymentInfo_OK(Integer id) &#123;\n        return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot; paymentInfo_OK,id&#x3D;&quot;+id +&quot; \\t O(∩_∩)O哈哈~&quot;;\n    &#125;\n\n    &#x2F;&#x2F;超时降级演示\n    @HystrixCommand(fallbackMethod &#x3D; &quot;payment_TimeoutHandler&quot;,commandProperties &#x3D; &#123;\n            @HystrixProperty(name&#x3D;&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value&#x3D;&quot;5000&quot;) &#x2F;&#x2F;5秒钟以内就是正常的业务逻辑\n    &#125;)\n    @Override\n    public String payment_Timeout(Integer id) &#123;\n        &#x2F;&#x2F;int timeNumber &#x3D; 3; &#x2F;&#x2F;小于等于3秒算是正常情况\n        int timeNumber &#x3D; 15; &#x2F;&#x2F;模拟非正常情况\n        try &#123;\n            TimeUnit.SECONDS.sleep(timeNumber);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot; payment_Timeout,id&#x3D;&quot;+id+&quot; \\t o(╥﹏╥)o 耗时：&quot;+timeNumber;\n    &#125;\n\n    &#x2F;&#x2F;兜底方法，上面方法出问题,我来处理，返回一个出错信息\n    public String payment_TimeoutHandler(Integer id) &#123;\n        return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot; payment_TimeoutHandler,系统繁忙,请稍后再试\\t o(╥﹏╥)o &quot;;\n    &#125;\n&#125;</code></pre>\n\n<p>4、主启动类激活：@EnableCircuitBreaker</p>\n<p>5、测试超时和算数异常，都会走兜底方法——服务降级</p>\n<p><a href=\"http://localhost:8001/payment/hystrix/timeout/1\">http://localhost:8001/payment/hystrix/timeout/1</a></p>\n<img src=\"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:08:25-10:26:07.png\" alt=\"image-20210824231948951\" style=\"zoom:75%;\" />\n\n<p>6、80 fallback</p>\n<p>80订单微服务，也可以更好的保护自己，自己也依样画葫芦进行客户端降级保护。注意：服务降级可以在服务提供者侧，也可以在服务消费者侧。更多是在服务消费者侧。</p>\n<p>题外话，切记：我们自己配置过的热部署方式对java代码的改动明显，但对@HystrixCommand内属性的修改建议重启微服务</p>\n<p>YML</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">feign:\n  hystrix:\n    enabled: true #如果处理自身的容错就开启。开启方式与生产端不一样。</code></pre>\n\n<p>==主启动：@EnableHystrix== </p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@EnableHystrix </code></pre>\n\n<p>查看@EnableHystrix的源码可以发现，它继承了@EnableCircuitBreaker，并对它进行了在封装。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Target(&#123;ElementType.TYPE&#125;)\n        @Retention(RetentionPolicy.RUNTIME)\n        @Documented\n        @Inherited\n        @EnableCircuitBreaker\n        public @interface EnableHystrix &#123;\n        &#125;\n这两个注解都是激活hystrix的功能，我们根据上面代码得出来结论，只需要在服务启动类加入@EnableHystrix注解即可，无须增加@EnableCircuitBreaker注解，本身@EnableHystrix注解已经涵盖了EnableCircuitBreaker的功能。\n</code></pre>\n\n<p>业务类：OrderHystrixController</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;超时降级演示\n@HystrixCommand(fallbackMethod &#x3D; &quot;payment_TimeoutHandler&quot;,commandProperties &#x3D; &#123;\n  @HystrixProperty(name&#x3D;&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value&#x3D;&quot;1500&quot;)&#x2F;&#x2F;超过1.5秒就降级自己\n&#125;)\n@GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;hystrix&#x2F;timeout&#x2F;&#123;id&#125;&quot;)\npublic String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123;\n  &#x2F;&#x2F;int age&#x3D; 1&#x2F;0;\n  String result &#x3D; paymentHystrixService.payment_Timeout(id);\n  log.info(&quot;*******result:&quot;+result);\n  return result;\n&#125;\n&#x2F;&#x2F;兜底方法，上面方法出问题,我来处理，返回一个出错信息\npublic String payment_TimeoutHandler(Integer id) &#123;\n  return &quot;我是消费者80,对方支付系统繁忙请10秒后再试。或自己运行出错，请检查自己。&quot;;\n&#125;</code></pre>\n<p>测试超时：<a href=\"http://localhost/consumer/payment/hystrix/timeout/1\">http://localhost/consumer/payment/hystrix/timeout/1</a></p>\n<img src=\"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:08:25-10:26:15.png\" alt=\"image-20210824233550326\" style=\"zoom:75%;\" />\n\n<h5 id=\"7、目前问题\"><a href=\"#7、目前问题\" class=\"headerlink\" title=\"7、目前问题\"></a>7、目前问题</h5><ul>\n<li>每个业务方法对应一个兜底的方法，代码膨胀，代码耦合</li>\n<li>统一通用处理和自定义独立处理的分开</li>\n</ul>\n<h5 id=\"8、代码膨胀的解决办法\"><a href=\"#8、代码膨胀的解决办法\" class=\"headerlink\" title=\"8、代码膨胀的解决办法\"></a>8、代码膨胀的解决办法</h5><p>每个方法都去配置一个兜底方法，代码后期会很多，占用很大</p>\n<p>我们可以在controller上加伤 @DefaultProperties(defaultFallback = “”) 注解</p>\n<p>说明：</p>\n<ul>\n<li>@DefaultProperties(defaultFallback = “”)</li>\n<li>1:1 每个方法配置一个服务降级方法，技术上可以，但实际上傻X</li>\n<li>1:N 除了个别重要核心业务有专属，其它普通的可以通过@DefaultProperties(defaultFallback = “”)统一跳转到统一处理结果页面</li>\n<li>通用的和独享的各自分开，避免了代码膨胀，合理减少了代码量</li>\n</ul>\n<p>controller</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.springcloud.controller;\n\nimport com.atguigu.springcloud.service.PaymentHystrixService;\nimport com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties;\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\nimport javax.annotation.Resource;\n\n@RestController\n@Slf4j\n@DefaultProperties(defaultFallback &#x3D; &quot;payment_Global_FallbackMethod&quot;)  &#x2F;&#x2F;全局的\npublic class OrderHystrixController &#123;\n\n    @Resource\n    private PaymentHystrixService paymentHystrixService;\n\n    @GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;hystrix&#x2F;ok&#x2F;&#123;id&#125;&quot;)\n    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id)&#123;\n        String result &#x3D; paymentHystrixService.paymentInfo_OK(id);\n        return result;\n    &#125;\n\n    @HystrixCommand\n    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123;\n        int age &#x3D; 10&#x2F;0;\n        String result &#x3D; paymentHystrixService.paymentInfo_TimeOut(id);\n        return result;\n    &#125;\n\n    &#x2F;&#x2F;兜底方法\n    public String paymentTimeOutFallbackMethod(@PathVariable(&quot;id&quot;) Integer id)&#123;\n        return &quot;我是消费者80，对付支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,(┬＿┬)&quot;;\n    &#125;\n\n    &#x2F;&#x2F;下面是全局fallback方法\n    public String payment_Global_FallbackMethod()&#123;\n        return &quot;Global异常处理信息，请稍后再试,(┬＿┬)&quot;;\n    &#125;\n&#125;</code></pre>\n\n<h5 id=\"9、代码耦合的解决办法\"><a href=\"#9、代码耦合的解决办法\" class=\"headerlink\" title=\"9、代码耦合的解决办法\"></a>9、代码耦合的解决办法</h5><p>我们将兜底方法写在controller中或者service中，与其他业务逻辑混合，后期难以维护</p>\n<p>服务降级，客户端去调用服务端，碰上服务端宕机或关闭</p>\n<p>本次案例服务降级处理是在客户端80实现完成的，与服务端8001没有关系，<strong>只需要为Feign客户端定义的接口</strong>添加一个服务降级处理的实现类即可<strong>实现解耦</strong></p>\n<p>未来我们要面对的异常</p>\n<ul>\n<li>运行</li>\n<li>超时</li>\n<li>宕机</li>\n</ul>\n<p>再看我们的业务类PaymentController</p>\n<p>修改cloud-consumer-feign-hystrix-order80</p>\n<p>根据cloud-consumer-feign-hystrix-order80已经有的PaymentHystrixService接口，重新新建一个类（PaymentFallbackService）实现该接口，统一为接口里面的方法进行异常处理</p>\n<p>PaymentFallbackService类实现PaymentFeignClientService接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.springcloud.service;\n\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class PaymentFallbackService implements PaymentHystrixService &#123;\n    @Override\n    public String paymentInfo_OK(Integer id) &#123;\n        return &quot;-----PaymentFallbackService fall back-paymentInfo_OK , (┬＿┬)&quot;;\n    &#125;\n\n    @Override\n    public String paymentInfo_TimeOut(Integer id) &#123;\n        return &quot;-----PaymentFallbackService fall back-paymentInfo_TimeOut , (┬＿┬)&quot;;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">feign:\n  hystrix:\n    enabled: true #如果处理自身的容错就开启。开启方式与生产端不一样。</code></pre>\n\n<p>PaymentHystrixService</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.springcloud.service;\n\nimport org.springframework.cloud.openfeign.FeignClient;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\n\n@Component\n@FeignClient(value &#x3D; &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;,fallback &#x3D; PaymentFallbackService.class)\npublic interface PaymentHystrixService &#123;\n\n    @GetMapping(&quot;&#x2F;payment&#x2F;hystrix&#x2F;ok&#x2F;&#123;id&#125;&quot;)\n    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id);\n\n    @GetMapping(&quot;&#x2F;payment&#x2F;hystrix&#x2F;timeout&#x2F;&#123;id&#125;&quot;)\n    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id);\n&#125;</code></pre>\n\n<p>测试：</p>\n<ul>\n<li>单个eureka先启动7001</li>\n<li>PaymentHystrixMain8001启动</li>\n<li>正常访问测试：<a href=\"http://localhost/consumer/payment/hystrix/ok/31\">http://localhost/consumer/payment/hystrix/ok/31</a></li>\n<li>故意关闭微服务8001</li>\n<li>客户端自己调用提升</li>\n<li>此时服务端provider已经down了，但是我们做了服务降级处理，让客户端在服务端不可用时也会获得提示信息而不会挂起耗死服务器</li>\n</ul>\n<h4 id=\"21、服务熔断\"><a href=\"#21、服务熔断\" class=\"headerlink\" title=\"21、服务熔断\"></a>21、服务熔断</h4><h5 id=\"1、断路器\"><a href=\"#1、断路器\" class=\"headerlink\" title=\"1、断路器\"></a>1、断路器</h5><ul>\n<li>一句话就是家里保险丝</li>\n</ul>\n<h5 id=\"2、熔断是什么\"><a href=\"#2、熔断是什么\" class=\"headerlink\" title=\"2、熔断是什么\"></a>2、熔断是什么</h5><ul>\n<li><p>熔断机制概述</p>\n<p>熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。</p>\n</li>\n<li><p>当检测到该节点微服务调用响应正常后，恢复调用链路。</p>\n<p>在SpringCloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状态，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解是@HystrixCommand</p>\n</li>\n</ul>\n<h5 id=\"3、大神论文\"><a href=\"#3、大神论文\" class=\"headerlink\" title=\"3、大神论文\"></a>3、大神论文</h5><p><a href=\"https://martinfowler.com/bliki/CircuitBreaker.html\">https://martinfowler.com/bliki/CircuitBreaker.html</a></p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:08:25-10:26:31.png\" alt=\"image-20210824233931715\"></p>\n<h4 id=\"22、服务熔断实操\"><a href=\"#22、服务熔断实操\" class=\"headerlink\" title=\"22、服务熔断实操\"></a>22、服务熔断实操</h4><p>1、修改cloud-provider-hystrix-payment8001</p>\n<p>2、PaymentServiceImpl</p>\n<p>com.netflix.hystrix.HystrixCommandProperties</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;服务熔断\n@HystrixCommand(fallbackMethod &#x3D; &quot;paymentCircuitBreaker_fallback&quot;,commandProperties &#x3D; &#123;\n        @HystrixProperty(name &#x3D; &quot;circuitBreaker.enabled&quot;,value &#x3D; &quot;true&quot;),  &#x2F;&#x2F;是否开启断路器\n        @HystrixProperty(name &#x3D; &quot;circuitBreaker.requestVolumeThreshold&quot;,value &#x3D; &quot;10&quot;),   &#x2F;&#x2F;当在配置时间窗口内达到此数量的失败后，打开断路，默认20个\n        @HystrixProperty(name &#x3D; &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value &#x3D; &quot;10000&quot;),  &#x2F;&#x2F;断路多久以后开始尝试是否恢复，默认5s\n        @HystrixProperty(name &#x3D; &quot;circuitBreaker.errorThresholdPercentage&quot;,value &#x3D; &quot;60&quot;), &#x2F;&#x2F;出错百分比阈值，当达到此阈值后，开始短路。默认50%\n&#125;)\npublic String paymentCircuitBreaker(Integer id)&#123;\n    if (id &lt; 0)&#123;\n        throw new RuntimeException(&quot;*****id 不能负数&quot;);\n    &#125;\n    String serialNumber &#x3D; IdUtil.simpleUUID();&#x2F;&#x2F;hutool.cn工具包\n\n    return Thread.currentThread().getName()+&quot;\\t&quot;+&quot;调用成功,流水号：&quot;+serialNumber;\n&#125;\npublic String paymentCircuitBreaker_fallback(@PathVariable(&quot;id&quot;) Integer id)&#123;\n    return &quot;id 不能负数，请稍候再试,(┬＿┬)&#x2F;~~     id: &quot; +id;\n&#125;</code></pre>\n\n<p>PaymentController</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;服务熔断\n@GetMapping(&quot;&#x2F;payment&#x2F;circuit&#x2F;&#123;id&#125;&quot;)\npublic String paymentCircuitBreaker(@PathVariable(&quot;id&quot;) Integer id)&#123;\n    String result &#x3D; paymentService.paymentCircuitBreaker(id);\n    log.info(&quot;*******result:&quot;+result);\n    return result;\n&#125;</code></pre>\n\n<p>测试：</p>\n<ul>\n<li><p>自测cloud-provider-hystrix-payment8001</p>\n<p>正确： <a href=\"http://localhost:8001/payment/circuit/31\">http://localhost:8001/payment/circuit/31</a></p>\n<p>错误： <a href=\"http://localhost:8001/payment/circuit/-31\">http://localhost:8001/payment/circuit/-31</a></p>\n</li>\n<li><p>一次正确一次错误trytry</p>\n</li>\n<li><p>重点测试</p>\n<p>多次错误（狂点），然后慢慢正确，发现刚开始不满足条件，就算是正确的访问地址也不能进行访问，需要慢慢的恢复链路</p>\n</li>\n</ul>\n<h4 id=\"23、熔断原理\"><a href=\"#23、熔断原理\" class=\"headerlink\" title=\"23、熔断原理\"></a>23、熔断原理</h4><h5 id=\"1、大神理论\"><a href=\"#1、大神理论\" class=\"headerlink\" title=\"1、大神理论\"></a>1、大神理论</h5><p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:08:25-10:27:42.png\" alt=\"image-20210824233931715\"></p>\n<h5 id=\"2、熔断类型\"><a href=\"#2、熔断类型\" class=\"headerlink\" title=\"2、熔断类型\"></a>2、熔断类型</h5><ul>\n<li>熔断打开<ul>\n<li>请求不再进行调用当前服务，内部设置时钟一般为MTTR(平均故障处理时间)，当打开时长达到所设时钟则进入熔断状态</li>\n</ul>\n</li>\n<li>熔断关闭<ul>\n<li>熔断关闭不会对服务进行熔断</li>\n</ul>\n</li>\n<li>熔断半开<ul>\n<li>部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"3、官网断路器流程图\"><a href=\"#3、官网断路器流程图\" class=\"headerlink\" title=\"3、官网断路器流程图\"></a>3、官网断路器流程图</h5><h6 id=\"1⃣️-官网步骤\"><a href=\"#1⃣️-官网步骤\" class=\"headerlink\" title=\"1⃣️ 官网步骤\"></a>1⃣️ 官网步骤</h6><h6 id=\"2⃣️-断路器在什么情况下开始起作用\"><a href=\"#2⃣️-断路器在什么情况下开始起作用\" class=\"headerlink\" title=\"2⃣️ 断路器在什么情况下开始起作用\"></a>2⃣️ 断路器在什么情况下开始起作用</h6><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;服务熔断\n\n@HystrixCommand(fallbackMethod &#x3D; &quot;paymentCircuitBreaker_fallback&quot;,commandProperties &#x3D; &#123;\n\n@HystrixProperty(name &#x3D; &quot;circuitBreaker.enabled&quot;,value &#x3D; &quot;true&quot;),  &#x2F;&#x2F;是否开启断路器\n\n@HystrixProperty(name &#x3D; &quot;circuitBreaker.requestVolumeThreshold&quot;,value &#x3D; &quot;20&quot;),  &#x2F;&#x2F;当快照时间窗（默认10秒）内达到此数量才有资格打开断路，默认20个\n\n@HystrixProperty(name &#x3D; &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value &#x3D; &quot;50000&quot;),  &#x2F;&#x2F;断路多久以后开始尝试是否恢复，默认5s\n\n@HystrixProperty(name &#x3D; &quot;circuitBreaker.errorThresholdPercentage&quot;,value &#x3D; &quot;50&quot;), &#x2F;&#x2F;出错百分比阈值，当达到此阈值后，开始短路。默认50%\n\n  &#125;)</code></pre>\n\n<p>涉及到断路器的三个重要参数：<strong>快照时间窗、请求总数阈值、错误百分比阈值。</strong></p>\n<p>1、快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。</p>\n<p>2、请求总数阈值：在快照时间窗内，必须满足请求总数阈值才有资格熔断。默认20，意味着在10秒内，如果该hystrix命令的调用次数不足20次，即使所有的请求都超时或其他原因失败，断路器都不会打开。</p>\n<p>3、错误百分比阈值：当请求总数在快照时间窗内超过了阈值，比如发生了30次调用，如果在这30次调用，有15次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%阈值情况下，这时候就会将断路器打开。</p>\n<h6 id=\"3⃣️-断路器开启或者关闭的条件\"><a href=\"#3⃣️-断路器开启或者关闭的条件\" class=\"headerlink\" title=\"3⃣️ 断路器开启或者关闭的条件\"></a>3⃣️ 断路器开启或者关闭的条件</h6><p>当满足一定阀值的时候（默认10秒内超过20个请求次数）</p>\n<p>当失败率达到一定的时候（默认10秒内超过50%请求失败）</p>\n<p>到达以上阀值，断路器将会开启</p>\n<p>当开启的时候，所有请求都不会进行转发</p>\n<p>一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。重复4和5</p>\n<h6 id=\"4⃣️-断路器打开之后\"><a href=\"#4⃣️-断路器打开之后\" class=\"headerlink\" title=\"4⃣️ 断路器打开之后\"></a>4⃣️ 断路器打开之后</h6><p>1、再有请求调用的时候，将不会调用主逻辑，而是直接调用降级fallbak。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。</p>\n<p>2、原来的主逻辑要如何恢复呢？</p>\n<p>对于这一个问题，hystrix也为我们实现了自动恢复功能。</p>\n<p>当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。</p>\n<h4 id=\"24、服务限流\"><a href=\"#24、服务限流\" class=\"headerlink\" title=\"24、服务限流\"></a>24、服务限流</h4><p>后面讲</p>\n<h4 id=\"25、服务监控：hystrixDashboard\"><a href=\"#25、服务监控：hystrixDashboard\" class=\"headerlink\" title=\"25、服务监控：hystrixDashboard\"></a>25、服务监控：hystrixDashboard</h4><h5 id=\"1、概述\"><a href=\"#1、概述\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h5><p>除了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控(Hystrix Dashboard)，Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。Netflix通过hystrix-metrics-event-stram项目实现了对以上指示的监控。Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。</p>\n<h5 id=\"2、仪表盘：9001\"><a href=\"#2、仪表盘：9001\" class=\"headerlink\" title=\"2、仪表盘：9001\"></a>2、仪表盘：9001</h5><p>新建Module：cloud-consumer-hystrix-dashboard9001</p>\n<p>pom</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;cloud2020&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n    &lt;artifactId&gt;cloud-consumer-hystrix-dashboard9001&lt;&#x2F;artifactId&gt;\n\n    &lt;dependencies&gt;\n        &lt;!--新增hystrix dashboard--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;</code></pre>\n\n<p>yml</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">server:\n  port: 9001</code></pre>\n\n<p>HystrixDashboardMain9001+新注解@EnableHystrixDashboard</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;\n\n@SpringBootApplication\n@EnableHystrixDashboard\npublic class HystrixDashboardMain9001 &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(HystrixDashboardMain9001.class,args);\n    &#125;\n&#125;</code></pre>\n\n<p>所有Provider微服务提供类（8001/8002/8003）都需要监控依赖配置</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>启动cloud-consumer-hystrix-dashboard9001该微服务后续将监控微服务8001</p>\n<p><a href=\"http://localhost:9001/hystrix\">http://localhost:9001/hystrix</a></p>\n<img src=\"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:08:25-10:27:54.png\" alt=\"image-20210824235549533\" style=\"zoom:65%;\" />\n\n\n\n<h4 id=\"26、断路器演示\"><a href=\"#26、断路器演示\" class=\"headerlink\" title=\"26、断路器演示\"></a>26、断路器演示</h4><p>1、修改cloud-provider-hystrix-payment8001\\</p>\n<p>注意：新版本Hystrix需要在主启动类MainAppHystrix8001中指定监控路径</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑\n *ServletRegistrationBean因为springboot的默认路径不是&quot;&#x2F;hystrix.stream&quot;，\n *只要在自己的项目里配置上下面的servlet就可以了\n *&#x2F;\n@Bean\npublic ServletRegistrationBean getServlet() &#123;\nHystrixMetricsStreamServlet streamServlet &#x3D; new HystrixMetricsStreamServlet();\nServletRegistrationBean registrationBean &#x3D; new ServletRegistrationBean(streamServlet);\nregistrationBean.setLoadOnStartup(1);\nregistrationBean.addUrlMappings(&quot;&#x2F;hystrix.stream&quot;);\nregistrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;);\nreturn registrationBean;\n&#125;</code></pre>\n\n<p>Unable to connect to Command Metric Stream</p>\n<p>404</p>\n<p>2、监控测试</p>\n<ol>\n<li>启动1个eureka</li>\n<li>观察监控窗口</li>\n</ol>\n<p>9001监控8001</p>\n<p><a href=\"http://localhost:9001/hystrix\">http://localhost:9001/hystrix</a></p>\n<p><a href=\"http://localhost:8001/hystrix.stream\">http://localhost:8001/hystrix.stream</a></p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:08:25-10:29:23.jpg\" alt=\"img\"> </p>\n<p>测试地址</p>\n<p><a href=\"http://localhost:8001/payment/circuit/31\">http://localhost:8001/payment/circuit/31</a></p>\n<p><a href=\"http://localhost:8001/payment/circuit/-31\">http://localhost:8001/payment/circuit/-31</a></p>\n<p>上述测试通过</p>\n<p>ok</p>\n<p>先访问正确地址，再访问错误地址，再正确地址，会发现图示断路器都是慢慢放开的</p>\n<p>监控结果，成功</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:08:25-10:28:07.jpg\" alt=\"img\"> </p>\n<p>监控结果，失败</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:08:25-10:28:10.jpg\" alt=\"img\"> </p>\n<p>如何看，7色</p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:08:25-10:28:14.jpg\" alt=\"img\"> </p>\n<p>1圈，实心圆：共有两种含义。它通过颜色的变化代表了实例的健康程度，它的健康度从绿色&lt;黄色&lt;橙色&lt;红色递减。</p>\n<p>该实心圆除了颜色的变化之外，它的大小也会根据实例的请求流量发生变化，流量越大该实心圆就越大。所以通过该实心圆的展示，就可以在大量的实体中快速的发现故障实例和高压力实例。</p>\n<p>1线，曲线：用来记录2分钟内流量的相对变化，可以通过它来观察到流量的上升和下降趋势。</p>\n<p><strong>整图说明</strong></p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:08:25-10:28:19.jpg\" alt=\"img\"> </p>\n<p><strong>整图说明2</strong></p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:08:25-10:28:26.jpg\" alt=\"img\"> </p>\n<p><strong>搞懂一个才能看懂复杂的</strong></p>\n<p><img src=\"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:08:25-10:28:31.jpg\" alt=\"img\"></p>\n","text":"01、Eureka 基本内容 在微服务架构中，服务注册与发现是核心组件之一，手动指定每个服务是很低效的，Spring cloud提供了多种服务注册与发现的实现方式,例如: Eureka、Consu、 Zookeeper SringCloud支持得最好的是 Eureka,其次是 C...","link":"","photos":[],"count_time":{"symbolsCount":"48k","symbolsTime":"44 mins."},"categories":[{"name":"SpringCloud","slug":"SpringCloud","count":4,"path":"api/categories/SpringCloud.json"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","count":4,"path":"api/tags/SpringCloud.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#01%E3%80%81Eureka-%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">01、Eureka 基本内容</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86\"><span class=\"toc-text\">1.1、什么是服务治理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C\"><span class=\"toc-text\">1.2、什么是服务注册</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-3%E3%80%81%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0\"><span class=\"toc-text\">1.3、服务注册与发现</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-4%E3%80%81Eureka%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">1.4、Eureka是什么</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-5%E3%80%81Eureka%E5%92%8CZookeeper%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">1.5、Eureka和Zookeeper对比</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#02%E3%80%81Eureka-%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">02、Eureka 入门程序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-1%E3%80%81%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%BB%BAModule\"><span class=\"toc-text\">2.1、服务注册中心建Module</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2%E3%80%81%E6%94%B9POM\"><span class=\"toc-text\">2.2、改POM</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-3%E3%80%81Eureka%E7%89%88%E6%9C%AC%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">2.3、Eureka版本对比</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-4%E3%80%81%E5%86%99YML\"><span class=\"toc-text\">2.4、写YML</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-5%E3%80%81%E4%B8%BB%E5%90%AF%E5%8A%A8\"><span class=\"toc-text\">2.5、主启动</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-6%E3%80%81%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">2.6、测试</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-7%E3%80%81%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85\"><span class=\"toc-text\">2.7、服务提供者</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-8%E3%80%81%E5%BB%BAModule\"><span class=\"toc-text\">2.8、建Module</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-9%E3%80%81%E6%94%B9POM\"><span class=\"toc-text\">2.9、改POM</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-0%E3%80%81%E5%86%99YML\"><span class=\"toc-text\">3.0、写YML</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-1%E3%80%81%E4%B8%BB%E5%90%AF%E5%8A%A8\"><span class=\"toc-text\">3.1、主启动</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-2%E3%80%81%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">3.2、测试</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-3%E3%80%81%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85\"><span class=\"toc-text\">3.3、服务消费者</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-4%E3%80%81%E5%BB%BAModule\"><span class=\"toc-text\">3.4、建Module</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-5%E3%80%81POM\"><span class=\"toc-text\">3.5、POM</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-6%E3%80%81%E5%86%99YML\"><span class=\"toc-text\">3.6、写YML</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-7%E3%80%81%E4%B8%BB%E5%90%AF%E5%8A%A8\"><span class=\"toc-text\">3.7、主启动</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-8%E3%80%81%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">3.8、测试</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#03%E3%80%81Eureka-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">03、Eureka 注册中心高可用集群概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#04%E3%80%81Eureka-%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">04、Eureka 详解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">1、服务消费者模式</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">2、服务注册模式</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#05%E3%80%81Ribbon-%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">05、Ribbon 是什么</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-2%E3%80%81Ribbon%E8%83%BD%E5%B9%B2%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">5.2、Ribbon能干什么</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-3%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%80%E8%BF%B0\"><span class=\"toc-text\">5.3、负载均衡简述</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-4%E3%80%81Ribbon%E4%B8%8E-Nginx%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">5.4、Ribbon与 Nginx的区别</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-5%E3%80%81Spring-Cloud%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8Ribbon\"><span class=\"toc-text\">5.5、Spring Cloud如何调用Ribbon</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#06%E3%80%81Ribbon-%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\"><span class=\"toc-text\">06、Ribbon 实现客户端负载均衡</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#07%E3%80%81Ribbon-%E5%AE%9A%E4%B9%89%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">07、Ribbon 定义负载均衡策略</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7-1%E3%80%81Ribbon-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E7%B1%BB\"><span class=\"toc-text\">7.1、Ribbon 负载均衡策略类</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7-2%E3%80%81Ribbon-%E6%8C%87%E5%AE%9A%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">7.2、Ribbon 指定策略</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#08%E3%80%81Feign-%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">08、Feign 是什么</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#09%E3%80%81Feign-%E5%AE%9E%E7%8E%B0%E6%B6%88%E8%B4%B9%E8%80%85\"><span class=\"toc-text\">09、Feign 实现消费者</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10%E3%80%81%E4%BD%BF%E7%94%A8Feign%E6%94%AF%E6%8C%81%E7%9A%84%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">10、使用Feign支持的特性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#11%E3%80%81Feign-%E9%BB%98%E8%AE%A4%E8%B6%85%E6%97%B6%E6%97%B6%E9%95%BF1%E7%A7%92\"><span class=\"toc-text\">11、Feign 默认超时时长1秒</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#12%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">12、分布式面临的问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#13%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFHystrix\"><span class=\"toc-text\">13、什么是Hystrix</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#14%E3%80%81Hystrix%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">14、Hystrix的作用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#15%E3%80%81Hystrix%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">15、Hystrix重要概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#16%E3%80%81Hystrix-%E6%A1%88%E4%BE%8B%E5%88%9B%E5%BB%BA-%E6%94%AF%E4%BB%98%E6%9C%8D%E5%8A%A1%E7%AB%AF\"><span class=\"toc-text\">16、Hystrix 案例创建 支付服务端</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#17%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">17、高并发测试</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#18%E3%80%81Hystrix-%E6%A1%88%E4%BE%8B%E5%88%9B%E5%BB%BA-%E8%AE%A2%E5%8D%95%E6%B6%88%E8%B4%B9%E7%AB%AF\"><span class=\"toc-text\">18、Hystrix 案例创建 订单消费端</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#19%E3%80%81%E6%95%85%E9%9A%9C%E7%8E%B0%E8%B1%A1%E5%92%8C%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95\"><span class=\"toc-text\">19、故障现象和原因及解决办法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#20%E3%80%81%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7\"><span class=\"toc-text\">20、服务降级</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7%E3%80%81%E7%9B%AE%E5%89%8D%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">7、目前问题</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8%E3%80%81%E4%BB%A3%E7%A0%81%E8%86%A8%E8%83%80%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95\"><span class=\"toc-text\">8、代码膨胀的解决办法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#9%E3%80%81%E4%BB%A3%E7%A0%81%E8%80%A6%E5%90%88%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95\"><span class=\"toc-text\">9、代码耦合的解决办法</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#21%E3%80%81%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD\"><span class=\"toc-text\">21、服务熔断</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%96%AD%E8%B7%AF%E5%99%A8\"><span class=\"toc-text\">1、断路器</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2%E3%80%81%E7%86%94%E6%96%AD%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">2、熔断是什么</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%A4%A7%E7%A5%9E%E8%AE%BA%E6%96%87\"><span class=\"toc-text\">3、大神论文</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#22%E3%80%81%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E5%AE%9E%E6%93%8D\"><span class=\"toc-text\">22、服务熔断实操</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#23%E3%80%81%E7%86%94%E6%96%AD%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">23、熔断原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%A4%A7%E7%A5%9E%E7%90%86%E8%AE%BA\"><span class=\"toc-text\">1、大神理论</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2%E3%80%81%E7%86%94%E6%96%AD%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">2、熔断类型</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%AE%98%E7%BD%91%E6%96%AD%E8%B7%AF%E5%99%A8%E6%B5%81%E7%A8%8B%E5%9B%BE\"><span class=\"toc-text\">3、官网断路器流程图</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#1%E2%83%A3%EF%B8%8F-%E5%AE%98%E7%BD%91%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">1⃣️ 官网步骤</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2%E2%83%A3%EF%B8%8F-%E6%96%AD%E8%B7%AF%E5%99%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%BC%80%E5%A7%8B%E8%B5%B7%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">2⃣️ 断路器在什么情况下开始起作用</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#3%E2%83%A3%EF%B8%8F-%E6%96%AD%E8%B7%AF%E5%99%A8%E5%BC%80%E5%90%AF%E6%88%96%E8%80%85%E5%85%B3%E9%97%AD%E7%9A%84%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">3⃣️ 断路器开启或者关闭的条件</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#4%E2%83%A3%EF%B8%8F-%E6%96%AD%E8%B7%AF%E5%99%A8%E6%89%93%E5%BC%80%E4%B9%8B%E5%90%8E\"><span class=\"toc-text\">4⃣️ 断路器打开之后</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#24%E3%80%81%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81\"><span class=\"toc-text\">24、服务限流</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#25%E3%80%81%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7%EF%BC%9AhystrixDashboard\"><span class=\"toc-text\">25、服务监控：hystrixDashboard</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1、概述</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2%E3%80%81%E4%BB%AA%E8%A1%A8%E7%9B%98%EF%BC%9A9001\"><span class=\"toc-text\">2、仪表盘：9001</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#26%E3%80%81%E6%96%AD%E8%B7%AF%E5%99%A8%E6%BC%94%E7%A4%BA\"><span class=\"toc-text\">26、断路器演示</span></a></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"SpringCloud GateWay","uid":"6dd02a05274ef2720cdd348b80b5ceee","slug":"70-SpringCloud-GateWay","date":"2021-09-13T15:46:32.000Z","updated":"2021-09-15T10:46:26.355Z","comments":true,"path":"api/articles/70-SpringCloud-GateWay.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog6.jpg","text":"一、SpringCloud Gateway 网关 1、Gateway 的概念SpringCloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网...","link":"","photos":[],"count_time":{"symbolsCount":"33k","symbolsTime":"30 mins."},"categories":[{"name":"SpringCloud","slug":"SpringCloud","count":4,"path":"api/categories/SpringCloud.json"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","count":4,"path":"api/tags/SpringCloud.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"SpringCloud 基础内容","uid":"74daf6bfc632564c16acab051038d38a","slug":"68-SpringCloud-基础内容","date":"2021-09-13T15:44:32.000Z","updated":"2021-09-15T10:46:40.017Z","comments":true,"path":"api/articles/68-SpringCloud-基础内容.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog8.jpg","text":"1、本章导读 2、微服务理论In short, the microservice architectural style [1] is an approach to developing a single application as a suite of small servi...","link":"","photos":[],"count_time":{"symbolsCount":"28k","symbolsTime":"25 mins."},"categories":[{"name":"SpringCloud","slug":"SpringCloud","count":4,"path":"api/categories/SpringCloud.json"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","count":4,"path":"api/tags/SpringCloud.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}