{"title":"JDBC 事务，工具类，行级锁","uid":"55745060491eb4938fdbbffa36e92659","slug":"24-JDBC事务、工具类、行级锁","date":"2021-09-13T15:01:32.000Z","updated":"2021-09-15T10:21:51.879Z","comments":true,"path":"api/articles/24-JDBC事务、工具类、行级锁.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","content":"<h3 id=\"一、JDBC事务机制\"><a href=\"#一、JDBC事务机制\" class=\"headerlink\" title=\"一、JDBC事务机制\"></a>一、JDBC事务机制</h3><ol>\n<li>Jdbc中的事务是自动提交的。</li>\n<li>只要执行任意一条DML语句，则自动提交一次，这是JDBC的默认事务提交行为。但是实际业务中，很多情况是 需要N条DML语句联合才能完成的，必须保证他们同时成功或者同事失败。</li>\n<li>conn表示一个连接，与数据库的连接，不为空表示还连接着，为空就表示没有连接，就不需要释放资源 stmt，rs，ps与之一样。</li>\n<li>开启事务，提交，catch里写rollback并判断conn不等于nul1<br>rollback的意义在于当还有连接，如果上面的联合语句有些地方有问题，可以进行回滚</li>\n<li>开启事务：conn.setAutoCommit(false);<br>提交事务：conn.commit();<br>回滚事务：conn.rollback();<br>设置回滚点：Savepoint sp = conn.getSavepoint();<br>回滚到回滚点：conn.rollback(sp)；</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">*两个人转账\n\t  &#x2F;&#x2F;开启事务\n      conn.setAutoCommit(false);\n      \n      &#x2F;&#x2F;转账\n\t  String sql &#x3D; &quot;update deposit set balance &#x3D;? where id &#x3D;?&quot;;\n\t  &#x2F;&#x2F;111的\n\t  ps.setString(1, balance);\n      ps.setString(2, id);\n      int count &#x3D; ps.executeUpdate();\n      &#x2F;&#x2F;222的\n      ps.setString(1, balance2);\n      ps.setString(2, id2);\n      count +&#x3D; ps.executeUpdate();\n      \n      &#x2F;&#x2F;进行查询（发现数据改变，变为更新的值，而数据库中的数据并未改变，因为还事务开启未提交）\n      ps2 &#x3D; conn.prepareStatement(&quot;select * from deposit&quot;);\n            ResultSet rs &#x3D; ps2.executeQuery();\n            while (rs.next())&#123;\n                String id3 &#x3D; rs.getString(1);\n                String balance3 &#x3D; rs.getString(2);\n                System.out.println(id3+&quot;:&quot;+balance3);\n            &#125;\n            \n      &#x2F;&#x2F;若没有问题，此时提交，则数据库中数据进行更新同步\n      \n      &#x2F;&#x2F;若还没提交这里有一个异常，比如空指针异常\n      String s&#x3D;null;\n      s.toString();\n      &#x2F;&#x2F;因为异常，所以会进入到catch()中执行语句\n      \n      &#x2F;&#x2F;首先再次查询一下数据（发现数据和上次查到的一样，所以我们要进行数据回滚）\n      try &#123;\n      ps3 &#x3D; conn.prepareStatement(&quot;select * from deposit&quot;);\n      ResultSet rs &#x3D; ps3.executeQuery();\n      while (rs.next())&#123;\n      String id4 &#x3D; rs.getString(1);\n      String balance4 &#x3D; rs.getString(2);\n      System.out.println(id4+&quot;:&quot;+balance4);\n      &#125;\n      &#125;catch (Exception es)&#123;\n      es.printStackTrace();\n      &#125;\n            \n      &#x2F;&#x2F;回滚\n      if (conn !&#x3D; null) &#123;\n      try &#123;\n      conn.rollback();\n      &#125; catch (SQLException ex) &#123;\n      ex.printStackTrace();\n      &#125;\n      &#125;\n      \n      &#x2F;&#x2F;再次查询（数据更新取消，回到原来的数值）\n            try &#123;\n                ps4 &#x3D; conn.prepareStatement(&quot;select * from deposit&quot;);\n                ResultSet rs &#x3D; ps4.executeQuery();\n                while (rs.next())&#123;\n                    String id5 &#x3D; rs.getString(1);\n                    String balance5 &#x3D; rs.getString(2);\n                    System.out.println(id5+&quot;:&quot;+balance5);\n                &#125;\n            &#125;catch (Exception es)&#123;\n                es.printStackTrace();\n            &#125;\n      \n      </code></pre>\n\n<h3 id=\"二、JDBC工具类的制作\"><a href=\"#二、JDBC工具类的制作\" class=\"headerlink\" title=\"二、JDBC工具类的制作\"></a>二、JDBC工具类的制作</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package DBUtil;\nimport java.sql.*;\n\n&#x2F;* 工具类中的构造方法都是私有的，不是必须是私有，只是模仿（模仿sun公司）\n\t\n   因为工具类的方法都是静态的，不需要new对象，直接采用类名调用\n   \n   为了防止别人new对象，所以私有化\n\t\n*&#x2F;\n\npublic class DBUtil &#123;\n\n\t&#x2F;&#x2F;构造方法\n    private DBUtil()&#123;&#125;\n\n\t&#x2F;&#x2F;以静态代码块的方式生成注册驱动的功能，因为类的加载会调用静态代码块，并且只执行一次\n    static &#123;\n        try &#123;\n            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n\t&#x2F;&#x2F;获取数据库连接，\n    public static Connection getConnection() throws Exception&#123;\n\t\treturn  DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db_sql&quot;,&quot;root&quot;,&quot;hhhh&quot;);\n    &#125;\n\t\n    &#x2F;&#x2F;封装关闭资源的方法，因为在jdbc增删改时，用不到rs对象，所以用方法重载，又写了一个此方法\n    public static void close(Connection conn, Statement ps, ResultSet rs)&#123;\n\n        if (rs!&#x3D;null)&#123;\n            try &#123;\n                rs.close();\n            &#125; catch (SQLException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        if (ps!&#x3D;null)&#123;\n            try &#123;\n                ps.close();\n            &#125; catch (SQLException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        if (conn!&#x3D;null)&#123;\n            try &#123;\n                conn.close();\n            &#125; catch (SQLException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n    public static void close(Connection conn, Statement ps)&#123;\n\n        if (ps!&#x3D;null)&#123;\n            try &#123;\n                ps.close();\n            &#125; catch (SQLException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        if (conn!&#x3D;null)&#123;\n            try &#123;\n                conn.close();\n            &#125; catch (SQLException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n\n    &#125;\n&#125;\n</code></pre>\n\n<h3 id=\"三、行级锁\"><a href=\"#三、行级锁\" class=\"headerlink\" title=\"三、行级锁\"></a>三、行级锁</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">* 使用需要开启事务\n\n1、for update叫排它锁，是一种行级锁，一旦用户对某个行施加了行级加锁，则该用户可以查询也可以更新被加锁的数据行，其它用户只能查询但不能更新被加锁的数据行．如果其它用户想更新该表中的数据行，则也必须对该表施加行级锁．即使多个用户对一个表均使用了共享更新，但也不允许两个事务同时对一个表进行更新，真正对表进行更新时，是以独占方式锁表，一直到提交或复原该事务为止。行锁永远是独占方式锁。\n只有当出现如下之一的条件，便释放共享更新锁：\n（1）、执行提交（COMMIT）语句；\n（2）、退出数据库（LOG　OFF）\n（3）、程序停止运行。\n\nSelect …for update语句是我们经常使用手工加锁语句。通常情况下，select语句是不会对数据加锁，妨碍影响其他的DML和DDL操作。同时，在多版本一致读机制的支持下，select语句也不会被其他类型语句所阻碍。\n\n2、 借助for update子句，我们可以在应用程序的层面手工实现数据加锁保护操作\n\n什么时候需要使用for update？就是那些需要业务层面数据独占时，可以考虑使用for update。场景上，比如火车票订票，在屏幕上显示邮票，而真正进行出票时，需要重新确定一下这个数据没有被其他客户端修改。所以，在这个确认过程中，可以使用for update。\n\n3、顺便说一下乐观锁和悲观锁\n\n悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。\n\n乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。\n\n4、一般遇到高并发会有多服务器部署，这时候就要用到分布式锁\n    \n【此内容来自】https:&#x2F;&#x2F;www.cnblogs.com&#x2F;h-c-g&#x2F;p&#x2F;10234477.html</code></pre>\n\n<h3 id=\"四、封装JDBCTools\"><a href=\"#四、封装JDBCTools\" class=\"headerlink\" title=\"四、封装JDBCTools\"></a>四、封装JDBCTools</h3><p>配置文件：src/jdbc.properties</p>\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\">#key&#x3D;value\ndriverClassName&#x3D;com.mysql.jdbc.Driver\nurl&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test\nusername&#x3D;root\npassword&#x3D;123456\ninitialSize&#x3D;5\nmaxActive&#x3D;10\nmaxWait&#x3D;1000</code></pre>\n\n<p>JDBCTools工具类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.util;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Properties;\nimport javax.sql.DataSource;\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\n\n&#x2F;*\n * 获取连接或释放连接的工具类\n *&#x2F;\npublic class JDBCTools &#123;\n\t&#x2F;&#x2F; 1、数据源,即连接池\n\tprivate static DataSource dataSource;\n\t\n\t&#x2F;&#x2F; 2、ThreadLocal对象\n\tprivate static ThreadLocal&lt;Connection&gt; threadLocal &#x3D; new ThreadLocal&lt;&gt;();\n\n\tstatic &#123;\n\t\ttry &#123;\n\t\t\t&#x2F;&#x2F;1、读取druip.properties文件\n\t\t\tProperties pro &#x3D; new Properties();\n\t\t\tpro.load(JDBCTools2.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));\n\t\t\t\n\t\t\t&#x2F;&#x2F;2、创建线程池\n\t\t\tdataSource &#x3D; DruidDataSourceFactory.createDataSource(pro);\n\t\t&#125; catch (Exception e) &#123;\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;**\n\t * 获取连接的方法\n\t * \n\t * @return\n\t * @throws SQLException\n\t *&#x2F;\n\tpublic static Connection getConnection() &#123;\n\t\t&#x2F;&#x2F; 从当前线程中获取连接\n\t\tConnection connection &#x3D; threadLocal.get();\n\t\tif (connection &#x3D;&#x3D; null) &#123;\n\t\t\t&#x2F;&#x2F; 从连接池中获取一个连接\n\t\t\ttry &#123;\n\t\t\t\tconnection &#x3D; dataSource.getConnection();\n\t\t\t\t&#x2F;&#x2F; 将连接与当前线程绑定\n\t\t\t\tthreadLocal.set(connection);\n\t\t\t&#125; catch (SQLException e) &#123;\n\t\t\t\te.printStackTrace();\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn connection;\n\t&#125;\n\n\t&#x2F;**\n\t * 释放连接的方法\n\t * \n\t * @param connection\n\t *&#x2F;\n\tpublic static void releaseConnection() &#123;\n\t\t&#x2F;&#x2F; 获取当前线程中的连接\n\t\tConnection connection &#x3D; threadLocal.get();\n\t\tif (connection !&#x3D; null) &#123;\n\t\t\ttry &#123;\n\t\t\t\tconnection.close();\n\t\t\t&#125; catch (SQLException e) &#123;\n\t\t\t\te.printStackTrace();\n\t\t\t&#125;finally&#123;\n\t\t\t\t&#x2F;&#x2F; 将已经关闭的连接从当前线程中移除\n\t\t\t\tthreadLocal.remove();\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<p>其中ThreadLocal的介绍如下：</p>\n<p>JDK 1.2的版本中就提供java.lang.ThreadLocal，为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。通常用来在在多线程中管理共享数据库连接、Session等</p>\n<p>ThreadLocal用于保存某个线程共享变量，原因是在Java中，每一个线程对象中都有一个ThreadLocalMap&lt;ThreadLocal, Object&gt;，其key就是一个ThreadLocal，而Object即为该线程的共享变量。而这个map是通过ThreadLocal的set和get方法操作的。对于同一个static ThreadLocal，不同线程只能从中get，set，remove自己的变量，而不会影响其他线程的变量。</p>\n<p>1、ThreadLocal.get: 获取ThreadLocal中当前线程共享变量的值。</p>\n<p>2、ThreadLocal.set: 设置ThreadLocal中当前线程共享变量的值。</p>\n<p>3、ThreadLocal.remove: 移除ThreadLocal中当前线程共享变量的值。</p>\n<p><img src=\"https://gitee.com/xiuxiuai/picture/raw/master/img/jdbc4.png\" alt=\"image-20200518102603167\"></p>\n<h3 id=\"五、封装BasicDAOImpl\"><a href=\"#五、封装BasicDAOImpl\" class=\"headerlink\" title=\"五、封装BasicDAOImpl\"></a>五、封装BasicDAOImpl</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;1.获取泛型父类\nType genType &#x3D; getClass().getGenericSuperclass();\n&#x2F;&#x2F;2.获取实际传入的泛型参数类型\nType[] typeParams &#x3D; ((ParameterizedType) genType).getActualTypeArguments();\nClass entityClass &#x3D; (Class)typeParams[0];</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Field field &#x3D; entityClass.getDeclaredField(colName);\nfield.setAccessible(true);\nfield.set(instance, rs.getObject(i));</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.atguigu.test08.dao;\n\nimport java.lang.reflect.Field;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\n\nimport com.atguigu.util.JDBCTools;\n\npublic class BasicDAOImpl &#123;\n\t&#x2F;*\n\t * 通用的增、删、改的方法\n\t *&#x2F;\n\tprotected int update(String sql,Object... args) throws SQLException&#123;\n\t\t&#x2F;&#x2F;1、获取链接对象\n\t\tConnection conn &#x3D; JDBCTools.getConnection();\n\t\t\n\t\t&#x2F;&#x2F;2、编写sql，用形参传入的方式代替\n\t\t\n\t\t&#x2F;&#x2F;3、获取Statement或PreparedStatement对象\n\t\tPreparedStatement pst &#x3D; conn.prepareStatement(sql);\n\t\t\n\t\t&#x2F;&#x2F;设置？的值\n\t\t&#x2F;&#x2F;因为不知道sql中是否有?，以及？设置为什么值，通过形参来传入\n\t\t&#x2F;&#x2F;Object... args可变形参，可以传入0~n个值\n\t\t&#x2F;&#x2F;如果没有传入，说明没有？需要设置\n\t\t&#x2F;&#x2F;如果传入了n个值，那么说明sql中有n个？需要设置\n\t\tif(args!&#x3D;null  &amp;&amp; args.length&gt;0)&#123;\n\t\t\tfor (int i &#x3D; 0; i &lt; args.length; i++) &#123;\n\t\t\t\t&#x2F;&#x2F;数组的下标从0开始，pst的？的序号是从1开始，所以这里用i+1\n\t\t\t\tpst.setObject(i+1, args[i]);\n\t\t\t&#125;\n\t\t&#125;\n\t\t\n\t\t&#x2F;&#x2F;4、执行sql\n\t\tint len &#x3D; pst.executeUpdate();\n\t\t&#x2F;&#x2F;5、关闭\t\t\n\t\tpst.close();\n\t\t&#x2F;&#x2F;这里不关闭conn，因为它在同一个事务的其他地方还要使用\n\t\treturn len;\n\t&#125;\n\t\n\t&#x2F;*\n\t * 通用查询多个Javabean对象的方法\n\t *&#x2F;\n\tprotected &lt;T&gt; ArrayList&lt;T&gt; getList(Class&lt;T&gt; clazz,String sql,Object... args) throws Exception&#123;\n\t\t&#x2F;&#x2F;1、获取链接对象\n\t\tConnection conn &#x3D; JDBCTools.getConnection();\n\t\t&#x2F;&#x2F;2、编写sql，由形参传入\n\t\t\n\t\t&#x2F;&#x2F;3、获取PreparedStatement对象\n\t\tPreparedStatement pst &#x3D; conn.prepareStatement(sql);\n\t\t\n\t\t&#x2F;&#x2F;4、设置？，由形参传入\n\t\tif(args!&#x3D;null  &amp;&amp; args.length&gt;0)&#123;\n\t\t\tfor (int i &#x3D; 0; i &lt; args.length; i++) &#123;\n\t\t\t\t&#x2F;&#x2F;数组的下标从0开始，pst的？的序号是从1开始，所以这里用i+1\n\t\t\t\tpst.setObject(i+1, args[i]);\n\t\t\t&#125;\n\t\t&#125;\n\t\t\n\t\t&#x2F;&#x2F;5、执行sql\n\t\tResultSet rs &#x3D; pst.executeQuery();\n\t\t&#x2F;*\n\t\t * 如何把ResultSet结果集中的数据变成一个一个的Javabean对象，放到ArrayList对象，并且返回\n\t\t *&#x2F;\n\t\tArrayList&lt;T&gt; list &#x3D; new ArrayList&lt;&gt;();\n\t\t&#x2F;*\n\t\t * 要从ResultSet结果集中获取一共有几行，决定要创建几个对象\n\t\t * 要从ResultSet结果集中获取一共有几列，决定要为几个属性赋值\n\t\t * ResultSet结果集对象中，有一个方法ResultSetMetaData getMetaData()获取结果集的元数据\n\t\t * 元数据就是描述结果集中的数据的数据，例如：列数，列名称等\n\t\t *&#x2F;\n\t\tResultSetMetaData metaData &#x3D; rs.getMetaData();\n\t\tint count &#x3D; metaData.getColumnCount();&#x2F;&#x2F;获取列数\n\t\t\n\t\twhile(rs.next())&#123;&#x2F;&#x2F;循环一次代表一行，就要创建一个Javabean对象\n\t\t\t&#x2F;&#x2F;(1)创建一个Javabean对象\n\t\t\tT t  &#x3D; clazz.newInstance();&#x2F;&#x2F;这个方法有要求，要求Javabean这个类要有无参构造\n\t\t\t\n\t\t\t&#x2F;&#x2F;(2)设置对象的属性值\n\t\t\t&#x2F;*\n\t\t\t * 反射操作属性的步骤：\n\t\t\t * ①获取Class对象，现在有了\n\t\t\t * ②获取属性对象Field\n\t\t\t * \t\tField f &#x3D; clazz.getDeclaredField(&quot;属性名&quot;);\n\t\t\t * ③创建Javabean对象，已经创建\n\t\t\t * ④设置属性的可访问性  setAccessible(true)\n\t\t\t * ⑤设置属性的值\n\t\t\t *&#x2F;\n\t\t\tfor (int i &#x3D; 0; i &lt; count; i++) &#123;&#x2F;&#x2F;一共要为count个属性赋值\n&#x2F;&#x2F;\t\t\t\tField f &#x3D; clazz.getDeclaredField(&quot;属性名&quot;);\n\t\t\t\tString fieldName &#x3D; metaData.getColumnLabel(i+1);&#x2F;&#x2F;获取第几列的字段名\n\t\t\t\tField f &#x3D; clazz.getDeclaredField(fieldName);\n\t\t\t\t\n\t\t\t\tf.setAccessible(true);\n\t\t\t\t\n\t\t\t\tf.set(t, rs.getObject(i+1));&#x2F;&#x2F;rs.getObject(i+1)获取第几列的值\n\t\t\t&#125;\n\t\t\t\n\t\t\t&#x2F;&#x2F;(3)把Javabean对象放到list中\n\t\t\tlist.add(t);\n\t\t&#125;\n\t\tpst.close();\n\t\trs.close();\n\t\t&#x2F;&#x2F;这里不关闭conn，因为它在同一个事务的其他地方还要使用\n\t\treturn list;\n\t&#125;\n\n\tprotected &lt;T&gt; T getBean(Class&lt;T&gt; clazz,String sql,Object... args) throws Exception&#123;\n\t\treturn getList(clazz,sql,args).get(0);\n\t&#125;\n&#125;\n</code></pre>\n\n","text":"一、JDBC事务机制 Jdbc中的事务是自动提交的。 只要执行任意一条DML语句，则自动提交一次，这是JDBC的默认事务提交行为。但是实际业务中，很多情况是 需要N条DML语句联合才能完成的，必须保证他们同时成功或者同事失败。 conn表示一个连接，与数据库的连接，不为空表示还连...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"JDBC","slug":"JDBC","count":4,"path":"api/categories/JDBC.json"}],"tags":[{"name":"JDBC","slug":"JDBC","count":4,"path":"api/tags/JDBC.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81JDBC%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">一、JDBC事务机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81JDBC%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E5%88%B6%E4%BD%9C\"><span class=\"toc-text\">二、JDBC工具类的制作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E8%A1%8C%E7%BA%A7%E9%94%81\"><span class=\"toc-text\">三、行级锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E5%B0%81%E8%A3%85JDBCTools\"><span class=\"toc-text\">四、封装JDBCTools</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E5%B0%81%E8%A3%85BasicDAOImpl\"><span class=\"toc-text\">五、封装BasicDAOImpl</span></a></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"JDBC 返回自增，批处理","uid":"ed74ba118184352b8cd4d1ed4148e31c","slug":"25-JDBC返回自增，批处理","date":"2021-09-13T15:02:32.000Z","updated":"2021-09-15T10:22:44.011Z","comments":true,"path":"api/articles/25-JDBC返回自增，批处理.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"0.0！等待录入！","link":"","photos":[],"count_time":{"symbolsCount":9,"symbolsTime":"1 mins."},"categories":[{"name":"JDBC","slug":"JDBC","count":4,"path":"api/categories/JDBC.json"}],"tags":[{"name":"JDBC","slug":"JDBC","count":4,"path":"api/tags/JDBC.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"JDBC 连接池及项目结构","uid":"bb5bc50a09711181a6e48f61d586b1e3","slug":"23-三层架构、项目结构、连接池","date":"2021-09-13T14:58:32.000Z","updated":"2021-09-15T10:21:18.315Z","comments":true,"path":"api/articles/23-三层架构、项目结构、连接池.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"1、三层架构UI(表现层): 主要是指与用户交互的界面。用于接收用户输入的数据和显示处理后用户需要的数据。 BLL(业务逻辑层): UI层和DAL层之间的桥梁。实现业务逻辑。业务逻辑具体包含：验证、计算、业务规则等等。 DAL(数据访问层): 与数据库打交道。主要实现对数据的增、...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"JDBC","slug":"JDBC","count":4,"path":"api/categories/JDBC.json"}],"tags":[{"name":"JDBC","slug":"JDBC","count":4,"path":"api/tags/JDBC.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}