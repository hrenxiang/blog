{"title":"多线程","uid":"ed728f6a9d3e4347d3410adc7305d745","slug":"15-多线程","date":"2021-09-13T14:50:32.000Z","updated":"2021-09-15T10:16:45.091Z","comments":true,"path":"api/articles/15-多线程.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","content":"<h3 id=\"一、多任务\"><a href=\"#一、多任务\" class=\"headerlink\" title=\"一、多任务\"></a>一、多任务</h3><p>我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？为什么操作系统上可以同时运行多个程序而用户感觉不出来？</p>\n<p>这是因为无论是单CPU还是多CPU，操作系统都营造出了可以同时运行多个程序的<strong>假象</strong>。实际的过程操作系统对进程的调度以及CPU的快速上下文切换实现的：<strong>每个进程执行一会就先停下来，然后CPU切换到下个被操作系统调度到的进程上使之运行</strong>。因为切换的很快，使得用户认为操作系统一直在服务自己的程序。</p>\n<ul>\n<li>并发：多个任务”同时“执行。</li>\n<li>并行：多个任务同时执行。</li>\n</ul>\n<p>它们虽然都说是”多个进程同时运行”，但是它们的”同时”不是一个概念。并行的”同时”是同一时刻可以多个进程在运行，是真实的同时运行；而并发所说的”同时”，是经过CPU上下文快速切换，使得看上去多个进程同时都在运行的现象，是一种OS欺骗用户的现象。</p>\n<p>单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。而在多核 CPU 系统中，则可以将多个任务分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核越多，并行处理的程序越多，能大大的提高电脑运行的效率。</p>\n<p>实际上，当程序中写下多进程或多线程代码实现多任务时，只是告诉操作系统有多个任务需要同时执行。而这多个任务最终是有多个CPU分别并行执行，还是由一个CPU来切换并发执行，都是由操作系统的调度器决定的。也就是说，<strong>并行与否程序员无法控制，只能让操作系统决定</strong>。</p>\n<h3 id=\"二、进程和线程\"><a href=\"#二、进程和线程\" class=\"headerlink\" title=\"二、进程和线程\"></a>二、进程和线程</h3><h4 id=\"1、进程\"><a href=\"#1、进程\" class=\"headerlink\" title=\"1、进程\"></a>1、进程</h4><ul>\n<li>进程是正在运行的程序</li>\n<li>是系统资源分配和调用的单位</li>\n<li>每一个进程都有他的内存空间和资源</li>\n<li>一个应用程序可以有多个进程</li>\n</ul>\n<h4 id=\"2、线程\"><a href=\"#2、线程\" class=\"headerlink\" title=\"2、线程\"></a>2、线程</h4><ul>\n<li><p>线程就是独立的执行路径，一个进程至少有一个线程</p>\n</li>\n<li><p>在程序运行时，即使没有自己创建线程，后台也会有多个线程（例如主线程，gc线程）</p>\n</li>\n<li><p>在一个进程中如果开辟了多个线程，线程的运行由调度器安排调度，调度器与操作系统紧密联系，先后顺序不能人为是干预的</p>\n</li>\n<li><p>对同一份资源操作，会存在资源抢夺的问题，需要加入并发控制</p>\n</li>\n<li><p>线程会带来额外的开销，如cpu调度时间，并发控制开销</p>\n</li>\n<li><p>每个线程都在自己工作内存中交互，内存控制不当会造成数据不一致</p>\n</li>\n</ul>\n<p><strong>注意</strong>：启动一个线程时，其实不止一个线程开启，因为main方法也开启了一个线程</p>\n<p><strong>简而言之</strong>：一个程序运行后至少有一个进程，一个进程中也至少包含一个线程 。</p>\n<h3 id=\"三、线程调度\"><a href=\"#三、线程调度\" class=\"headerlink\" title=\"三、线程调度\"></a>三、线程调度</h3><h4 id=\"1、两种模型\"><a href=\"#1、两种模型\" class=\"headerlink\" title=\"1、两种模型\"></a>1、两种模型</h4><ul>\n<li><p>分时调度模型</p>\n<p>所有线程轮流使用cpu使用权，平均分配每个线程占用cpu的时间片</p>\n</li>\n<li><p>抢占式调度模型</p>\n<p>优先让优先级高的使用cpu，如果线程优先级相同，那么随机选择一个，优先级高的线程获取cpu的时间片相对多一些</p>\n</li>\n</ul>\n<h4 id=\"2、-随机性\"><a href=\"#2、-随机性\" class=\"headerlink\" title=\"2、 随机性\"></a>2、 随机性</h4><p>若 计算机只有一个cpu，那么cpu在某一时刻只能执行一条指令，线程只有抢到cpu时间片，才能执行命令</p>\n<p>所以 多线程执行具有随机性（抢到使用权是随机的）</p>\n<h4 id=\"3、有关线程优先级的方法\"><a href=\"#3、有关线程优先级的方法\" class=\"headerlink\" title=\"3、有关线程优先级的方法\"></a>3、有关线程优先级的方法</h4><p>方法在 Thread类中</p>\n<ul>\n<li><p>public final int getPriority() 返回此线程的优先级</p>\n</li>\n<li><p>public final void setPriority() 更改线程优先级</p>\n</li>\n<li><p>异常<br>IllegalArgumentException - 如果优先级不在 MIN_PRIORITY到 MAX_PRIORITY范围内。<br>SecurityException - 如果当前线程不能修改此线程。</p>\n</li>\n<li><p><strong>优先级的取值范围</strong><br>MIN_PRIORITY：最小值是1     MAX-PRIORITY：最大值是10        NORM_PRIORITY：默认线程是5</p>\n</li>\n<li><p>线程的优先级高，只是获取cpu时间片的几率大，并不是每一次都一定会按照级别顺序获取</p>\n</li>\n</ul>\n<h3 id=\"四、部分问题\"><a href=\"#四、部分问题\" class=\"headerlink\" title=\"四、部分问题\"></a>四、部分问题</h3><ol>\n<li><p>jvm的启动是多线程还是单线程</p>\n<ul>\n<li>多线程的，至少启动两个线程（主线程，垃圾回收线程）</li>\n<li>垃圾回收线程不可能在程序执行完才启动，否则我们的程序很容易 内存溢出</li>\n</ul>\n</li>\n<li><p>调用 start方法后的线程状态</p>\n<ul>\n<li>调用 start方法，线程进入就绪状态，此时线程对象 仅有执行资格，没有执行权</li>\n<li>当就绪的线程抢到 执行权时（进入运行状态），方可调用 run方法，run方法执行完毕后，线程死亡，不能复生</li>\n<li>在没有执行完时，也可以调用stop方法来结束线程，强制死亡</li>\n<li>若在运行时 调用了 sleep / wait 方法，也会进入阻塞状态，此时释放执行资格和执行权。</li>\n<li>等 sleep / wait状态结束时，或者嗲用notifyall方法，该线程被唤醒，又进入就绪状态</li>\n</ul>\n</li>\n<li><p>线程的随机性的原因</p>\n<ul>\n<li>实际上的多线程，是由多核（多个cpu）决定的</li>\n<li>而我们的电脑只有一个cpu（一个时间只能干一件事），同一时刻，cpu只能执行一个程序，多线程的程序其实是由cpu高速切换造成的</li>\n</ul>\n</li>\n<li><p>什么时候使用多线程</p>\n<ul>\n<li><p>多个对象对同一有限资源进行操作时</p>\n</li>\n<li><p>使用多线程是为了 提高解决问题的效率</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"五、线程的使用\"><a href=\"#五、线程的使用\" class=\"headerlink\" title=\"五、线程的使用\"></a>五、线程的使用</h3><p>概述：在Java中我们可以使用，<code>Thread</code>类和<code>Runnable</code>接口来创建一个线程</p>\n<h4 id=\"1、Thread类\"><a href=\"#1、Thread类\" class=\"headerlink\" title=\"1、Thread类\"></a>1、Thread类</h4><p>概述：Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。</p>\n<p>– 通过继承Thread类，开启线程的流程：</p>\n<ol>\n<li>定义Thread类的子类，并重写 <code>run()</code> 方法，该 run() 方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li>\n<li>创建Thread子类的实例，即创建了线程对象。</li>\n<li>调用线程对象的start()方法来启动该线程。</li>\n</ol>\n<p>– Thread类中的构造方法：</p>\n<ul>\n<li><code>public Thread()</code> :分配一个新的线程对象。</li>\n<li><code>public Thread(String name)</code> :分配一个指定名字的新的线程对象。</li>\n<li><code>public Thread(Runnable target)</code> :分配一个带有指定目标新的线程对象。</li>\n<li><code>public Thread(Runnable target,String name)</code> :分配一个带有指定目标新的线程对象并指定名字。</li>\n</ul>\n<p>– 例子，继承Thread类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyThread  extends Thread&#123;\n\n    public MyThread() &#123;\n    &#125;\n\n    &#x2F;&#x2F;定义指定线程名称的构造方法\n    public MyThread(String name) &#123;\n        super(name);&#x2F;&#x2F;引用父类的构造方法\n    &#125;\n\n    @Override\n    public void run() &#123;\n        for (int i &#x3D; 1; i &lt; 21; i++) &#123;\n            System.out.println(getName()+&quot;:&quot;+i);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;创建自定义线程对象\n        MyThread myThread1 &#x3D; new MyThread(&quot;hh&quot;);\n        MyThread myThread2 &#x3D; new MyThread(&quot;gg&quot;);\n        myThread1.start();\n        myThread2.start();\n        &#x2F;&#x2F;结果：交替执行（start方法启动了线程）\n    &#125;\n&#125;</code></pre>\n\n<p>– 常见方法:</p>\n<ul>\n<li>public String getName() :获取当前线程名称。</li>\n<li>public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。</li>\n<li>public void run() :此线程要执行的任务在此处定义代码。</li>\n<li>public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</li>\n<li>public static Thread currentThread() :返回对当前正在执行的线程对象的引用。</li>\n</ul>\n<h4 id=\"2、Runnable接口\"><a href=\"#2、Runnable接口\" class=\"headerlink\" title=\"2、Runnable接口\"></a>2、Runnable接口</h4><p>– 使用步骤:</p>\n<ol>\n<li>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li>\n<li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正 的线程对象。</li>\n<li>调用线程对象的start()方法来启动线程。</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyRunnable implements Runnable&#123;\n    @Override  \n    public void run() &#123;\n        for (int i &#x3D; 0; i &lt; 20; i++) &#123;\n            System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);         \n        &#125;       \n    &#125;    \n&#125;\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;创建自定义类对象  线程任务对象\n        MyRunnable mr &#x3D; new MyRunnable();\n        &#x2F;&#x2F;创建线程对象\n        Thread t &#x3D; new Thread(mr, &quot;小强&quot;);\n        t.start();\n        for (int i &#x3D; 0; i &lt; 20; i++) &#123;\n            System.out.println(&quot;旺财 &quot; + i);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>通过实现Runnable接口，使得该类有了多线程类的特征，run()方法是多线程程序的一个执行目标。所有的多线程代码都在run方法里面，Thread类实际上也是实现了Runnable接口的类。</p>\n<p>在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。</p>\n<p>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。</p>\n<h4 id=\"3、Thread和Runnable的区别\"><a href=\"#3、Thread和Runnable的区别\" class=\"headerlink\" title=\"3、Thread和Runnable的区别\"></a>3、Thread和Runnable的区别</h4><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。 实现Runnable接口比继承Thread类所具有的优势：</p>\n<ol>\n<li>适合多个相同的程序代码的线程去共享同一个资源，把线程和程序代码，数据有限分离，较好地体现了面向对象的思想。</li>\n<li>可以避免java中的单继承的局限性，实现接口，可以允许有其他父类。</li>\n<li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li>\n<li>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。</li>\n<li>在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。</li>\n<li>实现Runnable，不能用 getName直接获取线程名，需要用Thread类中的currentThread获取当前线程，在使用 getName获取线程名</li>\n</ol>\n<h4 id=\"4、start-和run-的区别\"><a href=\"#4、start-和run-的区别\" class=\"headerlink\" title=\"4、start()和run()的区别\"></a>4、start()和run()的区别</h4><ol>\n<li><p>调用start方法开启了线程，而run方法只是普通方法的调用，还是在一条线程中顺序执行</p>\n</li>\n<li><p>start()方法释义：     * 用start方法来启动线程，真正实现了多线程运行，这时无需等待 run()方法体代码执行完毕而直接继续执行下面的代码。</p>\n</li>\n</ol>\n<pre><code> * 通过调用 Thread类的 start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法 run()称为 线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。\n\n * start() 方法执行，将自动调用 run()方法，这是由 jvm内存机制规定的\n</code></pre>\n<ol start=\"3\">\n<li>run() 方法释义：</li>\n</ol>\n<pre><code> * run() 方法只是 Thread类 的一个普通方法，程序中只有主线程这一个线程，其程序路径还是一条，还是要顺序执行，还是要等待\n    run() 方法执行完毕后才能执行其他代码\n\n * 把需要并行的代码放到 run() 方法里，调用 start方法即可启动线程，抢到cpu时间片，就会运行run方法，以及run方法内部的代码\n\n * 为什么 重写 run() 方法？\n    因为 run()方法是用来封装线程执行代码的\n</code></pre>\n<h3 id=\"六、线程控制\"><a href=\"#六、线程控制\" class=\"headerlink\" title=\"六、线程控制\"></a>六、线程控制</h3><h4 id=\"1、线程休眠\"><a href=\"#1、线程休眠\" class=\"headerlink\" title=\"1、线程休眠\"></a>1、线程休眠</h4><ul>\n<li><p>static void sleep(long millis)  是当前正在执行的线程停留(暂停执行) 指定的<code>毫秒数</code></p>\n</li>\n<li><p>sleep时间到达后，线程再次进入就绪状态</p>\n</li>\n<li><p>每一个对象都有一个锁，sleep不会释放锁</p>\n</li>\n<li><p>sleep可以模拟网络延迟，计时器等</p>\n</li>\n<li><p>InterruptedException：如果任何线程中断了当前线程，当抛出此异常，抛出后，中断异常的状态被清除</p>\n</li>\n</ul>\n<h4 id=\"2、线程礼让\"><a href=\"#2、线程礼让\" class=\"headerlink\" title=\"2、线程礼让\"></a>2、线程礼让</h4><ul>\n<li><p><code>static void yield()</code>：使当前正在执行的线程向另外一个线程<strong>交出运行权</strong>，静态方法。</p>\n</li>\n<li><p>礼让线程，使当前正在执行的线程暂停，但不阻塞，从运行状态变为就绪状态，使cpu重新调度</p>\n</li>\n<li><p>但是 调度不一定成功，要看 cpu心情。</p>\n</li>\n</ul>\n<h4 id=\"3、线程强制执行\"><a href=\"#3、线程强制执行\" class=\"headerlink\" title=\"3、线程强制执行\"></a>3、线程强制执行</h4><ul>\n<li><p><code>void join()</code>：等待线程死亡（待此线程执行完成，在执行其他线程，其他线程阻塞）</p>\n</li>\n<li><p>join 合并线程，可以想象成 插队</p>\n</li>\n</ul>\n<h4 id=\"4、守护线程\"><a href=\"#4、守护线程\" class=\"headerlink\" title=\"4、守护线程\"></a>4、守护线程</h4><ul>\n<li><p><code>void setDaemon(Boolean isDaemon)</code>：标识该线程为守护线程或用户线程，这一方法在线程启动前调用</p>\n<p>true为Daemon模式，false为User模式。</p>\n<p>注意：守护线程必须在start之前设置，否则会报错。</p>\n</li>\n<li><p>线程分为 用户线程和守护线程，守护线程也被称为 — “服务线程”</p>\n</li>\n<li><p>用户线程：Java虚拟机在它所有非守护线程已经离开后自动离开。</p>\n</li>\n<li><p>守护线程：守护线程用来服务用户线程，如果没有用户线程在运行，那就没有可服务对象，也就没有理由继续执行下去。</p>\n</li>\n<li><p>当只剩下守护线程时，虚拟机就会退出（没有可服务对象，没必要继续执行）</p>\n</li>\n<li><p>如果在守护线程中产生了新的线程，那么将不用设置Daemon属性，他们都是守护线程，用户线程同样</p>\n</li>\n</ul>\n<h4 id=\"5、停止线程\"><a href=\"#5、停止线程\" class=\"headerlink\" title=\"5、停止线程\"></a>5、停止线程</h4><ul>\n<li>不推荐使用，JDK 中的stop()、destroy()方法【已经废弃】</li>\n<li>推荐线程自己停下来</li>\n<li>建议使用一个标志位进行终止变量<br>当flag=false，则终止线程运行</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class stopThread implements Runnable &#123;\n\n    private boolean flag &#x3D; true;\n\n    @Override\n    public void run() &#123;\n        while (flag)&#123;\n            System.out.println(Thread.currentThread().getName());\n        &#125;\n    &#125;\n\n\tpublic void stop()&#123;\n   \t\t this.flag&#x3D;false;\n\t&#125;\n&#125;</code></pre>\n\n<h3 id=\"七、线程生命周期\"><a href=\"#七、线程生命周期\" class=\"headerlink\" title=\"七、线程生命周期\"></a>七、线程生命周期</h3><p><img src=\"https://gitee.com/xiuxiuai/picture/raw/master/img/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png\" alt=\"线程生命周期\"></p>\n<h3 id=\"八、线程安全\"><a href=\"#八、线程安全\" class=\"headerlink\" title=\"八、线程安全\"></a>八、线程安全</h3><h4 id=\"1、卖票案例代码\"><a href=\"#1、卖票案例代码\" class=\"headerlink\" title=\"1、卖票案例代码\"></a>1、卖票案例代码</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class sellTickets implements Runnable &#123;\n\n    private int tickets &#x3D; 100;\n    \n    @Override\n    public void run() &#123;\n\n        while (true) &#123;\n            if (tickets &gt; 0) &#123;\n                try &#123;\n                    Thread.sleep(100);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                System.out.println(Thread.currentThread().getName() + &quot;:&quot; + tickets + &quot;张票&quot;);\n                tickets --;\n            &#125;\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n\n        sellTickets st &#x3D; new sellTickets();\n\n        Thread t1&#x3D;new Thread(st,&quot;窗口1&quot;);\n        Thread t2&#x3D;new Thread(st,&quot;窗口2&quot;);\n        Thread t3&#x3D;new Thread(st,&quot;窗口3&quot;);\n\n        t1.start();\n        t2.start();\n        t3.start();\n\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"2、出现问题\"><a href=\"#2、出现问题\" class=\"headerlink\" title=\"2、出现问题\"></a>2、出现问题</h4><ul>\n<li><p>出售一张票时，虽然出票时间短暂，但是存在问题</p>\n</li>\n<li><p>相同的票出现了多次（结果中，一号窗口买了第100号票，二号窗口也卖出了第100号）</p>\n</li>\n<li><p>会出现 负数的票（加上 票号判断，tickets &gt; 0后，问题解决）</p>\n</li>\n</ul>\n<h4 id=\"3、问题原因\"><a href=\"#3、问题原因\" class=\"headerlink\" title=\"3、问题原因\"></a>3、问题原因</h4><ul>\n<li>线程的随机性</li>\n<li>线程访问的延迟</li>\n</ul>\n<h4 id=\"4、线程安全问题的表现\"><a href=\"#4、线程安全问题的表现\" class=\"headerlink\" title=\"4、线程安全问题的表现\"></a>4、线程安全问题的表现</h4><ul>\n<li>当一个线程对象在执行run()方法的某一操作时，其他线程也进来了，并发访问了临界资源，破坏了原子操作，造成数据不一致</li>\n<li>这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。</li>\n<li>线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若<u>有多个线程同时执行写操作，一般都需要考虑<code>线程同步</code></u>， 否则的话就可能影响线程安全。</li>\n</ul>\n<h4 id=\"5、数据安全问题\"><a href=\"#5、数据安全问题\" class=\"headerlink\" title=\"5、数据安全问题\"></a>5、数据安全问题</h4><ul>\n<li>判断多线程程序是否有 数据安全问题的标准<br>1、是否为多线程环境<br>2、是否有共享数据<br>3、是否有多条语句操作共享数据</li>\n<li>如何解决多线程安全问题把多条语句曹作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可（同步代码块/同步方法）具体就是给哪个原子操作加锁，使整个操作同步，不让其他线程对象破坏，保证数据的一致性</li>\n</ul>\n<h3 id=\"九、线程同步\"><a href=\"#九、线程同步\" class=\"headerlink\" title=\"九、线程同步\"></a>九、线程同步</h3><p>–  概述：为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。 那么怎么去使用呢？有三种方式完成同步操作：</p>\n<ol>\n<li>同步代码块。</li>\n<li>同步方法。</li>\n<li>锁机制</li>\n</ol>\n<p>– 同步的前提</p>\n<ul>\n<li><p>至少要有两个线程</p>\n</li>\n<li><p>同一个锁</p>\n</li>\n</ul>\n<p>– 同步的好处</p>\n<ul>\n<li>提高了安全性，解决了多线程数据安全问题</li>\n</ul>\n<p>– 同步的弊端</p>\n<ul>\n<li>效率较低，当线程很多时，每个线程都会去判断同步上的锁，十分耗费资源，无形中降低运行效率</li>\n</ul>\n<h4 id=\"1、同步代码块\"><a href=\"#1、同步代码块\" class=\"headerlink\" title=\"1、同步代码块\"></a>1、同步代码块</h4><p>– 概述：同步代码块： synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。 格式:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">synchronized(同步锁)&#123;\n     需要同步操作的代码\n&#125;</code></pre>\n\n<ol>\n<li>任意对象称之为同步监视器，推荐使用共享资源作为同步监视器</li>\n<li>非静态方法内的同步代码块，使用this对象锁</li>\n<li>静态方法内的同步底阿妈快，锁用 类名.class</li>\n</ol>\n<p>同步监视器执行过程：</p>\n<ul>\n<li><p>第一个线程访问，锁定同步监视器，自行其中代码</p>\n</li>\n<li><p>第二个线程访问，发现同步监视器被锁定，无法访问</p>\n</li>\n<li><p>第一个线程访问完毕，解锁同步监视器</p>\n</li>\n<li><p>第二个线程访问，发现同步监视器没有锁，然后锁定并访问</p>\n</li>\n</ul>\n<p>– 同步锁:</p>\n<ol>\n<li>对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁。</li>\n<li>锁对象可以是任意类型，多个线程对象要使用同一把锁。 </li>\n<li>注意：在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。 使用同步代码块解决代码：</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Ticket implements Runnable &#123;\n    private int ticket &#x3D; 100;\n\n    @Override\n    public void run() &#123;\n        while (ticket &gt; 0) &#123;\n            System.out.println(Thread.currentThread().getName() + &quot;开始售票&quot;);\n            try &#123;\n                Thread.sleep(100);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n            synchronized (this) &#123;\n                if (ticket &gt; 0) ticket--;\n                System.out.println(Thread.currentThread().getName() + &quot;售票完成,还剩&quot; + ticket + &quot;张票&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"2、同步方法\"><a href=\"#2、同步方法\" class=\"headerlink\" title=\"2、同步方法\"></a>2、同步方法</h4><p>– 概述：同步方法就是使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。</p>\n<p>– 格式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public synchronized void method()&#123;\n    可能会产生线程安全问题的代码\n&#125;</code></pre>\n\n<p>– 同步方法使用的锁</p>\n<ul>\n<li>同步方法使用的是 this对象锁，静态同步方法的锁是(类名.class)</li>\n<li>同步方法使用 双重判断完成，效率低，多宜采用同步代码块完成单例的延迟加载</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class Ticket implements Runnable&#123;\n    private int ticket &#x3D; 100;   \n    &#x2F;*\n     * 执行卖票操作   \n     *&#x2F;  \n    @Override \n    public void run() &#123;        \n    &#x2F;&#x2F;每个窗口卖票的操作             \n    &#x2F;&#x2F;窗口 永远开启             \n        while(ticket &gt; 0)&#123;        \n            sellTicket();            \n        &#125;        \n    &#125;\n\n        &#x2F;*   \n         * 锁对象 是 谁调用这个方法 就是谁     \n         *   隐含 锁对象 就是  this    \n         *            \n         *&#x2F;\n\n    public synchronized void sellTicket()&#123;\n        if(ticket&gt;0)&#123;&#x2F;&#x2F;有票 可以卖   \n          &#x2F;&#x2F;出票操作\n          &#x2F;&#x2F;使用sleep模拟一下出票时间 \n            try &#123;              \n                Thread.sleep(100);\n            &#125; catch (InterruptedException e) &#123;\n                  e.printStackTrace();\n            &#125;\n        &#125;\n            &#x2F;&#x2F;获取当前线程对象的名字 \n        String name &#x3D; Thread.currentThread().getName();\n        System.out.println(name+&quot;正在卖:&quot;+ticket‐‐);\n   &#125;\n&#125;</code></pre>\n\n<h4 id=\"3、代码块与方法的比较\"><a href=\"#3、代码块与方法的比较\" class=\"headerlink\" title=\"3、代码块与方法的比较\"></a>3、代码块与方法的比较</h4><p>synchronized<code>代码块 要比 synchronized方法灵活</code>，因为一个方法中可能只有一部分代码需要同步，如果同步整个方法会影响执行效率，而是用代码块就避免了这个问题</p>\n<h4 id=\"4、Lock锁\"><a href=\"#4、Lock锁\" class=\"headerlink\" title=\"4、Lock锁\"></a>4、Lock锁</h4><p>– 概述：<code>java.util.concurrent.locks.Lock</code> 机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作。同步代码块/同步方法具有的功能Lock都有，除此之外更强大，更体现面向对象。《<code>Lock</code>锁目前只做了解，详细使用在后续的<code>JUC</code>课程里会介绍》</p>\n<p>– Lock锁也称同步锁，加锁与释放锁方法，如下：</p>\n<ul>\n<li>public void lock() :加同步锁。</li>\n<li>public void unlock() :释放同步锁。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Ticket implements Runnable&#123;\n    private int ticket &#x3D; 100;    \n    Lock lock &#x3D; new ReentrantLock();   \n    @Override        \n    public void run() &#123;        \n        &#x2F;&#x2F;每个窗口卖票的操作             \n        &#x2F;&#x2F;窗口 永远开启             \n        while(ticket &gt; 0)&#123;        \n            lock.lock();                \n            if(ticket&gt;0)&#123;&#x2F;&#x2F;有票 可以卖            \n                &#x2F;&#x2F;出票操作                 \n                &#x2F;&#x2F;使用sleep模拟一下出票时间                 \n                try &#123;                \n                    Thread.sleep(50);                    \n                &#125; catch (InterruptedException e) &#123;                \n                &#x2F;&#x2F; TODO Auto‐generated catch block                    \n                    e.printStackTrace();                    \n                &#125;                \n                &#x2F;&#x2F;获取当前线程对象的名字                 \n                String name &#x3D; Thread.currentThread().getName();               \n                System.out.println(name+&quot;正在卖:&quot;+ticket‐‐);                    \n            &#125;            \n            lock.unlock();            \n        &#125;        \n    &#125;    \n&#125;</code></pre>\n\n<h3 id=\"十、死锁\"><a href=\"#十、死锁\" class=\"headerlink\" title=\"十、死锁\"></a>十、死锁</h3><h4 id=\"1、概念\"><a href=\"#1、概念\" class=\"headerlink\" title=\"1、概念\"></a>1、概念</h4><ul>\n<li>每个线程都不会释放自己拥有的锁的标记，却阻塞在另外的线程所拥有的的锁标记的对象锁池中，就造成了死锁现象</li>\n</ul>\n<h4 id=\"2、产生原因\"><a href=\"#2、产生原因\" class=\"headerlink\" title=\"2、产生原因\"></a>2、产生原因</h4><ul>\n<li><p>一个进程因请求资源而阻塞时，对已获得的资源保持不放</p>\n</li>\n<li><p>例如：a锁中要使用b锁，在b锁中要使用a锁，而他们都不想让，最终导致了死锁</p>\n</li>\n<li><p>系统资源不足，进程的运行顺序不合适，资源分配不当</p>\n</li>\n</ul>\n<h4 id=\"3、产生死锁的四个必要条件\"><a href=\"#3、产生死锁的四个必要条件\" class=\"headerlink\" title=\"3、产生死锁的四个必要条件\"></a>3、产生死锁的四个必要条件</h4><ul>\n<li>互斥条件: 一个资源每次只能被一个线程使用</li>\n<li>请求保持条件: 一个进程因请求资源而阻塞时.对以获得的资源保持不放</li>\n<li>不剥夺条件: 线程已获得的资源,在未使用完之前,不能强行剥夺</li>\n<li>循环等待条件: 若干线程之间形成一种头尾相接的循环等待资源关系（1等2的资源，2等1的资源）</li>\n</ul>\n<p><strong>注意</strong>：如果所有线程以固定顺序来获得锁，那么在程序中就不会出现 锁顺序 死锁问题。</p>\n<h4 id=\"4、破坏死锁发生的条件\"><a href=\"#4、破坏死锁发生的条件\" class=\"headerlink\" title=\"4、破坏死锁发生的条件\"></a>4、破坏死锁发生的条件</h4><ul>\n<li>一次性申请所有资源</li>\n<li>申请资源而得不到时，主动释放占有的资源</li>\n<li>靠按申请顺序预防，先申请资源序号小的，在申请大的，线性申请</li>\n</ul>\n<h3 id=\"十一、线程状态\"><a href=\"#十一、线程状态\" class=\"headerlink\" title=\"十一、线程状态\"></a>十一、线程状态</h3><ol>\n<li>Timed Waiting（计时等待）</li>\n<li>BLOCKED(阻塞)</li>\n<li>Waiting（无限等待）</li>\n<li>其他状态</li>\n</ol>\n<h3 id=\"十二、等待唤醒机制\"><a href=\"#十二、等待唤醒机制\" class=\"headerlink\" title=\"十二、等待唤醒机制\"></a>十二、等待唤醒机制</h3><h4 id=\"1、概念-1\"><a href=\"#1、概念-1\" class=\"headerlink\" title=\"1、概念\"></a>1、概念</h4><p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。</p>\n<p>就是在一个线程进行了规定操作后，就进入等待状态（**wait()<strong>）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（</strong>notify()**）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。</p>\n<p>wait/notify 就是线程间的一种协作机制。</p>\n<h4 id=\"2、等待唤醒中的方法\"><a href=\"#2、等待唤醒中的方法\" class=\"headerlink\" title=\"2、等待唤醒中的方法\"></a>2、等待唤醒中的方法</h4><ol>\n<li>wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是“<strong>通知（notify）</strong>”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中</li>\n<li>notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。</li>\n<li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li>\n</ol>\n<p>总结如下：</p>\n<ul>\n<li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；</li>\n<li>否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态</li>\n</ul>\n<h4 id=\"3、wait和notify方法要注意的\"><a href=\"#3、wait和notify方法要注意的\" class=\"headerlink\" title=\"3、wait和notify方法要注意的\"></a>3、wait和notify方法要注意的</h4><ol>\n<li>wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li>\n<li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li>\n<li>wait方法与notify方法必须要在同步代码块或者是同步方法中使用。因为：必须要通过锁对象调用这2个方法。</li>\n</ol>\n<h4 id=\"4、其它问题\"><a href=\"#4、其它问题\" class=\"headerlink\" title=\"4、其它问题\"></a>4、其它问题</h4><ol>\n<li>为什么wait()，notify()，notifyAll()都定义在Object 类中？<br>A：这些方法存在于同步中。<br>B：使用这些方法时必须要标识所属的同步的锁。<br>C：锁可以是任意对象，所以任意对象调用的方法一定定义 Object 类中。<br>D：wait() 让线程等待 notify() 唤醒线程 notifyAll() 唤醒线程池中的所有线程 。 这些方法需要在同步方法内（锁内，需要锁对象）使用。</li>\n<li>wait() 和 sleep()的区别<br>A：对时间指定而言<br>   wait()：可以不指定时间。<br>   sleep()：必须指定时间。<br>B：对执行权和锁而言<br>   wait()：释放 cpu 执行权(资格也没了)，释放锁。存储于线程池<br>   sleep()：释放 cpu 执行权，不释放锁(会自动醒)。</li>\n</ol>\n<h3 id=\"十三、Lock-amp-Condition接口（了解）\"><a href=\"#十三、Lock-amp-Condition接口（了解）\" class=\"headerlink\" title=\"十三、Lock&amp;Condition接口（了解）\"></a>十三、Lock&amp;Condition接口（了解）</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">1. 概念\n   * JDK1.5 以后将同步和锁封装成了对象。并将操作锁的隐式方式定义到了对象中，将隐式动作编程了显示动作。对多线程中的内部细节进行了升级改良。\n   * 它的出现替代了同步代码块或者同步函数。将同步的隐式锁操作编程了显示锁操作。同时更为灵活。可以一个锁上加上多组监视器。</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">2. Lock接口\n\n   * 提供了获得锁 释放锁的方法\n     1 void lock()：获得锁\n     2 void unlock()：释放锁【注意：通常需要定义在finally代码块中】\n     \n   * lock锁不能直接实例化，这里采用他的实现类 ReentrantLock来实现\n     构造方法 ReentrantLock()。\n     \n   * java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。\n     锁提供了对共享资源的独占访问,每次只能有一个线程对Lock对象加锁,线程开始访问共享资源之前应先获得Lock对象</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">3. Lock与synchronized对比\n\n   * Lock是显示锁(手动开启和关闭,别忘记关闭锁)\n     synchronized是隐式锁,出了作用域自动释放\n     \n   * Lock只有代码块锁,synchronized有代码块锁和方法锁\n   \n   * 使用lock锁,JVM将花费较少的时间来调度线程,性能更好,并且具有更好的扩展性(提供更多的子类)\n   \n   * 优先使用顺序：Lock &gt; 同步代码块 &gt; 同步方法</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">4. Condition \n\n   * Lock 接口替代了 synchronized \n   \n     Condition 替代了 Object 类中监视器方法 wait，notify，notifyAll。\n     \n   * JDK1.5后 将监视器方法单独封装成了 Condition 对象。而且一个锁上可以组合多组监视器对象\n   \n     实现了多生产者多消费者时，本方只唤醒对方中一个的操作，提高效率。\n     \n   * await()睡眠; signal(), signalAll()唤醒;将这些监视器方法单独进行封装，变成了Condition 监视器对象。\n     可以任意锁进行组合。使用为一般是生产者是被消费者唤醒，消费者是被生产者唤醒。</code></pre>\n\n\n\n<h3 id=\"十四、生产者消费者问题\"><a href=\"#十四、生产者消费者问题\" class=\"headerlink\" title=\"十四、生产者消费者问题\"></a>十四、生产者消费者问题</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">假设仓库中只能存放一件产品,生产者将生产出来的产品放入仓库,消费者将仓库产品取走消费\n如果仓库中没有产品,则生产者将产品放入仓库,否则停止生产并等待,直到仓库中的产品被消费者取走为止\n如果仓库中放有产品,则消费者可以将产品取走消费,否则停止消费并等待,直到仓库中再次放入产品为止\n这是一个线程同步问题,生产者和消费者共享一个资源,并且生产者和消费者之间相互依赖,互为条件\n\n对于生产者,没有生产产品之前,要通知消费者等待,而生产了产品之后,又要马上通知消费者消费\n对于消费者,在消费之后,要通知生产者已经结束消费,需要生产新的产品以供消费\n在生产者消费者问题上,仅有synchronized是不够的\nsynchronized可阻止并发更新同一个共享资源,实现了同步\nsynchronized不能用来实现不同线程之间消息传递(通信)</code></pre>\n\n\n\n<h3 id=\"十五、常用方法总结\"><a href=\"#十五、常用方法总结\" class=\"headerlink\" title=\"十五、常用方法总结\"></a>十五、常用方法总结</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">1. 停止线程 \n    A：通过控制循环 \n    B：interrupt()方法 stop 已过时，被 interrupt 取代\n\n2. 守护线程 后台线程 \n   你只要把一个线程设置为守护线程，那么主方法线程结束，不管什么情况，守护线程就结束.\n   举例：坦克大战 A：setDaemon(boolean flag)\n   \n3. join：加入线程,把执行权抢夺,自己执行完毕,其他的线程才可能有机会执行.\n\n4. yield()：让本线程暂停执行,把执行权给其他线程. \n\n5. setPriority(int num)：设置线程优先级 \n   getPrinrity()：获取线程优先级 线程的级别:1 - 10  默认级别为 5.</code></pre>\n\n","text":"一、多任务我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？为什么操作系统上可以同时运行多个程序而用户感觉不出来？ 这是因为无论是单CPU还是多CPU，操作系统都营造出了可以同时运行多个程序的假象。实际的过程操作...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/tags/JavaSE.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%A4%9A%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">一、多任务</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">二、进程和线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E8%BF%9B%E7%A8%8B\"><span class=\"toc-text\">1、进程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">2、线程</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">三、线程调度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">1、两种模型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81-%E9%9A%8F%E6%9C%BA%E6%80%A7\"><span class=\"toc-text\">2、 随机性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%9C%89%E5%85%B3%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">3、有关线程优先级的方法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E9%83%A8%E5%88%86%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">四、部分问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">五、线程的使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81Thread%E7%B1%BB\"><span class=\"toc-text\">1、Thread类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81Runnable%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">2、Runnable接口</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81Thread%E5%92%8CRunnable%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">3、Thread和Runnable的区别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81start-%E5%92%8Crun-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4、start()和run()的区别</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">六、线程控制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0\"><span class=\"toc-text\">1、线程休眠</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E7%BA%BF%E7%A8%8B%E7%A4%BC%E8%AE%A9\"><span class=\"toc-text\">2、线程礼让</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E7%BA%BF%E7%A8%8B%E5%BC%BA%E5%88%B6%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">3、线程强制执行</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">4、守护线程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%E3%80%81%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">5、停止线程</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%83%E3%80%81%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">七、线程生命周期</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AB%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">八、线程安全</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%8D%96%E7%A5%A8%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">1、卖票案例代码</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">2、出现问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">3、问题原因</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E8%A1%A8%E7%8E%B0\"><span class=\"toc-text\">4、线程安全问题的表现</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%E3%80%81%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">5、数据安全问题</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B9%9D%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">九、线程同步</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97\"><span class=\"toc-text\">1、同步代码块</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2、同步方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">3、代码块与方法的比较</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81Lock%E9%94%81\"><span class=\"toc-text\">4、Lock锁</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%81%E3%80%81%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">十、死锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1、概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">2、产生原因</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">3、产生死锁的四个必要条件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E7%A0%B4%E5%9D%8F%E6%AD%BB%E9%94%81%E5%8F%91%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">4、破坏死锁发生的条件</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%B8%80%E3%80%81%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">十一、线程状态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%BA%8C%E3%80%81%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">十二、等待唤醒机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%A6%82%E5%BF%B5-1\"><span class=\"toc-text\">1、概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2、等待唤醒中的方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81wait%E5%92%8Cnotify%E6%96%B9%E6%B3%95%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84\"><span class=\"toc-text\">3、wait和notify方法要注意的</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E5%85%B6%E5%AE%83%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">4、其它问题</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%B8%89%E3%80%81Lock-amp-Condition%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89\"><span class=\"toc-text\">十三、Lock&amp;Condition接口（了解）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%81%E5%9B%9B%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">十四、生产者消费者问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%BA%94%E3%80%81%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">十五、常用方法总结</span></a></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"网络编程","uid":"b85a5ed5aa29024c7191b1325f9b4bb8","slug":"16-网络编程","date":"2021-09-13T14:51:32.000Z","updated":"2021-09-15T10:16:58.700Z","comments":true,"path":"api/articles/16-网络编程.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"一、实现通信需解决的两个问题 1.如何准确地定位网络上一台或多台主机；定位主机上的特定的应用 2.找到主机后如何可靠高效地进行数据传输 二、网络通信的两个要素 对应问题一：IP和端口号 对应问题二：提供网络通信协议：TCP/IP参考模型（应用层、传输层、网络层、物理+数据链路层）...","link":"","photos":[],"count_time":{"symbolsCount":"8.5k","symbolsTime":"8 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/tags/JavaSE.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"IO流（下）","uid":"76d4babd3007758066655a1fc80352b9","slug":"14-IO流（下）","date":"2021-09-13T14:49:32.000Z","updated":"2021-09-15T10:16:21.465Z","comments":true,"path":"api/articles/14-IO流（下）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog12.jpg","text":"一、字符流当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。 字符流与字节流的区别：字符流虽然以字节流为基础创建的，但是字...","link":"","photos":[],"count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/tags/JavaSE.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}