{"title":"面向对象（下）","uid":"5a1c4f03caf8f9ffac125f63d3a94727","slug":"06-面向对象（下）","date":"2021-09-13T14:38:32.000Z","updated":"2021-09-14T15:53:58.076Z","comments":true,"path":"api/articles/06-面向对象（下）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog6.jpg","content":"<h3 id=\"一、内部类\"><a href=\"#一、内部类\" class=\"headerlink\" title=\"一、内部类\"></a>一、内部类</h3><h4 id=\"1-成员内部类\"><a href=\"#1-成员内部类\" class=\"headerlink\" title=\"1.成员内部类\"></a>1.成员内部类</h4><h5 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1  概念\"></a>1.1  概念</h5><p>在成员位置定义的类（定义在另一个类的内部，最普通的内部类），称之为成员内部类</p>\n<h5 id=\"1-2-成员内部类特点\"><a href=\"#1-2-成员内部类特点\" class=\"headerlink\" title=\"1.2  成员内部类特点:\"></a>1.2  成员内部类特点:</h5><ol>\n<li>不能使用 <code>static</code>关键字，但是可以使用<code>static final</code>关键字定义常量。</li>\n<li>成员内部类 可以无条件的访问外部类的 成员属性 和 成员方法 （包括private成员）</li>\n<li>注意：当成员内部类拥有和外部类同名的成员变量或方法时，默认访问的是 <strong>成员内部类</strong> 的</li>\n<li>如过要访问外部类 同名成员，可以下述方式访问：      <ul>\n<li>外部类.this.外部成员变量</li>\n<li>外部类.this.外部成员方法</li>\n</ul>\n</li>\n<li>可以使用<code>final</code>修饰内部类，表示不能被继承。</li>\n<li>编译以后也会有自己独立的字节码文件，只不过文件名是<code>Outer$Inner.class</code></li>\n<li>外部函数的<code>static</code>成员里，不允许访问成员内部类。</li>\n<li>由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰</li>\n</ol>\n<h5 id=\"1-3-创建成员内部类的对象\"><a href=\"#1-3-创建成员内部类的对象\" class=\"headerlink\" title=\"1.3  创建成员内部类的对象\"></a>1.3  创建成员内部类的对象</h5><p>前提是存在外部类的对象，然后通过外部类对象创建内部类对象</p>\n<ul>\n<li><p>第一种（Outter外，Inner内部类 类举例）</p>\n<p>Outter outter = new Outter;</p>\n<p>Outter.Inner inner = outter.new Inner();</p>\n</li>\n<li><p>第二种，在内部类中给出 获取内部类实例化的方法（getInnerInstance(){return new Inner();}）</p>\n</li>\n</ul>\n<h4 id=\"2-局部内部类\"><a href=\"#2-局部内部类\" class=\"headerlink\" title=\"2.局部内部类\"></a>2.局部内部类</h4><h5 id=\"2-1-概述\"><a href=\"#2-1-概述\" class=\"headerlink\" title=\"2.1  概述\"></a>2.1  概述</h5><p>局部内部类是定义在一个方法或者一个作用域里面的类，他和成员内部类的区别在于 </p>\n<p>局部内部类的访问 仅限于 方法内 或者 该作用域内。</p>\n<h5 id=\"2-2-语法格式\"><a href=\"#2-2-语法格式\" class=\"headerlink\" title=\"2.2  语法格式\"></a>2.2  语法格式</h5><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">[修饰符] class 外部类&#123;\n    [修饰符] 返回值类型  方法名([形参列表])&#123;\n            [final&#x2F;abstract] class 内部类&#123;\n        &#125;\n    &#125;    \n&#125;</code></pre>\n\n<h5 id=\"2-3-局部内部类特点\"><a href=\"#2-3-局部内部类特点\" class=\"headerlink\" title=\"2.3  局部内部类特点\"></a>2.3  局部内部类特点</h5><ol>\n<li>局部内部类 可随意访问 外部类的成员变量和方法，即使是私有的；</li>\n<li> 局部内部类像是方法里面的一个局部变量，前面<strong>不能有权限修饰符</strong>！</li>\n<li>在外部类中不能创建内部类的实例；<ul>\n<li>创建内部类的实例<strong>只能在包含他的方法中</strong>；</li>\n</ul>\n</li>\n<li>局部内部类里不能使用static声明变量！</li>\n<li>局部内部类中能访问外部类的静态成员。</li>\n<li>如果这个局部内部类所在的方法是静态方法，它无法访问访问外部类的非静态成员。</li>\n<li>内部类和外部类有同名变量和方法时，需要通过Outer.this方式来访问外部类成员变量或方法</li>\n<li>局部内部类<strong>可以访问外部函数的局部变量</strong>，但是这个局部变量<strong>必须要被final修饰</strong>。JDK8以后，如果局部变量被局部内部类使用了，会自动在前面加final.</li>\n</ol>\n<h5 id=\"2-4-为什么要加final\"><a href=\"#2-4-为什么要加final\" class=\"headerlink\" title=\"2.4  为什么要加final\"></a>2.4  为什么要加final</h5><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestInner&#123;\n    public static void main(String[] args) &#123;\n        A obj &#x3D; Outer.method();\n        &#x2F;&#x2F;因为如果c不是final的，那么method方法执行完，method的栈空间就释放了，那么c也就消失了\n        obj.a();&#x2F;&#x2F;这里打印c就没有中可取了，所以把c声明为常量，存储在方法区中\n    &#125;\n&#125;\n\ninterface A&#123;\n    void a();\n&#125;\nclass Outer&#123;\n    public static A method()&#123;\n        final int c &#x3D; 3;\n        class Sub implements A&#123;\n            @Override\n            public void a() &#123;\n                System.out.println(&quot;method.c &#x3D; &quot; + c);\n            &#125;\n        &#125;\n        return new Sub();\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"3-匿名内部类\"><a href=\"#3-匿名内部类\" class=\"headerlink\" title=\"3.匿名内部类\"></a>3.匿名内部类</h4><h5 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1.  概念\"></a>1.  概念</h5><p>匿名内部类就是 局部内部类的简化写法</p>\n<h5 id=\"2-格式\"><a href=\"#2-格式\" class=\"headerlink\" title=\"2.  格式\"></a>2.  格式</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">new 类名或接口名()&#123;\n\t重写方法\n&#125;;</code></pre>\n\n<h5 id=\"3-注意\"><a href=\"#3-注意\" class=\"headerlink\" title=\"3.  注意\"></a>3.  注意</h5><ul>\n<li><p>根据格式看，所谓的匿名内部类，就是 <strong>实现了父类 或者 实现了父接口 的 子类匿名对象</strong></p>\n</li>\n<li><p>在匿名内部类中的this，代表的是 该匿名内部类 这个对象</p>\n</li>\n<li><p>一个匿名内部类 最好对应一种 抽象方法的实现，可以使功能更加单一化，修改时不易出错</p>\n</li>\n<li><p>匿名内部类没有类名，所以匿名内部类是唯一一种<strong>没有构造器</strong>的类，所以适用范围十分有限，大部分用于<strong>接口回调</strong></p>\n<p>匿名内部类在编译的时候由系统自动起名为 Outter$1.class</p>\n</li>\n<li><p>一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写</p>\n</li>\n</ul>\n<h4 id=\"4-静态内部类\"><a href=\"#4-静态内部类\" class=\"headerlink\" title=\"4.静态内部类\"></a>4.静态内部类</h4><h5 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1.  定义\"></a>1.  定义</h5><p>静态内部类也是定义在 另一个类里面的类，只不过前面多了一个关键字 static</p>\n<p>静态内部类是不需要依赖于 外部类的，与类的静态成员有点类似，不能使用外部类的非静态成员方法</p>\n<p>在没有外部类的对象情况下，可以创建静态内部类的对象，外部类的费static成员必须依附于具体的对象</p>\n<h5 id=\"2-静态内部类特点\"><a href=\"#2-静态内部类特点\" class=\"headerlink\" title=\"2.  静态内部类特点:\"></a>2.  静态内部类特点:</h5><ul>\n<li>使用<code>static</code>关键字修饰。</li>\n<li>在静态内部类里，可以使用<code>static</code>关键字定义静态成员。</li>\n<li><strong>只能访问外部的静态成员</strong>，不能访问外部的非静态成员。</li>\n<li>外部类可以直接通过<code>静态内部类名.静态成员名</code>访问静态内部类的静态成员。</li>\n</ul>\n<h3 id=\"二、代码块\"><a href=\"#二、代码块\" class=\"headerlink\" title=\"二、代码块\"></a>二、代码块</h3><h4 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1.概述\"></a>1.概述</h4><ol>\n<li>普通代码块：就是类里方法体代码。</li>\n<li>构造代码块：类里直接使用 { } 编写的代码。</li>\n<li>静态代码块：在构造代码块前添加<code>static</code>关键字。</li>\n<li>同步代码块：使用<code>synchronize</code>关键字包裹起来的代码块，用于多线程。</li>\n</ol>\n<h4 id=\"2-静态代码块\"><a href=\"#2-静态代码块\" class=\"headerlink\" title=\"2.静态代码块\"></a>2.静态代码块</h4><h5 id=\"2-1-语法结构\"><a href=\"#2-1-语法结构\" class=\"headerlink\" title=\"2.1 语法结构\"></a>2.1 语法结构</h5><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">【修饰符】 class 类名&#123;\n    static&#123;\n        静态代码块语句;\n    &#125;\n&#125;</code></pre>\n\n<h5 id=\"2-2-特点\"><a href=\"#2-2-特点\" class=\"headerlink\" title=\"2.2 特点\"></a>2.2 特点</h5><ol>\n<li>使用<code>static</code>关键字修饰，写在类里，方法外，用来对类进行初始化。</li>\n<li>一个类里可以有多个静态代码块，但是通常情况下只会定义一个。</li>\n<li><strong>随着类加载而执行，只执行一次</strong>，只要类加载就会执行，所以执行的优先级很高。</li>\n<li>一般情况下,如果有些代码必须在项目启动的时候就执行的时候,就需要使用静态代码块</li>\n</ol>\n<h4 id=\"3-构造代码块\"><a href=\"#3-构造代码块\" class=\"headerlink\" title=\"3.构造代码块\"></a>3.构造代码块</h4><h5 id=\"3-1-语法结构\"><a href=\"#3-1-语法结构\" class=\"headerlink\" title=\"3.1 语法结构:\"></a>3.1 语法结构:</h5><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#123;\n    &#x2F;&#x2F;代码块里的内容\n&#125;</code></pre>\n\n<h5 id=\"3-2-特点\"><a href=\"#3-2-特点\" class=\"headerlink\" title=\"3.2 特点\"></a>3.2 特点</h5><ol>\n<li>对象一建立就会执行构造代码块，构造代码块<strong>先于构造方法</strong>执行，用来给对象进行初始化。</li>\n<li><strong>每创建一个对象都会调用一次构造代码块</strong>。</li>\n<li>构造代码块是给所有对象统一初始化，构造函数是给各自对应的对象初始化。</li>\n<li>如果每个实例对象都需要统一的初始化，可以考虑将这部分代码写入到构造代码块里。</li>\n</ol>\n<h3 id=\"三、初始化\"><a href=\"#三、初始化\" class=\"headerlink\" title=\"三、初始化\"></a>三、初始化</h3><h4 id=\"1-类的初始化\"><a href=\"#1-类的初始化\" class=\"headerlink\" title=\"1.类的初始化\"></a>1.类的初始化</h4><p>当我们 用new关键字创建一个对象时，其实就是调用了这个对象的无参构造方法进行了初始化</p>\n<p>无参构造方法可以隐藏，由JVM自动添加，构造方法能保证类的初始化</p>\n<h4 id=\"2-成员初始化\"><a href=\"#2-成员初始化\" class=\"headerlink\" title=\"2.成员初始化\"></a>2.成员初始化</h4><p>Java 会尽量保证每个变量在使用前都会获得初始化。</p>\n<ul>\n<li><p>编译器默认指定的字段初始化，基本数据类型的初始化</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>初始值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean</td>\n<td>false</td>\n</tr>\n<tr>\n<td>char</td>\n<td>/u0000</td>\n</tr>\n<tr>\n<td>byte</td>\n<td>(byte)0</td>\n</tr>\n<tr>\n<td>short</td>\n<td>(short)0</td>\n</tr>\n<tr>\n<td>int</td>\n<td>0</td>\n</tr>\n<tr>\n<td>long</td>\n<td>0L</td>\n</tr>\n<tr>\n<td>float</td>\n<td>0.0f</td>\n</tr>\n<tr>\n<td>double</td>\n<td>0.0d</td>\n</tr>\n<tr>\n<td>引用类型</td>\n<td>null</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>指定数值初始化</p>\n</li>\n<li><p>指定数值后，初始化值，就不是默认初始化值了，而是指定数值，基本类型和引用类型也一样</p>\n</li>\n</ul>\n<h4 id=\"3-构造器初始化\"><a href=\"#3-构造器初始化\" class=\"headerlink\" title=\"3.构造器初始化\"></a>3.构造器初始化</h4><p>可以利用构造器对某些方法和动作进行初始化，确定初始值<strong>（完成对象初始化）</strong>。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class Test&#123;\n\n\tint i;\n\tpublic Test()&#123;\n\t\ti&#x3D;11;\n\t&#125;\n\n&#125;</code></pre>\n\n<h4 id=\"4-实例对象的初始化\"><a href=\"#4-实例对象的初始化\" class=\"headerlink\" title=\"4.实例对象的初始化\"></a>4.实例对象的初始化</h4><h5 id=\"4-1-使用一个类来实例化对象的几种方式\"><a href=\"#4-1-使用一个类来实例化对象的几种方式\" class=\"headerlink\" title=\"4.1 使用一个类来实例化对象的几种方式:\"></a>4.1 使用一个类来实例化对象的几种方式:</h5><ul>\n<li>最常见的方式，使用关键字<code>new</code>来创建一个实例对象。</li>\n<li>使用反射，调用<code>Class</code>或者<code>java.lang.reflect.Constructor</code>对象的<code>newInstance()</code>方法。</li>\n<li>调用对象的clone()方法。</li>\n<li>调用<code>java.io.ObjectInputStream</code>类的<code>getOjbect()</code>方法序列化。</li>\n</ul>\n<h5 id=\"4-2-对象加载\"><a href=\"#4-2-对象加载\" class=\"headerlink\" title=\"4.2 对象加载\"></a>4.2 对象加载</h5><ul>\n<li>先给成员变量设置默认值。</li>\n<li>调用构造方法里 super 的构造方法。</li>\n<li>给成员变量赋值和执行构造代码块。</li>\n<li>执行构造方法里其他的代码。</li>\n</ul>\n<h4 id=\"5-初始化顺序\"><a href=\"#5-初始化顺序\" class=\"headerlink\" title=\"5.初始化顺序\"></a>5.初始化顺序</h4><ul>\n<li><strong>初始化顺序：</strong>父类的静态变量–&gt;父类的静态代码块–&gt;子类的静态变量–&gt;子类的静态代码快–&gt;父类的非静态变量(父类的非静态代码块)–&gt;父类的构造函数–&gt;子类的非静态变量（子类的非静态代码块）–&gt;子类的构造函数</li>\n<li><strong>值得注意的是：</strong>父类的非静态变量(父类的非静态代码块)是同一级的，看哪个部分写在类的最前面谁就先被执行，子类的非静态变量（子类的非静态代码块）也是一样。</li>\n</ul>\n","text":"一、内部类1.成员内部类1.1 概念在成员位置定义的类（定义在另一个类的内部，最普通的内部类），称之为成员内部类 1.2 成员内部类特点: 不能使用 static关键字，但是可以使用static final关键字定义常量。 成员内部类 可以无条件的访问外部类的 成员属性 和 成员...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/tags/JavaSE.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">一、内部类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">1.成员内部类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.1  概念</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">1.2  成员内部类特点:</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-3-%E5%88%9B%E5%BB%BA%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">1.3  创建成员内部类的对象</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">2.局部内部类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">2.1  概述</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">2.2  语法格式</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-3-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">2.3  局部内部类特点</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0final\"><span class=\"toc-text\">2.4  为什么要加final</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">3.匿名内部类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.  概念</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">2.  格式</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E6%B3%A8%E6%84%8F\"><span class=\"toc-text\">3.  注意</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">4.静态内部类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">1.  定义</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">2.  静态内部类特点:</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97\"><span class=\"toc-text\">二、代码块</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97\"><span class=\"toc-text\">2.静态代码块</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-1-%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">2.1 语法结构</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">2.2 特点</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97\"><span class=\"toc-text\">3.构造代码块</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-1-%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">3.1 语法结构:</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-2-%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">3.2 特点</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">三、初始化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">1.类的初始化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">2.成员初始化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">3.构造器初始化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">4.实例对象的初始化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-1-%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%9D%A5%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">4.1 使用一个类来实例化对象的几种方式:</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-2-%E5%AF%B9%E8%B1%A1%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">4.2 对象加载</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">5.初始化顺序</span></a></li></ol></li></ol>","author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}},"mapped":true,"prev_post":{"title":"常用的类（上）","uid":"01fd53219624f0d973c128a92b2b96c5","slug":"07-常用的类（上）","date":"2021-09-13T14:41:32.000Z","updated":"2021-09-14T15:54:12.626Z","comments":true,"path":"api/articles/07-常用的类（上）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-blog7.jpg","text":"一、单例设计模式1.1 概述单例模式，是一种常用的软件设计模式，在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中应用该模式的类一个类只有一个实例，即一个类只有一个对象实例。例如，windows操作系统里的回收站。 单例设计模式分为饿汉式（立即加载型）和懒汉...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/tags/JavaSE.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}},"next_post":{"title":"面向对象（中）","uid":"6a12650511ac8438957ec15fcbb76cbc","slug":"05-面向对象（中）","date":"2021-09-13T14:37:32.000Z","updated":"2021-09-14T16:10:51.551Z","comments":true,"path":"api/articles/05-面向对象（中）.json","cover":"https://gitee.com/hrenxiang/picture/raw/master/img/sky1.jpg","text":"一、封装1.1 概述 面向对象编程语言是对客观世界的模拟，客观世界里实例变量都是隐藏在对象内部的，外界无法直接操作和修改。 封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。 1.2 原则 将类的某些信息隐藏在类内部，不允许...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"JavaSE","slug":"JavaSE","count":18,"path":"api/tags/JavaSE.json"}],"author":{"name":"大黄","slug":"blog-author","avatar":"https://gitee.com/hrenxiang/picture/raw/master/uPic/2021:09:14-hh.JPG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/hrenxiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/15236325327","zhihu":"https://www.zhihu.com/people/hrenxiang","csdn":"https://blog.csdn.net/hrenxiang","juejin":"https://juejin.cn/user/985642616227406","customs":{}}}}}