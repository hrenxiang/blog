[{"id":"8eb5da915bb87dd80146b401007f8494","title":"iterm的使用","content":"一、安装zsh一定先执行zsh --version检查是否已安装zsh。\n返回类似zsh 5.7.1的内容说明可以跳过zsh直接安装iTerm2。\n1、macOSmacOS最新系统已经内置zsh，所以你很可能不需要执行这一步操作。\n安装Homebrew可以访问：https://brew.idayer.com/ ，教你如何飞速安装Homebrew。\nbrew install zsh\n\n设置为默认：\nchsh -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;zsh\n\n更多平台安装方法请浏览 Installing-ZSH 。\n二、安装iTerm21、下载iTerm2是macOS平台上终端的替代方案，功能也更强大，目前支持macOS 10.14及更高版本。\n你可以直接从官网下载iTerm2。\n2、把iTerm2设为默认iTerm2 -&gt; Make ITerm2 Default Term\n三、安装oh-my-zsh1、选择其中一种脚本安装curl（这种即可）：\nsh -c &quot;$(curl -fsSL https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;tools&#x2F;install.sh)&quot;\n\nwget：\nexport REMOTE&#x3D;https:&#x2F;&#x2F;gitee.com&#x2F;imirror&#x2F;ohmyzsh.git\nsh -c &quot;$(wget -O- https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;tools&#x2F;install.sh)&quot;\n\nfetch：\nexport REMOTE&#x3D;https:&#x2F;&#x2F;gitee.com&#x2F;imirror&#x2F;ohmyzsh.git\nsh -c &quot;$(fetch -o - https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;tools&#x2F;install.sh)&quot;\n\n四、配置主题官方收集了一些主题（不再收录新主题），你可以访问 主题&amp;&amp;截图 页面查看并选取。\n这里以Dracula为例说明。\n1、下载主题文件git clone https:&#x2F;&#x2F;github.com&#x2F;dracula&#x2F;zsh.git ~&#x2F;Downloads\n\n在下载中将压缩包解压\n移动主题文件 dracula.zsh-theme 到 ~/.oh-my-zsh/themes/ 下\n然后移动压缩包中 lib 文件夹中的文件到 ~/.oh-my-zsh/thems/lib （没有 lib 就创建）\n2、编辑~/.zshrc文件# 启用相关主题\nZSH_THEME&#x3D;&quot;dracula&quot;\n\n# 添加 bash中的环境变量到 ~&#x2F;.zshrc 中\nsource ~&#x2F;.bash_profile\n\n# 保存退出\nwq\n\n# 在外面重新加载 配置文件\nsource ~&#x2F;.zshrc\n\n# 主题介绍请访问 https:&#x2F;&#x2F;github.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;wiki&#x2F;Themes （dracula不在这里）\n\n3、安装字体大部分主题都用到了 Powerline Fonts  ，我们可以直接安装 Powerline Fonts 中的全部字体\n将字体安装包下载到一个文件夹内\ngit clone https:&#x2F;&#x2F;github.com&#x2F;powerline&#x2F;fonts.git  ~&#x2F;iterm2&#x2F;fonts\n\n进入文件夹\ncd ~&#x2F;iterm2&#x2F;fonts\n\n安装字体\n.&#x2F;install.sh\n\n安装完成后，字体文件可以保存，也可以删除\n4、选择字体然后打开iTerm -&gt; Preferences -&gt; Profiles -&gt; Text -&gt; Change Font，选择Meslo LG S Regular for Powerline （只要是 poweline 的任意一种就可以）。\n重新打开iTerm2就能看到效果。\n5、其他主题设置如果没有找到满意的主题，可以试下 更多主题 。\n你也可以试下random，不用纠结选择哪个主题：\nZSH_THEME&#x3D;&quot;random&quot;\n\n指定参与随机的主题：\nZSH_THEME_RANDOM_CANDIDATES&#x3D;(\n  &quot;robbyrussell&quot;\n  &quot;agnoster&quot;\n)\n\n也可以排除主题：\nZSH_THEME_RANDOM_IGNORED&#x3D;(pygmalion tjkirch_mod)\n\n\n\n五、功能增强1、zsh-autosuggestions命令自动补全功能。\n1、克隆代码到$ZSH_CUSTOM/plugins（默认位于~/.oh-my-zsh/custom/plugins）\ngit clone https:&#x2F;&#x2F;gitee.com&#x2F;imirror&#x2F;zsh-autosuggestions.git $&#123;ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom&#125;&#x2F;plugins&#x2F;zsh-autosuggestions\n\n最后执行source ~/.zshrc生效。\n2、在Oh My Zsh配置启用插件\n打开~/.zshrc，找到plugins，追加zsh-autosuggestions。\ngit为默认配置。\nplugins&#x3D;(git zsh-autosuggestions)\n\n如果有看不到自动补全的内容，确保以下两个颜色不是相近的：\niTerm &gt; Preferences &gt; Profiles &gt; Colors &gt; ANSI Colors &gt; Bright &gt; Black\niTerm &gt; Preferences &gt; Profiles &gt; Colors &gt; Basic Colors &gt; Background\n\n2、zsh-syntax-highlighting语法高亮。\n1、克隆代码到$ZSH_CUSTOM/plugins（默认位于~/.oh-my-zsh/custom/plugins）\ngit clone https:&#x2F;&#x2F;gitee.com&#x2F;imirror&#x2F;zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom&#125;&#x2F;plugins&#x2F;zsh-syntax-highlighting\n\n2、在Oh My Zsh配置启用插件\n打开~/.zshrc，找到plugins，追加zsh-autosuggestions。\ngit为默认配置。\nplugins&#x3D;(git zsh-autosuggestions zsh-syntax-highlighting)\n\n最后执行source ~/.zshrc生效。\n六、番外篇1、iTerm2一键ssh连接远程服务器配置1、编写一个文件，内容如下，把对应的中文改成你的服务器相关内容就行，这里我将其编写为txt文本文件，放到用户目录下的 .zsh 文件夹下 (  ~/.zsh/aliyun.txt  )\n#!&#x2F;usr&#x2F;bin&#x2F;expect -f\n  set user 用户名\n  set host ip地址\n  set password 密码\n  set timeout -1\n  \n  spawn ssh $user@$host\n  expect &quot;*assword:*&quot;\n  send &quot;$password\\r&quot;\n  interact\n  expect eof\n\n2、打开iTerm2，打开设置(Preferences)，点击Profiles，点左下角+\n3、以后在终端界面直接点击即可连接到服务器\n\n2、一些功能和快捷键\n鼠标选中即复制\n\ncommand + d 垂直分屏\n\ncommand + shift + d 水平分屏\n\ncommand + shift + h 打开剪切板(复制历史)\n\ncommand + ; 命令自动完成\n\ncommand + shift + ; 查看历史命令\n\ncommand + option + b 按键回放(输入命令回放, 通过时间线)\n\ncommand+方向键: 切换tab。\n\ncommand+enter: 全屏模式。\n\ncommand+f: 搜索，支持正则表达式。\n\ncommand+[ 或 command +]: 在最近使用的分屏直接切换。\n\ncommand+t: 打开新标签。\n\ncommand+w: 关闭新标签。\n\ncommand+;: 自动补全历史命令。\n\ncommand+r: 清除屏幕，相当与clear.\n\ncommand+p/n: 上一条/下一条命令，相当于方向键上和下。\n\nctrl+r: 搜索命令历史。\n\n\n1、光标快速切换到行尾行首\n   ctrl+a 行首\n   ctrl+e 行尾\n2、删除至行尾\n   ctrl+k\n3、使用alias命令查看一些命令的简写","slug":"iterm的使用","date":"2021-09-13T14:32:32.000Z","categories_index":"Mac相关","tags_index":"Mac终端","author_index":"大黄"},{"id":"97e5d14896602922a9c354542d00c374","title":"HomeBrew 基本使用","content":"1、搜索包brew search mysql\n\n\n\n2、安装包brew install mysql\n\n\n\n3、查看包信息注意：比如查看目前的版本，依赖，安装后注意事项等\nbrew info mysql\n\n\n\n4、卸载包brew uninstall wget\n\n\n\n5、显示已安装的包brew list\n\n\n\n6、查看brew的帮助brew –help\n\n\n\n7、更新注意：这会更新 Homebrew 自己\nbrew update\n\n\n\n8、检查过时注意：（是否有新版本），这会列出所有安装的包里，哪些可以升级\nbrew outdated\nbrew outdated mysql\n\n\n\n9、升级所有可以升级的软件brew upgrade\nbrew upgrade mysql\n\n\n\n10、清理不需要的版本极其安装包缓存brew cleanup\nbrew cleanup mysql\n\n\n\n11、brew 查看源配置在目录中可以通过git remote get-url origin来查看当前的源的URL。\ngit -C &quot;$(brew --repo)&quot; remote get-url origin\ngit -C &quot;$(brew --repo homebrew&#x2F;core)&quot; remote get-url origin \ngit -C &quot;$(brew --repo homebrew&#x2F;cask)&quot; remote get-url origin \n\n\n\n12、brew 修改国内源清华源\n# 替换brew.git\ncd &quot;$(brew --repo)&quot;\ngit remote set-url origin https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;git&#x2F;homebrew&#x2F;brew.git\n\n# 替换homebrew-core.git\ncd &quot;$(brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core&quot;\ngit remote set-url origin https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;git&#x2F;homebrew&#x2F;homebrew-core.git\n\n# 刷新源\nbrew update\n\n阿里云\n# 替换brew.git\ncd &quot;$(brew --repo)&quot;\ngit remote set-url origin https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;homebrew&#x2F;brew.git\n\n# 替换homebrew-core.git\ncd &quot;$(brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core&quot;\ngit remote set-url origin https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;homebrew&#x2F;homebrew-core.git\n\n# 刷新源\nbrew update\n\n腾讯源\n替换brew.git:\ncd &quot;$(brew --repo)&quot;\ngit remote set-url origin https:&#x2F;&#x2F;mirrors.cloud.tencent.com&#x2F;homebrew&#x2F;brew.git\n\n替换homebrew-core.git:\ncd &quot;$(brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core&quot;\ngit remote set-url origin https:&#x2F;&#x2F;mirrors.cloud.tencent.com&#x2F;homebrew&#x2F;homebrew-core.git\n\n# 刷新源\nbrew update\n\n默认值，可以通过以下三个命令设置为默认值，最后需要更新\ngit -C &quot;$(brew --repo)&quot; remote set-url origin &#39;https:&#x2F;&#x2F;github.com&#x2F;Homebrew&#x2F;brew.git&#39;\n\ngit -C &quot;$(brew --repo homebrew&#x2F;core)&quot; remote set-url origin &#39;https:&#x2F;&#x2F;github.com&#x2F;Homebrew&#x2F;homebrew-core.git&#39;\n\ngit -C &quot;$(brew --repo homebrew&#x2F;cask)&quot; remote set-url origin &#39;https:&#x2F;&#x2F;github.com&#x2F;Homebrew&#x2F;homebrew-cask.git&#39;\n\nbrew update\n\n\n\n13、安装 homebrew&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;ineo6&#x2F;homebrew-install&#x2F;install)&quot;\n\n该脚本用了中科大镜像加速访问，仅修改仓库地址部分，不会产生安全隐患。 关于中科大所提供的 Homebrew 镜像服务 https://lug.ustc.edu.cn/wiki/mirrors/help/brew.git\n注：注意这里的速度，几百kib/s或几m/s才是正常的。若只有几kib/s，通常为无效的安装方法，一般加载了百分之几十后就会报错。\n然后还需设置环境变量，具体操作步骤如下，一定要仔细阅读。\n\n在终端执行命令echo $SHELL获得终端类型：\n\n/bin/zsh =&gt; zsh =&gt; .zprofile\n/bin/bash =&gt; bash =&gt; .bash_profile\n\n\n如果看到的是/bin/zsh\necho &#39;eval &quot;$(&#x2F;opt&#x2F;homebrew&#x2F;bin&#x2F;brew shellenv)&quot;&#39; &gt;&gt; ~&#x2F;.zprofile\neval &quot;$(&#x2F;opt&#x2F;homebrew&#x2F;bin&#x2F;brew shellenv)&quot;\n\n如果看到的是/bin/bash\necho &#39;eval &quot;$(&#x2F;opt&#x2F;homebrew&#x2F;bin&#x2F;brew shellenv)&quot;&#39; &gt;&gt; ~&#x2F;.bash_profile\neval &quot;$(&#x2F;opt&#x2F;homebrew&#x2F;bin&#x2F;brew shellenv)&quot;\n\n\n\n\n\n\n\n\n\n\n从macOS Catalina(10.15.x) 版开始，Mac使用zsh作为默认Shell。\n14、homebrew 组成\n\n\n组成\n功能\n\n\n\nHomebrew\n源代码仓库\n\n\nhomebrew-core\nHomebrew 核心源\n\n\nhomebrew-cask\n提供macos应用和大型二进制文件的安装\n\n\nhomebrew-bottles\n预编译二进制软件包\n\n\n15、删除 homebrew&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;ineo6&#x2F;homebrew-install&#x2F;uninstall)&quot;\n\n\n\n16、下载可视化界面官网：https://www.cakebrew.com/\ngithub：https://github.com/brunophilipe/Cakebrew/releases\n","slug":"HomeBrew基本使用","date":"2021-09-13T14:30:32.000Z","categories_index":"Mac相关","tags_index":"Mac终端","author_index":"大黄"},{"id":"28f9cbb3f87fb083ac5744977081fb5c","title":"你好\thexo","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"你好 hexo !","date":"2021-09-13T14:28:32.000Z","categories_index":"","tags_index":"Mac终端","author_index":"大黄"},{"id":"2b44c6e424a6331818e54e65d2f7d5d8","title":"SpringCloudALibaba Sentinel","content":"01、Sentinel 简介\n\n1.1、官方文档GitHub：https://github.com/alibaba/Sentinel\n中文：https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D\n1.2、Sentinel 是什么Sentinel: 分布式系统的流量防卫兵\n随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\n1.3、Sentinel 的特征1、丰富的应用场景\nSentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。\n2、完备的实时监控\nSentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。\n3、广泛的开源生态\nSentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Apache Dubbo、gRPC、Quarkus 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。同时 Sentinel 提供 Java/Go/C++ 等多语言的原生实现。\n4、完善的 SPI 扩展机制\nSentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。\n1.3、Sentinel 的主要特性\n\n\n\n1.4、Sentinel 的开源生态Sentinel 分为两个部分:\n\n核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。\n控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。\n\n\n    \n\n\n\n\n1.5、下载及使用地址下载地址：https://github.com/alibaba/Sentinel/releases\n使用地址：https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_sentinel\n1.6、服务使用中的各种问题服务雪崩\n服务降级\n服务熔断\n服务限流\n02、安装控制台\n\nSentinel 分为两个部分:\n核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。\n控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。\n\n后台\n前台8080\n\n1.1、下载https://github.com/alibaba/Sentinel/releases\n下载到本地sentinel-dashboard-1.7.0.jar\n1.2、运行java -jar sentinel-dashboard-1.7.0.jar\n\n\n\n1.3、访问http://localhost:8080        登录账号密码均为sentinel\n03、初始化演示过程\n\n1.1、启动 Nacoshttp://localhost:8848/nacos/#/login\n1.2、创建 Modulecloudalibaba-sentinel-service8401\n添加POM\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;cloud2020&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n    &lt;artifactId&gt;cloudalibaba-sentinel-service8401&lt;&#x2F;artifactId&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;cloud-api-commons&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;$&#123;project.version&#125;&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba.csp&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;sentinel-datasource-nacos&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;cn.hutool&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;hutool-all&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;4.6.3&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;\n\nYML\nserver:\n  port: 8401\n\nspring:\n  application:\n    name: cloudalibaba-sentinel-service\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848\n    sentinel:\n      transport:\n        dashboard: localhost:8080\n        port: 8719  #默认8719，应用与Sentinel控制台交互的端口，应用本地会起一个该端口占用HttpServer\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: &#39;*&#39;\n\nhttps://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-endpoints\n*可用于选择所有端点。例如，要通过 HTTP 公开除env和beans端点之外的所有内容，请使用以下属性：\nmanagement.endpoints.web.exposure.include&#x3D;*\nmanagement.endpoints.web.exposure.exclude&#x3D;env,beans\n\n主启动\npackage com.atguigu.springcloud.alibaba;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class MainApp8401&#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(MainApp8401.class, args);\n    &#125;\n&#125;\n\n业务类\npackage com.atguigu.springcloud.alibaba.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@Slf4j\npublic class FlowLimitController&#123;\n    @GetMapping(&quot;&#x2F;testA&quot;)\n    public String testA() &#123;\n        return &quot;------testA&quot;;\n    &#125;\n\n    @GetMapping(&quot;&#x2F;testB&quot;)\n    public String testB() &#123;\n        return &quot;------testB&quot;;\n    &#125;\n&#125;\n\n\n\n1.3、启动 Sentinel 8080java -jar sentinel-dashboard-1.7.0\n1.4、启动 服务提供者 84011.5、查看控制台空空如也，啥都没有\n==Sentinel采用的懒加载说明==\n执行一次访问即可\nhttp://localhost:8401/testA\nhttp://localhost:8401/testB\n效果\n\n04、流控规则\n\n1.1、基本介绍\n    \n    \n    \n\n\n\n\n1.2、流控模式 – 直接默认的流控模式是直接，流控效果是快速失败。直接就是直接访问限定规则的资源，快速失败就是效果是访问失败直接出现限流的文字。\n\n\n==设置线程数为2，快熟点击不会出现Blocked by Sentinel (flow limiting)（线程处理请求很快），但是，在映射方法里添加sleep后，同样也会出现Blocked by Sentinel (flow limiting)默认提示信息。==\n1.3、流控模式 – 关联微服务的系统资源一般都有关联关系，比如：订单接口会调用支付接口，如果支付接口出现流量激增的情况，会导致调用订单接口出现问题，这时我们除了直接对支付接口限流外，也可以对订单接口限流。\n为验证效果，我们编写控制器\n@RestController\npublic class OrderController &#123;\n\n    @GetMapping(&quot;&#x2F;order&quot;)\n    public String order()&#123;\n        return &quot;这是订单接口!&quot;;\n    &#125;\n\n    @GetMapping(&quot;&#x2F;payment&quot;)\n    public String payment()&#123;\n        return &quot;这是支付接口!&quot;;\n    &#125;\n&#125;\n复制代码\n\n先访问一下/order接口，然后给它添加流控规则，流控模式选择关联，关联资源设置为/payment，也就是：payment接口每秒访问超过1次后，将对order接口进行限流。\n总结一下，关联就是：关联资源超过了阈值，限流当前的资源。\n1.4、流控模式 – 链路链路是资源的调用可能出现上下级的层次结构，如下图：\nA是根节点，以A为入口，可以访问B和C，B和C又可以访问D和E，那么我们如果对A进行限流，就可以对A下面的所有资源进行限流了。\n做下测试：查看簇点链路，选择树状视图，就可以看到上下级的关系了。\n\n\n我们看到上层的资源是/sentinel_web_servlet_context，下层资源也/testA，给下面的/testA添加流控\n05、流控效果\n\n1.1、快速失败快速失败是默认效果，既当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。\n直接失败，抛出异常：Blocked by Sentinel (flow limiting)\n源码：com.alibaba.csp.sentinel.slots.block.flow.controller.DefaultController\n1.2、Warm Up即预热/冷启动方式。\n当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。 比如：在春节抢热点地区火车票的时候，如果直接把流量放进来，可能会一下直接把12306的服务器打死，那么我们可以设定一个预热时间，给服务器一个缓冲期，慢慢的把流量放进来，直到达到最大的阈值。\n修改一下前面的流控规则，这里阈值是10，预热时间是5秒，前面讲过流量是逐步加到阈值上限的，那么就有一个初始的阈值： 初始阈值 = 阈值上限 / coldFactor， coldFactor 是冷加载因子，默认为3，则初始阈值为 10 / 3 = 3 下面配置的效果就是：一开始限流的阈值是3，然后5秒后上升到10.\n\n\n应用场景，如：秒杀系统在开启的瞬间，会有很多流量上来，很有可能把系统打死，预热方式就是为了保护系统，可慢慢的把流量放进来，慢慢的把阈值增长到设置的阈值。\n1.3、排队等待排队等待方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。也比较好理解，就是不管流量再多，进来访问资源时都必须排队，一个个的访问。\n 这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。\n\n匀速排队，让请求以均匀的速度通过，阈值类型必须设置成QPS，否则无效。\n设置含义：/testB每秒1次请求，超过的话就排队等待，等待的超时时间为20000毫秒。\n\n06、降级规则\n\n1.1、官网概述官网：https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7\n除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库，或者第三方 API 等。例如，支付的时候，可能需要远程调用银联提供的 API；查询某个商品的价格，可能需要进行数据库查询。然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现了不稳定的情况，请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身也变得不可用。\n\n    \n\n\n现代微服务架构都是分布式的，由非常多的服务组成。不同服务之间相互调用，组成复杂的调用链路。以上的问题在链路调用中会产生放大的效果。复杂链路上的某一环不稳定，就可能会层层级联，最终导致整个链路都不可用。因此我们需要对不稳定的弱依赖服务调用进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩。熔断降级作为保护自身的手段，通常在客户端（调用端）进行配置。\n\n\n\n\n\n\n\n\n\n注意：此文档针对 Sentinel 1.8.0 及以上版本。1.8.0 版本对熔断降级特性进行了全新的改进升级，请使用最新版本以更好地利用熔断降级的能力。==但是本文 采用的是 1.7.x 的版本请注意==\n1.2、熔断策略Sentinel 提供以下几种熔断策略：\n\n慢调用比例 (SLOW_REQUEST_RATIO)：选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。\n\n\n\n\n\n\n\n\n\n1.7.x 中叫平均响应时间，当1S内持续进入N个请求，如果平均响应时间超过阈值，那么在接下来的时间窗口内，按降级逻辑进行处理（报一个DegradeException错误）。\n\n异常比例 (ERROR_RATIO)：当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。\n\n\n\n\n\n\n\n\n\n普通来说，可以输入一个0.0~1.0的数字，表示出现异常的比例。如果一秒内超过这个比例，那么在接下来的时间窗口内，按降级逻辑进行处理。\n\n异常数 (ERROR_COUNT)：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。\n\n\n\n\n\n\n\n\n\n普通来说，指当资源近一分钟的异常数超过阈值之后会，那么在接下来的时间窗口内，按降级逻辑进行处理。\n\n\n注意异常降级仅针对业务异常，对 Sentinel 限流降级本身的异常（BlockException）不生效。为了统计异常比例或异常数，需要通过 Tracer.trace(ex) 记录业务异常。\n\n    \n\n\n\n\n\n\n07、热点规则\n\n所谓热点规则，就是对某些经常访问的数据（热点数据），对其访问进行限制，\n比如以商品ID为参数，限制这个商品的访问次数。在代码中需要对要限制的请求进行埋点\n@GetMapping(&quot;&#x2F;test3&quot;)\n@SentinelResource(value &#x3D; &quot;test3&quot;,blockHandler &#x3D; &quot;handHotKey&quot;)\n    public String testA(@RequestParam(value &#x3D; &quot;a&quot;,required &#x3D; false)String a,\n                    @RequestParam(value &#x3D; &quot;b&quot;,required &#x3D; false)String b)&#123;\n    return &quot;test3&quot;+a+b;\n&#125;\n\npublic String handHotKey(String a1, String a2, BlockException e)&#123;\n    return &quot;热点数据限流&quot;;\n&#125;\n\n1、设置热点规则，这里的资源名就是@SentinelResource中所设置的value，参数索引的表示对第几个参数进行限流控制，阈值和窗口时长表示在1秒内如果有2个对参数0的请求，就限流。限流后会执行自己设置的blockHandler方法。\n\n如果访问/test3，我们发现热点规则没有生效\n如果访问/test3?a=1，若一秒钟 超过两次，则直接显示 热点数据限流（我们上述兜底方法中返回给客户端的）\n如果访问/test3?b=1，我们发现热点规则没有生效\n所以说，我们只限定我们设置的参数索引位置的数据\n2、高级设置中可以设置参数例外项，即根据设置参数的值进行限流\n\n    \n\n\nhttp://localhost:8401/test3?a=5，一秒超过5次才会 显示热点数据限流\nhttp://localhost:8401/test3?a=1，一秒一次就显示\n08、系统规则\n\n通过监控系统的一些参数进行规则限流： \n\n\nLoad：这个参数只能在Linux或类Unix机器生效，将系统的1分钟的loadAverage作为指标，这个值一般设置为CPU核心数量 * 2.5。\nRT：当单台机器上所有入口流量的平均RT达到阈值就触发系统保护，单位是毫秒。\n并发线程数：当单台机器上所有入口流量的并发线程数达到阈值就触发系统保护。\n入口QPS：当单台机器上所有入口流量的QPS达到阈值就触发阈值就触发系统保护。（设置0，代表1秒中最多一个，设置1，代表一秒中最多两个）\nCPU使用率：当系统CPU使用率超过阈值就触发系统保护。\n09、@SentinelResource\n\n1.1、按资源名称限流+后续处理\n启动Nacos成功\n启动Sentinel成功\nModule：cloudalibaba-sentinel-service8401\nPOM\nYML\n\nserver:\n  port: 8401\n\nspring:\n  application:\n    name: cloudalibaba-sentinel-service\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848\n    sentinel:\n      transport:\n        dashboard: localhost:8080\n        port: 8719  #默认8719，应用与Sentinel控制台交互的端口，应用本地会起一个该端口占用的HttpServer\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: &#39;*&#39;\n\n\n业务类RateLimitController\n\npackage com.atguigu.springcloud.alibaba.controller;\n\nimport com.alibaba.csp.sentinel.annotation.SentinelResource;\nimport com.alibaba.csp.sentinel.slots.block.BlockException;\nimport com.atguigu.springcloud.alibaba.entities.CommonResult;\nimport com.atguigu.springcloud.alibaba.entities.Payment;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class RateLimitController&#123;\n    @GetMapping(&quot;&#x2F;byResource&quot;)\n    @SentinelResource(value &#x3D; &quot;byResource&quot;,blockHandler &#x3D; &quot;handleException&quot;)\n    public CommonResult byResource()&#123;\n        return new CommonResult(200,&quot;按资源名称限流测试OK&quot;,new Payment(2020L,&quot;serial001&quot;));\n    &#125;\n    public CommonResult handleException(BlockException exception)&#123;\n        return new CommonResult(444,exception.getClass().getCanonicalName()+&quot;\\t 服务不可用&quot;);\n    &#125;\n&#125;\n\n\n主启动\n\npackage com.atguigu.springcloud.alibaba;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class MainApp8401&#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(MainApp8401.class, args);\n    &#125;\n&#125;\n\n\n配置流控规则，配置步骤\n\n\n    \n\n\n\n表示1秒钟内查询次数大于1，就跑到我们自定义的处理，限流\n测试\n1秒钟点击1下，OK\n超过上述问题，疯狂点击，返回了自己定义的限流处理信息，限流发生\n\n\nSentinel控制台，流控规则消失了？？？？？临时/持久？\n\n1.2、按 Url 地址限流+后续处理通过访问的URL来限流，会返回Sentinel自带默认的限流处理信息业务类RateLimitController\n@GetMapping(&quot;&#x2F;rateLimit&#x2F;byUrl&quot;)\n@SentinelResource(value &#x3D; &quot;byUrl&quot;)\npublic CommonResult byUrl()&#123;\n    return new CommonResult(200,&quot;按url限流测试OK&quot;,new Payment(2020L,&quot;serial002&quot;));\n&#125;\n\n访问一次\nSentinel控制台配置\n\n    \n\n\n\n测试\n疯狂点击http://localhost:8401/rateLimit/byUrl\n结果，会返回Sentinel自带的限流处理结果\n\n\n上面兜底方法面临的问题\n系统默认的，没有体现我们自己的业务要求。\n依照现有条件，我们自定义的处理方法又和业务代码耦合在一起，不直观。\n每个业务方法都增加一个兜底的，那代码膨胀加剧。\n全局统一的处理方法没有体现。\n\n\n\n1.3、客户自定义限流处理逻辑\n创建customerBlockHandler类用于自定义限流处理逻辑\n自定义限流处理类\n==方法必须是public static修饰的。(在注解中我们指明了类的class对象和方法所对应的异常处理方法，所以我们是直接使用类调用的)==\n\npackage com.atguigu.springcloud.alibaba.myhandler;\n\nimport com.alibaba.csp.sentinel.slots.block.BlockException;\nimport com.atguigu.springcloud.entities.CommonResult;\n\npublic class CustomerBlockHandler &#123;\n    public static CommonResult handleException(BlockException exception)&#123;\n        return new CommonResult(2020,&quot;自定义限流处理信息.... CustomerBlockHandler --- 1&quot;);\n    &#125;\n\n    public static CommonResult handleException2(BlockException exception)&#123;\n        return new CommonResult(2020,&quot;自定义限流处理信息.... CustomerBlockHandler --- 2&quot;);\n    &#125;\n\n&#125;\n\n\nRateLimitController\n\n@GetMapping(&quot;&#x2F;rateLimit&#x2F;customerBlockHandler&quot;)\n@SentinelResource(value &#x3D; &quot;customerBlockHandler&quot;,\n        blockHandlerClass &#x3D; CustomerBlockHandler.class, blockHandler &#x3D; &quot;handleException2&quot;)\npublic CommonResult customerBlockHandler()&#123;\n    return new CommonResult(200,&quot;按客戶自定义&quot;,new Payment(2020L,&quot;serial003&quot;));\n&#125;\n\n\n启动微服务后先调用一次\nhttp://localhost:8401/rateLimit/customerBlockHandlerSentinel\n\n控制台配置\n\n测试后我们自定义的出来了\n\n进一步说明\n\n\n\n    \n\n\n\n\n1.4、更多注解属性说明https://github.com/alibaba/Sentinel/wiki/%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81\n==@SentinelResource 注解方式埋点不支持 private 方法。==\n10、服务熔断功能\n\nsentinel整合ribbon+openFeign+fallback\n1.1、Ribbon 系列1.2、Feign 系列1.3、容器框架比较\n    \n\n\n\n\n11、规则持久化\n\nPush模式： 客户端通过注册监听器的方式时刻监听变化，比如使用Nacos、Zookeeper等配置中心，这种方式保证了很好的实时性和一致性，生产环境中一般采用push模式。我们用Nacos实现\n1、添加sentinel-datasource-nacos依赖\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.csp&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;sentinel-datasource-nacos&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n2、配置持久化数据源\nserver:\n  port: 8401\n\nspring:\n  application:\n    name: cloudalibaba-sentinel-service\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #Nacos服务注册中心地址\n    sentinel:\n      transport:\n        dashboard: localhost:8080 #配置Sentinel dashboard地址\n        port: 8719\n      datasource:\n        ds1:\n          nacos:\n            server-addr: localhost:8848\n            dataId: cloudalibaba-sentinel-service\n            groupId: DEFAULT_GROUP\n            data-type: json\n            rule-type: flow\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: &#39;*&#39;\n\n3、在Nacos中手动添加配置文件,这里的配置文件取的就是和本地配置文件相同格式\n\n\n[\n    &#123;\n        &quot;clusterMode&quot;:false,\n        &quot;controlBehavior&quot;:0,\n        &quot;count&quot;:2,\n        &quot;grade&quot;:1,\n        &quot;limitApp&quot;:&quot;default&quot;,\n        &quot;maxQueueingTimeMs&quot;:500,\n        &quot;resource&quot;:&quot;&#x2F;test&quot;,\n        &quot;strategy&quot;:0,\n        &quot;warmUpPeriodSec&quot;:10\n    &#125;\n]\n\n\n\npush模式目前还有缺点，Nacos修改配置文件后可同步到Sentinel，但是在Sentinel中修改配置后无法同步到Nacos，需要手动去同步数据。\n","slug":"73-SpringCloudAlibaba-Sentinel","date":"2021-09-13T15:49:32.000Z","categories_index":"SpringCloud Alibaba","tags_index":"SpringCloud Alibaba","author_index":"大黄"},{"id":"a48e6dda0c21e40880cba7e763278b04","title":"Docker","content":"简介\n\n\n\n\n\n\n\n\n\n本文将整体介绍一下如何使用安装docker、获取docker资源、使用docker获得MySQL、redis等中间件服务并快速搭建，以及管理和使用这些中间件服务，docker容器和宿主机如何交互、如何构建我们自己的服务镜像等等。\n\n\n本文内容有\n\n我们为啥要用docker？\n管理docker image镜像\n使用镜像创建docker container容器服务\n管理docker container容器服务\n查看docker container容器服务状态\n容器服务和宿主机如何交互\n使用docker搭建中间件基础服务示例\n使用docker构建我们自己的服务镜像\n搭建docker UI工具服务portainer\n更多docker资料\n\n\n参考文章\n原文传送门\nDockerfile官方教程\ndocker镜像构建命令官方教程\ndocker镜像推送命令官方教程\ndocker镜像拉取命令官方教程\ndocker私服登录命令官方教程\n\n1、我们为啥要用docker？1.1 docker能给我们带来哪些好处？\n\n\n\n\n\n\n\n\n传统的服务器系统更新的步骤是这样的，我们使用归档后的服务发布包，上传到不同环境的服务器上，进行部署。很多公司的服务发版流程中各个环境的发布包更新顺序是这样的：开发环境–&gt;测试环境–&gt;预发布环境–&gt;线上灰度环境–&gt;线上环境（有的大公司环境可能更多，小公司也许就两套环境）。只有前面的环境都验证通过后，才能把服务发布包更新到线上环境。\n先说说上面这种发布流程存在哪些弊端吧:\n\n服务发布包操作和管理不方便，导致发布效率低\n各个环境很难做到完全一致（如操作系统、网络环境、基础服务版本、jdk版本等等），可能导致服务在不同环境中存在兼容性问题\n服务发布流程想要做到自动化难度大，浪费人力成本\n系统中的服务会互相争抢资源，如果某个服务耗费了所有的系统资源（如：CPU、内存等等）就会导致其他服务也无法使用\n不同服务如果使用了相同的端口号，会互相竞争，导致某些服务无法正常工作\n传统服务很难做到服务自动伸缩和故障转移\n很多时候研发人员需要花费不少时间来排查由于环境不一致导致的问题，排查难度高\n无法完全控制服务的行为，比如服务内某些不法研发人员给自己开后门，访问其他资源。\n项目整体的迭代速度低\n\n\n\n\n\n\n\n\n\n\n使用docker管理我们的服务后，有如下优点：\n\n服务发布包可以做成镜像，稳定且使用方便，可以做到一次构建，多处运行\n降低了服务部署的复杂性，减少了因环境不一致导致的兼容性问题。由于服务运行在docker的虚拟容器中，容器中包含了该服务运行所需的所有环境信息，包括操作系统和jdk等等资源。所以无需担心环境不一致导致的兼容性问题\ndocker可以对服务的可使用资源进行限制，比如说限制服务只使用多少cpu和内存等等\ndocker可以管理容器服务的网络，服务间可以做到互不影响\ndocker容器服务很轻量。也许你会有疑问，docker既然把服务所需要的环境都打包到镜像一起发布，会不会非常占用服务器资源呀？其实docker早就考虑了这一点，docker提供的是一个轻量级的VM，而且同主机上的基础镜像可以被不同的docker服务所共用，所以不会有很大的资源浪费，当然会比传统的服务占用的资源稍微多一些。\ndocker服务性能稳定，较传统服务部署方式有些微性能损耗。也许你会担心docker服务的性能问题，其实docker经过多年的迭代更新，现在产品已经非常稳定，经测试，使用docker部署的服务在性能上的损耗非常小。\n使用docker的集群功能可以带来更多的好处，比如：服务实例数动态伸缩、故障转移、滚动发布、统一协调管理服务器资源等等功能，能够提高服务器资源整体的利用率，而且大大提升了服务的可用性和稳定性，服务的并发能力也能动态提升。\n使用docker可以提高服务的安全性，控制服务所能访问的资源范围和提供的服务范围。\n使用docker部署服务非常容易做到完全自动化，节省研发和运维成本\n服务资源备份、迁移更容易，由于服务都是运行在docker虚拟的容器内，所以可以非常方便的将服务转移到其他服务器上运行\n\n1.2 docker的组成结构\ndocker容器的整体结构\n\n\n\ndocker基础组件介绍\n\n\nDockerClient客户端\n\n\n\n\n\n\n\n\n\ndocker客户端提供了人机交互命令，用来向docker的服务器端（守护进程）发出请求，守护进程处理完所有的工作，并返回结果客户端对服务器端的访问既可以在本地也可以在远程来访问。\n\nDocker Daemon守护进程\n\n\n\n\n\n\n\n\n\ndocker提供的后台服务，用于管理image镜像、container容器和其他docker组件，接收并执行docker client发送的命令。\n\nDocker Image镜像\n\n\n\n\n\n\n\n\n\n功能跟传统的服务发布包类似，提供了服务运行所需要的所有信息。服务发布包可以被打包成镜像，以供后续的部署。\n\nDockerContainer容器\n\n\n\n\n\n\n\n\n\n运行服务的载体，提供了一个轻量级的VM环境，这个环境里提供了服务运行所需要的所有资源，包括操作系统、jdk、网络环境等等。\n\n\n\n\ndocker 镜像仓库Registry介绍\n\n\n\n\n\n\n\n\n\n安装了docker的主机上都会有一个本地仓库，docker可以从不同的远程仓库中拉取镜像到本地仓库，然后使用拉取下来的镜像创建可运行的容器服务。\n\n\n\n\n\n\n\n\n\n常见的远程仓库有：\n\nDocker Hub(docker官方镜像仓库): https://hub.docker.com/\ndocker官方中国区 https://registry.docker-cn.com\nustc http://docker.mirrors.ustc.edu.cn\n阿里云 http://&lt;你的ID&gt;.mirror.aliyuncs.com\n\n如果需要使用某些国内镜像源，可以在/etc/docker/daemon.json中添加内容：\n&#123;\n    &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;,&quot;http:&#x2F;&#x2F;hub-mirror.c.163.com&quot;]\n &#125;\n123\n\n\n\n\n\n\n\n\n\n\n当然你也可以搭建自己的docker镜像私服，常见的有Docker Registry 、nexus3等等\n\ndocker 其他组件介绍\n\ndocker swarm集群管理组件\n\n\n\n\n\n\n\n\n\n可以将不同的服务器都加入到集群中进行管理，统一分配服务器资源给业务服务部署和运行，包括服务伸缩、故障转移、滚动发布等等功能。\n\ndocker compose服务编排工具\n\n\n\n\n\n\n\n\n\n可以提供一个模板配置文件，控制服务自己的子元素使用以及服务间的依赖关系等等，可以提供整个平台的服务一键部署能力。\n\n\n\ndocker第三方管理平台介绍\n\n\n\n\n\n\n\n\n\nKubernetes(K8s)、Apache Mesos等等，可以提供比docker swarm更强大的集群能力，目前比较推荐使用k8s，毕竟更成熟，很多业界主流大平台都在用它，中小企业可以选择用云平台提供的k8s服务即可，自建成本太高。\n\n\n1.3 docker如何工作的？Docker 采用的是 Client/Server 架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。客户端和服务器可以运行在同一个 Host 上，客户端也可以通过 socket 或 REST API 与远程的服务器通信。\nDocker daemon 一般在宿主主机后台运行，等待接收来自客户端的消息。 Docker 客户端则为用户提供一系列可执行命令，用户用这些命令实现跟 Docker daemon 交互。\n容器提供了在计算机上的隔离环境中安装和运行应用程序的方法。在容器内运行的应用程序仅可使用于为该容器分配的资源，例如：CPU，内存，磁盘，进程空间，用户，网络，卷等。在使用有限的容器资源的同时，并不与其他容器冲突。您可以将容器视为简易计算机上运行应用程序的隔离沙箱。\n1.4 我们如何使用docker?\n\n\n\n\n\n\n\n\n传统企业如何过渡到docker生态，可以参考如下步骤:\n\n先将部分业务服务进行容器化，并使用容器化部署；\n待企业内容技术人员对容器化相关技术熟悉后，逐步将所有服务全部容器化\n整合企业内部所有服务器资源，使用docker集群工具进行统一管理和分配资源，提高资源使用率\n搭建整个devops技术体系，研发、测试、发布流程逐步自动化\n继而使用docker集群工具如docker swarm或者k8s管理所有线上服务\n\n2、管理docker image镜像\n\n\n\n\n\n\n\n\ndocker客户端账号相关命令\n\n登录服务器\n\n有的docker远程仓库开启了登录认证，需要登录后才能拉取镜像、推送镜像等等\n\n\ndocker login [参数] [服务器地址]\n#####参数说明######\n# --password , -p\t\t登录密码\n# --password-stdin\t\t从标准输入流获取密码，也就是说通过shell命令输入密码的意思,不带password参数默认就是这种方式\n# --username , -u\t\t登录账号\n#######使用示例#######\ndocker login --username&#x3D;admin --password&#x3D;123456 192.168.10.12:5000\n1234567\n\n\n登出命令\n\n\n\n\n\n\n\n\n\n登出当前的docker账号，下次使用前需要先登录\n\n\ndocker logout [服务器地址]\n#eg. docker logout 192.168.10.12:5000\n12\n\n2.1 docker search 镜像搜索命令\n\n\n\n\n\n\n\n\n通过命令查找远程仓库里匹配的镜像信息\ndocker search [参数] 关键字\n#比如搜索redis的镜像\ndocker search redis\n#也可以配合shell命令一起使用\ndocker search redis |grep sentinel\n12345\n\n详细示例如下：\n#比如搜索redis的镜像\ndocker search redis\n#结果\nNAME                             DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED\nredis                            Redis is an open source key-value store that…   8204                [OK]                \nbitnami&#x2F;redis                    Bitnami Redis Docker Image                      145                                     [OK]\nsameersbn&#x2F;redis                                                                  80                                      [OK]\ngrokzen&#x2F;redis-cluster            Redis cluster 3.0, 3.2, 4.0, 5.0, 6.0           68   \n#更多的就不展开了\n123456789\n\n当然也可以到 Docker Hub官网进行搜索\n2.2 docker pull 镜像拉取命令\n\n\n\n\n\n\n\n\n从远程仓库拉取镜像到本地仓库\ndocker pull [参数] NAME[:TAG|@DIGEST]\n#####参数说明######\n# --all-tags , -a\t\t下载该镜像的所有版本\n# --disable-content-trust\ttrue\t跳过安全认证\n# --platform\t\t平台兼容性相关的参数\n# --quiet , -q\t\t不显示详细信息\n\n#比如拉取某个redis镜像\ndocker pull grokzen&#x2F;redis-cluster:5.0\n123456789\n2.3 docker rmi 删除本地镜像命令\n\n\n\n\n\n\n\n\n删除本地仓库中不需要再使用的镜像，比如一些过时的镜像\ndocker rmi [参数] 镜像名或者镜像ID [IMAGE...] #可以同时删除多个镜像\n#####参数说明######\n# --force , -f\t\t强制删除\n# --no-prune\t\t不删除未标记的父镜像\n1234\n2.4 docker images 查看镜像信息docker images [参数] [REPOSITORY[:TAG]]\n#####参数说明######\n# --all , -a\t\t展示所有镜像，默认就是这个操作\n# --digests\t\t展示镜像包签名信息\n# --filter , -f\t\t通过镜像某些信息过滤镜像,如镜像名、ID、标签等等\n# --format\t\t指定一个展示模板用于镜像信息的展示，比如说需要展示的内容及顺序，感觉没啥卵用\n# --no-trunc\t展示完整的容器ID信息\n# --quiet , -q\t\t只展示镜像ID\n12345678\n\n示例如下：\n#查看所有镜像信息\ndocker images\n#查看带关键字redis的镜像\ndocker images redis #或者 docker images |grep redis\ndocker images java:8 #带版本信息筛选\n#查看未标记的镜像\ndocker images --filter &quot;dangling&#x3D;true&quot;\n#查看带某个标签的镜像\ndocker images --filter &quot;label&#x3D;com.example.version&quot;\n#注：构建镜像时可以打label标签哦\n12345678910\n\n过滤器支持如下条件\n\ndangling (boolean - true or false) 筛选未tag的镜像\nlabel (label=&lt;key&gt; or label=&lt;key&gt;=&lt;value&gt;) 筛选带某个标记的镜像\nbefore (&lt;image-name&gt;[:&lt;tag&gt;], &lt;image id&gt; or &lt;image@digest&gt;) - 筛选某镜像某版本之前的镜像\nsince (&lt;image-name&gt;[:&lt;tag&gt;], &lt;image id&gt; or &lt;image@digest&gt;) - 筛选某镜像某版本开始以及之后的镜像\nreference (pattern of an image reference) - 筛选匹配描述信息的镜像\n\n2.5 docker tag 给镜像重命名docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]\n#示例如下\ndocker tag redis 192.168.10.12:5000&#x2F;danyuan&#x2F;redis #将官方的redis镜像更名为自己的私服的镜像，之后可以push到私服中\n123\n\n2.4 docker build 构建自己的镜像docker build [参数] PATH | URL | -\n#####参数说明######\n--add-host\t\tAdd a custom host-to-IP mapping (host:ip) 给容器内的&#x2F;etc&#x2F;hosts添加记录\n--build-arg\t\tSet build-time variables\n--cache-from\t\tImages to consider as cache sources\n--cgroup-parent\t\tOptional parent cgroup for the container\n--compress\t\tCompress the build context using gzip 镜像使用gzip进行压缩存储\n--cpu-period\t\tLimit the CPU CFS (Completely Fair Scheduler) period\n--cpu-quota\t\tLimit the CPU CFS (Completely Fair Scheduler) quota\n--cpu-shares , -c\t\tCPU shares (relative weight)\n--cpuset-cpus\t\tCPUs in which to allow execution (0-3, 0,1)\n--cpuset-mems\t\tMEMs in which to allow execution (0-3, 0,1)\n--disable-content-trust\ttrue\tSkip image verification\n--file , -f\t\tName of the Dockerfile (Default is ‘PATH&#x2F;Dockerfile’) 指定文件进行构建,默认为当前目录下的Dockerfile\n--force-rm\t\tAlways remove intermediate containers\n--iidfile\t\tWrite the image ID to the file\n--isolation\t\tContainer isolation technology\n--label\t\tSet metadata for an image\n--memory , -m\t\tMemory limit\n--memory-swap\t\tSwap limit equal to memory plus swap: ‘-1’ to enable unlimited swap\n--network\t\tAPI 1.25+ Set the networking mode for the RUN instructions during build\n--no-cache\t\tDo not use cache when building the image\n--output , -o\t\tAPI 1.40+ Output destination (format: type&#x3D;local,dest&#x3D;path) 输出构建信息到文件\n--platform\t\tAPI 1.38+ Set platform if server is multi-platform capable\n--progress\tauto\tSet type of progress output (auto, plain, tty). Use plain to show container output\n--pull\t\tAlways attempt to pull a newer version of the image\n--quiet , -q\t\tSuppress the build output and print image ID on success\n--rm\ttrue\tRemove intermediate containers after a successful build\n--secret\t\tAPI 1.39+\nSecret file to expose to the build (only if BuildKit enabled): id&#x3D;mysecret,src&#x3D;&#x2F;local&#x2F;secret\n--security-opt\t\tSecurity options\n--shm-size\t\tSize of &#x2F;dev&#x2F;shm\n--squash\t\texperimental (daemon)API 1.25+ Squash newly built layers into a single new layer\n--ssh\t\tAPI 1.39+ SSH agent socket or keys to expose to the build (only if BuildKit enabled) (format: default|[&#x3D;|[,]])\n--stream\t\texperimental (daemon)API 1.31+ Stream attaches to server to negotiate build context\n--tag , -t\t\tName and optionally a tag in the ‘name:tag’ format,给镜像重命名\n--target\t\tSet the target build stage to build.\n--ulimit\t\tUlimit options\n1234567891011121314151617181920212223242526272829303132333435363738\n\n示例如下：\n#执行当前目录下的Dockerfile文件内的镜像构建命令，并将生成的镜像命名\ndocker build -t 192.168.56.22:5000&#x2F;danyuanblog&#x2F;elk . \n#执行指定目录下的Dockerfile文件内的镜像构建命令，并将生成的镜像命名\ndocker build -f &#x2F;data&#x2F;docker&#x2F;elk&#x2F;Dockerfile -t 192.168.56.22:5000&#x2F;danyuanblog&#x2F;elk . \n1234\n\n2.5 docker push 推送镜像到远程仓库命令docker push [参数] NAME[:TAG]\n#####参数说明######\n--disable-content-trust\ttrue\t是否需要跳过镜像内容信任,默认跳过\n\n#示例\ndocker push registry-host:5000&#x2F;myadmin&#x2F;rhel-httpd\n123456\n\n3、创建docker container容器服务3.1 docker create 容器创建命令docker create [参数] IMAGE [COMMAND] [ARG...]\n#####参数说明######\n--add-host\t\tAdd a custom host-to-IP mapping (host:ip)\n--attach , -a\t\tAttach to STDIN, STDOUT or STDERR\n--blkio-weight\t\tBlock IO (relative weight), between 10 and 1000, or 0 to disable (default 0)\n--blkio-weight-device\t\tBlock IO weight (relative device weight)\n--cap-add\t\tAdd Linux capabilities\n--cap-drop\t\tDrop Linux capabilities\n--cgroup-parent\t\tOptional parent cgroup for the container\n--cidfile\t\tWrite the container ID to the file\n--cpu-count\t\tCPU count (Windows only)\n--cpu-percent\t\tCPU percent (Windows only)\n--cpu-period\t\tLimit CPU CFS (Completely Fair Scheduler) period\n--cpu-quota\t\tLimit CPU CFS (Completely Fair Scheduler) quota\n--cpu-rt-period\t\tAPI 1.25+\nLimit CPU real-time period in microseconds\n--cpu-rt-runtime\t\tAPI 1.25+\nLimit CPU real-time runtime in microseconds\n--cpu-shares , -c\t\tCPU shares (relative weight)\n--cpus\t\tAPI 1.25+\nNumber of CPUs\n--cpuset-cpus\t\tCPUs in which to allow execution (0-3, 0,1)\n--cpuset-mems\t\tMEMs in which to allow execution (0-3, 0,1)\n--device\t\tAdd a host device to the container\n--device-cgroup-rule\t\tAdd a rule to the cgroup allowed devices list\n--device-read-bps\t\tLimit read rate (bytes per second) from a device\n--device-read-iops\t\tLimit read rate (IO per second) from a device\n--device-write-bps\t\tLimit write rate (bytes per second) to a device\n--device-write-iops\t\tLimit write rate (IO per second) to a device\n--disable-content-trust\ttrue\tSkip image verification\n--dns\t\tSet custom DNS servers\n--dns-opt\t\tSet DNS options\n--dns-option\t\tSet DNS options\n--dns-search\t\tSet custom DNS search domains\n--domainname\t\tContainer NIS domain name\n--entrypoint\t\tOverwrite the default ENTRYPOINT of the image\n--env , -e\t\tSet environment variables\n--env-file\t\tRead in a file of environment variables\n--expose\t\tExpose a port or a range of ports\n--gpus\t\tAPI 1.40+\nGPU devices to add to the container (‘all’ to pass all GPUs)\n--group-add\t\tAdd additional groups to join\n--health-cmd\t\tCommand to run to check health\n--health-interval\t\tTime between running the check (ms|s|m|h) (default 0s)\n--health-retries\t\tConsecutive failures needed to report unhealthy\n--health-start-period\t\tAPI 1.29+\nStart period for the container to initialize before starting health-retries countdown (ms|s|m|h) (default 0s)\n--health-timeout\t\tMaximum time to allow one check to run (ms|s|m|h) (default 0s)\n--help\t\tPrint usage\n--hostname , -h\t\tContainer host name\n--init\t\tAPI 1.25+\nRun an init inside the container that forwards signals and reaps processes\n--interactive , -i\t\tKeep STDIN open even if not attached\n--io-maxbandwidth\t\tMaximum IO bandwidth limit for the system drive (Windows only)\n--io-maxiops\t\tMaximum IOps limit for the system drive (Windows only)\n--ip\t\tIPv4 address (e.g., 172.30.100.104)\n--ip6\t\tIPv6 address (e.g., 2001:db8::33)\n--ipc\t\tIPC mode to use\n--isolation\t\tContainer isolation technology\n--kernel-memory\t\tKernel memory limit\n--label , -l\t\tSet meta data on a container\n--label-file\t\tRead in a line delimited file of labels\n--link\t\tAdd link to another container\n--link-local-ip\t\tContainer IPv4&#x2F;IPv6 link-local addresses\n--log-driver\t\tLogging driver for the container\n--log-opt\t\tLog driver options\n--mac-address\t\tContainer MAC address (e.g., 92:d0:c6:0a:29:33)\n--memory , -m\t\tMemory limit\n--memory-reservation\t\tMemory soft limit\n--memory-swap\t\tSwap limit equal to memory plus swap: ‘-1’ to enable unlimited swap\n--memory-swappiness\t-1\tTune container memory swappiness (0 to 100)\n--mount\t\tAttach a filesystem mount to the container\n--name\t\tAssign a name to the container\n--net\t\tConnect a container to a network\n--net-alias\t\tAdd network-scoped alias for the container\n--network\t\tConnect a container to a network\n--network-alias\t\tAdd network-scoped alias for the container\n--no-healthcheck\t\tDisable any container-specified HEALTHCHECK\n--oom-kill-disable\t\tDisable OOM Killer\n--oom-score-adj\t\tTune host’s OOM preferences (-1000 to 1000)\n--pid\t\tPID namespace to use\n--pids-limit\t\tTune container pids limit (set -1 for unlimited)\n--platform\t\texperimental (daemon)API 1.32+\nSet platform if server is multi-platform capable\n--privileged\t\tGive extended privileges to this container\n--publish , -p\t\tPublish a container’s port(s) to the host\n--publish-all , -P\t\tPublish all exposed ports to random ports\n--read-only\t\tMount the container’s root filesystem as read only\n--restart\tno\tRestart policy to apply when a container exits\n--rm\t\tAutomatically remove the container when it exits\n--runtime\t\tRuntime to use for this container\n--security-opt\t\tSecurity Options\n--shm-size\t\tSize of &#x2F;dev&#x2F;shm\n--stop-signal\tSIGTERM\tSignal to stop a container\n--stop-timeout\t\tAPI 1.25+\nTimeout (in seconds) to stop a container\n--storage-opt\t\tStorage driver options for the container\n--sysctl\t\tSysctl options\n--tmpfs\t\tMount a tmpfs directory\n--tty , -t\t\tAllocate a pseudo-TTY\n--ulimit\t\tUlimit options\n--user , -u\t\tUsername or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])\n--userns\t\tUser namespace to use\n--uts\t\tUTS namespace to use\n--volume , -v\t\tBind mount a volume\n--volume-driver\t\tOptional volume driver for the container\n--volumes-from\t\tMount volumes from the specified container(s)\n--workdir , -w\t\tWorking directory inside the container\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108\n\n常用示例如下：\n\n指定基本信息，如名字、重启策略等等\n#创建一个redis服务，当检测到redis服务挂了，自动重启\ndocker create --restart always --name my-redis redis\n12\n指定端口映射\n#创建一个redis服务，当检测到redis服务挂了，自动重启,对外端口为2379\ndocker create -p 2379:6379 --restart always --name my-redis redis\n12\n指定磁盘目录挂载\n#创建一个redis服务，当检测到redis服务挂了，自动重启,对外端口为2379,并将配置文件挂载出来\ndocker create -p 2379:6379 -v &#x2F;data&#x2F;docker-data&#x2F;service&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf --restart always --name my-redis redis\n12\n指定网络模式\n#创建一个redis服务，当检测到redis服务挂了，自动重启,对外端口为2379,并将配置文件挂载出来,指定为自定义的网络模式\ndocker create --network some-network -p 2379:6379 -v &#x2F;data&#x2F;docker-data&#x2F;service&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf --restart always --name my-redis redis\n12\n指定资源限制\n#创建一个redis服务，当检测到redis服务挂了，自动重启,对外端口为2379,并将配置文件挂载出来,指定为自定义的网络模式,限制cpu使用权重、内存、磁盘使用\ndocker create --cpu-shares 512 -m 1G --memory-swap 3G --storage-opt size&#x3D;10G --network some-network -p 2379:6379 -v &#x2F;data&#x2F;docker-data&#x2F;service&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf --restart always --name my-redis redis\n#单个 CPU 为 1024，两个为 2048，以此类推\n123\n指定环境变量\n#创建一个redis服务，当检测到redis服务挂了，自动重启,对外端口为2379,并将配置文件挂载出来,指定为自定义的网络模式,限制cpu使用权重、内存、磁盘使用\ndocker create --cpu-shares 512 -m 1G --memory-swap 3G --storage-opt size&#x3D;10G --network some-network -p 2379:6379 -v &#x2F;data&#x2F;docker-data&#x2F;service&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf -e HOST_NAME&#x3D;danyuan --restart always --name my-redis redis\n#单个 CPU 为 1024，两个为 2048，以此类推\n123\n指定服务参数\n#创建一个redis服务，当检测到redis服务挂了，自动重启,对外端口为2379,并将配置文件挂载出来,指定为自定义的网络模式,限制cpu使用权重、内存、磁盘使用,指定redis服务参数\ndocker create --cpu-shares 512 -m 1G --memory-swap 3G --storage-opt size&#x3D;10G --network some-network -p 2379:6379 -v &#x2F;data&#x2F;docker-data&#x2F;service&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf --restart always --name my-redis redis --appendonly yes\n#单个 CPU 为 1024，两个为 2048，以此类推\n123\n\n3.2 docker run 创建并运行容器docker run [OPTIONS] IMAGE [COMMAND] [ARG...]\n#参数和docker create大多相同\n#多了以下参数\n--detach , -d\t\tRun container in background and print container ID,后台运行服务\n--detach-keys\t\tOverride the key sequence for detaching a container\n12345\n\n示例如下\n#创建并后台启动一个redis服务，当检测到redis服务挂了，自动重启,对外端口为6379,指定为共享主机网络模式,限制cpu使用权重、内存使用,指定redis服务参数\ndocker run -d --cpu-shares 512 -m 512M --memory-swap 1G --network host --restart always --name my-redis redis --appendonly yes\n#单个 CPU 为 1024，两个为 2048，以此类推\n123\n\n3.3 docker start 启动已存在的容器docker start [参数] CONTAINER [CONTAINER...]\n#####参数说明######\n--attach , -a\t\tAttach STDOUT&#x2F;STDERR and forward signals\n--checkpoint\t\texperimental (daemon)\nRestore from this checkpoint\n--checkpoint-dir\t\texperimental (daemon)\nUse a custom checkpoint storage directory\n--detach-keys\t\tOverride the key sequence for detaching a container\n--interactive , -i\t\tAttach container’s STDIN\n123456789\n\n示例如下\n#启动刚刚的redis服务\ndocker start my-redis\n12\n\n3.4 docker stop 停止正在运行的容器docker stop [OPTIONS] CONTAINER [CONTAINER...]\n#####参数说明######\n--time , -t\t10\tSeconds to wait for stop before killing it\n123\n\n示例如下\ndocker stop my-redis\n1\n\n3.5 docker restart 重启容器docker restart [OPTIONS] CONTAINER [CONTAINER...]\n#####参数说明######\n--time , -t\t10\tSeconds to wait for stop before killing the container\n123\n\n示例如下\ndocker restart my-redis\n1\n\n3.6 docker pause 暂停容器服务\n\n\n\n\n\n\n\n\n暂停状态的容器服务，无法对外提供服务\ndocker pause CONTAINER [CONTAINER...]\n#示例如下\ndocker pause my-redis\n123\n\n3.7 docker kill 杀掉某容器服务docker kill [参数] CONTAINER [CONTAINER...]\n#####参数说明######\n--signal , -s\tKILL\tSignal to send to the container\n#示例\ndocker kill my_redis  #作用和 kill pid 相同\ndocker kill --signal&#x3D;9 my_redis #作用和 kill -9 pid 相同\n123456\n\n3.8 docker rm 删除容器docker rm [参数] CONTAINER [CONTAINER...]\n#####参数说明######\n--force , -f\t\tForce the removal of a running container (uses SIGKILL),强制删除正在运行的容器\n--link , -l\t\tRemove the specified link\n--volumes , -v\t\tRemove anonymous volumes associated with the container\n12345\n\n示例如下\ndocker rm my-redis\ndocker rm -f my-redis\n12\n\n3.9 docker update 更新容器信息docker update [参数] CONTAINER [CONTAINER...]\n#####参数说明######\n--blkio-weight\t\tBlock IO (relative weight), between 10 and 1000, or 0 to disable (default 0)\n--cpu-period\t\tLimit CPU CFS (Completely Fair Scheduler) period\n--cpu-quota\t\tLimit CPU CFS (Completely Fair Scheduler) quota\n--cpu-rt-period\t\tAPI 1.25+\nLimit the CPU real-time period in microseconds\n--cpu-rt-runtime\t\tAPI 1.25+\nLimit the CPU real-time runtime in microseconds\n--cpu-shares , -c\t\tCPU shares (relative weight)\n--cpus\t\tAPI 1.29+\nNumber of CPUs\n--cpuset-cpus\t\tCPUs in which to allow execution (0-3, 0,1)\n--cpuset-mems\t\tMEMs in which to allow execution (0-3, 0,1)\n--kernel-memory\t\tKernel memory limit\n--memory , -m\t\tMemory limit\n--memory-reservation\t\tMemory soft limit\n--memory-swap\t\tSwap limit equal to memory plus swap: ‘-1’ to enable unlimited swap\n--pids-limit\t\tAPI 1.40+\nTune container pids limit (set -1 for unlimited)\n--restart\t\tRestart policy to apply when a container exits\n123456789101112131415161718192021\n\n示例如下\n#更新容器启动策略\ndocker update --restart&#x3D;always my-redis\n12\n\n4、查看docker container容器服务状态4.1 docker ps 查看容器信息docker ps [参数]\n#####参数说明######\n--all , -a\t\tShow all containers (default shows just running)\n--filter , -f\t\tFilter output based on conditions provided\n--format\t\tPretty-print containers using a Go template\n--last , -n\t-1\tShow n last created containers (includes all states)\n--latest , -l\t\tShow the latest created container (includes all states)\n--no-trunc\t\tDon’t truncate output\n--quiet , -q\t\tOnly display numeric IDs\n--size , -s\t\tDisplay total file sizes\n12345678910\n\n示例如下\n#查看所有正在运行的容器\ndocker ps\n#查看所有的容器\ndocker ps -a\n#查看最近创建的容器\ndocker ps -l\n#查看名字匹配的容器\ndocker ps -a |grep my-redis\n12345678\n\n4.2 docker stats 查看正在运行的容器资源使用情况docker stats [参数] [CONTAINER...]\n#####参数说明######\n--all , -a\t\tShow all containers (default shows just running)\n--format\t\tPretty-print images using a Go template\n--no-stream\t\tDisable streaming stats and only pull the first result\n--no-trunc\t\tDo not truncate output\n123456\n\n示例如下\n#查看所有容器资源使用情况\ndocker stats \n#查看某个容器资源占用情况\ndocker stats |grep my-redis\n1234\n\n4.3 docker logs 查看容器的日志信息docker logs [参数] CONTAINER\n#####参数说明######\n--details\t\tShow extra details provided to logs\n--follow , -f\t\tFollow log output\n--since\t\tShow logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes)\n--tail\tall\tNumber of lines to show from the end of the logs\n--timestamps , -t\t\tShow timestamps\n--until\t\tAPI 1.35+ Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes)\n12345678\n\n示例如下\n#查看最后500条日志信息\ndocker logs --tail 500 my-redis\n#查看最新500条日志，并持续查看最新的日志\ndocker logs --tail 500 -f my-redis\n1234\n\n4.4 docker top 查看容器内服务资源使用情况docker top CONTAINER [ps OPTIONS]\n#相当于你在linux上输入top命令一样的效果\n#示例如下\ndocker top my-redis\n1234\n\n4.5 docker inspect 查看某个容器的详细信息docker inspect [参数] NAME|ID [NAME|ID...]\n#####参数说明######\n--format , -f\t\tFormat the output using the given Go template\n--size , -s\t\tDisplay total file sizes if the type is container\n--type\t\tReturn JSON for specified type\n12345\n\n示例如下\n#查看容器所有信息\ndocker inspect my-redis\n#查看容器网络信息\ndocker inspect my-redis|grep Network\n#查看容器ip信息\ndocker inspect my-redis|grep IP\n123456\n\n4.6 docker port 查看容器端口映射情况docker port CONTAINER [PRIVATE_PORT[&#x2F;PROTO]]\n#示例如下\n docker port my-redis #查看网络映射情况\n docker port my-redis 6379&#x2F;tcp #查看改端口映射情况\n1234\n\n5、容器服务和宿主机如何交互docker exec [参数] CONTAINER COMMAND [ARG...]\n#####参数说明######\n--detach , -d\t\tDetached mode: run command in the background\n--detach-keys\t\tOverride the key sequence for detaching a container\n--env , -e\t\tAPI 1.25+ Set environment variables\n--interactive , -i\t\tKeep STDIN open even if not attached 开启可交互性能力，进入容器执行命令\n--privileged\t\tGive extended privileges to the command\n--tty , -t\t\tAllocate a pseudo-TTY\n--user , -u\t\tUsername or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])\n--workdir , -w\t\tAPI 1.35+\nWorking directory inside the container\n1234567891011\n\n示例如下\n#进入容器执行命令,就跟登录到linux主机上一样的操作\ndocker exec -it my-redis &#x2F;bin&#x2F;bash\n12\n\n6、使用docker搭建中间件基础服务示例6.1 搭建redis服务docker run -d --cpu-shares 512 -m 512M --memory-swap 1G --restart always --name redis redis --appendonly yes\n1\n\n6.2 搭建MariaDB服务sudo docker run -d --restart always --name mysql -p 3306:3306 -v &#x2F;data&#x2F;workspace&#x2F;service&#x2F;mysql&#x2F;old-data&#x2F;mysql:&#x2F;var&#x2F;lib&#x2F;mysql -v &#x2F;data&#x2F;workspace&#x2F;service&#x2F;mysql&#x2F;conf.d:&#x2F;etc&#x2F;mysql&#x2F;conf.d -v &#x2F;data&#x2F;workspace&#x2F;service&#x2F;mysql&#x2F;my.cnf:&#x2F;etc&#x2F;mysql&#x2F;my.cnf -e MYSQL_ROOT_PASSWORD&#x3D;&quot;123456&quot; mariadb:10.3\n1\n\n6.3 搭建MongoDB服务docker run -p 8069:80 -v &#x2F;var&#x2F;data&#x2F;mongodb:&#x2F;var&#x2F;lib&#x2F;mongodb -v &#x2F;var&#x2F;data&#x2F;mongo_conf&#x2F;config.js:&#x2F;opt&#x2F;countly&#x2F;api&#x2F;config.js  -v &#x2F;var&#x2F;data&#x2F;mongo_conf&#x2F;web&#x2F;config.js:&#x2F;opt&#x2F;countly&#x2F;frontend&#x2F;express&#x2F;config.js -d countly&#x2F;countly-server\n1\n\n6.4 搭建RabbitMQ服务docker run -d --restart always --name rabbitmq -p 15672:15672 -p 5672:5672 -e RABBITMQ_DEFAULT_USER&#x3D;admin -e RABBITMQ_DEFAULT_PASS&#x3D;admin rabbitmq:3-management\n1\n\n7、使用docker构建我们自己的服务镜像参考地址如下：\n\nspringboot应用制作docker镜像教程\ndocker基础镜像centos7-jdk8-logstash构建\n\n8、搭建portainer服务管理宿主机上的docker服务\n安装步骤\nmkdir -p &#x2F;data&#x2F;workspace&#x2F;service&#x2F;portainer&#x2F;data\n\nmkdir -p &#x2F;data&#x2F;workspace&#x2F;service&#x2F;portainer&#x2F;public\n\nwget http:&#x2F;&#x2F;www.danyuanblog.com&#x2F;file-gateway&#x2F;mediaDownload.do?mediaId&#x3D;5ec04f7b4c63637cd6ab5763 #下载汉化包\n\nunzip public.zip #解压汉化包\n\nmv public&#x2F;* &#x2F;data&#x2F;workspace&#x2F;service&#x2F;portainer&#x2F;public&#x2F; #移动汉化内容到需要挂载的资源目录下\n\ndocker run -d --restart always --name portainer -p 9000:9000 -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock  -v &#x2F;data&#x2F;workspace&#x2F;service&#x2F;portainer&#x2F;data:&#x2F;data  -v &#x2F;data&#x2F;workspace&#x2F;service&#x2F;portainer&#x2F;public:&#x2F;public portainer&#x2F;portainer \n\n123456789101112\n添加需要管理的主机\n\n访问地址：http://192.168.56.22:9000打开web后台\n\n初次进入设置管理员登录密码，然后登录\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dh3kwgy8-1590333357272)(http://www.danyuanblog.com/file-gateway//ueditor/jsp/upload/image/20200517/1589662278830069192.png)]\n进入后：\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kFp08xzQ-1590333357275)(http://www.danyuanblog.com/file-gateway//ueditor/jsp/upload/image/20200517/1589662351411086467.png)]\n\n添加节点到protainer中\n\n点击菜单： 端点 –&gt; 添加端点\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9hlHkYM4-1590333357278)(http://www.danyuanblog.com/file-gateway//ueditor/jsp/upload/image/20200517/1589662488794083232.png)]\n\n\n\n管理节点\n\n\n\n\n\n\n\n\n\n进入某个管理节点: 首页 –&gt; 点击某个管理节点\n\n\n\n\n\n9、更多docker资料\nspringboot应用制作docker镜像教程\ndocker基础镜像centos7-jdk8-logstash构建\nDocker swarm容器集群使用总结\n\n","slug":"74-Docker","date":"2021-09-13T15:49:32.000Z","categories_index":"Docker","tags_index":"Docker","author_index":"大黄"},{"id":"46276fa8df4cb43fb10a4919c6ba9d21","title":"SpringCloudALibaba Nacos","content":"01、SpringCloud Alibaba 简介\n\n1.1、SpringCloud Alibaba为何出现\n1.2、SpringCloud Alibaba是什么诞生：2018.10.31，Spring Cloud Alibaba正式入驻了Spring Cloud官网孵化器，并在Maven中央库发布了第一个版本。\nSpring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。\n依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。\n1.3、SpringCloud Alibaba能做什么\n服务限流降级：默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。\n服务注册与发现：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。\n分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新。\n消息驱动能力：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。\n分布式事务：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。\n阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。\n分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。\n阿里云短信服务：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。\n\n1.4、它的具体组件Sentinel\n阿里巴巴开源产品，把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\nNacos\n阿里巴巴开源产品，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\nRocketMQ\nApache RocketMQ™ 基于java以及高可用分布式集群技术的，提供低延时的、高可靠的消息发布与订阅服务。\nDubbo\nApache Dubbo™ 是一款高性能 Java RPC 框架。\nSeata\n阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。\nAlibaba Cloud OSS\n阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。\nAlibaba Cloud SchedulerX\n阿里中间件团队开发的一款分布式任务调度产品，支持周期性的任务与固定时间点触发任务。\nAlibaba Cloud SMS\n覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。\n1.5、它的 Maven 依赖&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;2.2.0.RELEASE&lt;&#x2F;version&gt;\n            &lt;type&gt;pom&lt;&#x2F;type&gt;\n            &lt;scope&gt;import&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;dependencyManagement&gt;\n\n\n\n1.6、SpringCloud Alibaba学习文档英文\nhttps://github.com/alibaba/spring-cloud-alibaba\nhttps://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html\n中文\nhttps://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md\n02、服务注册和配置中心  Nacos\n\n1.1、Nacos 能做什么Nacos（官网：nacos.io）是一个易于使用的平台，专为动态服务发现和配置以及服务管理而设计。它可以帮助您轻松构建云原生应用程序和微服务平台。\n服务是Nacos的一等公民。Nacos 支持几乎所有类型的服务，例如 Dubbo/gRPC 服务、Spring Cloud RESTFul 服务或Kubernetes 服务。\n一个更易于构建云原生应用的动态服务发现，配置管理和服务管理中心\n\nNacos：Dynamic Naming and Configuration Service\nNacos就是==注册中心+配置中心==的组合\n等价于：Nacos = Eureka+Config+Bus\n\n1.2、Nacos 主要功能1、服务发现和服务健康检查\nNacos 使服务通过 DNS 或 HTTP 接口注册自己和发现其他服务变得简单。Nacos 还提供服务的实时健康检查，以防止向不健康的主机或服务实例发送请求。\n2、动态配置管理\n动态配置服务允许您在所有环境中以集中和动态的方式管理所有服务的配置。Nacos 无需在更新配置时重新部署应用程序和服务，这使得配置更改更加高效和敏捷。\n3、动态 DNS 服务\nNacos 支持加权路由，让您更容易在数据中心内的生产环境中实现中层负载均衡、灵活的路由策略、流量控制和简单的 DNS 解析服务。它可以帮助您轻松实现基于 DNS 的服务发现，并防止应用程序耦合到特定于供应商的服务发现 API。\n4、服务和元数据管理\nNacos 提供了一个易于使用的服务仪表板，帮助您管理您的服务元数据、配置、kubernetes DNS、服务健康和指标统计。\n1.3、Nacos 在哪里GitHub：https://github.com/alibaba/Nacos\n官方文档：https://nacos.io/zh-cn/index.html\nhttps://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html\n1.4、各种注册中心比较\n    \n\n\n据说nacos在阿里巴巴内部有超过10万的实例运行，已经过了类似双十一等各种大型流量的考验\nCAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。\n1、一致性（C）\n在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）\n2、可用性（A）\n在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）\n3、分区容忍性（P）\n以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。\n==注意：CAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。==\n如果在某个分布式系统中数据无副本， 那么系统必然满足强一致性条件， 因为只有独一数据，不会出现数据不一致的情况，此时C和P两要素具备，但是如果系统发生了网络分区状况或者宕机，必然导致某些数据不可以访问，此时可用性条件就不能被满足，即在此情况下获得了CP系统，但是CAP不可同时满足。\n因此在进行分布式架构设计时，必须做出取舍。当前一般是通过分布式缓存中各节点的最终一致性来提高系统的性能，通过使用多节点之间的数据异步复制技术来实现集群化的数据一致性。\n\n\n\n\n\n\n\n\n\nNacos支持AP和CP模式的切换\ncurl -X PUT ‘$NACOS_SERVER:8848/nacos/v1/ns/operator/switches?entry=serverMode&amp;value=CP’\n1.5、安装并运行 Nacos\n本地Java8+Maven环境已经OK\n先从官网下载Nacos：https://github.com/alibaba/nacos/releases/tag/1.1.4\n解压安装包，直接运行bin/startup.cmd\n命令运行成功后直接访问：http://localhost:8848/nacos         默认账号密码都是nacos\n\n界面如下：\n\n    \n\n\n\n\n03、Nacos 作为服务注册中心\n\n1.1、基于Nacos的服务提供者新建模块：cloudalibaba-provider-payment9001\n父POM\n&lt;!--spring cloud alibaba 2.1.0.RELEASE--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.1.0.RELEASE&lt;&#x2F;version&gt;\n    &lt;type&gt;pom&lt;&#x2F;type&gt;\n    &lt;scope&gt;import&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\n本模块POM\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;\n        &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n        &lt;optional&gt;true&lt;&#x2F;optional&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n        &lt;optional&gt;true&lt;&#x2F;optional&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n        &lt;scope&gt;test&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\nYML\nserver:\n  port: 9001\n\nspring:\n  application:\n    name: nacos-payment-provider\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #配置Nacos地址\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: &#39;*&#39;  #默认只公开了&#x2F;health和&#x2F;info端点，要想暴露所有端点只需设置成星号\n\n主启动类\npackage com.atguigu.springcloud.alibaba;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class PaymentMain9001 &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(PaymentMain9001.class,args);\n    &#125;\n&#125;\n\n业务类\npackage com.atguigu.springcloud.alibaba.controller;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class PaymentController&#123;\n    @Value(&quot;$&#123;server.port&#125;&quot;)\n    private String serverPort;\n \n    @GetMapping(value &#x3D; &quot;&#x2F;payment&#x2F;nacos&#x2F;&#123;id&#125;&quot;)\n    public String getPayment(@PathVariable(&quot;id&quot;) Long id) &#123;\n        return &quot;nacos registry, serverPort: &quot;+ serverPort+&quot;\\t id&quot;+id;\n    &#125;\n&#125;\n\n测试：http://localhost:9001/payment/nacos/1，控制台如下：\n\n    \n\n\n\n\n1.2、演示nacos的负载均衡的准备参照9001新建9002，新建cloudalibaba-provider-payment9002，9002其他步骤你懂的，或者取巧不想新建重复体力劳动，==直接拷贝虚拟端口映射==\n\n    \n\n\n\n\n1.3、提供Nacos的服务消费者新建module：cloudalibaba-consumer-nacos-order83\nPOM\n&lt;dependencies&gt;\n    &lt;!--SpringCloud ailibaba nacos --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n        &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;cloud-api-commons&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;$&#123;project.version&#125;&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;\n        &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n        &lt;optional&gt;true&lt;&#x2F;optional&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n        &lt;optional&gt;true&lt;&#x2F;optional&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n        &lt;scope&gt;test&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\nYML\nserver:\n  port: 83\n\nspring:\n  application:\n    name: nacos-order-consumer\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848\n#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者【可选】，注意：nacos-payment-provider含有IP和端口)\nservice-url:\n  nacos-user-service: http:&#x2F;&#x2F;nacos-payment-provider\n\n主启动类\npackage com.atguigu.springcloud.alibaba;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class OrderNacosMain83&#123;\n    public static void main(String[] args)&#123;\n        SpringApplication.run(OrderNacosMain83.class,args);\n    &#125;\n&#125;\n\n定义负载均衡策略类，使用rest风格定义加载RestTemplate对象的配置类，及业务类\n\n\n测试：https://gitee.com/hrenxiang/picture/raw/master/img/alibaba-6.png\n1.4、注意这里虽然自定义了负载均衡的策略，但是我们发现我们并没有再任何地方引用，所以本案例中的负载均衡策略与我们定义的策略无关，是本身自带的策略\n04、Nacos 作为配置中心 - 基础配置\n\n\n\n设置DataId\n公式: ${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension}\n小总结说明\n\n    \n\n\n历史配置：Nacos会记录配置文件的历史版本默认保留30天\n05、Nacos 作为配置中心 - 分类配置\n\n1.1、多环境多项目管理如何管理问题1\n·    实际开发中，通常一个系统会准备\n·    dev开发环境\n·    test测试环境\n·    prod生产环境\n·    如何保证指定环境启动时服务能正确读取到 Nacos上相应环境的配置文件呢?\n问题2\n·    一个大型分布式微服务心痛会有很多微服务子项目\n·    每一个微服务项目又会相应的开发环境、测试环境、预发环境、正式环境….\n·    那怎么对这些微服务配置进行管理呢？\n1.2、Nacos的图形化管理界面\n\n1.3、Namespace+Group+Data ID最外层的namespace是可以用于区分部署环境的，Group和DataID逻辑上区分两个目标对象。\n\n\n默认情况：Namespace=public，Group=DEFAULT_GROUP，默认Cluster是DEFAULT\n\nNacos默认的命名空间是public，Namespace主要用来实现隔离。\n比方说我们现在有三个环境：开发、测试、生产环境，我们就可以创建三个Namespace，不同的 Namespace之间是隔离的。\n\nGroup默认是DEFAULT_GROUP，Group可以把不同的微服务划分到同一个分组里面去。\n\nService就是微服务；一个Service可以包含多个Cluster(集群)，Nacos默认Cluster是DEFAULTCluster是对指定微服务的一个虚拟划分。\n比方说为了容灾，将Service微服务分别部署在了杭州机房和广州机房，这时就可以给杭州机房的Service微服务起一个集群名称(HZ)，给广州机房的Service微服务起一个集群名字(GZ)，还可以尽量让同一个机房的微服务互相调用，以提升性能。\n\n最后是Instance，就是微服务的实例\n\n\n1.4、Data ID 方案==指定 spring.profile.active 和 配置文件的DataID 来使不同环境下读取不同的配置==\n默认空间 + 默认分组+ 新建dev 和 test 两个DataID\n新建dev配置DataID，新建test配置DataID\n\n通过spring.profile.active属性就能进行多环境下配置文件的读取，测试：http://localhost:3377/config/info\nspring:\n  profiles:\n    active: test #表示开发环境或者dev\n\n\n\n1.5、Group 方案通过Group实现环境区分\nData ID相同，分区不同，那我们可以按照不同的分区名称读取不同分区相同ID的服务\n\nbootstrap+application：在bootstrap中的config下加上 Group来指定 调用那个分区的服务（图片中的分区是我的另外一个分区）\n\n1.6、Namespace 方案YML，bootstrap\n# nacos配置\nserver:\n  port: 3377\n\nspring:\n  application:\n    name: nacos-config-client\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #Nacos服务注册中心地址\n      config:\n        server-addr: localhost:8848 #Nacos作为配置中心地址\n        file-extension: yaml #指定yaml格式的配置\n        group: DEV_GROUP\n        namespace: 7d8f0f5a-6a53-4785-9686-dd460158e5d4\n\napplication \nspring:\n  profiles:\n    active: dev # 表示开发环境\n    #active: test # 表示测试环境\n    #active: info\n\n\n\n06、Nacos集群和持久化配置（重要）\n\n1.1、集群部署架构图因此开源的时候推荐用户把所有服务列表放到一个vip下面，然后挂到一个域名下面\nhttp://ip1:port/openAPI 直连ip模式，机器挂则需要修改ip才可以使用。\nhttp://SLB:port/openAPI 挂载SLB模式(内网SLB，不可暴露到公网，以免带来安全风险)，直连SLB即可，下面挂server真实ip，可读性不好。\nhttp://nacos.com:port/openAPI 域名 + SLB模式(内网SLB，不可暴露到公网，以免带来安全风险)，可读性好，而且换ip方便，推荐模式\n\n    \n\n\n\n\n1.2、真实情况\n    \n\n\n\n\n1.3、Nacos 支持三种部署模式\n单机模式 - 用于测试和单机试用。\n集群模式 - 用于生产环境，确保高可用。\n多集群模式 - 用于多数据中心场景。\n\n默认Nacos使用嵌入式数据库实现数据的存储。所以，如果启动多个默认配置下的Nacos节点，数据存储是存在一致性问题多的。\n==为了解决这个问题，Nacos采用了集中式存储的方式来支持集群化部署，目前只支持MySQL 的存储。==\n文档：https://nacos.io/zh-cn/docs/deployment.html\n1.4、单机模式支持mysql在0.7版本之前，在单机模式时nacos使用嵌入式数据库实现数据的存储，不方便观察数据存储的基本情况。0.7版本增加了支持mysql数据源能力，具体的操作步骤：\n\n1.安装数据库，版本要求：5.6.5+\n2.初始化mysql数据库，数据库初始化文件：nacos-mysql.sql\n3.修改conf/application.properties文件，增加支持mysql数据源配置（目前只支持mysql），添加mysql数据源的url、用户名和密码。\n\nspring.datasource.platform&#x3D;mysql\n\ndb.num&#x3D;1\ndb.url.0&#x3D;jdbc:mysql:&#x2F;&#x2F;11.162.196.16:3306&#x2F;nacos_devtest?characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true\ndb.user&#x3D;nacos_devtest\ndb.password&#x3D;youdontknow\n\n再以单机模式启动nacos，nacos所有写嵌入式数据库的数据都写到了mysql\n1.5、Nacos持久化配置解释1、Nacos默认自带的是嵌入式数据库derby\nhttps://github.com/alibaba/nacos/blob/develop/config/pom.xml\n2、derby到mysql切换配置步骤\nnacos-server-1.1.4\\nacos\\conf目录下找到sql脚本\nnacos-mysql.sql\n执行脚本\nnacos-server-1.1.4\\nacos\\conf目录下找到application.properties\nspring.datasource.platform&#x3D;mysql     \ndb.num&#x3D;1  \ndb.url.0&#x3D;jdbc:mysql:&#x2F;&#x2F;11.162.196.16:3306&#x2F;nacos_devtest?characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true  \ndb.user&#x3D;nacos_devtest  \ndb.password&#x3D;youdontknow  \n\n3、启动nacos，可以看到是个全新的空记录界面，以前是记录进derby\n4、测试：新建配置，发现配置信息写入了MySQL数据库\n1.6、Linux版Nacos+MySQL配置\n预计需要，1个nginx+3个nacos注册中心+1个mysql\n\nNacos下载linux版本\n\nhttps://github.com/alibaba/nacos/releases/tag/1.1.4\nnacos-server-1.1.4.tar.gz\n\n\n1.7、集群配置步骤（重点）① 安装 nacos\n② vim application.propertiesspring.datasource.platform&#x3D;mysql\n\ndb.num&#x3D;1\ndb.url.0&#x3D;jdbc:mysql:&#x2F;&#x2F;192.168.137.128:3306&#x2F;nacos_config?characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true\ndb.user&#x3D;root\ndb.password&#x3D;Root123.\n\n③ 复制3台nacos梳理出3台nacos机器的不同服务端口号\n\n\n\n\n\n\n\n\n\n复制出cluster.conf\ncp cluster.conf.example cluster.conf\n\n\n\n\n\n\n\n\n\n\nvim cluster.conf\n192.168.96.66:3333\n192.168.96.66:4444\n192.168.96.66:5555\n\n这个IP不能写127.0.0.1,必须是Linux命令hostname -i能够识别的IP\n④ 编辑启动端\n\n\n\n\n\n\n\n\n编辑Nacos的启动脚本startup.sh，使它能够接受不同的启动端\n/nacos/bin目录下有startup.sh\n在什么地方，修改什么，怎么修改\n思考\n/nacos/bin目录下有startup.sh\n平时单机版的启动，都是./startup.sh即可。\n但是\n集群启动，我们希望可以类似其它软件的shell命令，传递不同的端口号启动不同的nacos实例。\n命令：./startup.sh -p 3333表示启动端口号为3333的nacos服务器实例，和上一步的cluster.conf配置的一致。\n修改内容\nvim startup.sh\n\n\n\n⑤ 启动 nacos\n⑥ 修改nginx.conf修改nginx的配置文件：vim /usr/local/nginx/conf/nginx.conf\nnginx.conf\nupstream cluster&#123; \n    server 192.168.137.128:3333;\n    server 192.168.137.128:4444;\n    server 192.168.137.128:5555;\n&#125;\n\nserver&#123;               \n    listen 1111;\n    server_name 192.168.137.128;\n    location &#x2F; &#123;\n         proxy_pass http:&#x2F;&#x2F;cluster;                        \n    &#125;\n....省略  \n\n⑦ 启动 nginxvim /usr/local/nginx/sbin\n.&#x2F;nginx    .&#x2F;nginx -s start      .&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf\n\n.&#x2F;nginx -s stop\n\n⑧ 测试通过nginx访问nacoshttps:// 192.168.137.128:1111/nacos/#/login\n⑨ 新建一个配置测试\n\n⑩ 微服务启动注册进nacos集群修改 cloudalibaba-provider-payment9002\nyml \n\n1.8、高可用小总结\n","slug":"72-SpringCloudAlibaba-Nacos","date":"2021-09-13T15:48:32.000Z","categories_index":"SpringCloud Alibaba","tags_index":"SpringCloud Alibaba","author_index":"大黄"},{"id":"2254a0dbf3036d34e7e7cb5837d981ff","title":"SpringCloud Slueth","content":"1、概述随着业务发展，系统拆分导致系统调用链路愈发复杂一个前端请求可能最终需要调用很多次后端服务才能完成，当整个请求变慢或不可用时，我们是无法得知该请求是由某个或某些后端服务引起的，这时就需要解决如何快读定位服务故障点，以对症下药。于是就有了分布式系统调用跟踪的诞生。\n现今业界分布式服务跟踪的理论基础主要来自于 Google 的一篇论文《Dapper, a Large-Scale Distributed Systems Tracing Infrastructure》，使用最为广泛的开源实现是 Twitter 的 Zipkin，为了实现平台无关、厂商无关的分布式服务跟踪，CNCF 发布了布式服务跟踪标准 Open Tracing。国内，淘宝的“鹰眼”、京东的“Hydra”、大众点评的“CAT”、新浪的“Watchman”、唯品会的“Microscope”、窝窝网的“Tracing”都是这样的系统。\n2、Spring Cloud Sleuth一般的，一个分布式服务跟踪系统，主要有三部分：数据收集、数据存储和数据展示。根据系统大小不同，每一部分的结构又有一定变化。譬如，对于大规模分布式系统，数据存储可分为实时数据和全量数据两部分，实时数据用于故障排查（troubleshooting），全量数据用于系统优化；数据收集除了支持平台无关和开发语言无关系统的数据收集，还包括异步数据收集（需要跟踪队列中的消息，保证调用的连贯性），以及确保更小的侵入性；数据展示又涉及到数据挖掘和分析。虽然每一部分都可能变得很复杂，但基本原理都类似。\n\n服务追踪的追踪单元是从客户发起请求（request）抵达被追踪系统的边界开始，到被追踪系统向客户返回响应（response）为止的过程，称为一个“trace”。每个 trace 中会调用若干个服务，为了记录调用了哪些服务，以及每次调用的消耗时间等信息，在每次调用服务时，埋入一个调用记录，称为一个“span”。这样，若干个有序的 span 就组成了一个 trace。在系统向外界提供服务的过程中，会不断地有请求和响应发生，也就会不断生成 trace，把这些带有span 的 trace 记录下来，就可以描绘出一幅系统的服务拓扑图。附带上 span 中的响应时间，以及请求成功与否等信息，就可以在发生问题的时候，找到异常的服务；根据历史数据，还可以从系统整体层面分析出哪里性能差，定位性能优化的目标。\nSpring Cloud Sleuth为服务之间调用提供链路追踪。通过Sleuth可以很清楚的了解到一个服务请求经过了哪些服务，每个服务处理花费了多长。从而让我们可以很方便的理清各微服务间的调用关系。此外Sleuth可以帮助我们：\n\n耗时分析: 通过Sleuth可以很方便的了解到每个采样请求的耗时，从而分析出哪些服务调用比较耗时;\n可视化错误: 对于程序未捕捉的异常，可以通过集成Zipkin服务界面上看到;\n链路优化: 对于调用比较频繁的服务，可以针对这些服务实施一些优化措施。\n\nspring cloud sleuth可以结合zipkin，将信息发送到zipkin，利用zipkin的存储来存储信息，利用zipkin ui来展示数据。\n这是Spring Cloud Sleuth的概念图：\n\n3、ZipKinZipkin 是一个开放源代码分布式的跟踪系统，由Twitter公司开源，它致力于收集服务的定时数据，以解决微服务架构中的延迟问题，包括数据的收集、存储、查找和展现。\n每个服务向zipkin报告计时数据，zipkin会根据调用关系通过Zipkin UI生成依赖关系图，显示了多少跟踪请求通过每个服务，该系统让开发者可通过一个 Web 前端轻松的收集和分析数据，例如用户每次请求服务的处理时间等，可方便的监测系统中存在的瓶颈。\nZipkin提供了可插拔数据存储方式：In-Memory、MySql、Cassandra以及Elasticsearch。接下来的测试为方便直接采用In-Memory方式进行存储，生产推荐Elasticsearch。\n4、快速上手创建zipkin-server项目项目依赖\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;io.zipkin.java&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;zipkin-server&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;io.zipkin.java&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;zipkin-autoconfigure-ui&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n启动类\n@SpringBootApplication\n@EnableEurekaClient\n@EnableZipkinServer\npublic class ZipkinApplication &#123;\n\n    public static void main(String[] args) &#123;\n        SpringApplication.run(ZipkinApplication.class, args);\n    &#125;\n\n&#125;\n\n使用了@EnableZipkinServer注解，启用Zipkin服务。\n配置文件\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F;\nserver:\n  port: 9000\nspring:\n  application:\n    name: zipkin-server\n\n配置完成后依次启动示例项目：spring-cloud-eureka、zipkin-server项目。刚问地址:http://localhost:9000/zipkin/可以看到Zipkin后台页面\n\n项目添加zipkin支持在项目spring-cloud-producer和spring-cloud-zuul中添加zipkin的支持。\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\nSpring应用在监测到Java依赖包中有sleuth和zipkin后，会自动在RestTemplate的调用过程中向HTTP请求注入追踪信息，并向Zipkin Server发送这些信息。\n同时配置文件中添加如下代码：\nspring:\n  zipkin:\n    base-url: http:&#x2F;&#x2F;localhost:9000\n  sleuth:\n    sampler:\n      percentage: 1.0\n\nspring.zipkin.base-url指定了Zipkin服务器的地址，spring.sleuth.sampler.percentage将采样比例设置为1.0，也就是全部都需要。\nSpring Cloud Sleuth有一个Sampler策略，可以通过这个实现类来控制采样算法。采样器不会阻碍span相关id的产生，但是会对导出以及附加事件标签的相关操作造成影响。 Sleuth默认采样算法的实现是Reservoir sampling，具体的实现类是PercentageBasedSampler，默认的采样比例为: 0.1(即10%)。不过我们可以通过spring.sleuth.sampler.percentage来设置，所设置的值介于0.0到1.0之间，1.0则表示全部采集。\n这两个项目添加zipkin之后，依次进行启动。\n进行验证这样我们就模拟了这样一个场景，通过外部请求访问Zuul网关，Zuul网关去调用spring-cloud-producer对外提供的服务。\n四个项目均启动后，在浏览器中访问地址：http://localhost:8888/producer/hello?name=neo 两次，然后再打开地址： http://localhost:9000/zipkin/点击对应按钮进行查看。\n点击查找看到有两条记录\n\n点击记录进去页面，可以看到每一个服务所耗费的时间和顺序\n\n点击依赖分析，可以看到项目之间的调用关系\n\n","slug":"71-SpringCloud-Slueth","date":"2021-09-13T15:47:32.000Z","categories_index":"SpringCloud","tags_index":"SpringCloud","author_index":"大黄"},{"id":"6dd02a05274ef2720cdd348b80b5ceee","title":"SpringCloud GateWay","content":"一、SpringCloud Gateway 网关\n\n1、Gateway 的概念SpringCloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。\nSpringCloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Zuul，在Spring Cloud 2.0以上版本中，没有对新版本的Zuul 2.0以上最新高性能版本进行集成，仍然还是使用的Zuul 2.0之前的非Reactor模式的老版本。而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。\nSpring Cloud Gateway 的目标，不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，和限流。\n提前声明：Spring Cloud Gateway 底层使用了高性能的通信框架Netty。\n2、Gateway 的作用 网关是整个微服务API请求的入口，负责拦截所有请求，分发到服务上去。可以实现反向代理、日志拦截、权限控制、解决跨域问题、限流、熔断、负载均衡，隐藏服务端的ip，黑名单与白名单拦截、授权等\n3、过滤器和网关的对比过滤器：对单个服务器的请求进行拦截控制\n网关：对所有的服务器的请求进行拦截控制\n4、zuul 和 gateway的对比zuul：是Netflix的，是基于servlet实现的，阻塞式的api，不支持长连接。\ngateway：是springcloud自己研制的微服务网关，是基于Spring5构建，能够实现响应式非阻塞式的Api，支持长连接\n\n\n\n\n\n\n\n\n\nSpring在2017年下半年迎来了Webflux，Webflux的出现填补了Spring在响应式编程上的空白，Webflux的响应式编程不仅仅是编程风格的改变，而且对于一系列的著名框架，都提供了响应式访问的开发包，比如Netty、Redis等等。\n==SpringCloud Gateway 使用的Webflux中的reactor-netty响应式编程组件，底层使用了Netty通讯框架。==\n5、Gateway 和 Nginx 的却别相同点：都是可以实现对api接口的拦截，负载均衡、反向代理、请求过滤等，可以实现和网关一样的效果。\n不同点：Nginx采用C语言编写，Gateway属于Java语言编写的， 能够更好让我们使用java语言来实现对请求的处理。\nNginx 属于服务器端负载均衡器。\nGateway 属于本地负载均衡器，因为是java 编写，所以速度上可能会较慢\n6、Gateway 的组成\nFilter 过滤器\n和Zuul的过滤器在概念上类似，可以使用它拦截和修改请求，并且对上游的响应，进行二次处理。过滤器为org.springframework.cloud.gateway.filter.GatewayFilter类的实例。\n\nRoute 路由\n网关配置的基本组成模块，和Zuul的路由配置模块类似。一个Route模块由一个 ID，一个目标 URI，一组断言和一组过滤器定义。如果断言为真，则路由匹配，目标URI会被访问。\n\nPredicate 断言\n这是一个 Java 8 的 Predicate，可以使用它来匹配来自 HTTP 请求的任何内容，例如 headers 或参数。断言的输入类型是一个 ServerWebExchange。\n\n\n7、Gateway 流程\n  \n\n\na. 客户端发送请求，会到达网关的DispatcherHandler处理，匹配到RoutePredicateHandlerMapping。\nb. 根据RoutePredicateHandlerMapping匹配到具体的路由策略。\nc. FilteringWebHandler获取的路由的GatewayFilter数组，创建 GatewayFilterChain 处理过滤请求\nd. 执行我们的代理业务逻辑访问。\n二、路由配置方式\n\n1、基础 URI 路由配置方式如果请求的目标地址，匹配的是单个的Uri 资源路径，配置文件示例如下：\n\n各字段含义如下：\nid：我们自定义的路由 ID，保持唯一\nuri：目标服务地址\npredicates：路由条件，Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。\n上面这段配置的意思是，配置了一个 id 为 url-proxy-1的URI代理规则，路由的规则为：\n当访问地址http://localhost:8080/csdn/1.jsp时，\n会路由到上游地址https://blog.csdn.net/1.jsp。\n2、基于代码的路由配置方式转发功能同样可以通过代码来实现，我们可以在启动类 GateWayApplication 中添加方法 customRouteLocator() 来定制转发规则。\n\n我们在yaml配置文件中注销掉相关路由的配置，重启服务，访问链接：http://localhost:8080/ csdn， 可以看到和上面一样的页面，证明我们测试成功。\n上面两个示例中 uri 都是指向了我的CSDN博客，在实际项目使用中可以将 uri 指向对外提供服务的项目地址，统一对外输出接口。\n3、和注册中心相结合的路由配置在uri的schema协议部分为自定义的lb:类型，表示从微服务注册中心（如Eureka）订阅服务，并且进行服务的路由。\n一个典型的示例如下：\n\n#lb是一个动态路由协议，后面的是要跳转的服务名称。\n\n注册中心相结合的路由配置方式，与单个URI的路由配置，区别其实很小，仅仅在于URI的schema协议不同。单个URI的地址的schema协议，一般为http或者https协议。\n三、路由匹配规则\n\nSpring Cloud Gateway 的功能很强大，我们仅仅通过 Predicates 的设计就可以看出来，前面我们只是使用了 predicates 进行了简单的条件匹配，其实 Spring Cloud Gataway 帮我们内置了很多 Predicates 功能。\nSpring Cloud Gateway 是通过 Spring WebFlux 的 HandlerMapping 做为底层支持来匹配到转发路由，Spring Cloud Gateway 内置了很多 Predicates 工厂，这些 Predicates 工厂通过不同的 HTTP 请求参数来匹配，多个 Predicates 工厂可以组合使用。\n\n\n\n\n三大元素\n解释\n\n\n\n\nRoute（路由）\n路由是网关的基本单元，由ID、URI、一组Predicate、一组Filter组成，根据Predicate进行匹配转发。\n\n\n\nPredicate（谓语、断言）\n路由转发的判断条件，目前SpringCloud Gateway支持多种方式，常见如：Path、Query、Method、Header等，写法必须遵循 key=vlue的形式\n\n\n\nFilter（过滤器）\n过滤器是路由转发请求时所经过的过滤逻辑，可用于修改请求、响应内容\n\n\n\n==其中Route和Predicate必须同时申明==\n例子：\n&#x2F;&#x2F;通过配置文件配置\nspring:\n  cloud:\n    gateway:\n      routes:\n        - id: gate_route\n          uri: http:&#x2F;&#x2F;localhost:9023\n          predicates:\n          ## 当请求的路径为gate、rule开头的时，转发到http:&#x2F;&#x2F;localhost:9023服务器上\n            - Path&#x3D;&#x2F;gate&#x2F;**,&#x2F;rule&#x2F;**\n        ### 请求路径前加上&#x2F;app\n          filters:\n          - PrefixPath&#x3D;&#x2F;app\n\n\n\n1、Predicate 断言条件(转发规则)介绍Predicate 来源于 Java 8，是 Java 8 中引入的一个函数，Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。可以用于接口请求参数校验、判断新老数据是否有变化需要进行更新操作。\n在 Spring Cloud Gateway 中 Spring 利用 Predicate 的特性实现了各种路由匹配规则，有通过 Header、请求参数等不同的条件来进行作为条件匹配到对应的路由。网上有一张图总结了 Spring Cloud 内置的几种 Predicate 的实现。\n\n  \n\n\n说白了 Predicate 就是为了实现一组匹配规则，方便让请求过来找到对应的 Route 进行处理，接下来我们接下 Spring Cloud GateWay 内置几种 Predicate 的使用。\n\n转发规则（predicates），假设 转发uri都设定为***http://localhost:9023***\n\n\n\n\n规则\n实例\n说明\n\n\n\nPath\n- Path=/gate/,/rule/\n## 当请求的路径为gate、rule开头的时，转发到http://localhost:9023服务器上\n\n\nBefore\n- Before=2017-01-20T17:42:47.789-07:00[America/Denver]\n在某个时间之前的请求才会被转发到 http://localhost:9023服务器上\n\n\nAfter\n- After=2017-01-20T17:42:47.789-07:00[America/Denver]\n在某个时间之后的请求才会被转发\n\n\nBetween\n- Between=2017-01-20T17:42:47.789-07:00[America/Denver],2017-01-21T17:42:47.789-07:00[America/Denver]\n在某个时间段之间的才会被转发\n\n\nCookie\n- Cookie=chocolate, ch.p\n名为chocolate的表单或者满足正则ch.p的表单才会被匹配到进行请求转发\n\n\nHeader\n- Header=X-Request-Id, \\d+\n携带参数X-Request-Id或者满足\\d+的请求头才会匹配\n\n\nHost\n- Host=www.hd123.com\n当主机名为www.hd123.com的时候直接转发到http://localhost:9023服务器上\n\n\nMethod\n- Method=GET\n只有GET方法才会匹配转发请求，还可以限定POST、PUT等请求方式\n\n\n2、通过请求参数匹配Query Route Predicate 支持传入两个参数，一个是属性名一个为属性值，属性值可以是正则表达式。\nserver:\n  port: 8080\nspring:\n  application:\n  \t name: api-gateway\n  cloud:\n    gateway:\n      routes:\n        -id: gateway-service\n          uri: https:&#x2F;&#x2F;www.baidu.com\n          order: 0\n          predicates:\n            -Query&#x3D;smile\n\n这样配置，只要请求中包含 smile 属性的参数即可匹配路由。\n使用 curl 测试，命令行输入:\ncurl localhost:8080?smile=x&amp;id=2\n经过测试发现只要请求汇总带有 smile 参数即会匹配路由，不带 smile 参数则不会匹配。\n还可以将 Query 的值以键值对的方式进行配置，这样在请求过来时会对属性值和正则进行匹配，匹配上才会走路由。\nserver:\n\n  port: 8080\n\nspring:\n\n  application:\n\n    name: api-gateway\n\n  cloud:\n\n    gateway:\n\n      routes:\n\n        -id: gateway-service\n\n          uri: https:&#x2F;&#x2F;www.baidu.com\n\n          order: 0\n\n          predicates:\n\n            -Query&#x3D;keep, pu.\n\n这样只要当请求中包含 keep 属性并且参数值是以 pu 开头的长度为三位的字符串才会进行匹配和路由。\n使用 curl 测试，命令行输入:\ncurl localhost:8080?keep=pub\n测试可以返回页面代码，将 keep 的属性值改为 pubx 再次访问就会报 404,证明路由需要匹配正则表达式才会进行路由。\n3、通过 Header 属性匹配Header Route Predicate 和 Cookie Route Predicate 一样，也是接收 2 个参数，一个 header 中属性名称和一个正则表达式，这个属性值和正则表达式匹配则执行。\nserver:\n\n  port: 8080\n\nspring:\n\n  application:\n\n    name: api-gateway\n\n  cloud:\n\n    gateway:\n\n      routes:\n\n        -id: gateway-service\n\n          uri: https:&#x2F;&#x2F;www.baidu.com\n\n          order: 0\n\n          predicates:\n\n            - Header&#x3D;X-Request-Id, \\d+\n\n使用 curl 测试，命令行输入:\ncurl http://localhost:8080 -H “X-Request-Id:88”\n则返回页面代码证明匹配成功。将参数-H “X-Request-Id:88”改为-H “X-Request-Id:spring”再次执行时返回404证明没有匹配。\n4、通过 Cookie 匹配Cookie Route Predicate 可以接收两个参数，一个是 Cookie name ,一个是正则表达式，路由规则会通过获取对应的 Cookie name 值和正则表达式去匹配，如果匹配上就会执行路由，如果没有匹配上则不执行。\nserver:\n  port: 8080\nspring:\n  application:\n    name: api-gateway\n  cloud:\n    gateway:\n      routes:\n        -id: gateway-service\n          uri: https:&#x2F;&#x2F;www.baidu.com\n          order: 0\n          predicates:\n            - Cookie&#x3D;sessionId, test\n\n使用 curl 测试，命令行输入:\ncurl http://localhost:8080 –cookie “sessionId=test”\n则会返回页面代码，如果去掉–cookie “sessionId=test”，后台汇报 404 错误。\n5、通过 Host 匹配Host Route Predicate 接收一组参数，一组匹配的域名列表，这个模板是一个 ant 分隔的模板，用.号作为分隔符。它通过参数中的主机地址作为匹配规则。\nserver:\n\n  port: 8080\n\nspring:\n\n  application:\n\n    name: api-gateway\n\n  cloud:\n\n    gateway:\n\n      routes:\n\n        -id: gateway-service\n\n          uri: https:&#x2F;&#x2F;www.baidu.com\n\n          order: 0\n\n          predicates:\n\n            - Host&#x3D;**.baidu.com\n\n使用 curl 测试，命令行输入:\ncurl http://localhost:8080 -H “Host: www.baidu.com&quot;\ncurl http://localhost:8080 -H “Host: md.baidu.com”\n经测试以上两种 host 均可匹配到 host_route 路由，去掉 host 参数则会报 404 错误。\n6、通过请求方式匹配可以通过是 POST、GET、PUT、DELETE 等不同的请求方式来进行路由。\nserver:\n\n  port: 8080\n\nspring:\n\n  application:\n\n    name: api-gateway\n\n  cloud:\n\n    gateway:\n\n      routes:\n\n        -id: gateway-service\n\n          uri: https:&#x2F;&#x2F;www.baidu.com\n\n          order: 0\n\n          predicates:\n\n            - Method&#x3D;GET\n\n使用 curl 测试，命令行输入:\n# curl 默认是以 GET 的方式去请求\ncurl http://localhost:8080\n测试返回页面代码，证明匹配到路由，我们再以 POST 的方式请求测试。\n# curl 默认是以 GET 的方式去请求\ncurl -X POST http://localhost:8080\n返回 404 没有找到，证明没有匹配上路由\n7、通过请求路径匹配Path Route Predicate 接收一个匹配路径的参数来判断是否走路由。\nserver:\n\n  port: 8080\n\nspring:\n\n  application:\n\n    name: api-gateway\n\n  cloud:\n\n    gateway:\n\n      routes:\n\n        -id: gateway-service\n\n          uri: http:&#x2F;&#x2F;ityouknow.com\n\n          order: 0\n\n          predicates:\n\n            -Path&#x3D;&#x2F;foo&#x2F;&#123;segment&#125;\n\n如果请求路径符合要求，则此路由将匹配，例如：/foo/1 或者 /foo/bar。\n使用 curl 测试，命令行输入:\ncurl http://localhost:8080/foo/1\ncurl http://localhost:8080/foo/xx\ncurl http://localhost:8080/boo/xx\n经过测试第一和第二条命令可以正常获取到页面返回值，最后一个命令报404，证明路由是通过指定路由来匹配。\n8、通过请求 ip 地址进行匹配Predicate 也支持通过设置某个 ip 区间号段的请求才会路由，RemoteAddr Route Predicate 接受 cidr 符号(IPv4 或 IPv6 )字符串的列表(最小大小为1)，例如 192.168.0.1/16 (其中 192.168.0.1 是 IP 地址，16 是子网掩码)。\nserver:\n\n  port: 8080\n\nspring:\n\n  application:\n\n    name: api-gateway\n\n  cloud:\n\n    gateway:\n\n      routes:\n\n        - id: gateway-service\n\n          uri: https:&#x2F;&#x2F;www.baidu.com\n\n          order: 0\n\n          predicates:\n\n            - RemoteAddr&#x3D;192.168.1.1&#x2F;24\n\n可以将此地址设置为本机的 ip 地址进行测试。\ncurl localhost:8080\n如果请求的远程地址是 192.168.1.10，则此路由将匹配。\n9、组合使用server:\n  port: 8080\nspring:\n  application:\n    name: api-gateway\n  cloud:\n    gateway:\n      routes:\n        - id: gateway-service\n          uri: https:&#x2F;&#x2F;www.baidu.com\n          order: 0\n          predicates:\n            - Host&#x3D;**.foo.org\n            - Path&#x3D;&#x2F;headers\n            - Method&#x3D;GET\n            - Header&#x3D;X-Request-Id, \\d+\n            - Query&#x3D;foo, ba.\n            - Query&#x3D;baz\n            - Cookie&#x3D;chocolate, ch.p\n\n各种 Predicates 同时存在于同一个路由时，请求必须同时满足所有的条件才被这个路由匹配。\n一个请求满足多个路由的断言条件时，请求只会被首个成功匹配的路由转发\n四、过滤器规则（Filter）Gateway filter 多达31种\nhttps://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.2.RELEASE/reference/html/#gatewayfilter-factories\n\n\n\n过滤规则\n实例\n说明\n\n\n\nPrefixPath\n- PrefixPath=/app\n在请求路径前加上app\n\n\nRewritePath\n- RewritePath=/test, /app/test\n访问localhost:9022/test,请求会转发到localhost:8001/app/test\n\n\nSetPath\nSetPath=/app/{path}\n通过模板设置路径，转发的规则时会在路径前增加app，{path}表示原请求路径\n\n\nRedirectTo\n\n重定向\n\n\nRemoveRequestHeader\n\n去掉某个请求头信息\n\n\n注：当配置多个filter时，优先定义的会被调用，剩余的filter将不会生效\nPrefixPath对所有的请求路径添加前缀：\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: prefixpath_route\n        uri: https:&#x2F;&#x2F;example.org\n        filters:\n        - PrefixPath&#x3D;&#x2F;mypath\n\n访问/hello的请求被发送到https://example.org/mypath/hello。\nRedirectTo重定向，配置包含重定向的返回码和地址：\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: prefixpath_route\n        uri: https:&#x2F;&#x2F;example.org\n        filters:\n        - RedirectTo&#x3D;302, https:&#x2F;&#x2F;acme.org\n\nRemoveRequestHeader去掉某个请求头信息：\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: removerequestheader_route\n        uri: https:&#x2F;&#x2F;example.org\n        filters:\n        - RemoveRequestHeader&#x3D;X-Request-Foo\n\n去掉请求头信息 X-Request-Foo\nRemoveResponseHeader去掉某个回执头信息：\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: removerequestheader_route\n        uri: https:&#x2F;&#x2F;example.org\n        filters:\n        - RemoveResponseHeader&#x3D;X-Request-Foo\n\nRemoveRequestParameter去掉某个请求参数信息：\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: removerequestparameter_route\n        uri: https:&#x2F;&#x2F;example.org\n        filters:\n        - RemoveRequestParameter&#x3D;red\n\nRewritePath改写路径：\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: rewrite_filter\n        uri: http:&#x2F;&#x2F;localhost:8081\n        predicates:\n        - Path&#x3D;&#x2F;test&#x2F;**\n        filters:\n        - RewritePath&#x3D;&#x2F;where(?&lt;segment&gt;&#x2F;?.*), &#x2F;test(?&lt;segment&gt;&#x2F;?.*)\n\n/where/… 改成 test/…\n使用代码改下路径\nRouteLocatorBuilder.Builder builder &#x3D; routeLocatorBuilder.routes();\n   builder\n           .route(&quot;path_rote_at_guigu&quot;, r -&gt; r.path(&quot;&#x2F;guonei&quot;)\n                   .uri(&quot;http:&#x2F;&#x2F;news.baidu.com&#x2F;guonei&quot;))\n           .route(&quot;csdn_route&quot;, r -&gt; r.path(&quot;&#x2F;csdn&quot;)\n                   .uri(&quot;https:&#x2F;&#x2F;blog.csdn.net&quot;))\n           .route(&quot;blog3_rewrite_filter&quot;, r -&gt; r.path(&quot;&#x2F;blog3&#x2F;**&quot;)\n                   .filters(f -&gt; f.rewritePath(&quot;&#x2F;blog3&#x2F;(?&lt;segment&gt;.*)&quot;, &quot;&#x2F;$\\\\&#123;segment&#125;&quot;))\n                   .uri(&quot;https:&#x2F;&#x2F;blog.csdn.net&quot;))\n           .route(&quot;rewritepath_route&quot;, r -&gt; r.path(&quot;&#x2F;baidu&#x2F;**&quot;)\n                   .filters(f -&gt; f.rewritePath(&quot;&#x2F;baidu&#x2F;(?&lt;segment&gt;.*)&quot;, &quot;&#x2F;$\\\\&#123;segment&#125;&quot;))\n                   .uri(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;))\n\n           .build();\n\nSetPath设置请求路径，与RewritePath类似。\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: setpath_route\n        uri: https:&#x2F;&#x2F;example.org\n        predicates:\n        - Path&#x3D;&#x2F;red&#x2F;&#123;segment&#125;\n        filters:\n        - SetPath&#x3D;&#x2F;&#123;segment&#125;\n\n如/red/blue的请求被转发到/blue。\nSetRequestHeader设置请求头信息。\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: setrequestheader_route\n        uri: https:&#x2F;&#x2F;example.org\n        filters:\n        - SetRequestHeader&#x3D;X-Request-Red, Blue\n\nSetStatus设置回执状态码。\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: setstatusint_route\n        uri: https:&#x2F;&#x2F;example.org\n        filters:\n        - SetStatus&#x3D;401\n\nStripPrefix跳过指定路径。\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: nameRoot\n        uri: https:&#x2F;&#x2F;nameservice\n        predicates:\n        - Path&#x3D;&#x2F;name&#x2F;**\n        filters:\n        - StripPrefix&#x3D;2\n\n请求/name/blue/red会转发到/red。\nRequestSize请求大小。\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: request_size_route\n        uri: http:&#x2F;&#x2F;localhost:8080&#x2F;upload\n        predicates:\n        - Path&#x3D;&#x2F;upload\n        filters:\n        - name: RequestSize\n          args:\n            maxSize: 5000000\n\n超过5M的请求会返回413错误。\nDefault-filters对所有请求添加过滤器。\nspring:\n  cloud:\n    gateway:\n      default-filters:\n      - AddResponseHeader&#x3D;X-Response-Default-Red, Default-Blue\n      - PrefixPath&#x3D;&#x2F;httpbin\n\n通过代码进行配置通过代码进行配置，将路由规则设置为一个Bean即可：\n@Bean\npublic RouteLocator customRouteLocator(RouteLocatorBuilder builder) &#123;\n\treturn builder.routes()\n\t\t.route(&quot;path_route&quot;, r -&gt; r.path(&quot;&#x2F;get&quot;)\n\t\t\t.uri(&quot;http:&#x2F;&#x2F;httpbin.org&quot;))\n\t\t.route(&quot;host_route&quot;, r -&gt; r.host(&quot;*.myhost.org&quot;)\n\t\t\t.uri(&quot;http:&#x2F;&#x2F;httpbin.org&quot;))\n\t\t.route(&quot;rewrite_route&quot;, r -&gt; r.host(&quot;*.rewrite.org&quot;)\n\t\t\t.filters(f -&gt; f.rewritePath(&quot;&#x2F;foo&#x2F;(?&lt;segment&gt;.*)&quot;, &quot;&#x2F;$&#123;segment&#125;&quot;))\n\t\t\t.uri(&quot;http:&#x2F;&#x2F;httpbin.org&quot;))\n\t\t.route(&quot;hystrix_route&quot;, r -&gt; r.host(&quot;*.hystrix.org&quot;)\n\t\t\t.filters(f -&gt; f.hystrix(c -&gt; c.setName(&quot;slowcmd&quot;)))\n\t\t\t.uri(&quot;http:&#x2F;&#x2F;httpbin.org&quot;))\n\t\t.route(&quot;hystrix_fallback_route&quot;, r -&gt; r.host(&quot;*.hystrixfallback.org&quot;)\n\t\t\t.filters(f -&gt; f.hystrix(c -&gt; c.setName(&quot;slowcmd&quot;).setFallbackUri(&quot;forward:&#x2F;hystrixfallback&quot;)))\n\t\t\t.uri(&quot;http:&#x2F;&#x2F;httpbin.org&quot;))\n\t\t.route(&quot;limit_route&quot;, r -&gt; r\n\t\t\t.host(&quot;*.limited.org&quot;).and().path(&quot;&#x2F;anything&#x2F;**&quot;)\n\t\t\t.filters(f -&gt; f.requestRateLimiter(c -&gt; c.setRateLimiter(redisRateLimiter())))\n\t\t\t.uri(&quot;http:&#x2F;&#x2F;httpbin.org&quot;))\n\t\t.build();\n&#125;\n\n\n\n五、实现熔断降级为什么要实现熔断降级？\n在分布式系统中，网关作为流量的入口，因此会有大量的请求进入网关，向其他服务发起调用，其他服务不可避免的会出现调用失败（超时、异常），失败时不能让请求堆积在网关上，需要快速失败并返回给客户端，想要实现这个要求，就必须在网关上做熔断、降级操作。\n为什么在网关上请求失败需要快速返回给客户端？\n因为当一个客户端请求发生故障的时候，这个请求会一直堆积在网关上，当然只有一个这种请求，网关肯定没有问题（如果一个请求就能造成整个系统瘫痪，那这个系统可以下架了），但是网关上堆积多了就会给网关乃至整个服务都造成巨大的压力，甚至整个服务宕掉。因此要对一些服务和页面进行有策略的降级，以此缓解服务器资源的的压力，以保证核心业务的正常运行，同时也保持了客户和大部分客户的得到正确的相应，所以需要网关上请求失败需要快速返回给客户端。\nserver.port: 8082\n\nspring:\n  application:\n    name: gateway\n  redis:\n      host: localhost\n      port: 6379\n      password: 123456\n  cloud:\n    gateway:\n      routes:\n        - id: rateLimit_route\n          uri: http:&#x2F;&#x2F;localhost:8000\n          order: 0\n          predicates:\n            - Path&#x3D;&#x2F;test&#x2F;**\n          filters:\n            - StripPrefix&#x3D;1\n            - name: Hystrix\n              args:\n                name: fallbackCmdA\n                fallbackUri: forward:&#x2F;fallbackA\n\n  hystrix.command.fallbackCmdA.execution.isolation.thread.timeoutInMilliseconds: 5000\n\n这里的配置，使用了两个过滤器：\n（1）过滤器StripPrefix，作用是去掉请求路径的最前面n个部分截取掉。\nStripPrefix=1就代表截取路径的个数为1，比如前端过来请求/test/good/1/view，匹配成功后，路由到后端的请求路径就会变成http://localhost:8888/good/1/view。\n（2）过滤器Hystrix，作用是通过Hystrix进行熔断降级\n当上游的请求，进入了Hystrix熔断降级机制时，就会调用fallbackUri配置的降级地址。需要注意的是，还需要单独设置Hystrix的commandKey的超时时间\nfallbackUri配置的降级地址的代码如下：\npackage org.gateway.controller;\n\nimport org.gateway.response.Response;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class FallbackController &#123;\n\n    @GetMapping(&quot;&#x2F;fallbackA&quot;)\n    public Response fallbackA() &#123;\n        Response response &#x3D; new Response();\n        response.setCode(&quot;100&quot;);\n        response.setMessage(&quot;服务暂时不可用&quot;);\n        return response;\n    &#125;\n&#125;\n\n\n\n六、高级配置\n\n1、分布式限流从某种意义上讲，令牌桶算法是对漏桶算法的一种改进，桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。在令牌桶算法中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝。放令牌这个动作是持续不断的进行，如果桶中令牌数达到上限，就丢弃令牌，所以就存在这种情况，桶中一直有大量的可用令牌，这时进来的请求就可以直接拿到令牌执行，比如设置qps为100，那么限流器初始化完成一秒后，桶中就已经有100个令牌了，这时服务还没完全启动好，等启动完成对外提供服务时，该限流器可以抵挡瞬时的100个请求。所以，只有桶中没有令牌时，请求才会进行等待，最后相当于以一定的速率执行。\n在Spring Cloud Gateway中，有Filter过滤器，因此可以在“pre”类型的Filter中自行实现上述三种过滤器。但是限流作为网关最基本的功能，Spring Cloud Gateway官方就提供了RequestRateLimiterGatewayFilterFactory这个类，适用在Redis内的通过执行Lua脚本实现了令牌桶的方式。具体实现逻辑在RequestRateLimiterGatewayFilterFactory类中，lua脚本在如下图所示的文件夹中：\n首先在工程的pom文件中引入gateway的起步依赖和redis的reactive依赖，代码如下：\n配置如下：\nserver:\n  port: 8081\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: limit_route\n        uri: http:&#x2F;&#x2F;httpbin.org:80&#x2F;get\n        predicates:\n        - After&#x3D;2017-01-20T17:42:47.789-07:00[America&#x2F;Denver]\n        filters:\n        - name: RequestRateLimiter\n          args:\n            key-resolver: &#39;#&#123;@userKeyResolver&#125;&#39;\n            redis-rate-limiter.replenishRate: 1\n            redis-rate-limiter.burstCapacity: 3\n  application:\n    name: cloud-gateway\n  redis:\n    host: localhost\n    port: 6379\n    database: 0\n\n在上面的配置文件，指定程序的端口为8081，配置了 redis的信息，并配置了RequestRateLimiter的限流过滤器，该过滤器需要配置三个参数：\n\nburstCapacity，令牌桶总容量。\nreplenishRate，令牌桶每秒填充平均速率。\nkey-resolver，用于限流的键的解析器的 Bean 对象的名字。它使用 SpEL 表达式根据#{@beanName}从 Spring 容器中获取 Bean 对象。\n\n这里根据用户ID限流，请求路径中必须携带userId参数\n@Bean\n\nKeyResolver userKeyResolver() &#123;\n  return exchange -&gt; Mono.just(exchange.getRequest().getQueryParams().getFirst(&quot;user&quot;));\n&#125;\n\n \n\nKeyResolver需要实现resolve方法，比如根据userid进行限流，则需要用userid去判断。实现完KeyResolver之后，需要将这个类的Bean注册到Ioc容器中。\n如果需要根据IP限流，定义的获取限流Key的bean为：\n@Bean\npublic KeyResolver ipKeyResolver() &#123;\n  return exchange -&gt; Mono.just(exchange.getRequest().getRemoteAddress().getHostName());\n&#125;\n\n通过exchange对象可以获取到请求信息，这边用了HostName，如果你想根据用户来做限流的话这边可以获取当前请求的用户ID或者用户名就可以了，比如：\n如果需要根据接口的URI进行限流，则需要获取请求地址的uri作为限流key，定义的Bean对象为：\n@Bean\nKeyResolver apiKeyResolver() &#123;\n  return exchange -&gt; Mono.just(exchange.getRequest().getPath().value());\n&#125;\n\n通过exchange对象可以获取到请求信息，这边用了HostName，如果你想根据用户来做限流的话这边可以获取当前请求的用户ID或者用户名就可以了，比如：\n如果需要根据接口的URI进行限流，则需要获取请求地址的uri作为限流key，定义的Bean对象为：\n@Bean\nKeyResolver apiKeyResolver() &#123;\n  return exchange -&gt; Mono.just(exchange.getRequest().getPath().value());\n&#125;\n\n\n\n2、健康检查配置admin-client、actuator健康检查配置，为之后的功能提供支持，此部分比较简单，不再赘述，加入以下maven依赖和配置\nmaven依赖  &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;\n &lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n        &lt;groupId&gt;de.codecentric&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-admin-starter-client&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.1.0&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n\n配置文件spring:\n  application:\n    name: mas-cloud-gateway\n  boot:\n    admin:\n      client:\n      ### 本地搭建的admin-server\n        url: http:&#x2F;&#x2F;localhost:8011\neureka:\n  client:\n    registerWithEureka: true\n    fetchRegistry: true\n    healthcheck:\n      enabled: true\n    serviceUrl:\n      defaultZone: http:&#x2F;&#x2F;localhost:6887&#x2F;eureka&#x2F;\n    enabled: true\nfeign:\n  sentinel:\n    enabled: true\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: &#39;*&#39;\n  endpoint:\n    health:\n      show-details: ALWAYS\n\n若转发的目标地址为微服务中组件，不为具体ip:port形式的，应写成lb://mas-openapi-service形式，目标地址会从注册中心直接拉取\n3、统一配置跨域请求现在的请求通过经过gateWay网关时，需要在网关统一配置跨域请求，需求所有请求通过\nspring:\n  cloud:\n    gateway:\n      globalcors:\n        cors-configurations:\n          &#39;[&#x2F;**]&#39;:\n            allowed-origins: &quot;*&quot; # 允许的请求源\n            allowed-headers: &quot;*&quot; # 允许携带的请求头\n            allow-credentials: true # 是否允许携带cookie\n            allowed-methods: # 允许的http方法\n              - GET\n              - POST\n              - DELETE\n              - PUT\n              - OPTION\n\njava代码方式书写\npackage com.atguigu.guli.infrastructure.apigateway.config;\n\n@Configuration\npublic class CorsConfig &#123;\n    @Bean\n    public CorsWebFilter corsFilter() &#123;\n        &#x2F;&#x2F;CorsConfiguration 相关配置说明\n        &#x2F;&#x2F; 是否允许携带cookies\n        &#x2F;&#x2F;private Boolean allowCredentials;\n        &#x2F;&#x2F; 允许的请求源\n        &#x2F;&#x2F; private List&lt;String&gt; allowedOrigins;\n        &#x2F;&#x2F; 允许的http方法\n        &#x2F;&#x2F;private List&lt;String&gt; allowedMethods;\n        &#x2F;&#x2F; 允许的请求头\n        &#x2F;&#x2F;private List&lt;String&gt; allowedHeaders;\n        CorsConfiguration config &#x3D; new CorsConfiguration();\n        config.setAllowCredentials(true);\n        config.addAllowedOrigin(&quot;*&quot;);\n        config.addAllowedHeader(&quot;*&quot;);\n        config.addAllowedMethod(&quot;*&quot;);\n\n        UrlBasedCorsConfigurationSource source &#x3D; new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(&quot;&#x2F;**&quot;, config);\n\n        return new CorsWebFilter(source);\n    &#125;\n&#125;\n\n\n\n4、鉴权七、整合Sentinel完成流控和降级maven依赖使用Sentinel作为gateWay的限流、降级、系统保护工具\n&lt;!--alibaba 流量卫士--&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;com.alibaba.csp&lt;&#x2F;groupId&gt;\n       &lt;artifactId&gt;sentinel-core&lt;&#x2F;artifactId&gt;\n       &lt;version&gt;$&#123;sentinel.version&#125;&lt;&#x2F;version&gt;\n   &lt;&#x2F;dependency&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n       &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;&#x2F;artifactId&gt;\n   &lt;&#x2F;dependency&gt;\n  &lt;dependency&gt;\n       &lt;groupId&gt;com.alibaba.csp&lt;&#x2F;groupId&gt;\n       &lt;artifactId&gt;sentinel-spring-cloud-gateway-adapter&lt;&#x2F;artifactId&gt;\n       &lt;version&gt;1.7.1&lt;&#x2F;version&gt;\n   &lt;&#x2F;dependency&gt;\n\n配置文件客户端配置：在配置文件中增加下列配置，dashboard就可以轻松管理客户端了，还有一种方式是在启动时加入\nspring:\n  cloud:\n    sentinel:\n      transport:\n        ## VM\n        ##-Djava.net.preferIPv4Stack&#x3D;true -Dcsp.sentinel.dashboard.server&#x3D;localhost:8080 -Dcsp.sentinel.api.port&#x3D;8666 -Dproject.name&#x3D;gateway -Dcsp.sentinel.app.type&#x3D;1\n        dashboard: localhost:8880\n        port: 8880\n\n限流规则通用配置由于sentinel的工作原理其实借助于全局的filter进行请求拦截并计算出是否进行限流、熔断等操作的，增加SentinelGateWayFilter配置\n@Bean&#x2F;&#x2F;拦截请求\n@Order(Ordered.HIGHEST_PRECEDENCE)\npublic GlobalFilter sentinelGatewayFilter() &#123;\n  return new SentinelGatewayFilter();\n&#125;\n\nsentinel 不仅支持通过硬代码方式进行资源的申明，还能通过注解方式进行声明，为了让注解生效，还需要配置切面类SentinelResourceAspect\n @Bean\npublic SentinelResourceAspect sentinelResourceAspect() &#123;\n  return new SentinelResourceAspect();\n&#125;\n\nsentinel拦截包括了视图、静态资源等，需要配置viewResolvers以及拦截之后的异常，我们也可以自定义抛出异常的提示\npublic SentinelConfig(ObjectProvider&lt;List&lt;ViewResolver&gt;&gt; viewResolversProvider,\n                      ServerCodecConfigurer serverCodecConfigurer) &#123;\n  this.viewResolvers &#x3D; viewResolversProvider.getIfAvailable(Collections::emptyList);\n  this.serverCodecConfigurer &#x3D; serverCodecConfigurer;\n&#125;\n\n@Bean&#x2F;&#x2F;自定义异常\n@Order(Ordered.HIGHEST_PRECEDENCE)\npublic ExceptionHandler sentinelGatewayBlockExceptionHandler() &#123;\n  &#x2F;&#x2F; Register the block exception handler for Spring Cloud Gateway.\n  return new ExceptionHandler(viewResolvers, serverCodecConfigurer);\n&#125;\n\n自定义异常提示：当发生限流、熔断异常时，会返回定义的提示信息。\n    &#x2F;**\n     * 配置限流的异常处理器:SentinelGatewayBlockExceptionHandler\n     *&#x2F;\n    @Bean\n    @Order(Ordered.HIGHEST_PRECEDENCE)\n    public SentinelGatewayBlockExceptionHandler sentinelGatewayBlockExceptionHandler() &#123;\n        return new SentinelGatewayBlockExceptionHandlerEX(viewResolvers, serverCodecConfigurer);\n    &#125;\n不需要额外的配置，sentinel就已经可以正常工作了\n\n限流规则设置1 资源定义：定义API组\n2 定义限流规则\n\n\n\n\n\n\n\n\n\n具体请参见学习视频\n网关限流参数其中网关限流规则 GatewayFlowRule的字段解释如下：\n\nresource：资源名称，可以是网关中的 route 名称或者用户自定义的 API 分组名称。\n\nresourceMode：规则是针对 API Gateway 的 route（RESOURCE_MODE_ROUTE_ID）还是用户在 Sentinel 中定义的 API 分组（RESOURCE_MODE_CUSTOM_API_NAME），默认是 route。\n\ngrade：限流指标维度，同限流规则的 grade 字段。\n\ncount：限流阈值\n\nintervalSec：统计时间窗口，单位是秒，默认是 1 秒。\n\ncontrolBehavior：流量整形的控制效果，同限流规则的 controlBehavior 字段，目前支持快速失败和匀速排队两种模式，默认是快速失败。\n\nburst：应对突发请求时额外允许的请求数目。\n\nmaxQueueingTimeoutMs：匀速排队模式下的最长排队时间，单位是毫秒，仅在匀速排队模式下生效。\n\nparamItem\n参数限流配置。若不提供，则代表不针对参数进行限流，该网关规则将会被转换成普通流控规则；否则会转换成热点规则。其中的字段：\n\nparseStrategy：从请求中提取参数的策略，目前支持提取来源 IP（PARAM_PARSE_STRATEGY_CLIENT_IP）、Host（PARAM_PARSE_STRATEGY_HOST）、任意 Header（PARAM_PARSE_STRATEGY_HEADER）和任意 URL 参数（PARAM_PARSE_STRATEGY_URL_PARAM）四种模式。\nfieldName：若提取策略选择 Header 模式或 URL 参数模式，则需要指定对应的 header 名称或 URL 参数名称。\npattern：参数值的匹配模式，只有匹配该模式的请求属性值会纳入统计和流控；若为空则统计该请求属性的所有值。（1.6.2 版本开始支持）\nmatchStrategy：参数值的匹配策略，目前支持精确匹配（PARAM_MATCH_STRATEGY_EXACT）、子串匹配（PARAM_MATCH_STRATEGY_CONTAINS）和正则匹配（PARAM_MATCH_STRATEGY_REGEX）。（1.6.2 版本开始支持）\n\n\n\n用户可以通过 GatewayRuleManager.loadRules(rules) 手动加载网关规则，或通过 GatewayRuleManager.register2Property(property) 注册动态规则源动态推送（推荐方式）。\n八、Gatway 网关的过滤器开发过滤器的执行次序Spring-Cloud-Gateway 基于过滤器实现，同 zuul 类似，有pre和post两种方式的 filter,分别处理前置逻辑和后置逻辑。客户端的请求先经过pre类型的 filter，然后将请求转发到具体的业务服务，收到业务服务的响应之后，再经过post类型的 filter 处理，最后返回响应到客户端。\n过滤器执行流程如下，order 越大，优先级越低\n\n  \n\n\n\n\n分为全局过滤器和局部过滤器\n\n全局过滤器：\n\n\n\n\n\n\n\n\n\n\n对所有路由生效\n2、接口用时统计\n\n局部过滤器：\n\n\n\n\n\n\n\n\n\n\n对指定路由生效\n定义全局过滤器实现 GlobalFilter 和 Ordered，重写相关方法，加入到spring容器管理即可，无需配置，全局过滤器对所有的路由都有效。\n全局过滤器举例：代码如下：\npackage com.crazymaker.cloud.nacos.demo.gateway.config;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.cloud.gateway.filter.GatewayFilterChain;\nimport org.springframework.cloud.gateway.filter.GlobalFilter;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.web.server.ServerWebExchange;\nimport reactor.core.publisher.Mono;\n\n@Configuration\npublic class FilterConfig\n&#123;\n\n    @Bean\n    @Order(-1)\n    public GlobalFilter a()\n    &#123;\n        return new AFilter();\n    &#125;\n\n    @Bean\n    @Order(0)\n    public GlobalFilter b()\n    &#123;\n        return new BFilter();\n    &#125;\n\n    @Bean\n    @Order(1)\n    public GlobalFilter c()\n    &#123;\n        return new CFilter();\n    &#125;\n\n\n    @Slf4j\n    public class AFilter implements GlobalFilter, Ordered\n    &#123;\n\n        @Override\n        public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain)\n        &#123;\n            log.info(&quot;AFilter前置逻辑&quot;);\n            return chain.filter(exchange).then(Mono.fromRunnable(() -&gt;\n            &#123;\n                log.info(&quot;AFilter后置逻辑&quot;);\n            &#125;));\n        &#125;\n\n        &#x2F;&#x2F;   值越小，优先级越高\n&#x2F;&#x2F;    int HIGHEST_PRECEDENCE &#x3D; -2147483648;\n&#x2F;&#x2F;    int LOWEST_PRECEDENCE &#x3D; 2147483647;\n        @Override\n        public int getOrder()\n        &#123;\n            return HIGHEST_PRECEDENCE + 100;\n        &#125;\n    &#125;\n\n    @Slf4j\n    public class BFilter implements GlobalFilter, Ordered\n    &#123;\n        @Override\n        public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain)\n        &#123;\n            log.info(&quot;BFilter前置逻辑&quot;);\n            return chain.filter(exchange).then(Mono.fromRunnable(() -&gt;\n            &#123;\n                log.info(&quot;BFilter后置逻辑&quot;);\n            &#125;));\n        &#125;\n\n\n        &#x2F;&#x2F;   值越小，优先级越高\n&#x2F;&#x2F;    int HIGHEST_PRECEDENCE &#x3D; -2147483648;\n&#x2F;&#x2F;    int LOWEST_PRECEDENCE &#x3D; 2147483647;\n        @Override\n        public int getOrder()\n        &#123;\n            return HIGHEST_PRECEDENCE + 200;\n        &#125;\n    &#125;\n\n    @Slf4j\n    public class CFilter implements GlobalFilter, Ordered\n    &#123;\n\n        @Override\n        public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain)\n        &#123;\n            log.info(&quot;CFilter前置逻辑&quot;);\n            return chain.filter(exchange).then(Mono.fromRunnable(() -&gt;\n            &#123;\n                log.info(&quot;CFilter后置逻辑&quot;);\n            &#125;));\n        &#125;\n\n        &#x2F;&#x2F;   值越小，优先级越高\n&#x2F;&#x2F;    int HIGHEST_PRECEDENCE &#x3D; -2147483648;\n&#x2F;&#x2F;    int LOWEST_PRECEDENCE &#x3D; 2147483647;\n        @Override\n        public int getOrder()\n        &#123;\n            return HIGHEST_PRECEDENCE + 300;\n        &#125;\n    &#125;\n&#125;\n\n\n\n定义局部过滤器步骤：\n1 需要实现GatewayFilter, Ordered，实现相关的方法\n2 加入到过滤器工厂，并且注册到spring容器中。\n3、在配置文件中进行配置，如果不配置则不启用此过滤器规则。\n局部过滤器举例, 对请求头部的 user-id 进行校验，代码如下：\n1 需要实现GatewayFilter, Ordered，实现相关的方法\npackage com.crazymaker.cloud.nacos.demo.gateway.filter;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.lang3.StringUtils;\nimport org.springframework.cloud.gateway.filter.GatewayFilter;\nimport org.springframework.cloud.gateway.filter.GatewayFilterChain;\nimport org.springframework.cloud.gateway.filter.GlobalFilter;\nimport org.springframework.core.Ordered;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.server.ServerWebExchange;\nimport reactor.core.publisher.Mono;\n\n&#x2F;&#x2F;@Component\n@Slf4j\npublic class UserIdCheckGateWayFilter implements GatewayFilter, Ordered\n&#123;\n    @Override\n    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain)\n    &#123;\n        String url &#x3D; exchange.getRequest().getPath().pathWithinApplication().value();\n        log.info(&quot;请求URL:&quot; + url);\n        log.info(&quot;method:&quot; + exchange.getRequest().getMethod());\n       &#x2F;*   String secret &#x3D; exchange.getRequest().getHeaders().getFirst(&quot;secret&quot;);\n        if (StringUtils.isBlank(secret))\n        &#123;\n            return chain.filter(exchange);\n        &#125;*&#x2F;\n         &#x2F;&#x2F;获取param 请求参数\n        String uname &#x3D; exchange.getRequest().getQueryParams().getFirst(&quot;uname&quot;);\n        &#x2F;&#x2F;获取header\n        String userId &#x3D; exchange.getRequest().getHeaders().getFirst(&quot;user-id&quot;);\n        log.info(&quot;userId：&quot; + userId);\n\n        if (StringUtils.isBlank(userId))\n        &#123;\n            log.info(&quot;*****头部验证不通过，请在头部输入  user-id&quot;);\n            &#x2F;&#x2F;终止请求，直接回应\n            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);\n            return exchange.getResponse().setComplete();\n        &#125;\n        return chain.filter(exchange);\n    &#125;\n\n    &#x2F;&#x2F;   值越小，优先级越高\n&#x2F;&#x2F;    int HIGHEST_PRECEDENCE &#x3D; -2147483648;\n&#x2F;&#x2F;    int LOWEST_PRECEDENCE &#x3D; 2147483647;\n    @Override\n    public int getOrder()\n    &#123;\n        return HIGHEST_PRECEDENCE;\n    &#125;\n&#125;\n\n2 加入到过滤器工厂，并且注册到spring容器中。\npackage com.crazymaker.cloud.nacos.demo.gateway.config;\n\nimport com.crazymaker.cloud.nacos.demo.gateway.filter.UserIdCheckGateWayFilter;\nimport org.springframework.cloud.gateway.filter.GatewayFilter;\nimport org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;\nimport org.springframework.stereotype.Component;\n\n\n@Component\npublic class UserIdCheckGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;Object&gt;\n&#123;\n    @Override\n    public GatewayFilter apply(Object config)\n    &#123;\n        return new UserIdCheckGateWayFilter();\n    &#125;\n&#125;\n\n3、在配置文件中进行配置，如果不配置则不启用此过滤器规则。\n- id: service_provider_demo_route_filter\n  uri: lb:&#x2F;&#x2F;service-provider-demo\n  predicates:\n    - Path&#x3D;&#x2F;filter&#x2F;**\n  filters:\n    - RewritePath&#x3D;&#x2F;filter&#x2F;(?&lt;segment&gt;.*), &#x2F;provider&#x2F;$\\&#123;segment&#125;\n    - UserIdCheck","slug":"70-SpringCloud-GateWay","date":"2021-09-13T15:46:32.000Z","categories_index":"SpringCloud","tags_index":"SpringCloud","author_index":"大黄"},{"id":"7782f77d73b91eb2c8a016712795b746","title":"SpringCloud Hoxton","content":"01、Eureka 基本内容\n\n在微服务架构中，服务注册与发现是核心组件之一，手动指定每个服务是很低效的，Spring cloud提供了多种服务注册与发现的实现方式,例如: Eureka、Consu、 Zookeeper\nSringCloud支持得最好的是 Eureka,其次是 Consul,再次是 Zookeeper。\n1.1、什么是服务治理在传统rpc远程调用中，服务与服务依赖关系，管理比较复杂，所以需要使用服务治理，管理服务与服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。\n1.2、什么是服务注册Eureka采用了 CS 的设计架构，==Eureka Server作为服务注册功能的服务器，它是服务注册中心。==\n而系统中的其他微服务，使用Eureka的客户端连接到Eureka Server并维持心跳连接。这样系统的维护人员可以通过Eureka Server来监控系统中各个微服务是否正常运行。\n在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息，比如：服务通讯地址等以别名方式注册到注册中心上。\n另一方（消费者服务），以该别名的方式去注册中心上获取到实际的服务通讯地址，然后，再实现本地RPC远程调用。\nRPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系（服务治理概念）。\n在任何RPC远程框架中，都会有一个注册中心（存放服务地址相关信息（接口地址））。\n\n\n\n\n1.3、服务注册与发现在服务注册与发现中，有一个注册中心，当服务器启动的时候，会把当前自己服务器的信息 比如 服务地址通讯地址等以别名方式注册到注册中心上。\n另一方（消费者|服务提供者），以该别名的方式去注册中心上获取到实际的服务通讯地址，让后在实现本地 rpc 调用远程。\nEureka Server提供服务注册服务\n各个微服务节点通过配置启动后，会在Eureka Server中进行注册，这样Eureka Server中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。\nEureka Client通过注册中心进行访问\n是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询（round-robin）负载算法的负载均衡器。在应用启动后，将会在Eureka Server发送心跳（默认周期30秒）。如果Eureka Server在多个心跳周期内没有收到某个节点的心跳，Eureka Server将会从服务注册表中把这个服务节点移出（默认90秒）\n1.4、Eureka是什么Eureka是一个服务治理组件，它主要包括服务注册和服务发现,主要用来搭建服务注册中心。\nEureka是一个基于REST的服务,用来定位服务，进行中间层服务器的负载均衡和故障转移。（根据 要调用的服务的网址加端口，加上方法路径）\nEureka是 Netflix公司开发的, Spring Cloud封装了Neix公司开发的Eureka模块来实现服务注册和发现也就是说 Spring Cloud对Netflix eureka做了二次封装\nEureka采用了C-S(客户端/服务端)的设计架构,也就是Eureka由两个组件组成：Eureka服务端 和 Eureka客户端。Eureka server作为服务注册的服务端,它是服务注册中心,而系统中的其他微服务,使用 Eureka的客户端连接到 Eureka server服务端,并维持心跳连接, Eureka客户端是一个Java客户端,用来简化与服务器的交互、负载均衡,服务的故障切换等。\n有了 Eureka注册中心,系统的维护人员就可以通过 Eureka server来监控系统中各个微服务是否正常运行。\n1.5、Eureka和Zookeeper对比著名的CAP理论指出,一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)\n由于分区容错性在是分布式系统中必须要保证的,因此我们只能在A和C之间进行权衡,在此 Zookeeper保证的是CP而 Eureka则是AP\n\nConsistency(一致性), 数据一致更新，所有数据变动都是同步的\nAvailability(可用性), 好的响应性能\nPartition tolerance(分区容忍性) 可靠性\n\n\n“C”是指一致性，即当一个Process（过程）修改了某个数据后，其他Process读取这是数据是，得到的是更新后的数据，但并不是所有系统都 可以做到这一点。例如，在一些并非严格要求一致性的系统中，后来的Process得到的数据可能还是修改之前的数据，或者需要等待一定时间后才能得到修改 之后的数据，这被成为“弱一致性”，最经典的应用就是DNS系统。当用户修改了DNS配置后，往往不会马上在全网更新，必定会有一个延迟，这个延迟被称为 “不一致窗口”，它的长度取决于系统的负载、冗余的个数等因素。但对于某些系统而言，一旦写入，后面读取的一定是修改后的数据，如银行账户信息，这被称为 “强一致性”。\n“A”是指可用性。即系统总是能够为用户提供连续的服务能力。当用户发出请求是，系统能给出响应（成功或者失败），而且是立即给出响应，而不是等待其他事情完成才响应。如果需要等待某件事情完成才响应，那么“可用性”就不存在了。\n“P”是指容错性。任何一个分布式计算系统都是由多个节点组成的。在正常情况下，节点与节点之间的通信是正常的。但是在某些情况下，节点之间的通信会 断开，这种断开成为“Partition”。在分布式计算的实现中，Partition是很常见的，因为节点不可能永远不出故障，尤其是对于跨物理地区的 海量存储系统而言，而容错性则可以保证如果只是系统中的部分节点不可用，那么相关的操作仍旧能够正常完成。\nZookeeper保证CP，在 ZooKeeper中,当 master节点因为网络故障与其他节点失去联系时,剩余节点会重新进行 leader选举,但是问题在于,选举 leader需要一定时间,且选举期间整个 ZooKeeper集群都是不可用的,这就导致在选举期间注册服务瘫痪。在云部署的环境下,因网络问题使得 ZooKeeper集群失去 master节点是大概率事件,虽然服务最终能够恢复,但是在选举时间内导致服务注册长期不可用是难以容忍的。\nEureka保证AP，Eureka优先保证可用性, Eureka各个节点是平等的,某几个节点挂掉不会影响正常节点的工作,剩余的节点依然可以提供注册和查询服务。而 Eureka的客户端在向某个 Eureka注册或时如果发现连接失败,则会自动切换至其它节点,只要有一台 Eureka还在,就能保证注册服务可用(保证可用性),只不过查到的信息可能不是最新的(不保证强一致性)\n\n所以 Eureka在网络故障导致部分节点失去联系的情况下,只要有一个节点可用,那么注册和查询服务就可以正常使用,而不会像 zookeeper那样使整个注册服务瘫痪, Eureka优先保证了可用性。\n02、Eureka 入门程序2.1、服务注册中心建Modulecloud-eureka-server7001\n2.2、改POM&lt;?xmversion&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;cloud2020&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n    &lt;artifactId&gt;cloud-eureka-server7001&lt;&#x2F;artifactId&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;cloud-api-commons&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;$&#123;project.version&#125;&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;\n2.3、Eureka版本对比1.X版本\n&lt;dependency&gt;\n&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n&lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n2.X版本\n&lt;dependency&gt;\n&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n2.4、写YML注册拉取都是false，因为本模块相当于服务注册中心\nserver:\n  port: 7001\n\neureka:\n  instance:\n    hostname: localhost\n\n  client:\n  \t#由于我们目前创建的应用是一个服务注册中心，而不是一个普通的应用，默认情况下，这个应用会向注册中心（也是它自己）注册它自己，设置为false表示禁止这种自己向自己注册的默认行为\n    register-with-eureka: false\n    #表示是否从Eureka Server获取注册信息，默认为true。如果这是一个单点的 Eureka Server，不需要同步其他节点的数据，可以设为false。\n    fetchRegistry: false\n    #如果是集群，Eureka集群相互指向注册中心\n    service-url:\n      defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka\n\n2.5、主启动@EnableEurekaServer\n2.6、测试http://localhost:7001/\n2.7、服务提供者EurekaClient端 cloud-provider-payment8001将注册进 EurekaServer 成为服务提供者provider\n2.8、建Modulecloud-provider-payment8001\n2.9、改POM&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n3.0、写YMLeureka:\n  client:\n    register-with-eureka: true\n    fetchRegistry: true\n    service-url:\n      defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka\n\n3.1、主启动加上==@EnableEurekaClient==\n3.2、测试先启动EurekaServerhttp://localhost:7001/\n3.3、服务消费者EurekaClient端cloud-consumer-order80将注册进EurekaServer成为服务消费者consumer\n3.4、建Modulecloud-consumer-order80\n3.5、POM&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n3.6、写YMLeureka:\n  client:\n    register-with-eureka: true\n    fetchRegistry: true\n    service-url:\n      defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka\n\n3.7、主启动加上==@EnableEurekaClient==\n3.8、测试先要启动EurekaServer，7001服务\n再要启动服务提供者8001服务和服务消费者80服务\neureka服务器\n03、Eureka 注册中心高可用集群概述在微服务架构的这种分布式系统中,我们要充分考虑各个微服务组件的高可用性问题,不能有单点故障,由于注册中心Eureka本身也是一个服务,如果它只有一个节点,那么它有可能发生故障,这样我们就不能注册与查询服务了,所以我们需要—个高可用的服务注册中心,这就需要通过注册中心集群来解决。Eureka服务注册中心它本身也是一个服务,它也可以看做是一个提供者,又可以看做是一个消费者,我们之前通过配置eureka.client.register-with-eureka= false让注册中心不注册自己,但是我们可以向其他注册中心注册自己。\nEureka server的高可用实际上就是将自己作为服务向其他服务注册中心注册自己,这样就会形成一组互相注册的服务注册中心,进而实现服务清单的互相同步,往注册中心A上注册的服务,可以被复制同步到注册中心B上,所以从任何一台注册中心上都能查询到已经注册的服务,从而达到高可用的效果。\n\n    \n\n\n\n\n04、Eureka 详解\n\n1、服务消费者模式1-1、获取服务\n 消费者启动的时候，使用服务别名，会发送一个rest请求到服务注册中心获取对应的服务信息，然后会缓存到本地jvm客户端中，同时客户端每隔30秒从服务器上更新一次。\n可以通过eureka.client.registry-fetch-interval-seconds=30参数进行修改，该配置默认值为30， 单位为秒。\n1-2、服务下线\n在系统运行过程中必然会面临关闭或重启服务的某个实例的情况，在服务关闭期间我们自然不希望客户端会继续调用关闭了的实例。所以在客户端程序中，当服务实例正常的关闭操作时，它会触发一个服务下线的REST请求给Eureka Server, 告诉服务中心:“我要下线了”。服务端在接收到请求之后，将该服务状态置为下线(DOWN)，并将该下线事件传播出去。\n2、服务注册模式2-1、失效剔除\n有些时候，我们的服务实例并不一定会正常下线，可能由于内存溢出、网络故障原因使得服务不能正常工作，而服务注册中心并未收到“服务下线”的请求。为了从服务表中将这些无法提供服务的实例剔除，Eureka Server 在启动的时候会创建一个定时任务默认每隔一段时间(默认为60秒eureka.server.eviction-interval-timer-in-ms=6000L)将当前清单中超时(默认为90秒eureka.instance.lease-expiration-duration-in-seconds= 90)没有续约的服务踢除出去\n2-2、Eureka服务注册中心自我保护机制\n当我们在本地调试基于Eureka的程序时，基本上都会碰到这样一个问题， 在服务主中心的信息面板中出现类似下面的红色警告信息，在开发测试时，需要频繁地重启微服务实例，但是我们很少会把eureka server一起重启（因为在开发过程中不会修改eureka注册中心），当一分钟内收到的心跳数大量减少时，会触发该保护机制。可以在eureka管理界面看到Renews threshold和Renews(last min)，当后者（最后一分钟收到的心跳数）小于前者（心跳阈值）的时候，触发保护机制，会出现红色的警告：\n\n实际上，该警告就是触发了Eureka Server的自我保护机制，服务注册到Eureka Server之后，会维护个心跳连接， 告诉Eureka Server自己还活着。Eureka Server在运行期间，会统计客户端节点的心跳失败的比例在15分钟之内是否低于85%如果出现低于的情况，如果低于85%，那就触发自我保护机制，单机调试的时候很容易满足，实际在生产环境上通常是由于网络不稳定导致)，Eureka Server会将当前的实例注册信息保护起来，让这些实例不会过期，尽可能保护这些注册信息。但是，在这段保护期间内实例若出现问题，那么客户端很容易拿到实际已经不存服务实例，会出现调用失败的情况，所以客户端必须要有容错机制，比如可以使用请使用重试、断路器等机制。\n在没有Eureka自我保护的情况下,如果 Eureka Server在一定时间内没有接收到某个微服务实例的心跳, Eureka Server将会注销该实例,但是当发生网络分区故障时,那么微服务与 Eureka Server之间将无法正常通信,以上行为可能变非常危险了，因为微服务本身其实是正常的,此时不应该注销这个微服务，如果没有自我保护机制，那么Eureka Server就会将此服务注销掉。\nEureka通过“自我保护模式”来解决这个问题——当 Eureka Server节点在短时间内丢失过多客户端时(可能发生了网络分区故障),那么就会把这个微服务节点进行保护。一旦进入自我保护模式, Eureka server就会保护服务注册表中的信息,不删除服务注册表中的数据(也就是不会注销任何微服务)。当网络故障恢复后,该 Eureka Server节点会再自动退出自我保护模式。所以,自我保护模式是一种应对网络异常的安全保护措施,它的架构哲学是宁可同时保留所有微服务(健康的微服务和不健康的微服务都会保留),也不盲目注销任何健康的微服务,使用自我保护模式,可以让Eureka集群更加的健壮、稳定当然也可以使用配置项: eureka.server.enable-self-preservation=fase禁用自我保护模式。\n但是Eureka Server自我保护模式也会给我们带来一些困扰,如果在保护期内某个服务提供者刚好非正常下线了,此时服务消费者就会拿到一个无效的服务实例,此时会调用失败,对于这个问题需要服务消费者端具有一些容错机制,如重试,断路器等。\nEureka的自我保护模式是有意义的,该模式被激活后,它不会从注册列表中剔除因长时间没收到心跳导致注册过期的服务,而是等待修复,直到心跳恢复正常之后,它自动退出自我保护模式。这种模式旨在避免因网络分区故障导致服务不可用的问题。\n例如,两个微服务客户端实例A和B之间有调用的关系,A是消费者,B是提供者,但是由于网络故障,B未能及时向Eureka发送心跳续约,这时候 Eureka不能简单的将B从注册表中剔除,因为如果剔除了,A就无法从Eureka服务器中获取B注册的服务,但是这时候B服务是可用的;所以, Eureka的自我保护模式最好还是开启它。\n05、Ribbon 是什么\n\n==Ribbon是一个基于HTTP和TCP的 客户端 负载均衡器==\n5.2、Ribbon能干什么当使用Ribbon对服务进行访问的时候，他会扩展Eureka客户端的服务发现功能，实现从Eureka注册中心获取服务端列表，并通过Eureka客户端来确定服务端是否已经启动。==(服务调用)==\nRibbon在Eureka客户端服务发现的基础上，实现对服务实例的选择策略，从而实现对服务的负载均衡消费。==（负载均衡）==\n5.3、负载均衡简述负载均衡在系统架构中是一个非常重要的内容，因为负载均衡是对系统的高可用、网络的压力的缓冲和处理能力扩容的重要手段之一，我们通常说的负载均衡都是指的是服务端的负载均衡，其中分为硬件负载均衡和软件负载均衡。\n\n硬件负载均衡：主要通过服务器节点之间安装专门用于负载均衡的设备，比如F5，深信服，Array等。\n软件负载均衡：则是通过服务器上安装一些具有负载功能或模块的软件来完成请求分发工作，比如Nginx、LVS、HAProxy等。\n\n硬件负载均衡的设备或是软件负载均衡的软件模块都会维护一个下挂可用的服务端清单，通过心跳检测来剔除故障的服务端节点保证清单中都是可以正常访问的服务端节点。当客户端发送请求到负载均衡的设备时候，该设备按某种算法（比如线性轮询、按权重负载、按流量负载等）从维护的可用服务端清单中取出一台服务端地址，然后进行转发。\nRibbon是Netflix发布的开源项目,主要功能是提供客户端的软件负载均衡算法,是一个基于HTTP和TCP的客户端负载均衡工具。Spring Cloud对Ribbon做了二次封装,可以让我们使用 RestTemplate的服务请求,自动转换成客户端负载均衡的服务调用。Ribbon支持多种负载均衡算法,还支持自定义的负载均衡算法。Ribbon只是一个工具类框架,比较小巧, Spring Cloud对它封装后使用也非 常方便,它不像服务注册中心、配置中心、AP网关那样需要独立部署, Ribbon 只需要在代码直接使用即可。\n5.4、Ribbon与 Nginx的区别\n都是软负载\nRibbon是客户端负载均衡\nNginx是服务器段负载均衡\n\n区别在于：\n服务清单所存储的位置不同，在客户端负载均衡中，所有客户端节点下的服务端清单，需要自己从服务注册中心上获取，比如Eureka服务注册中心。同服务端负载均衡的架构类似，在客户端负载均衡中也需要心跳去维护服务端清单的健康性，只是这个步骤需要与服务注册中心配合完成，在SpringCloud实现的服务治理框架中，默认会创建针对各个服务治理框架到的Ribbon自动化整合配置，比如Eureka中的org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration,在实际使用的时候，我们可以通过查看这个类的实现，以找到他们的配置详情来帮助我们更好的使用它。\n5.5、Spring Cloud如何调用Ribbon通过Spring Cloud Ribbon的封装，我们在微服务架构中使用客户端负载均衡调用非常的简单，只需要如下两步：\n\n服务提供者只需要启动多个服务实例并注册到一个注册中心或是多个相关联的服务注册中心上\n==服务消费者直接通过调用被@LoadBalanced注解修饰过的RestTemplate来实现面向服务的接口调用。==\n\n这样我们就可以将服务提供者的高可用以及服务消费者的负载均衡用一起实现了。\n\n服务端的负载均衡是提前配置好的：Nginx\n客户端的负载均衡是从注册中心找的：Ribbon\n\n在SpringCloud中，Ribbon主要与RestTemplate对象配合使用，Ribbon会自动化配置RestTemplate对象，通过@LoadBalance开启RestTemplate对象调用时的负载均衡，Ribbon所处的作用如图：\n\n    \n\n\n\n\n06、Ribbon 实现客户端负载均衡前面提到过，通过Spring Cloud Ribbon的封装，我们在微服务架构中使用客户端负载均衡调用非常的简单，只需要如下两步：\n\n服务提供者只需要启动多个服务实例并注册到一个注册中心或是多个相关联的服务注册中心上\n服务消费者直接通过调用被@LoadBalanced注解修饰过的RestTemplate来实现面向服务的接口调用。\n\n\n复制服务提供者 并且命名后面加2，表示第二个服务提供者\n修改第二个提供者的端口\n修改第二个提供者的controller中的 uri路径\n修改pom文件中此模块的名字\n\n在消费者的RestTemplate中添加如下代码：使用Ribbon实现负载均衡调用,默认是轮询 \n&#x2F;&#x2F;使用Ribbon实现负载均衡调用,默认是轮询    @LoadBalanced \n&#x2F;&#x2F;加入ribbon的支持，那么在调用时，即可改为使用服务名称来访问    \n@Bean    \n@LoadBalanced \npublic RestTemplate restTemplate()&#123;        \n    return new RestTemplate();    \n&#125;\n\nRest请求模板类解读\n当我们从服务消费端去调用服务提供者的服务的时候,使用了一个极其方便的对象叫RestTemplate,当时我们只使用了RestTemplate中最简单的一个功能getForEntity发起了一个get请求去调用服务端的数据,同时,我们还通过配置@Loadbalanced注解开启客户端负载均衡, RestTemplate的功能非常强大, 那么接下来就来详细的看一下RestTemplate中几种常见请求方法的使用。在日常操作中,基于Rest的方式通常是四种情况,它们分表是\n\nGET请求-查询数据\nPOST请求-添加数据\nPUT请求-修改数据\nDELETE-删除数据\n\n07、Ribbon 定义负载均衡策略\n\n7.1、Ribbon 负载均衡策略类\n\n\n\nRandomRule\n随机\n\n\n\nRoundRobinRule\n轮询\n\n\nAvailabilityFilteringRule\n先过滤掉由于多次访问故障的服务，以及并发连接数超过阀值的服务，然后对剩下的服务按照轮询策略进行访问\n\n\nWeightedResponseTimeRule\n根据平均响应时间计算所有服务的权重，响应时间越快服务权重就越大被选中的概率即越高，如果服务刚启动时间统计信息不足，，则使用RoundRobinRule策略，待统计信息足够，会切换到该WeightedResponseTimeRule策略\n\n\nRetryRule\n先按照RoundRobinRule策略分发，如果分发到的服务不能访问，则在指定的时间内重试，如果不行的话，则分发到其他可用的服务\n\n\nBestAvailableRule\n先过滤掉由于多次访问的故障的服务，然后选择一个并发量最小的服务\n\n\nZoneAvoidanceRule\n综合判断服务节点所在区域的性能和服务节点的可用性，来决定选择哪个服务\n\n\n==TIP：结合Ribbon负载均衡，默认的是轮询，重新注入IRule可以实现负载均衡的其他策略==\n7.2、Ribbon 指定策略Ribbon在工作时分成两步：\n第一步，先选择EurekaServer，它优先选择在同一个区域内负载较少的server。\n第二步，再根据用户指定的策略（需要自定义配置类），在从server取到的服务注册列表中选择一个地址。其中Ribbon提供了多种策略。比如：轮询、随机和根据响应时间加权。\n总结：Ribbon其实就是一个软负载均衡的客户端组件，他可以和其他所需请求的客户端结合使用，和eureka结合只是其中的一个实例。\n==TIP：这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达不到特殊化订制的目的了。==\n==自定义类中指定 负载均衡策略时，return的是各种策略的对象，但是方法上要用 IRule 接收==\n缺个图片\n08、Feign 是什么Feign是Netflix公司开发的一个声明式的REST调用客户端; Ribbon负载均衡、 Hystrⅸ服务熔断是我们Spring Cloud中进行微服务开发非常基础的组件，在使用的过程中我们也发现它们一般都是同时出现的，而且配置也都非常相似，每次开发都有很多相同的代码，因此Spring Cloud基于Netflix Feign整合了Ribbon和Hystrix两个组件，让我们的开发工作变得更加简单，就像Spring boot是对Spring + SpringMVC 的简化，Spring Cloud Feign对Ribbon负载均衡、 Hystrⅸ服务熔断进行简化，在其基础上进行了进一步的封装，不仅在配置上大大简化了开发工作，同时还提供了一种声明式的Web服务客户端定义方式。使用方式类似Dubbo的使用方式。\n09、Feign 实现消费者1、创建消费者服务命名为(springcloud-service-feign)\n2、添加依赖\n&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n3、在==启动类上添加注解==\n@EnableFeignClients\n\n4、声明服务\n定义一个HelloService接口，通过@FeignClient注解来指定服务名称进而绑定服务，然后在通过Spring  MVC中提供的注解来绑定服务提供者的接口，如下：\n&#x2F;&#x2F;使用feign的客户端注解绑定远程的名称，名称可以是大写，也可以小写\n@FeignClient(value &#x3D; &quot;springcloud-service-provider&quot;)\npublic interface HelloService &#123;\n    &#x2F;&#x2F;声明一个方法，这个方法就是远程的服务提供者提供的方法\n    @RequestMapping(&quot;&#x2F;provider&#x2F;hello&quot;)\n    public String hello();   \n&#125;\n\n5、使用Controller中调用服务，代码如下\n@Autowired\nprivate HelloService helloService;\n\n@RequestMapping(&quot;&#x2F;hello&quot;)\npublic String hello()&#123;\n    &#x2F;&#x2F;调用声明式接口方法,实现对远程服务的调用\n    return helloService.hello();\n&#125;\n6、application.yml配置如下\nspring:\n  application:\n    name: springcloud-service-feign\nserver:\n  port: 9091\neureka:\n  client:\n    service-url:\n      defaultZone: http:&#x2F;&#x2F;localhost:8700&#x2F;eureka\n    #客户端每隔30秒从Eureka服务上更新一次服务信息\n    registry-fetch-interval-seconds: 30\n    #需要将我的服务注册到eureka上\n    register-with-eureka: true\n\n7、启动测试，访问地址http://localhost:9091/feign/hello\n10、使用Feign支持的特性1、负载均衡\nSpring Cloud提供了Ribbon来实现负载均衡，使用Ribbon直接注入一个RestTemplate对象即可，RestTemplate已经做好了负载均衡的配置在Spring Cloud下，使用 Feign也是直接可以实现负载均衡的，定义一个有 @FeignClient 注解的接口，然后使用 @RequestMappin注解到方法上映射远程的REST服务，此方法也是做好负责均衡配置的。\n2、服务熔断\n在 application.yml文件开启hystrix功能\n#开启hystrix熔断机制\nfeign:\n  hystrix:\n    enabled: true\n\n指定熔断回调逻辑\n@FeignClient(value &#x3D; &quot;springcloud-service-provider&quot;, fallback &#x3D; MyFallback.class)\npublic interface HelloService &#123;\n    @RequestMapping(&quot;&#x2F;provider&#x2F;hello&quot;)\n    public String hello();   \n&#125;\n\n@Component\npublic class MyFallback implements HelloService &#123;\n    @Override\n    public String hello() &#123;\n        return &quot;远程服务不可用，暂时采用本地逻辑代替。。。。。&quot;;\n    &#125;\n&#125;\n\n3、测试，让服务提供者超时就行了\n如果需要捕获提供者抛出的异常可以用：\n@FeignClient(value &#x3D; &quot;springcloud-service-provider&quot;, fallbackFactory &#x3D; MyFallbackFactory.class)\n@Component\npublic class MyFallbackFactory implements FallbackFactory&lt;HelloService&gt; &#123;\n    @Override\n    public HelloService create(Throwable throwable) &#123;\n        return new HelloService() &#123;\n            @Override\n            public String hello() &#123;\n                return throwable.getMessage();\n            &#125;\n        &#125;;\n    &#125;\n&#125;\n\n\n\n11、Feign 默认超时时长1秒默认Feign客户端只等待一秒钟，但是，服务端处理需要超过1秒钟，导致Feign客户端不想等待了，直接报错。\n为了避免这样的情况，有时候我们需要设置Feign客户端的超时控制，也即Ribbon的超时时间，因为Feign集成了Ribbon进行负载均衡。\nYML中需要开启OpenFeign客户端超时控制，Feign设置超时时间\n使用Feign调用接口分两层，ribbon 的调用和 hystrix 的调用，所以 ribbon 的超时时间和 Hystrix 的超时时间的 结合 就是Feign的超时时间\n#设置Feign客户端超时时间（openfeign默认支持ribbon）\nribbon: \n  ReadTimeout:  3000 \n  ConnectTimeout: 3000\n\n\n\n12、分布式面临的问题复杂分布式体系结构中的应用程序有数十个依赖关系，每一个依赖关系在某些时候将不可避免的失败。\n \n服务雪崩\n多个微服务之间调用的时候，假如微服务A调用微服务B和微服务C，微服务B和微服务C又调用其他的微服务，这就是所谓的”扇出”。\n如果扇出的链路上某个微服务的调用响应的时间过长或者不可用，对微服A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的”雪崩效应”。\n对于高流量的应用来说，单一的后端依赖可能会导致所有的服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行****隔离和管理****，以便单个依赖关系的失败，不能取消整个应用程序或系统。\n所以，通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。\n13、什么是Hystrix“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（Fallback），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。\nHystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统中，每个服务都可能会调用很多其他服务，被调用的那些服务就是依赖服务，有的时候某些依赖服务出现故障（超时，异常）也是很正常的。\nHystrix 可以让我们在分布式系统中对服务间的调用进行控制，加入一些调用延迟或者依赖故障的容错机制。避免级联故障，以提高分布式系统的弹性。\nHystrix 通过将依赖服务进行资源隔离，进而阻止某个依赖服务出现故障时在整个系统所有的依赖服务调用中进行蔓延；同时Hystrix 还提供故障时的 fallback 降级机制。\n总而言之，Hystrix 通过这些方法帮助我们提升分布式系统的可用性和稳定性。\n14、Hystrix的作用\n保护和控制底层服务的高延迟和失效对上层服务的影响。        \n避免复杂分布式中服务失效的雪崩效应。在大型的分布式系统中，存在各种复杂的依赖关系。如果某个服务失效，很可能会对其他服务造成影响，形成连锁反应。        \n==快速失效和迅速恢复。== 以Spring为例，一般在实现controller的时候，都会以同步的逻辑调用依赖的服务。如果服务时效，而且没有客户端失效机制，就好导致请求长时间的阻塞。如果不能快速的发现失效，而就很难通过高可用机制或者负载均衡实现迅速的恢复。        \n==优雅地实现服务降级和熔断。== 个人理解，这一点是从用户体验来考虑的，一个预定义默认返回会比请求卡死或者500好很多。        \n==实现了服务监控、报警和运维控制。== Hystrix Dashboard和Turbine可以配合Hystrix完成这些功能。\n\n15、Hystrix重要概念1、服务降级Fallback\n\n服务器忙，请稍候再试，不让客户端等待并立刻返回一个友好提示\n哪些情况会触发降级\n程序运行异常\n超时自动降级\n服务熔断触发服务降级\n线程池/信号量打满也会导致服务降级\n人工降级\n\n2、服务熔断Breaker\n\n类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示\n就是保险丝\n服务的降级-&gt;进而熔断-&gt;恢复调用链路\n\n3、服务限流Flowlimit\n\n秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行\n\n16、Hystrix 案例创建 支付服务端新建Module：cloud-provider-hystrix-payment8001\npom文件\n&lt;?xmversion&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;cloud2020&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n\n    &lt;artifactId&gt;cloud-provider-hystrix-payment8001&lt;&#x2F;artifactId&gt;\n\n    &lt;dependencies&gt;\n        &lt;!--新增hystrix--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;cloud-api-commons&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;$&#123;project.version&#125;&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;\n\nyml\nserver:\n  port: 8001\n\nspring:\n  application:\n    name: cloud-hystrix-payment-service\n\neureka:\n  client:\n    register-with-eureka: true\n    fetch-registry: true\n    service-url:\n      defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka&#x2F;\n\n主启动\npackage com.atguigu.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.EnableEurekaClient;\n\n@SpringBootApplication\n@EnableEurekaClient\npublic class PaymentHystrixMain8001 &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(PaymentHystrixMain8001.class,args);\n    &#125;\n&#125;\n\nservice/serviceImpl\npackage com.atguigu.springcloud.service;\n\npublic interface PaymentService &#123;\n    public String paymentInfo_OK(Integer id);\n    public String payment_Timeout(Integer id);\n&#125;\npackage com.atguigu.springcloud.service.impl;\n\nimport org.springframework.stereotype.Service;\nimport java.util.concurrent.TimeUnit;\n\n@Service\npublic class PaymentServiceImpimplements PaymentService &#123;\n\n    &#x2F;&#x2F;成功\n    public String paymentInfo_OK(Integer id)&#123;\n        return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot;   paymentInfo_OK,id：  &quot;+id+&quot;\\t&quot;+&quot;哈哈哈&quot;  ;\n    &#125;\n\n    &#x2F;&#x2F;失败\n    public String payment_Timeout(Integer id)&#123;\n        int timeNumber &#x3D; 3;\n        try &#123; TimeUnit.SECONDS.sleep(timeNumber); &#125;catch (Exception e) &#123;e.printStackTrace();&#125;\n        return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot;   paymentInfo_TimeOut,id：  &quot;+id+&quot;\\t&quot;+&quot;呜呜呜&quot;+&quot; 耗时(秒)&quot;+timeNumber;\n    &#125;\n&#125;\n\ncontroller\npackage com.atguigu.springcloud.controller;\n\nimport com.atguigu.springcloud.service.PaymentService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\nimport javax.annotation.Resource;\n\n@RestController\n@Slf4j\npublic class PaymentController &#123;\n\n    @Resource\n    private PaymentService paymentService;\n\n    @Value(&quot;$&#123;server.port&#125;&quot;)\n    private String serverPort;\n\n    @GetMapping(&quot;&#x2F;payment&#x2F;hystrix&#x2F;ok&#x2F;&#123;id&#125;&quot;)\n    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id)&#123;\n        String result &#x3D; paymentService.paymentInfo_OK(id);\n        log.info(&quot;*******result:&quot;+result);\n        return result;\n    &#125;\n    @GetMapping(&quot;&#x2F;payment&#x2F;hystrix&#x2F;timeout&#x2F;&#123;id&#125;&quot;)\n    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123;\n        String result &#x3D; paymentService.paymentInfo_TimeOut(id);\n        log.info(&quot;*******result:&quot;+result);\n        return result;\n    &#125;\n&#125;\n\n正常测试\n启动eureka7001\n启动cloud-provider-hystrix-payment8001\n访问： http://localhost:8001/payment/hystrix/ok/31\n每次调用耗费3秒钟： http://localhost:8001/payment/hystrix/timeout/31\n上述module均OK，以上述为根基平台，从正确-&gt;错误-&gt;降级熔断-&gt;恢复\n17、高并发测试上述在非高并发情形下，还能勉强满足   but…..\nJmeter压测测试，下载地址：https://archive.apache.org/dist/jmeter/binaries/\n开启Jmeter，来20000个并发压死8001，20000个请求都去访问paymentInfo_TimeOut服务\n压测的过程中再来访问一下微服务http://localhost:8001/payment/hystrix/ok/31http://localhost:8001/payment/hystrix/timeout/31\n演示结果，两个都在自己转圈圈，为什么会被卡死，tomcat的默认的工作线程数被打满了，没有多余的线程来分解压力和处理。\nJmeter压测结论，上面还是服务提供者8001自己测试，假如此时外部的消费者80也来访问，那消费者只能干等，最终导致消费端80不满意，服务端8001直接被拖死\n看热闹不嫌事大，我们新建加入：cloud-consumer-feign-hystrix-order80\n18、Hystrix 案例创建 订单消费端新建：cloud-consumer-feign-hystrix-order80\npom\n&lt;?xmversion&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;cloud2020&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n    &lt;artifactId&gt;cloud-consumer-feign-hystrix-order80&lt;&#x2F;artifactId&gt;\n\n    &lt;dependencies&gt;\n        &lt;!--新增hystrix--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;cloud-api-commons&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;$&#123;project.version&#125;&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;\n\nyml\nserver:\n  port: 80\n\nspring:\n  application:\n    name: cloud-provider-hystrix-payment-service\n\neureka:\n  client:\n    register-with-eureka: true    #表识不向注册中心注册自己\n    fetch-registry: true   #表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务\n    service-url:\n      defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka&#x2F;\n\n主启动\npackage com.atguigu.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.openfeign.EnableFeignClients;\n\n@SpringBootApplication\n@EnableEurekaClient\n@EnableFeignClients\npublic class OrderHystrixMain80 &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(OrderHystrixMain80.class,args);\n    &#125;\n&#125;\n\n业务类\npackage com.atguigu.springcloud.service;\n\nimport org.springframework.cloud.openfeign.FeignClient;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\n\n@FeignClient(&quot;CLOUD-HYSTRIX-PAYMENT-SERVICE&quot;)\npublic interface PaymentHystrixService &#123;\n    @GetMapping(&quot;&#x2F;payment&#x2F;hystrix&#x2F;ok&#x2F;&#123;id&#125;&quot;)\n    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id);\n\n    @GetMapping(&quot;&#x2F;payment&#x2F;hystrix&#x2F;timeout&#x2F;&#123;id&#125;&quot;)\n    public String payment_Timeout(@PathVariable(&quot;id&quot;) Integer id);\n&#125;\n\ncontroller\npackage com.atguigu.springcloud.controller;\n\nimport com.atguigu.springcloud.service.PaymentHystrixService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\nimport javax.annotation.Resource;\n\n@RestController\n@Slf4j\npublic class OrderHystrixController &#123;\n    @Resource\n    private PaymentHystrixService paymentHystrixService;\n\n    @GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;hystrix&#x2F;ok&#x2F;&#123;id&#125;&quot;)\n    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id)&#123;\n        String result &#x3D; paymentHystrixService.paymentInfo_OK(id);\n        log.info(&quot;*******result:&quot;+result);\n        return result;\n    &#125;\n    @GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;hystrix&#x2F;timeout&#x2F;&#123;id&#125;&quot;)\n    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123;\n        String result &#x3D; paymentHystrixService.payment_Timeout(id);\n        log.info(&quot;*******result:&quot;+result);\n        return result;\n    &#125;\n\n&#125;\n\n正常测试：http://localhost/consumer/payment/hystrix/ok/32\n高并发测试：\n\n2W个线程压8001\n消费端80微服务再去访问正常的OK微服务8001地址\nhttp://localhost/consumer/payment/hystrix/timeout/32\n消费者80，呜呜呜\n要么转圈圈等待\n要么消费端报超时错误\n\n\n\n\n19、故障现象和原因及解决办法8001同一层次的其他接口服务被困死，因为tomcat线程里面的工作线程已经被挤占完毕\n80此时调用8001，客户端访问响应缓慢，转圈圈\n正因为有上述故障或不佳表现，才有我们的降级/容错/限流等技术诞生\n\n超时导致服务器变慢（转圈）\n超时不再等待\n\n\n出错（宕机或程序运行出错）\n出错要有兜底\n\n\n解决\n对方服务（8001）超时了，调用者（80）不能一直卡死等待，必须有服务降级\n对方服务（8001）down机了，调用者（80）不能一直卡死等待，必须有服务降级\n对方服务（8001）OK，调用者（80）自己出故障或有自我要求（自己的等待时间小于服务提供者），自己处理降级\n\n\n\n20、服务降级1、降低配置\na使用注解：@HystrixCommand\n\n2、8001 从自身寻找问题：设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处理，作服务降级fallback\n3、8001 fallback：业务类启用阶级处理：使用@HystrixCommand注解来干活。\npackage com.atguigu.springcloud.service.impl;\n\nimport com.atguigu.springcloud.service.PaymentService;\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;\nimport org.springframework.stereotype.Service;\nimport java.util.concurrent.TimeUnit;\n\n@Service\npublic class PaymentServiceImpl implements PaymentService &#123;\n\n    @Override\n    public String paymentInfo_OK(Integer id) &#123;\n        return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot; paymentInfo_OK,id&#x3D;&quot;+id +&quot; \\t O(∩_∩)O哈哈~&quot;;\n    &#125;\n\n    &#x2F;&#x2F;超时降级演示\n    @HystrixCommand(fallbackMethod &#x3D; &quot;payment_TimeoutHandler&quot;,commandProperties &#x3D; &#123;\n            @HystrixProperty(name&#x3D;&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value&#x3D;&quot;5000&quot;) &#x2F;&#x2F;5秒钟以内就是正常的业务逻辑\n    &#125;)\n    @Override\n    public String payment_Timeout(Integer id) &#123;\n        &#x2F;&#x2F;int timeNumber &#x3D; 3; &#x2F;&#x2F;小于等于3秒算是正常情况\n        int timeNumber &#x3D; 15; &#x2F;&#x2F;模拟非正常情况\n        try &#123;\n            TimeUnit.SECONDS.sleep(timeNumber);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot; payment_Timeout,id&#x3D;&quot;+id+&quot; \\t o(╥﹏╥)o 耗时：&quot;+timeNumber;\n    &#125;\n\n    &#x2F;&#x2F;兜底方法，上面方法出问题,我来处理，返回一个出错信息\n    public String payment_TimeoutHandler(Integer id) &#123;\n        return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot; payment_TimeoutHandler,系统繁忙,请稍后再试\\t o(╥﹏╥)o &quot;;\n    &#125;\n&#125;\n\n4、主启动类激活：@EnableCircuitBreaker\n5、测试超时和算数异常，都会走兜底方法——服务降级\nhttp://localhost:8001/payment/hystrix/timeout/1\n\n\n6、80 fallback\n80订单微服务，也可以更好的保护自己，自己也依样画葫芦进行客户端降级保护。注意：服务降级可以在服务提供者侧，也可以在服务消费者侧。更多是在服务消费者侧。\n题外话，切记：我们自己配置过的热部署方式对java代码的改动明显，但对@HystrixCommand内属性的修改建议重启微服务\nYML\nfeign:\n  hystrix:\n    enabled: true #如果处理自身的容错就开启。开启方式与生产端不一样。\n\n==主启动：@EnableHystrix== \n@EnableHystrix \n\n查看@EnableHystrix的源码可以发现，它继承了@EnableCircuitBreaker，并对它进行了在封装。\n@Target(&#123;ElementType.TYPE&#125;)\n        @Retention(RetentionPolicy.RUNTIME)\n        @Documented\n        @Inherited\n        @EnableCircuitBreaker\n        public @interface EnableHystrix &#123;\n        &#125;\n这两个注解都是激活hystrix的功能，我们根据上面代码得出来结论，只需要在服务启动类加入@EnableHystrix注解即可，无须增加@EnableCircuitBreaker注解，本身@EnableHystrix注解已经涵盖了EnableCircuitBreaker的功能。\n\n\n业务类：OrderHystrixController\n&#x2F;&#x2F;超时降级演示\n@HystrixCommand(fallbackMethod &#x3D; &quot;payment_TimeoutHandler&quot;,commandProperties &#x3D; &#123;\n  @HystrixProperty(name&#x3D;&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value&#x3D;&quot;1500&quot;)&#x2F;&#x2F;超过1.5秒就降级自己\n&#125;)\n@GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;hystrix&#x2F;timeout&#x2F;&#123;id&#125;&quot;)\npublic String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123;\n  &#x2F;&#x2F;int age&#x3D; 1&#x2F;0;\n  String result &#x3D; paymentHystrixService.payment_Timeout(id);\n  log.info(&quot;*******result:&quot;+result);\n  return result;\n&#125;\n&#x2F;&#x2F;兜底方法，上面方法出问题,我来处理，返回一个出错信息\npublic String payment_TimeoutHandler(Integer id) &#123;\n  return &quot;我是消费者80,对方支付系统繁忙请10秒后再试。或自己运行出错，请检查自己。&quot;;\n&#125;\n测试超时：http://localhost/consumer/payment/hystrix/timeout/1\n\n\n7、目前问题\n每个业务方法对应一个兜底的方法，代码膨胀，代码耦合\n统一通用处理和自定义独立处理的分开\n\n8、代码膨胀的解决办法每个方法都去配置一个兜底方法，代码后期会很多，占用很大\n我们可以在controller上加伤 @DefaultProperties(defaultFallback = “”) 注解\n说明：\n\n@DefaultProperties(defaultFallback = “”)\n1:1 每个方法配置一个服务降级方法，技术上可以，但实际上傻X\n1:N 除了个别重要核心业务有专属，其它普通的可以通过@DefaultProperties(defaultFallback = “”)统一跳转到统一处理结果页面\n通用的和独享的各自分开，避免了代码膨胀，合理减少了代码量\n\ncontroller\npackage com.atguigu.springcloud.controller;\n\nimport com.atguigu.springcloud.service.PaymentHystrixService;\nimport com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties;\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\nimport javax.annotation.Resource;\n\n@RestController\n@Slf4j\n@DefaultProperties(defaultFallback &#x3D; &quot;payment_Global_FallbackMethod&quot;)  &#x2F;&#x2F;全局的\npublic class OrderHystrixController &#123;\n\n    @Resource\n    private PaymentHystrixService paymentHystrixService;\n\n    @GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;hystrix&#x2F;ok&#x2F;&#123;id&#125;&quot;)\n    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id)&#123;\n        String result &#x3D; paymentHystrixService.paymentInfo_OK(id);\n        return result;\n    &#125;\n\n    @HystrixCommand\n    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123;\n        int age &#x3D; 10&#x2F;0;\n        String result &#x3D; paymentHystrixService.paymentInfo_TimeOut(id);\n        return result;\n    &#125;\n\n    &#x2F;&#x2F;兜底方法\n    public String paymentTimeOutFallbackMethod(@PathVariable(&quot;id&quot;) Integer id)&#123;\n        return &quot;我是消费者80，对付支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,(┬＿┬)&quot;;\n    &#125;\n\n    &#x2F;&#x2F;下面是全局fallback方法\n    public String payment_Global_FallbackMethod()&#123;\n        return &quot;Global异常处理信息，请稍后再试,(┬＿┬)&quot;;\n    &#125;\n&#125;\n\n9、代码耦合的解决办法我们将兜底方法写在controller中或者service中，与其他业务逻辑混合，后期难以维护\n服务降级，客户端去调用服务端，碰上服务端宕机或关闭\n本次案例服务降级处理是在客户端80实现完成的，与服务端8001没有关系，只需要为Feign客户端定义的接口添加一个服务降级处理的实现类即可实现解耦\n未来我们要面对的异常\n\n运行\n超时\n宕机\n\n再看我们的业务类PaymentController\n修改cloud-consumer-feign-hystrix-order80\n根据cloud-consumer-feign-hystrix-order80已经有的PaymentHystrixService接口，重新新建一个类（PaymentFallbackService）实现该接口，统一为接口里面的方法进行异常处理\nPaymentFallbackService类实现PaymentFeignClientService接口\npackage com.atguigu.springcloud.service;\n\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class PaymentFallbackService implements PaymentHystrixService &#123;\n    @Override\n    public String paymentInfo_OK(Integer id) &#123;\n        return &quot;-----PaymentFallbackService fall back-paymentInfo_OK , (┬＿┬)&quot;;\n    &#125;\n\n    @Override\n    public String paymentInfo_TimeOut(Integer id) &#123;\n        return &quot;-----PaymentFallbackService fall back-paymentInfo_TimeOut , (┬＿┬)&quot;;\n    &#125;\n&#125;\n\nfeign:\n  hystrix:\n    enabled: true #如果处理自身的容错就开启。开启方式与生产端不一样。\n\nPaymentHystrixService\npackage com.atguigu.springcloud.service;\n\nimport org.springframework.cloud.openfeign.FeignClient;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\n\n@Component\n@FeignClient(value &#x3D; &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;,fallback &#x3D; PaymentFallbackService.class)\npublic interface PaymentHystrixService &#123;\n\n    @GetMapping(&quot;&#x2F;payment&#x2F;hystrix&#x2F;ok&#x2F;&#123;id&#125;&quot;)\n    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id);\n\n    @GetMapping(&quot;&#x2F;payment&#x2F;hystrix&#x2F;timeout&#x2F;&#123;id&#125;&quot;)\n    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id);\n&#125;\n\n测试：\n\n单个eureka先启动7001\nPaymentHystrixMain8001启动\n正常访问测试：http://localhost/consumer/payment/hystrix/ok/31\n故意关闭微服务8001\n客户端自己调用提升\n此时服务端provider已经down了，但是我们做了服务降级处理，让客户端在服务端不可用时也会获得提示信息而不会挂起耗死服务器\n\n21、服务熔断1、断路器\n一句话就是家里保险丝\n\n2、熔断是什么\n熔断机制概述\n熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。\n\n当检测到该节点微服务调用响应正常后，恢复调用链路。\n在SpringCloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状态，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解是@HystrixCommand\n\n\n3、大神论文https://martinfowler.com/bliki/CircuitBreaker.html\n\n22、服务熔断实操1、修改cloud-provider-hystrix-payment8001\n2、PaymentServiceImpl\ncom.netflix.hystrix.HystrixCommandProperties\n&#x2F;&#x2F;服务熔断\n@HystrixCommand(fallbackMethod &#x3D; &quot;paymentCircuitBreaker_fallback&quot;,commandProperties &#x3D; &#123;\n        @HystrixProperty(name &#x3D; &quot;circuitBreaker.enabled&quot;,value &#x3D; &quot;true&quot;),  &#x2F;&#x2F;是否开启断路器\n        @HystrixProperty(name &#x3D; &quot;circuitBreaker.requestVolumeThreshold&quot;,value &#x3D; &quot;10&quot;),   &#x2F;&#x2F;当在配置时间窗口内达到此数量的失败后，打开断路，默认20个\n        @HystrixProperty(name &#x3D; &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value &#x3D; &quot;10000&quot;),  &#x2F;&#x2F;断路多久以后开始尝试是否恢复，默认5s\n        @HystrixProperty(name &#x3D; &quot;circuitBreaker.errorThresholdPercentage&quot;,value &#x3D; &quot;60&quot;), &#x2F;&#x2F;出错百分比阈值，当达到此阈值后，开始短路。默认50%\n&#125;)\npublic String paymentCircuitBreaker(Integer id)&#123;\n    if (id &lt; 0)&#123;\n        throw new RuntimeException(&quot;*****id 不能负数&quot;);\n    &#125;\n    String serialNumber &#x3D; IdUtil.simpleUUID();&#x2F;&#x2F;hutool.cn工具包\n\n    return Thread.currentThread().getName()+&quot;\\t&quot;+&quot;调用成功,流水号：&quot;+serialNumber;\n&#125;\npublic String paymentCircuitBreaker_fallback(@PathVariable(&quot;id&quot;) Integer id)&#123;\n    return &quot;id 不能负数，请稍候再试,(┬＿┬)&#x2F;~~     id: &quot; +id;\n&#125;\n\nPaymentController\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;服务熔断\n@GetMapping(&quot;&#x2F;payment&#x2F;circuit&#x2F;&#123;id&#125;&quot;)\npublic String paymentCircuitBreaker(@PathVariable(&quot;id&quot;) Integer id)&#123;\n    String result &#x3D; paymentService.paymentCircuitBreaker(id);\n    log.info(&quot;*******result:&quot;+result);\n    return result;\n&#125;\n\n测试：\n\n自测cloud-provider-hystrix-payment8001\n正确： http://localhost:8001/payment/circuit/31\n错误： http://localhost:8001/payment/circuit/-31\n\n一次正确一次错误trytry\n\n重点测试\n多次错误（狂点），然后慢慢正确，发现刚开始不满足条件，就算是正确的访问地址也不能进行访问，需要慢慢的恢复链路\n\n\n23、熔断原理1、大神理论\n2、熔断类型\n熔断打开\n请求不再进行调用当前服务，内部设置时钟一般为MTTR(平均故障处理时间)，当打开时长达到所设时钟则进入熔断状态\n\n\n熔断关闭\n熔断关闭不会对服务进行熔断\n\n\n熔断半开\n部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断\n\n\n\n3、官网断路器流程图1⃣️ 官网步骤2⃣️ 断路器在什么情况下开始起作用&#x2F;&#x2F;服务熔断\n\n@HystrixCommand(fallbackMethod &#x3D; &quot;paymentCircuitBreaker_fallback&quot;,commandProperties &#x3D; &#123;\n\n@HystrixProperty(name &#x3D; &quot;circuitBreaker.enabled&quot;,value &#x3D; &quot;true&quot;),  &#x2F;&#x2F;是否开启断路器\n\n@HystrixProperty(name &#x3D; &quot;circuitBreaker.requestVolumeThreshold&quot;,value &#x3D; &quot;20&quot;),  &#x2F;&#x2F;当快照时间窗（默认10秒）内达到此数量才有资格打开断路，默认20个\n\n@HystrixProperty(name &#x3D; &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value &#x3D; &quot;50000&quot;),  &#x2F;&#x2F;断路多久以后开始尝试是否恢复，默认5s\n\n@HystrixProperty(name &#x3D; &quot;circuitBreaker.errorThresholdPercentage&quot;,value &#x3D; &quot;50&quot;), &#x2F;&#x2F;出错百分比阈值，当达到此阈值后，开始短路。默认50%\n\n  &#125;)\n\n涉及到断路器的三个重要参数：快照时间窗、请求总数阈值、错误百分比阈值。\n1、快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。\n2、请求总数阈值：在快照时间窗内，必须满足请求总数阈值才有资格熔断。默认20，意味着在10秒内，如果该hystrix命令的调用次数不足20次，即使所有的请求都超时或其他原因失败，断路器都不会打开。\n3、错误百分比阈值：当请求总数在快照时间窗内超过了阈值，比如发生了30次调用，如果在这30次调用，有15次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%阈值情况下，这时候就会将断路器打开。\n3⃣️ 断路器开启或者关闭的条件当满足一定阀值的时候（默认10秒内超过20个请求次数）\n当失败率达到一定的时候（默认10秒内超过50%请求失败）\n到达以上阀值，断路器将会开启\n当开启的时候，所有请求都不会进行转发\n一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。重复4和5\n4⃣️ 断路器打开之后1、再有请求调用的时候，将不会调用主逻辑，而是直接调用降级fallbak。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。\n2、原来的主逻辑要如何恢复呢？\n对于这一个问题，hystrix也为我们实现了自动恢复功能。\n当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。\n24、服务限流后面讲\n25、服务监控：hystrixDashboard1、概述除了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控(Hystrix Dashboard)，Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。Netflix通过hystrix-metrics-event-stram项目实现了对以上指示的监控。Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。\n2、仪表盘：9001新建Module：cloud-consumer-hystrix-dashboard9001\npom\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;cloud2020&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n    &lt;artifactId&gt;cloud-consumer-hystrix-dashboard9001&lt;&#x2F;artifactId&gt;\n\n    &lt;dependencies&gt;\n        &lt;!--新增hystrix dashboard--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;\n\nyml\nserver:\n  port: 9001\n\nHystrixDashboardMain9001+新注解@EnableHystrixDashboard\npackage com.atguigu.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;\n\n@SpringBootApplication\n@EnableHystrixDashboard\npublic class HystrixDashboardMain9001 &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(HystrixDashboardMain9001.class,args);\n    &#125;\n&#125;\n\n所有Provider微服务提供类（8001/8002/8003）都需要监控依赖配置\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n启动cloud-consumer-hystrix-dashboard9001该微服务后续将监控微服务8001\nhttp://localhost:9001/hystrix\n\n\n\n\n26、断路器演示1、修改cloud-provider-hystrix-payment8001\\\n注意：新版本Hystrix需要在主启动类MainAppHystrix8001中指定监控路径\n&#x2F;**\n *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑\n *ServletRegistrationBean因为springboot的默认路径不是&quot;&#x2F;hystrix.stream&quot;，\n *只要在自己的项目里配置上下面的servlet就可以了\n *&#x2F;\n@Bean\npublic ServletRegistrationBean getServlet() &#123;\nHystrixMetricsStreamServlet streamServlet &#x3D; new HystrixMetricsStreamServlet();\nServletRegistrationBean registrationBean &#x3D; new ServletRegistrationBean(streamServlet);\nregistrationBean.setLoadOnStartup(1);\nregistrationBean.addUrlMappings(&quot;&#x2F;hystrix.stream&quot;);\nregistrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;);\nreturn registrationBean;\n&#125;\n\nUnable to connect to Command Metric Stream\n404\n2、监控测试\n\n启动1个eureka\n观察监控窗口\n\n9001监控8001\nhttp://localhost:9001/hystrix\nhttp://localhost:8001/hystrix.stream\n \n测试地址\nhttp://localhost:8001/payment/circuit/31\nhttp://localhost:8001/payment/circuit/-31\n上述测试通过\nok\n先访问正确地址，再访问错误地址，再正确地址，会发现图示断路器都是慢慢放开的\n监控结果，成功\n \n监控结果，失败\n \n如何看，7色\n \n1圈，实心圆：共有两种含义。它通过颜色的变化代表了实例的健康程度，它的健康度从绿色&lt;黄色&lt;橙色&lt;红色递减。\n该实心圆除了颜色的变化之外，它的大小也会根据实例的请求流量发生变化，流量越大该实心圆就越大。所以通过该实心圆的展示，就可以在大量的实体中快速的发现故障实例和高压力实例。\n1线，曲线：用来记录2分钟内流量的相对变化，可以通过它来观察到流量的上升和下降趋势。\n整图说明\n \n整图说明2\n \n搞懂一个才能看懂复杂的\n\n","slug":"69-SpringCloud-Hoxton","date":"2021-09-13T15:45:32.000Z","categories_index":"SpringCloud","tags_index":"SpringCloud","author_index":"大黄"},{"id":"74daf6bfc632564c16acab051038d38a","title":"SpringCloud 基础内容","content":"1、本章导读\n2、微服务理论In short, the microservice architectural style [1] is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.\n简而言之，微服务架构风格[1]是一种将单个应用程序开发为一组小服务的方法，每个小服务都在自己的进程中运行，并与轻量级机制（通常是 HTTP 资源 API）进行通信。这些服务是围绕业务能力构建的，并且可以通过完全自动化的部署机制独立部署。这些服务有最低限度的集中管理，它们可以用不同的编程语言编写并使用不同的数据存储技术。\nhttp:&#x2F;&#x2F;blog.cuicc.com&#x2F;blog&#x2F;2015&#x2F;07&#x2F;22&#x2F;microservices&#x2F;\n\n\n\n3、架构及服务器间交流方式\n\n3.1、软件架构演变\n    \n\n\n\n单一应用架构\n当网站流量很小时，只需==一个应用，将所有功能都部署在一起==，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架 (ORM) 是关键。\n\n垂直应用架构\n当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用==拆成互不相干的几个应用（模块，但是模块间还是有联系），以提升效率==。此时，用于加速前端页面开发的Web框架 (MVC) 是关键。\n\n分布式服务（RPC）架构\n当垂直应用越来越多，应用之间交互不可避免，==将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心==，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架 (RPC) 是关键。\n\n流动计算（SOA）架构\n当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心 (SOA) 是关键。\n\n\n3.1、RPC是什么RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。\n它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。\n即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。\n3.2、RPC思想原理\n    \n    \n\n\n客户端（服务消费者）发送请求，底层以流的方式通过网络访问服务端（服务提供者），调用服务端的相关方法并返回相关数据，客户端在进行相应的处理\n\n\n\n名词\n定义\n\n\n\n服务提供者\n服务的被调用方（即：为其他服务提供服务的服务）\n\n\n服务消费者\n服务的调用方（即：依赖其他服务的服务）\n\n\n3.3、服务器间交流的两种方式RPC：Netty（Socket）+自定义序列化\nRestAPI   ==(严格来说，SpringCloud是使用Rest方式进行服务之间交互的，不属于RPC)==：HTTP + JSON\n4、分布式概念\n\n4.1、什么是分布式《分布式系统原理与范型》定义：“分布式系统是==若干独立计算机的集合==，这些计算机对于用户来说就像单个相关系统”。\n分布式系统（distributed system）是建立在网络之上的软件系统。\n4.2、分布式和集群的区别集群指的是将几台服务器集中在一起，实现同一业务。\n==分布式中的每一个节点，都可以做集群。 而集群并不一定就是分布式的。==\n5、分布式思想\n\n5.1、高并发通过设计保证系统可以==并行处理很多请求==。应对大量流量与请求\nTomcat最多支持并发多少用户？\n\nTomcat 默认配置的最大请求数是 150，也就是说同时支持 150 个并发，当然了，也可以将其改大。\n当某个应用拥有 250 个以上并发的时候，应考虑应用服务器的集群。\n具体能承载多少并发，需要看硬件的配置，CPU 越多性能越高，分配给 JVM 的内存越多性能也就越高，但也会加重 GC 的负担。\n\n操作系统对于进程中的线程数有一定的限制：\n\nWindows 每个进程中的线程数不允许超过 2000，Linux 每个进程中的线程数不允许超过 1000\n另外，在 Java 中每开启一个线程需要耗用 1MB 的 JVM 内存空间用于作为线程栈之用。\nTomcat 默认的 HTTP 实现是采用阻塞式的 Socket 通信，每个请求都需要创建一个线程处理。这种模式下的并发量受到线程数的限制，但对于 Tomcat 来说几乎没有 BUG 存在了。\nTomcat 还可以配置 NIO 方式的 Socket 通信，在性能上高于阻塞式的，每个请求也不需要创建一个线程进行处理，并发能力比前者高。但没有阻塞式的成熟。\n\n这个并发能力还与应用的逻辑密切相关：\n\n如果逻辑很复杂需要大量的计算，那并发能力势必会下降。如果每个请求都含有很多的数据库操作，那么对于数据库的性能也是非常高的。\n\n对于单台数据库服务器来说，允许客户端的连接数量是有限制的。并发能力问题涉及整个系统架构和业务逻辑。\n\n\n系统环境不同，Tomcat版本不同、JDK版本不同、以及修改的设定参数不同。并发量的差异还是满大的。\n\nmaxThreads=”1000” 最大并发数 ，默认值为200\nminSpareThreads=”100”//初始化时创建的线程数，默认值为10\nacceptCount=”700”// 指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理，默认值为100，https://tomcat.apache.org/tomcat-8.0-doc/config/http.html\n\n高并发衡量指标如下：\n\n响应时间(RT) ：请求做出响应的时间，即一个http请求返回所用的时间\n\n吞吐量：系统在单位时间内处理请求的数量\n\nQPS(Query/Request Per Second)、 TPS（Transaction Per Second）：每秒查询（请求）数、每秒事务数\n\n专业的测试工具：Load Runner            Apache ab            Apache JMeter\n\n并发用户数：承载的正常使用系统功能的用户的数量\n\n\n5.2、高可用服务集群部署，数据库主从+双机热备\n\n主-备方式（Active-Standby方式）\n主-备方式即指的是==一台服务器处于某种业务的激活状态==（即Active状态），另==一台服务器处于该业务的备用状态==（即Standby状态)。\n\n双主机方式（Active-Active方式）\n双主机方式即指==两种不同业务分别在两台服务器上互为主备状态==（即Active-Standby和Standby-Active状态）\n\n\n5.3、注册中心保存某个服务所在地址等信息，方便调用者实时获取其他服务信息\n服务注册：服务提供者\n服务发现：服务消费者\n5.4、负载均衡动态将请求派发给比较闲的服务器，有以下策略\n\n==轮询(Round Robin)==\n==加权轮询(Weighted Round Robin)==\n==随机Random==\n哈希Hash\n最小连接数LC\n最短响应时间LRT\n\n5.5、服务雪崩\n    \n    \n\n\n上面是一组简单的服务依赖关系A，B服务同时依赖于基础服务C，基础服务C又调用了服务D\n服务D是一个辅助类型服务，整个业务不依赖于D服务，某天D服务突然响应时间变长，却没有返回任何消息，导致了核心服务C还在等待D的响应，响应时间变长，而后续的请求也继续进来，其上请求越积越多，C服务也出现了响应变慢的情况，由于A，B强依赖于服务C，故而一个无关紧要的服务却影响了整个系统的可用。\n雪崩是系统中的蝴蝶效应导致其发生的原因多种多样，有不合理的容量设计，或者是高并发下某一个方法响应变慢，亦或是某台机器的资源耗尽。从源头上我们无法完全杜绝雪崩源头的发生，但是雪崩的根本原因来源于服务之间的强依赖，所以我们可以提前评估，做好熔断，隔离，限流。\n5.6、熔断简单来说就是在服务D前加一个阀门，某个服务频繁超时，直接将其短路，快速返回mock（模拟/虚拟）值\n说到熔断器，第一时间会想到Hystrix。下面我们一起来看下熔断器的实现原理\n\n    \n\n\n熔断器实际上是一个简单的有限状态机(Finite State Machine)\n\n请求错误率达到某一阈值，熔断器全开，产生熔断（熔断期间会对所有请求采用降级处理）\n\n到熔断时间窗口之后，熔断器会进入半开状态，此时hystrix会放过1个试验性请求\n\n如果该试验性请求成功，熔断器进入关闭状态\n\n如果该试验性请求失败，熔断器重新进入全开状态\n\n\n5.7、限流限流可以认为服务降级的一种，限流就是限制某个服务每秒的调用本服务的频率，限制系统的输入和输出流量已达到保护系统的目的。\n一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。\n\n    \n\n\n\n\n5.8、API网关API网关要做很多工作，它作为一个系统的后端总入口，承载着所有服务的组合路由转换等工作。除此之外，我们一般也会把安全，限流，缓存，日志，监控，重试，熔断等放到 API 网关来做。\n简单说，API网关是微服务架构中的“指路人”与“守护者”。首先，它会提供最基本的路由服务，将调用转发到上游服务。其次，作为一个入口，它还可以进行认证，鉴权，限流等操作，对上游服务保护。所以说，有了API网关，就可以做到“一夫当关，万夫莫开”。\n由于API网关在整个架构系统中位置特别重要，而且承受巨大的压力。所以，高性能和高可用都需要考虑。比较常用的做法是在网关的前面，加上负载均衡，这样，网关既能水平扩展，又能保证高可用。\n5.9、服务跟踪追踪服务的调用链，记录整个系统执行请求过程。如：请求响应时间，判断链中的哪些服务属于慢服务（可能存在问题，需要改善）。\n随着业务的发展,系统规模也会变得越来越大,各微服务间的调用关系也变得越来越错综复杂。通常一个由客户端发起的请求在后端系统中会经过多个不同的微服务调用来协同产生最后的请求结果,在复杂的微服务架构系统中,几乎每一个前端请求都会形成一条复杂的分布式服务调用链路,在每条链路中任何一个依赖服务出现延迟过高或错误的时候都有可能引起请求最后的失败。这时候, 对于每个请求,全链路调用的跟踪就变得越来越重要,通过实现对请求调用的跟踪可以帮助我们快速发现错误根源以及监控分析每条请求链路上的性能瓶颈等。\n6.0、弹性云Elastic Compute Service（ECS）弹性计算服务\n动态扩容，压榨服务器闲时能力\n例如：双11,618，高峰时多配置些服务器，平时减少多余的服务器配置（用于其他服务应用），避免资源浪费\n6、微服务内容\n\n6.1、微服务架构\n    \n\n\n物联网（ IoT ，Internet of things ）即“万物相连的互联网”，是互联网基础上的延伸和扩展的网络，将各种信息传感设备与互联网结合起来而形成的一个巨大网络，实现在任何时间、任何地点，人、机、物的互联互通。\nBreaker dashboard 断路器仪表板\nDistributed Tracing分布式跟踪 （分布式处理程序链跟踪用于监视网络等待时间，并可视化通过微服务的请求流）\n6.2、微服务是什么微服务架是从SOA架构演变过来，比SOA架构粒度会更加精细，让专业的人去做专业的事情（专注），目的提高效率，每个服务于服务之间互不影响，微服务架构中，每个服务必须独立部署，互不影响，微服务架构更加体现轻巧、轻量级，是适合于互联网公司敏捷开发。\n6.3、微服务理论简而言之，微服务架构风格是一种将单个应用程序开发为一组小服务的方法，每个小服务都在自己的进程中运行，并与轻量级机制（通常是 HTTP 资源 API）进行通信。这些服务是围绕业务能力构建的，并且可以通过完全自动化的部署机制独立部署。这些服务有最低限度的集中管理，它们可以用不同的编程语言编写并使用不同的数据存储技术。\n6.4、微服务架构特征微服务架构倡导应用程序设计程多个独立、可配置、可运行和可微服务的子服务。\n服务与服务通讯协议采用Http协议，使用restful风格API形式来进行通讯，数据交换格式轻量级json格式通讯，整个传输过程中，采用二进制，所以http协议可以跨语言平台，并且可以和其他不同的语言进行相互的通讯，所以很多开放平台都采用http协议接口。\n6.5、微服务架构如何拆分1、微服务把每一个职责单一功能存放在独立的服务中\n2、每个服务运行在单独的进程中\n3、每个服务有自己独立数据库存储、实际上有自己独立的缓存、数据库、消息队列等资源。\n6.6、微服务架构与SOA架构区别1、微服务架构基于 SOA架构 演变过来，继承 SOA架构的优点，在微服务架构中去除 SOA 架构中的 ESB 消息总线，采用 http+json（restful）进行传输。\n2、微服务架构比 SOA 架构粒度会更加精细，让专业的人去做专业的事情（专注），目的提高效率，每个服务于服务之间互不影响，微服务架构中，每个服务必须独立部署，微服务架构更加轻巧，轻量级。\n3、SOA 架构中可能数据库存储会发生共享，微服务强调独每个服务都是单独数据库，保证每个服务于服务之间互不影响。\n4、项目体现特征微服务架构比 SOA 架构更加适合与互联网公司敏捷开发、快速迭代版本，因为粒度非常精细。\n7、SpringCloud介绍及组件\n\n7.1、为什么选择SpringCloud因为SpringCloud出现，对微服务技术提供了非常大的帮助，因为SpringCloud 提供了一套完整的微服务解决方案，不像其他框架只是解决了微服务中某个问题。\n服务治理：阿里巴巴开源的Dubbo和当当网在其基础上扩展的Dubbox、Eureka、Apache 的Consul等。\n分布式配置中心：百度的disconf、Netfix的Archaius、360的QConf、SpringCloud Config、携程的阿波罗等。\n分布式任务：xxl-job、elastic-job、springcloud的task等。\n服务跟踪：京东的hyra、springcloud的sleuth等。\n7.2、SpringCloud介绍Spring Cloud为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理，服务发现，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁定，领导选举，分布式会话，集群状态）。分布式系统的协调导致了样板模式，使用Spring Cloud开发人员可以快速站起来实现这些模式的服务和应用程序。它们适用于任何分布式环境，包括开发人员自己的笔记本电脑，裸机数据中心和Cloud Foundry等托管平台。\n7.3、SpringCloud组件Spring Cloud构建微服务是基于SpringBoot开发的，服务之间通过基于 HTTP 的 RESTFUL API 进行通信协作的。\n版本选择：SpringBoot-2.2.2.RELEASE版和SpringCloud Hoxton.SR1版，后面会改用 SpringCloud Alibaba 2.1\nSpring Boot：https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/\nSpring Cloud：https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/\n中文版：https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md\nSpring Cloud组件由20多个组件组成的，常用的组件有如下：\n主要组件：\n\nEureka：服务注册中心，特性有失效剔除、服务保护\nDashboard，Hystrix仪表盘：监控集群模式和单点模式，其中集群模式需要收集器Turbine配合\nZuul：API服务网关，功能有路由分发和过滤\nConfig：分布式配置中心，支持本地仓库、SVN、Git、Jar包内配置等模式\n\n融合：融合在每个微服务中、依赖其它组件并为其提供服务\n\nRibbon：客户端负载均衡，特性有区域亲和、重试机制\nHystrix：客户端容错保护，特性有服务降级、服务熔断、请求缓存、请求合并、依赖隔离\nFeign：声明式服务调用，本质上就是Ribbon+Hystrix，类似于Dubbo的调用\nStream：消息驱动，有Sink、Source、Processor三种通道，特性有订阅发布、消费组、消息分区\nBus：消息总线，配合Config仓库修改的一种Stream实现\nSleuth：分布式服务追踪，需要搞清楚TraceID和SpanID以及抽样，并且与ZipKin整合\n在此还会涉及到SpringBoot的SpringBoot Admin（一个管理和监控 Spring Boot 应用程序的开源项目）\n\n组件的作用：\n每个组件都不是平白无故的产生的，是为了解决某一特定的问题而存在\n\nEureka：分为客户端和服务端，客户端是一个java客户端，用来连接Eureka服务端(说白了服务端就是Eureka注册中心)，与服务端进行交互，负载均衡，服务的故障切换等。。。作用类似于zookeeper\nRibbon：是一个基于HTTP和TCP的客户端负载均衡器，当使用Ribbon对服务进行访问的时候，他会扩展Eureka客户端的服务发现功能，实现从Eureka注册中心获取服务端列表，并通过Eureka客户端来确定服务端是否已经启动。Ribbon在Eureka客户端服务发现的基础上，实现对服务实例的选择策略，从而实现对服务的负载均衡消费。\n\n总结：Eureka和Ribbon，是最基础的组件，一个注册服务，一个负载均衡消费服务。\n\nHystrix(断路器/熔断器)：为了优化Ribbon、防止整个微服务架构因为某个服务节点的问题导致崩溃，是个保险丝的作用，防止服务雪崩。\nDashboard：给Hystrix统计和展示用的，而且监控服务节点的整体压力和健康情况。\nTurbine：是集群收集器，服务于Dashboard的。\nFeign：是Netflix公司开发的一个声明式的REST调用客户端，Ribbon负载均衡，Hystrix服务熔断是Spring Cloud中进行微服务开发的最基础的组件，在使用过程中我一般发现他们都是一起存在的，而且配置也相似，每次开发都有相同的代码，因此Spring Cloud基于Netflix Feign 整合了Ribbon和Hystrix两个组件，让开发更简单\nZuul：是加在整个微服务最前沿的防火墙和代理器，隐藏微服务结点IP端口信息，加强安全保护的。\nConfig：是为了解决所有微服务各自维护各自的配置，设置一个统一的配置中心，方便修改配置的。\nBus：是因为config修改完配置后各个结点都要refresh才能生效实在太麻烦，所以交给bus来通知服务节点刷新配置的。\nStream：是为了简化研发人员对MQ使用的复杂度，弱化MQ的差异性，达到程序和MQ松耦合。目前只支持RabbitMQ和Kafka\nSleuth：是因为单次请求在微服务节点中跳转无法追溯，解决任务链日志追踪问题的\n\n7.4、Cloud和Boot的依赖关系https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/\nhttps://cloud.spring.io/spring-cloud-static/Hoxton.SR3/reference/html/spring-cloud.html\n更详细的版本对应查看方法： https://start.spring.io/actuator/info \n8、SpringCloud入门程序\n\n8.1、父工程（cloud-parent）&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n\n    &lt;groupId&gt;com.atguigu&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;cloud-parent&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;!-- 统一管理jar包版本 --&gt;\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;\n        &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;\n        &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;\n        &lt;junit.version&gt;4.12&lt;&#x2F;junit.version&gt;\n        &lt;log4j.version&gt;1.2.17&lt;&#x2F;log4j.version&gt;\n        &lt;lombok.version&gt;1.16.18&lt;&#x2F;lombok.version&gt;\n        &lt;mysql.version&gt;5.1.47&lt;&#x2F;mysql.version&gt;\n        &lt;druid.version&gt;1.1.16&lt;&#x2F;druid.version&gt;\n        &lt;mybatis.spring.boot.version&gt;1.3.0&lt;&#x2F;mybatis.spring.boot.version&gt;\n    &lt;&#x2F;properties&gt;\n\n    &lt;!-- 子模块继承之后，提供作用：锁定版本+子modlue不用写groupId和version  --&gt;\n    &lt;dependencyManagement&gt;\n        &lt;dependencies&gt;\n            &lt;!--spring boot 2.2.2--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;2.2.2.RELEASE&lt;&#x2F;version&gt;\n                &lt;type&gt;pom&lt;&#x2F;type&gt;\n                &lt;scope&gt;import&lt;&#x2F;scope&gt;\n            &lt;&#x2F;dependency&gt;\n            &lt;!--spring cloud Hoxton.SR1--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;Hoxton.SR1&lt;&#x2F;version&gt;\n                &lt;type&gt;pom&lt;&#x2F;type&gt;\n                &lt;scope&gt;import&lt;&#x2F;scope&gt;\n            &lt;&#x2F;dependency&gt;\n            &lt;!--spring cloud alibaba 2.1.0.RELEASE--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;2.1.0.RELEASE&lt;&#x2F;version&gt;\n                &lt;type&gt;pom&lt;&#x2F;type&gt;\n                &lt;scope&gt;import&lt;&#x2F;scope&gt;\n            &lt;&#x2F;dependency&gt;\n\n            &lt;dependency&gt;\n                &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;$&#123;mysql.version&#125;&lt;&#x2F;version&gt;\n            &lt;&#x2F;dependency&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;$&#123;druid.version&#125;&lt;&#x2F;version&gt;\n            &lt;&#x2F;dependency&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;$&#123;mybatis.spring.boot.version&#125;&lt;&#x2F;version&gt;\n            &lt;&#x2F;dependency&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;$&#123;junit.version&#125;&lt;&#x2F;version&gt;\n            &lt;&#x2F;dependency&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;$&#123;log4j.version&#125;&lt;&#x2F;version&gt;\n            &lt;&#x2F;dependency&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;$&#123;lombok.version&#125;&lt;&#x2F;version&gt;\n                &lt;optional&gt;true&lt;&#x2F;optional&gt;\n            &lt;&#x2F;dependency&gt;\n        &lt;&#x2F;dependencies&gt;\n    &lt;&#x2F;dependencyManagement&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;fork&gt;true&lt;&#x2F;fork&gt;\n                    &lt;addResources&gt;true&lt;&#x2F;addResources&gt;\n                &lt;&#x2F;configuration&gt;\n            &lt;&#x2F;plugin&gt;\n        &lt;&#x2F;plugins&gt;\n    &lt;&#x2F;build&gt;\n\n&lt;&#x2F;project&gt;\n\n\n\n8.2、Rest微服务，服务提供者&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;cloud-parent&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;com.atguigu&lt;&#x2F;groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n\n    &lt;artifactId&gt;cloud-provider-payment8001&lt;&#x2F;artifactId&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;1.1.10&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;\n\nYML配置文件\nserver:\n  port: 8001\n\nspring:\n  application:\n    name: cloud-payment-service\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springcloud?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;false\n    username: root\n    password: root\n\nmybatis:\n  mapperLocations: classpath:&#x2F;mapper&#x2F;*.xml\n  type-aliases-package: com.atguigu.springcloud.entities\n\n主启动器\npackage com.atguigu.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class PaymentMain8001 &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(PaymentMain8001.class,args);\n    &#125;\n&#125;\n\n建表\nCREATE DATABASE  IF NOT EXISTS springcloud DEFAULT CHARACTER SET utf8 ;\n\nUSE springcloud;\n\nDROP TABLE IF EXISTS payment ;\n\nCREATE TABLE payment (\n  id BIGINT (20) NOT NULL AUTO_INCREMENT COMMENT &#39;ID&#39;,\n  SERIAL VARCHAR (300) DEFAULT NULL,\n  PRIMARY KEY (id)\n) ENGINE &#x3D; INNODB AUTO_INCREMENT &#x3D; 33 DEFAULT CHARSET &#x3D; utf8 ;\n\nINSERT INTO payment (id, SERIAL) VALUES(31, &#39;尚硅谷001&#39;),(32, &#39;atguigu002&#39;) ;\n\n实体\npackage com.atguigu.springcloud.entities;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport java.io.Serializable;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Payment implements Serializable &#123;\n    private Long id;\n    private String serial;\n&#125;\n\n结果封装实体类\npackage com.atguigu.springcloud.entities;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class CommonResult &lt;T&gt; implements Serializable&#123;\n\n    private Integer code;\n    private String message;\n    private T data;\n\n    public CommonResult(Integer code,String message)&#123;\n        this(code,message,null);&#x2F;&#x2F;如果这行报错，请安装lombok插件\n    &#125;\n&#125;\n\ndao\npackage com.atguigu.springcloud.dao;\n\nimport com.atguigu.springcloud.entities.Payment;\nimport org.apache.ibatis.annotations.Mapper;\nimport org.apache.ibatis.annotations.Param;\nimport org.springframework.stereotype.Repository;\n\n@Component       &#x2F;&#x2F;代替@Repository声明bean\n@Mapper               &#x2F;&#x2F;mybatis提供的，等价：@MapperScan(&quot;com.atguigu.springcloud.dao&quot;)\n&#x2F;&#x2F;@Repository     &#x2F;&#x2F;spring提供的。在此，只是为了声明bean对象\npublic interface PaymentDao &#123;\n    public int create(Payment payment);    \n    public Payment getPaymentById(@Param(&quot;id&quot;) Long id);\n&#125;\n\nmapper\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;\n\n&lt;mapper namespace&#x3D;&quot;com.atguigu.springcloud.dao.PaymentDao&quot;&gt;\n    &lt;insert id&#x3D;&quot;create&quot;  useGeneratedKeys&#x3D;&quot;true&quot; keyProperty&#x3D;&quot;id&quot;&gt;\n            insert into payment(serial) values(#&#123;serial&#125;);\n    &lt;&#x2F;insert&gt;\n\n    \n\n    &lt;select id&#x3D;&quot;getPaymentById&quot;  parameterType&#x3D;&quot;Long&quot; resultType&#x3D;“payment”&gt;\n            select * from payment where id&#x3D;#&#123;id&#125;\n    &lt;&#x2F;select&gt;\n\n&lt;&#x2F;mapper&gt;\n\nservice\npackage com.atguigu.springcloud.service;\n\nimport com.atguigu.springcloud.entities.Payment;\nimport org.apache.ibatis.annotations.Param;\n\npublic interface PaymentService &#123;\n    public int create(Payment payment); &#x2F;&#x2F;写\n    public Payment getPaymentById(Long id);  &#x2F;&#x2F;读取\n&#125;\n\nserviceimpl\npackage com.atguigu.springcloud.service.impl;\n\nimport com.atguigu.springcloud.dao.PaymentDao;\nimport com.atguigu.springcloud.entities.Payment;\nimport com.atguigu.springcloud.service.PaymentService;\nimport org.apache.ibatis.annotations.Param;\nimport org.springframework.stereotype.Service;\nimport javax.annotation.Resource;\n\n@Service\npublic class PaymentServiceImpl implements PaymentService &#123;\n\n    @Resource\n    &#x2F;&#x2F;@Autowired\n    private PaymentDao paymentDao;\n\n    public int create(Payment payment)&#123;\n        return paymentDao.create(payment);\n    &#125;\n\n    public Payment getPaymentById( Long id)&#123;\n        return paymentDao.getPaymentById(id);\n    &#125;\n&#125;\n\ncontroller（restful风格）\npackage com.atguigu.springcloud.controller;\n\nimport com.atguigu.springcloud.entities.CommonResult;\nimport com.atguigu.springcloud.entities.Payment;\nimport com.atguigu.springcloud.service.PaymentService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport javax.annotation.Resource;\n\n@RestController\n@Slf4j\npublic class PaymentController &#123;\n\n    @Resource\n    private PaymentService paymentService;\n\n    @PostMapping(value &#x3D; &quot;&#x2F;payment&#x2F;create&quot;)\n    public CommonResult&lt;Payment&gt; create(Payment payment)&#123; &#x2F;&#x2F;埋雷\n       int result &#x3D; paymentService.create(payment);\n       log.info(&quot;*****插入结果：&quot;+result);\n       if (result&gt;0)&#123;  &#x2F;&#x2F;成功\n           return new CommonResult(200,&quot;插入数据库成功&quot;,result);\n       &#125;else &#123;\n           return new CommonResult(444,&quot;插入数据库失败&quot;,null);\n       &#125;\n    &#125;\n\n    @GetMapping(value &#x3D; &quot;&#x2F;payment&#x2F;get&#x2F;&#123;id&#125;&quot;)\n    public CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(&quot;id&quot;) Long id)&#123;\n        Payment payment &#x3D; paymentService.getPaymentById(id);\n        log.info(&quot;*****查询结果：&quot;+payment);\n        if (payment!&#x3D;null)&#123;  &#x2F;&#x2F;说明有数据，能查询成功\n            return new CommonResult(200,&quot;查询成功&quot;,payment);\n        &#125;else &#123;\n            return new CommonResult(444,&quot;没有对应记录，查询ID：&quot;+id,null);\n        &#125;\n    &#125;\n&#125;\n\n\n\n8.3、Rest微服务，服务消费者pom和上述一样\nyml\nserver:\n  port: 80\nspring:\n  application:\n    name: cloud-consumer-order80\n\n写启动类\n写业务类\n\n创建entities(将cloud-provider-payment8001工程下的entities包下的两个实体类复制过来)\nRestTemplate是什么RestTemplate提供了多种便捷访问远程Http服务的方法，是一种简单便捷的访问Restful服务模板类，是Spring 提供的用于访问Rest服务的客户端模板工具集\n官网及使用官网地址： https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html\n使用RestTemplate访问Restful接口非常的简单粗暴无脑。（url，requestMap，ResponseBean.class）这三个参数分别代表REST请求地址、请求参数、Http响应转换被转换成的对象类型。\n\nconfig配置类ApplicationContextConfig\npackage com.atguigu.springcloud.config;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.client.RestTemplate;\n\n&#x2F;&#x2F;@Configuration\n@SpringBootConfiguration\npublic class ApplicationContextConfig &#123;\n    @Bean\n    &#x2F;&#x2F;@LoadBalanced\n    public RestTemplate getRestTemplate()&#123;\n        return new RestTemplate();\n    &#125;\n&#125;\n\n\n创建controller\npackage com.atguigu.springcloud.controller;\nimport com.atguigu.springcloud.entities.CommonResult;\nimport com.atguigu.springcloud.entities.Payment;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.client.RestTemplate;\nimport javax.annotation.Resource;\n\n@RestController\n@Slf4j\npublic class OrderController &#123;\n    public static final String PAYMENT_URL &#x3D; &quot;http:&#x2F;&#x2F;localhost:8001&quot;;\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @PostMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;create&quot;)\n    public CommonResult&lt;Payment&gt;   create(Payment payment)&#123;\n        return restTemplate.postForObject(PAYMENT_URL+&quot;&#x2F;payment&#x2F;create&quot;,payment,CommonResult.class);  &#x2F;&#x2F;写操作\n    &#125;\n\n    @GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;get&#x2F;&#123;id&#125;&quot;)\n    public CommonResult&lt;Payment&gt; getPayment(@PathVariable(&quot;id&quot;) Long id)&#123;\n        return restTemplate.getForObject(PAYMENT_URL+&quot;&#x2F;payment&#x2F;get&#x2F;&quot;+id,CommonResult.class);\n    &#125;\n&#125;\n测试\n\n先启动cloud-provider-payment8001\n\n再启动cloud-consumer-order80\n\nhttp://localhost/consumer/payment/get/32\n\n不要忘记@RequestBody注解\n\n服务提供者接口方法需要增加@RequestBody注解(踩雷or破雷)；否则，接收不到数据。\n\n\n8.4、提取重复代码，重构观察消费者和提供者模块中的内容，我们发现实体类是重复的\n新建：cloud-api-commons编写POM\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;cloud-parent&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;com.atguigu&lt;&#x2F;groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n    &lt;artifactId&gt;cloud-api-commons&lt;&#x2F;artifactId&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;cn.hutool&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;hutool-all&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;5.1.0&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;\n\n编写entities\n\nPayment实体\nCommonResult通用封装类\n\n服务消费者和提供者模块删除这两个实体类，并在两个pom中添加：\n&lt;dependency&gt;\n    &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;cloud-api-commons&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;$&#123;project.version&#125;&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n","slug":"68-SpringCloud-基础内容","date":"2021-09-13T15:44:32.000Z","categories_index":"SpringCloud","tags_index":"SpringCloud","author_index":"大黄"},{"id":"572316d3a9d6ae4c1865a38d55232e93","title":"RabbitMQ 高级部分","content":"01、消息的可靠性投递\n1.1、消息投递可靠性的简介在使用 RabbitMQ 时，作为消息发送方希望杜绝任何消息丢失或者失败的场景。RabbitMQ 为我们提供了两种方式用来控制消息的投递可靠性模式：==① confirm 确认模式        ② return 退回模式==\nrabbitmq 整个消息的 投递路径为：producer —&gt; rabbitmq broker —&gt; exchange —&gt; queue —&gt; consumer\n\n消息从 producer —&gt; exchange 则会返回一个 confirmCallback 。\n消息从 exchange ––&gt; queue 投递失败则会返回一个 returnCallback 。\n\n:star: 我们利用这两个 callback 控制消息的可靠性传递\n1.2、消息投递可靠性生产者在 spring 的配置文件中，我们定义rabbitmq connectionFactory 时，我们需要在连接工厂的配置项中 ==保证 确认模式 / 退回模式 开启==\n\npublisher-confirms = “true”\npublisher-returns = “true”\n\n若我们现在有一个测试方法，那==在测试方法中，我们需要定义相关的 确认或回退 的回调方法==，如下：\n:chestnut: 生产者的 spring 配置\n&lt;!--加载配置文件--&gt;\n&lt;context:property-placeholder location&#x3D;&quot;classpath:rabbitmq.properties&quot;&#x2F;&gt;\n\n&lt;!-- 定义rabbitmq connectionFactory\n     确认模式开启：publisher-confirms&#x3D;&quot;true&quot;\n    --&gt;\n&lt;rabbit:connection-factory id&#x3D;&quot;connectionFactory&quot; host&#x3D;&quot;$&#123;rabbitmq.host&#125;&quot;\n                           port&#x3D;&quot;$&#123;rabbitmq.port&#125;&quot;\n                           username&#x3D;&quot;$&#123;rabbitmq.username&#125;&quot;\n                           password&#x3D;&quot;$&#123;rabbitmq.password&#125;&quot;\n                           virtual-host&#x3D;&quot;$&#123;rabbitmq.virtual-host&#125;&quot;\n                           publisher-confirms&#x3D;&quot;true&quot;\n                           publisher-returns&#x3D;&quot;true&quot;\n                           &#x2F;&gt;\n&lt;!--定义管理交换机、队列--&gt;\n&lt;rabbit:admin connection-factory&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;\n\n&lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt;\n&lt;rabbit:template id&#x3D;&quot;rabbitTemplate&quot; connection-factory&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;\n\n&lt;!--消息可靠性投递（生产端）--&gt;\n&lt;rabbit:queue id&#x3D;&quot;test_queue_confirm&quot; name&#x3D;&quot;test_queue_confirm&quot;&gt;&lt;&#x2F;rabbit:queue&gt;\n&lt;rabbit:direct-exchange name&#x3D;&quot;test_exchange_confirm&quot;&gt;\n    &lt;rabbit:bindings&gt;\n        &lt;rabbit:binding queue&#x3D;&quot;test_queue_confirm&quot; key&#x3D;&quot;confirm&quot;&gt;&lt;&#x2F;rabbit:binding&gt;\n    &lt;&#x2F;rabbit:bindings&gt;\n&lt;&#x2F;rabbit:direct-exchange&gt;\n\n:chestnut: ​确认回调方法\npackage com.atguigu;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.amqp.AmqpException;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.core.MessagePostProcessor;\nimport org.springframework.amqp.rabbit.connection.CorrelationData;\nimport org.springframework.amqp.rabbit.core.RabbitTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\nimport org.springframework.test.context.junit4.SpringRunner;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations &#x3D; &quot;classpath:spring-rabbitmq-producer.xml&quot;)\npublic class ProducerTest &#123;\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n    &#x2F;**\n     * 确认模式：\n     * 步骤：\n     * 1. 确认模式开启：ConnectionFactory中开启publisher-confirms&#x3D;&quot;true&quot;\n     * 2. 在rabbitTemplate定义ConfirmCallBack回调函数\n     *&#x2F;\n    @Test\n    public void testConfirm() &#123;\n        &#x2F;&#x2F;2. 定义回调\n        rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() &#123;\n            @Override\n            public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123;\n                if (ack)&#123;\n                    &#x2F;&#x2F;接收成功\n                    System.out.println(&quot;接收成功消息&quot; + cause);\n                &#125;else &#123;\n                    &#x2F;&#x2F;接收失败\n                    System.out.println(&quot;接收失败消息&quot; + cause);\n                    &#x2F;&#x2F;做一些处理,让消息再次发送。\n                &#125;\n            &#125;\n        &#125;);\n\n        &#x2F;&#x2F;3. 发送消息\n        rabbitTemplate.convertAndSend(&quot;test_exchange_confirm&quot;, &quot;confirm&quot;, &quot;message confirm....&quot;);&#x2F;&#x2F;成功\n        &#x2F;&#x2F;rabbitTemplate.convertAndSend(&quot;test_exchange_confirm000&quot;, &quot;confirm&quot;, &quot;message confirm....&quot;);&#x2F;&#x2F;失败\n    &#125;\n&#125;\n\n\n\n:chestnut: ​退回回调方法\npackage com.atguigu;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.amqp.AmqpException;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.core.MessagePostProcessor;\nimport org.springframework.amqp.rabbit.connection.CorrelationData;\nimport org.springframework.amqp.rabbit.core.RabbitTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\nimport org.springframework.test.context.junit4.SpringRunner;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations &#x3D; &quot;classpath:spring-rabbitmq-producer.xml&quot;)\npublic class ProducerTest &#123;\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    &#x2F;**\n     * 回退模式： 当消息发送给Exchange后,Exchange路由到Queue失败时 才会执行 ReturnCallBack\n     * 步骤：\n     * 1. 开启回退模式：publisher-returns&#x3D;&quot;true&quot;\n     * 2. 设置ReturnCallBack\n     * 3. 设置Exchange处理消息的模式：\n     *      1). 如果消息没有路由到Queue,则丢弃消息（默认）\n     *      2). 如果消息没有路由到Queue,返回给消息发送方ReturnCallBack\n     *            rabbitTemplate.setMandatory(true);\n     *&#x2F;\n    @Test\n    public void testReturn() &#123;\n\n        &#x2F;&#x2F;设置交换机处理失败消息的模式\n        rabbitTemplate.setMandatory(true);\n\n        &#x2F;&#x2F;2.设置ReturnCallBack\n        rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() &#123;\n            &#x2F;**\n             * @param message   消息对象\n             * @param replyCode 错误码\n             * @param replyText 错误信息\n             * @param exchange  交换机\n             * @param routingKey 路由键\n             *&#x2F;\n            @Override\n            public void returnedMessage(Message message, int replyCode,String replyText,String exchange,String routingKey) &#123;\n                System.out.println(&quot;return 执行了....&quot;);\n\n                System.out.println(message);\n                System.out.println(replyCode);\n                System.out.println(replyText);\n                System.out.println(exchange);\n                System.out.println(routingKey);\n\n                &#x2F;&#x2F;处理\n            &#125;\n        &#125;);\n\n        &#x2F;&#x2F;3. 发送消息\n        rabbitTemplate.convertAndSend(&quot;test_exchange_confirm&quot;, &quot;confirm&quot;, &quot;message confirm....&quot;);\n    &#125;\n&#125;\n\n\n\n\n\n1.3、投递可靠性生产者小结\n设置 ConnectionFactory的publisher-confirms=”true” 开启 确认模式。\n使用 rabbitTemplate.setConfirmCallback 设置回调函数。当消息发送到 exchange 后回调 confirm 方法。在方法中判断 ack，如果为true，则发送成功，如果为false，则发送失败，需要处理。\n设置 ConnectionFactory 的 publisher-returns=”true” 开启 退回模式。\n使用 rabbitTemplate.setReturnCallback 设置退回函数，当消息从exchange 路由到 queue 失败后，如果设置了 rabbitTemplate.setMandatory(true) 参数，则会将消息退回给 producer并执行回调函数returnedMessage\n\n1.4、Consumer Ack 消费者ack 指 Acknowledge，确认。 ==表示消费端收到消息后的确认方式==。\n有二种确认方式：\n\n自动确认：acknowledge=“none” 默认\n手动确认：acknowledge=“manual”\n\n:star: ​确认方式的概念：\n\n自动确认是指，当消息一旦被Consumer接收到，则自动确认收到，并将相应 message 从 RabbitMQ 的消息缓存中移除。但是在实际业务处理中，很可能==消息接收到，业务处理出现异常，那么该消息就会丢失==。\n手动确认方式，让监听器类实现ChannelAwareMessageListener接口，并且需要在业务处理成功后，调用channel.basicAck()，手动签收，如果出现异常，则调用channel.basicNack()方法，让其自动重新发送消息\n\n:star: ==如果没有确认接收，那我们的数据会进入到 Unacked 状态，也就是 未确认的==，手动确认接收后，会消失或者进入死信队列\n:star: ​==如果没有设置限流，并且数据较少，那么mq会一下加载全部的数据，并且全部进入 Unacked状态，然后读出一条，删除一条==\n:star: ==如果到最后，mq中还有数据，但是消费者不读取了，那么 Unacked状态的数据会从新变为 待读取的状态，Ready==\n消费者的 spring 配置\n&lt;!--加载配置文件--&gt;\n&lt;context:property-placeholder location&#x3D;&quot;classpath:rabbitmq.properties&quot;&#x2F;&gt;\n\n&lt;!-- 定义rabbitmq connectionFactory --&gt;\n&lt;rabbit:connection-factory id&#x3D;&quot;connectionFactory&quot; host&#x3D;&quot;$&#123;rabbitmq.host&#125;&quot;\n                           port&#x3D;&quot;$&#123;rabbitmq.port&#125;&quot;\n                           username&#x3D;&quot;$&#123;rabbitmq.username&#125;&quot;\n                           password&#x3D;&quot;$&#123;rabbitmq.password&#125;&quot;\n                           virtual-host&#x3D;&quot;$&#123;rabbitmq.virtual-host&#125;&quot;&#x2F;&gt;\n\n&lt;context:component-scan base-package&#x3D;&quot;com.atguigu.listener&quot; &#x2F;&gt;\n\n&lt;!--定义监听器容器\n    acknowledge&#x3D;&quot;manual&quot;：手动签收\n    --&gt;\n&lt;rabbit:listener-container connection-factory&#x3D;&quot;connectionFactory&quot; acknowledge&#x3D;&quot;manual&quot;&gt;\n    &lt;rabbit:listener ref&#x3D;&quot;ackListener&quot; queue-names&#x3D;&quot;test_queue_confirm&quot;&gt;&lt;&#x2F;rabbit:listener&gt;\n&lt;&#x2F;rabbit:listener-container&gt;\n\n自动确认监听器代码\npackage com.atguigu.listener;\n\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.core.MessageListener;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class AckListener implements MessageListener &#123;\n    @Override\n    public void onMessage(Message message) &#123;\n        System.out.println(new String(message.getBody()));\n    &#125;\n&#125;\n\n手动确认监听器代码\npackage com.atguigu.listener;\n\nimport com.rabbitmq.client.Channel;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener;\nimport org.springframework.stereotype.Component;\nimport java.io.IOException;\n\n&#x2F;**\n * Consumer ACK机制：\n *  1. 设置手动签收。acknowledge&#x3D;&quot;manual&quot;\n *  2. 让监听器类实现ChannelAwareMessageListener接口\n *  3. 如果消息成功处理,则调用channel的 basicAck()签收\n *  4. 如果消息处理失败,则调用channel的basicNack()拒绝签收,broker重新发送给consumer\n*&#x2F;\n@Component\npublic class AckListener implements ChannelAwareMessageListener &#123;\n    @Override\n    public void onMessage(Message message, Channel channel) throws Exception &#123;\n        Thread.sleep(1000);\n        &#x2F;&#x2F; 获取消息传递标记\n        long deliveryTag &#x3D; message.getMessageProperties().getDeliveryTag();\n        try &#123;\n            &#x2F;&#x2F; ① 接收消息\n            System.out.println(new String(message.getBody()));\n            &#x2F;&#x2F; ② 处理业务逻辑\n            System.out.println(&quot;处理业务逻辑&quot;);\n            int i &#x3D; 3&#x2F;0;&#x2F;&#x2F;出现错误\n            &#x2F;&#x2F; ③ 手动签收\n            &#x2F;**\n             * 第一个参数：表示收到的标签\n             * 第二个参数：如果为true表示可以签收所有的消息\n             *&#x2F;\n            channel.basicAck(deliveryTag,true);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            &#x2F;&#x2F; ④ 拒绝签收\n             &#x2F;*\n            第三个参数：requeue：重回队列。\n            设置为true,则消息重新回到queue,broker会重新发送该消息给消费端\n             *&#x2F;\n            channel.basicNack(deliveryTag,true,true);\n        &#125;\n    &#125;\n&#125;\n\n消费端测试类\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations &#x3D; &quot;classpath:spring-rabbitmq-consumer.xml&quot;)\npublic class ConsumerTest &#123;\n    @Test\n    public void test()&#123;\n        while (true)&#123;\n\n        &#125;\n    &#125;\n&#125;\n\n\n\n1.5、投递可靠性消费者小结在rabbit:listener-container标签中设置acknowledge属性，设置ack方式 none：自动确认，manual：手动确认\n如果在消费端没有出现异常，则调用channel.basicAck(deliveryTag，true);方法确认签收消息\n如果出现异常，则在catch中调用 basicNack，拒绝消息，让MQ重新发送消息。\n02、消费端限流\n当请求很多时，限制消费端每次从 MQ 中拉取的消息数量，也就是所谓的 QPS ，每秒最大查询率\n2.1、限流操作的使用在 1 的项目中新建 QpsListener\npackage com.atguigu.listener;\n\nimport com.rabbitmq.client.Channel;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener;\n\n&#x2F;**\n * Consumer 限流机制\n *  1. 确保消息被确认。不确认是不继续处理其他消息的\n *  2. listener-container配置属性\n *      prefetch &#x3D; 1,表示消费端每次从mq拉去一条消息来消费,直到手动确认消费完毕后,才会继续拉取下一条消息。\n *&#x2F;\n@Component\npublic class QpsListener implements ChannelAwareMessageListener &#123;\n    @Override\n    public void onMessage(Message message, Channel channel) throws Exception &#123;\n        &#x2F;&#x2F;1.获取消息\n        System.out.println(new String(message.getBody()));\n    &#125;\n&#125;\n\n修改 consumer 的 spring 配置文件\n在 listener-container 标签中添加 ==prefetch（预取）== 属性，1，表示准备从 mq 中一次最多取 1个\n&lt;bean id&#x3D;&quot;QpsListener&quot; class&#x3D;&quot;com.atguigu.QpsListener&quot;&gt;&lt;&#x2F;bean&gt;\n\n&lt;rabbit:listener-container connection-factory&#x3D;&quot;connectionFactory&quot; auto-declare&#x3D;&quot;true&quot; prefetch&#x3D;&quot;1&quot;&gt;\n    &lt;rabbit:listener ref&#x3D;&quot;QpsListener&quot; queue-names&#x3D;&quot;test_qunue_confirm&quot;&#x2F;&gt;\n&lt;&#x2F;rabbit:listener-container&gt;\n\n运行生产者的测试代码\n@RunWith(SpringRunner.class)\n@ContextConfiguration(locations &#x3D; &quot;classpath:spring-rabbitmq-producer.xml&quot;)\npublic class ProducerTest &#123;\n\n    @Test\n    public void testSend() &#123;\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            rabbitTemplate.convertAndSend(&quot;test_exchange_confirm&quot;,&quot;confirm&quot;,&quot;message confirm&quot;);\n        &#125;\n    &#125;\n&#125; \n\n这个不太容易观察，因为一条一条的读也非常的快，几乎眨眼之间\n03、TTL\n3.1、TTL 概念TTL 全称 Time To Live（存活时间/过期时间）。\n当消息到达存活时间后，还没有被消费，会被自动清除，也有可能会变成 “死信”。\nRabbitMQ可以对消息设置过期时间，也可以对整个队列（Queue）设置过期时间。\n3.2、设置消息 TTL的两种方法\n第一种方法是通过队列属性设置，队列中所有消息都有相同的过期时间。\n默认情况下 value-type 的类型是 String 类型,但时间的类型是number类型,所以需要设置成 integer 类型\n&lt;!--TTL 队列--&gt;\n&lt;rabbit:queue name&#x3D;&quot;test_queue_ttl&quot; id&#x3D;&quot;test_queue_ttl&quot;&gt;\n    &lt;!--设置queue的参数--&gt;\n    &lt;rabbit:queue-arguments&gt;\n        &lt;!--\n              设置x-message-ttl队列的过期时间\n              默认情况下value-type的类型是String类型,但时间的类型是number类型,所以需要设置成integer类型\n            --&gt;\n        &lt;entry key&#x3D;&quot;x-message-ttl&quot; value&#x3D;&quot;10000&quot; value-type&#x3D;&quot;java.lang.Integer&quot;&#x2F;&gt;\n    &lt;&#x2F;rabbit:queue-arguments&gt;\n&lt;&#x2F;rabbit:queue&gt;\n第二种方法是对消息本身进行单独设置，每条消息的 TTL 可以不同。如果两种方法一起使用，则消息的 TTL 以两者之间较小的那个数值为准。使用的是 ==消息的后置处理器 MessagePostProcessor==\n@Test\npublic void testMessageTtl() &#123;\n    &#x2F;&#x2F; 消息后处理对象,设置一些消息的参数信息\n    MessagePostProcessor messagePostProcessor &#x3D; new MessagePostProcessor() &#123;\n\n        @Override\n        public Message postProcessMessage(Message message) throws AmqpException &#123;\n            &#x2F;&#x2F;1.设置message的信息\n            &#x2F;&#x2F; 第二个方法：消息的过期时间 ,5秒之后过期\n            message.getMessageProperties().setExpiration(&quot;5000&quot;);\n            &#x2F;&#x2F;2.返回该消息\n            return message;\n        &#125;\n    &#125;;\n\n    &#x2F;&#x2F;消息单独过期\n    rabbitTemplate.convertAndSend(&quot;test_exchange_ttl&quot;,&quot;ttl.hehe&quot;,&quot;message ttl....&quot;,messagePostProcessor);\n&#125;\n\n==注意：如果设置了消息的过期时间,也设置了队列的过期时间,它以时间短的为准。==\n3.3、代码实现1、第一种：队列全部消息过期修改 1 的 spring 配置文件\n&lt;!--加载配置文件--&gt;\n&lt;context:property-placeholder location&#x3D;&quot;classpath:rabbitmq.properties&quot;&#x2F;&gt;\n\n&lt;!-- 定义rabbitmq connectionFactory --&gt;\n&lt;rabbit:connection-factory id&#x3D;&quot;connectionFactory&quot; host&#x3D;&quot;$&#123;rabbitmq.host&#125;&quot;\n                           port&#x3D;&quot;$&#123;rabbitmq.port&#125;&quot;\n                           username&#x3D;&quot;$&#123;rabbitmq.username&#125;&quot;\n                           password&#x3D;&quot;$&#123;rabbitmq.password&#125;&quot;\n                           virtual-host&#x3D;&quot;$&#123;rabbitmq.virtual-host&#125;&quot;\n                           publisher-confirms&#x3D;&quot;true&quot;\n                           publisher-returns&#x3D;&quot;true&quot;&#x2F;&gt;\n&lt;!--定义管理交换机、队列--&gt;\n&lt;rabbit:admin connection-factory&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;\n\n&lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt;\n&lt;rabbit:template id&#x3D;&quot;rabbitTemplate&quot; connection-factory&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;\n\n&lt;!--消息可靠性投递（生产端）--&gt;\n&lt;rabbit:queue id&#x3D;&quot;test_queue_confirm&quot; name&#x3D;&quot;test_queue_confirm&quot;&#x2F;&gt;\n&lt;rabbit:direct-exchange name&#x3D;&quot;test_exchange_confirm&quot;&gt;\n    &lt;rabbit:bindings&gt;\n        &lt;rabbit:binding queue&#x3D;&quot;test_queue_confirm&quot; key&#x3D;&quot;confirm&quot;&#x2F;&gt;\n    &lt;&#x2F;rabbit:bindings&gt;\n&lt;&#x2F;rabbit:direct-exchange&gt;\n\n&lt;!--TTL 队列--&gt;\n&lt;rabbit:queue name&#x3D;&quot;test_queue_ttl&quot; id&#x3D;&quot;test_queue_ttl&quot;&gt;\n    &lt;!--设置queue的参数--&gt;\n    &lt;rabbit:queue-arguments&gt;\n        &lt;!--\n              设置x-message-ttl队列的过期时间\n              默认情况下value-type的类型是String类型,但时间的类型是number类型,所以需要设置成integer类型\n            --&gt;\n        &lt;entry key&#x3D;&quot;x-message-ttl&quot; value&#x3D;&quot;10000&quot; value-type&#x3D;&quot;java.lang.Integer&quot;&#x2F;&gt;\n    &lt;&#x2F;rabbit:queue-arguments&gt;\n&lt;&#x2F;rabbit:queue&gt;\n\n&lt;!--设置交换机--&gt;\n&lt;rabbit:topic-exchange name&#x3D;&quot;test_exchange_ttl&quot;&gt;\n    &lt;!--交换机绑定队列--&gt;\n    &lt;rabbit:bindings&gt;\n        &lt;rabbit:binding pattern&#x3D;&quot;ttl.#&quot; queue&#x3D;&quot;test_queue_ttl&quot;&#x2F;&gt;\n    &lt;&#x2F;rabbit:bindings&gt;\n&lt;&#x2F;rabbit:topic-exchange&gt;\n\n在测试类 ProducerTest 中,添加测试方法,发送消息\n@Test\npublic void testTTL() &#123;\n     for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n       rabbitTemplate.convertAndSend(&quot;test_exchange_ttl&quot;,&quot;ttl.hehe&quot;,&quot;message ttl&quot;);\n     &#125;\n&#125;\n\n查看控制台，10秒后自动过期\n\n\n2、第二种，消息过期@Test\npublic void testMessageTtl() &#123;\n    &#x2F;&#x2F; 消息后处理对象,设置一些消息的参数信息\n    MessagePostProcessor messagePostProcessor &#x3D; new MessagePostProcessor() &#123;\n\n        @Override\n        public Message postProcessMessage(Message message) throws AmqpException &#123;\n            &#x2F;&#x2F;1.设置message的信息\n            &#x2F;&#x2F; 第二个方法：消息的过期时间 ,5秒之后过期\n            message.getMessageProperties().setExpiration(&quot;5000&quot;);\n            &#x2F;&#x2F;2.返回该消息\n            return message;\n        &#125;\n    &#125;;\n\n    &#x2F;&#x2F;消息单独过期\n    rabbitTemplate.convertAndSend(&quot;test_exchange_ttl&quot;,&quot;ttl.hehe&quot;,&quot;message ttl....&quot;,messagePostProcessor);\n&#125;\n\n\n\n04、死信队列\n死信队列，英文缩写：DLX 。DeadLetter Exchange（死信交换机），当消息成为Dead message后，可以被重新发送到另一个交换机，这个交换机就是DLX。\n4.1、什么是死信队列先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，producer将消息投递到broker或者直接到queue里了，consumer从queue取出消息进行消费，但某些时候由于特定的原因导致queue中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信，自然就有了死信队列；\n消息变成死信一般是由于以下几种情况：\n\n==消息被拒绝（Reject/Nack），并且设置不把消息重新放入原目标队列 —&gt; requeue参数为false。==\n==消息过期（消息到达超时时间未被消费）。==\n==队列达到最大长度（消息数量达到最大限制）。==\n\nDLX也是一个正常的交换器，和一般的交换器没有区别，它能在任何的队列上被指定（实际上就是设置某个队列的属性）。当这个队列中存在死信时，RabbitMQ就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到死信队列，可以监听这个队列中的消息以进行相应的处理。\n\n    \n\n\n\n\n4.2、死信的处理方式死信的产生既然不可避免，那么就需要从实际的业务角度和场景出发，对这些死信进行后续的处理，常见的处理方式大致有下面几种，\n① 丢弃，如果不是很重要，可以选择丢弃\n② 记录死信入库，然后做后续的业务分析或处理\n③ 通过死信队列，由负责监听死信的应用程序进行处理\n综合来看，更常用的做法是第三种，即通过死信队列，将产生的死信通过程序的配置路由到指定的死信队列，然后应用监听死信队列，对接收到的死信做后续的处理，\n队列绑定死信交换机：\n给队列设置参数： x-dead-letter-exchange 和 x-dead-letter-routing-key\n\n    \n\n\n\n\n4.3、代码实现修改生产者项目的配置文件 spring-rabbitmq-producer.xml ，增加如下代码\n&lt;!--\n       死信队列：\n           1. 声明正常的队列(test_queue_dlx)和交换机(test_exchange_dlx)\n           2. 声明死信队列(queue_dlx)和死信交换机(exchange_dlx)\n           3. 正常队列绑定死信交换机\n               设置两个参数：\n                   * x-dead-letter-exchange：死信交换机名称\n                   * x-dead-letter-routing-key：发送给死信交换机的routingkey\n--&gt;\n&lt;!--\n    1. 声明正常的队列(test_queue_dlx)和交换机(test_exchange_dlx)\n--&gt;\n&lt;rabbit:queue name&#x3D;&quot;test_queue_dlx&quot; id&#x3D;&quot;test_queue_dlx&quot;&gt;\n    &lt;!--3. 正常队列绑定死信交换机--&gt;\n    &lt;rabbit:queue-arguments&gt;\n        &lt;!--3.1 x-dead-letter-exchange：死信交换机名称--&gt;\n        &lt;entry key&#x3D;&quot;x-dead-letter-exchange&quot; value&#x3D;&quot;exchange_dlx&quot;&#x2F;&gt;\n        &lt;!--3.2 x-dead-letter-routing-key：发送给死信交换机的routingkey--&gt;\n        &lt;entry key&#x3D;&quot;x-dead-letter-routing-key&quot; value&#x3D;&quot;dlx.hehe&quot;&gt;&lt;&#x2F;entry&gt;\n        &lt;!--4.1 设置队列的过期时间 ttl--&gt;\n        &lt;entry key&#x3D;&quot;x-message-ttl&quot; value&#x3D;&quot;10000&quot; value-type&#x3D;&quot;java.lang.Integer&quot;&#x2F;&gt;\n        &lt;!--4.2 设置队列的长度限制 max-length --&gt;\n        &lt;entry key&#x3D;&quot;x-max-length&quot; value&#x3D;&quot;10&quot; value-type&#x3D;&quot;java.lang.Integer&quot;&#x2F;&gt;\n    &lt;&#x2F;rabbit:queue-arguments&gt;\n&lt;&#x2F;rabbit:queue&gt;\n&lt;!--正常交换机--&gt;\n&lt;rabbit:topic-exchange name&#x3D;&quot;test_exchange_dlx&quot;&gt;\n    &lt;rabbit:bindings&gt;\n        &lt;rabbit:binding pattern&#x3D;&quot;test.dlx.#&quot; queue&#x3D;&quot;test_queue_dlx&quot;&gt;&lt;&#x2F;rabbit:binding&gt;\n    &lt;&#x2F;rabbit:bindings&gt;\n&lt;&#x2F;rabbit:topic-exchange&gt;\n&lt;!--\n   2. 声明死信队列(queue_dlx)和死信交换机(exchange_dlx)\n--&gt;\n&lt;rabbit:queue name&#x3D;&quot;queue_dlx&quot; id&#x3D;&quot;queue_dlx&quot;&gt;&lt;&#x2F;rabbit:queue&gt;\n&lt;rabbit:topic-exchange name&#x3D;&quot;exchange_dlx&quot;&gt;\n    &lt;rabbit:bindings&gt;\n        &lt;rabbit:binding pattern&#x3D;&quot;dlx.#&quot; queue&#x3D;&quot;queue_dlx&quot;&gt;&lt;&#x2F;rabbit:binding&gt;\n    &lt;&#x2F;rabbit:bindings&gt;\n&lt;&#x2F;rabbit:topic-exchange&gt;\n在测试类中，添加如下方法，进行测试\n1、到达过期时间后，变为死信&#x2F;**\n  * 发送测试死信消息：\n  *  1. 过期时间\n  *  2. 长度限制\n  *  3. 消息拒收\n  *&#x2F;\n@Test\npublic void testDlx()&#123;\n    &#x2F;&#x2F;1. 测试过期时间，死信消息\n    rabbitTemplate.convertAndSend(&quot;test_exchange_dlx&quot;,&quot;test.dlx.haha&quot;,&quot;我是一条消息,我会死吗？&quot;);\n&#125;\n\n\n\n\n\n2、到达长度限制后，变为死信&#x2F;**\n  *  2. 长度限制\n  *&#x2F;\n@Test\npublic void testDlx()&#123;\n    &#x2F;&#x2F;1. 测试过期时间,死信消息\n    &#x2F;&#x2F;rabbitTemplate.convertAndSend(&quot;test_exchange_dlx&quot;,&quot;test.dlx.haha&quot;,&quot;我是一条消息,我会死吗？&quot;);\n\n    &#x2F;&#x2F;2. 测试长度限制后,消息死信\n    for (int i &#x3D; 0; i &lt; 20; i++) &#123;\n        rabbitTemplate.convertAndSend(&quot;test_exchange_dlx&quot;,&quot;test.dlx.haha&quot;,&quot;我是一条消息,我会死吗？&quot;);\n    &#125;\n&#125;\n\n3、消息经过拒收后，变为死信在消费者工程 创建 com.atguigu.listener.DlxListener，经过错误，我们手动拒收，并且设置 rueue 为false，不重回原队列\npackage com.atguigu.listener;\nimport com.rabbitmq.client.Channel;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class DlxListener implements ChannelAwareMessageListener &#123;\n\n    @Override\n    public void onMessage(Message message, Channel channel) throws Exception &#123;\n        long deliveryTag &#x3D; message.getMessageProperties().getDeliveryTag();\n\n        try &#123;\n            &#x2F;&#x2F;1.接收转换消息\n            System.out.println(new String(message.getBody()));\n\n            &#x2F;&#x2F;2. 处理业务逻辑\n            System.out.println(&quot;处理业务逻辑...&quot;);\n            int i &#x3D; 3&#x2F;0;&#x2F;&#x2F;出现错误\n            &#x2F;&#x2F;3. 手动签收\n            channel.basicAck(deliveryTag,true);\n        &#125; catch (Exception e) &#123;\n            &#x2F;&#x2F;e.printStackTrace();\n            System.out.println(&quot;出现异常,拒绝接受&quot;);\n            &#x2F;&#x2F;4.拒绝签收,不重回队列 requeue&#x3D;false\n            channel.basicNack(deliveryTag,true,false);\n        &#125;\n    &#125;\n&#125;\n\n修改消费者的 spring-rabbitmq.xml\n&lt;rabbit:listener-container connection-factory&#x3D;&quot;connectionFactory&quot; acknowledge&#x3D;&quot;manual&quot;&gt;\n    &lt;!--&lt;rabbit:listener ref&#x3D;&quot;ackListener&quot; queue-names&#x3D;&quot;test_queue_confirm&quot;&gt;&lt;&#x2F;rabbit:listener&gt;--&gt;\n    &lt;!--&lt;rabbit:listener ref&#x3D;&quot;qosListener&quot; queue-names&#x3D;&quot;test_queue_confirm&quot;&gt;&lt;&#x2F;rabbit:listener&gt;--&gt;\n    &lt;!--定义监听器,监听正常队列--&gt;\n    &lt;rabbit:listener ref&#x3D;&quot;dlxListener&quot; queue-names&#x3D;&quot;test_queue_dlx&quot;&gt;&lt;&#x2F;rabbit:listener&gt;\n&lt;&#x2F;rabbit:listener-container&gt;\n\n测试代码\n@Test\n    public void testDlx()&#123;\n        &#x2F;&#x2F;1. 测试过期时间,死信消息\n        &#x2F;&#x2F;rabbitTemplate.convertAndSend(&quot;test_exchange_dlx&quot;,&quot;test.dlx.haha&quot;,&quot;我是一条消息,我会死吗？&quot;);\n\n        &#x2F;&#x2F;2. 测试长度限制后,消息死信\n\t\t&#x2F;&#x2F;for (int i &#x3D; 0; i &lt; 20; i++) &#123;\n\t\t&#x2F;&#x2F;    rabbitTemplate.convertAndSend(&quot;test_exchange_dlx&quot;,&quot;test.dlx.haha&quot;,&quot;我是一条消息,我会死吗？&quot;);\n\t\t&#x2F;&#x2F;&#125;\n        &#x2F;&#x2F;3. 测试消息拒收\n        rabbitTemplate.convertAndSend(&quot;test_exchange_dlx&quot;,\n                                     &quot;test.dlx.haha&quot;,\n                                         &quot;我是一条消息,我会死吗？&quot;);\n    &#125;\n\n\n\n4.4、死信队列小结\n死信交换机和死信队列和普通的没有区别\n当消息成为死信后，如果该队列绑定了死信交换机，则消息会被死信交换机重新路由到死信队列\n消息成为死信的三种情况：\n队列消息长度（数量）到达限制；\n消费者拒接消费消息，并且不重回队列；\n原队列存在消息过期设置，消息到达超时时间未被消费；\n\n\n\n05、延迟队列\n5.1、延迟队列概念延迟队列存储的对象肯定是对应的延时消息，==所谓 ”延时消息” 是指当消息被发送以后，并不想让消费者立即拿到消息，而是等待指定时间后，消费者才拿到这个消息进行消费。==\n:chestnut: 场景：在订单系统中，一个用户下单之后通常有30分钟的时间进行支付，如果30分钟之内没有支付成功，那么这个订单将进行取消处理。这时就可以使用延时队列将订单信息发送到延时队列。\n需求：\n\n下单后，30分钟未支付，取消订单，回滚库存。\n新用户注册成功30分钟后，发送短信问候。\n\n很可惜，在RabbitMQ中并未提供延迟队列功能。\n但是可以==使用：TTL + 死信队列 组合实现延迟队列的效果。==\n\n    \n    \n\n\n\n\n5.2、代码实现修改生产者配置文件\n\n    \n\n\n添加测试方法\n@Test\npublic  void testDelay() throws InterruptedException &#123;\n    &#x2F;&#x2F;1.发送订单消息。 将来是在订单系统中,下单成功后,发送消息\n    rabbitTemplate.convertAndSend(&quot;order_exchange&quot;,\n                                  &quot;order.msg&quot;,&quot;订单信息：id&#x3D;1,time&#x3D;2020年10月17日11：41：47&quot;);\n    &#x2F;&#x2F;2.打印倒计时10秒\n    for (int i &#x3D; 10; i &gt; 0 ; i--) &#123;\n        System.out.println(i+&quot;...&quot;);\n        Thread.sleep(1000);\n    &#125;\n&#125;\n\n修改消费者配置文件\n&lt;!--定义监听器容器\n    acknowledge&#x3D;&quot;manual&quot;：手动签收\n    acknowledge&#x3D;&quot;auto&quot; 自动签收\n    --&gt;\n&lt;rabbit:listener-container connection-factory&#x3D;&quot;connectionFactory&quot; acknowledge&#x3D;&quot;manual&quot;&gt;\n\n    &lt;!--&lt;rabbit:listener ref&#x3D;&quot;ackListener&quot; queue-names&#x3D;&quot;test_queue_confirm&quot;&gt;&lt;&#x2F;rabbit:listener&gt;--&gt;\n    &lt;!--&lt;rabbit:listener ref&#x3D;&quot;qosListener&quot; queue-names&#x3D;&quot;test_queue_confirm&quot;&gt;&lt;&#x2F;rabbit:listener&gt;--&gt;\n    &lt;!--定义监听器,监听正常队列--&gt;\n    &lt;!--&lt;rabbit:listener ref&#x3D;&quot;dlxListener&quot; queue-names&#x3D;&quot;test_queue_dlx&quot;&gt;&lt;&#x2F;rabbit:listener&gt;--&gt;\n    &lt;!--延迟队列效果实现：  一定要监听的是 死信队列！！！--&gt;\n    &lt;rabbit:listener ref&#x3D;&quot;orderListener&quot; queue-names&#x3D;&quot;order_queue_dlx&quot;&gt;&lt;&#x2F;rabbit:listener&gt;\n&lt;&#x2F;rabbit:listener-container&gt;\n\n添加监听器\n@Component\npublic class OrderListener implements ChannelAwareMessageListener &#123;\n\n    @Override\n    public void onMessage(Message message, Channel channel) throws Exception &#123;\n        long deliveryTag &#x3D; message.getMessageProperties().getDeliveryTag();\n\n        try &#123;\n            &#x2F;&#x2F;1.接收转换消息\n            System.out.println(new String(message.getBody()));\n\n            &#x2F;&#x2F;2. 处理业务逻辑\n            System.out.println(&quot;处理业务逻辑...&quot;);\n            System.out.println(&quot;根据订单id查询其状态...&quot;);\n            System.out.println(&quot;判断状态是否为支付成功&quot;);\n            System.out.println(&quot;取消订单,回滚库存....&quot;);\n            &#x2F;&#x2F;3. 手动签收\n            channel.basicAck(deliveryTag,true);\n        &#125; catch (Exception e) &#123;\n            &#x2F;&#x2F;e.printStackTrace();\n            System.out.println(&quot;出现异常,拒绝接受&quot;);\n            &#x2F;&#x2F;4.拒绝签收,不重回队列 requeue&#x3D;false\n            channel.basicNack(deliveryTag,true,false);\n        &#125;\n    &#125;\n&#125;\n\n运行测试类，可在后台看出结果\n06、RabbitMQ 集成 SpringBoot\n6.1、创建 生产者和消费者 模块① springboot_rabbitmq_producer        ② springboot_rabbitmq_consumer\n6.2、添加依赖两个模块都进行添加如下依赖\n&lt;!--1. 父工程依赖--&gt;\n&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.2.2.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;parent&gt;\n\n&lt;dependencies&gt;\n    &lt;!--2. rabbitmq--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n\n\n6.3、配置整合两个模块都添加 application.yml\nspring: \n  rabbitmq: \n    host: 192.168.137.118\n    port: 5672\n    username: admin\n    password: 123456\n    virtual-host: &#x2F;\n\n两个模块都添加 入口类 Application\npackage com.atguigu;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Application.class);\n    &#125;\n&#125;\n\n生产者创建配置类 RabbitMQConfig\npackage com.atguigu.config;\nimport org.springframework.amqp.core.*;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class RabbitMQConfig &#123;\n    public static final String EXCHANGE_NAME &#x3D; &quot;boot_topic_exchange&quot;;\n    public static final String QUEUE_NAME &#x3D; &quot;boot_queue&quot;;\n\n    &#x2F;&#x2F; 1 交换机\n    @Bean(&quot;bootExchange&quot;)\n    public Exchange bootExchange()&#123;\n        return ExchangeBuilder.topicExchange(EXCHANGE_NAME).durable(true).build();\n    &#125;\n    &#x2F;&#x2F;2.Queue 队列\n    @Bean(&quot;bootQueue&quot;)\n    public Queue bootQueue()&#123;\n        return QueueBuilder.durable(QUEUE_NAME).build();\n    &#125;\n    &#x2F;&#x2F;3. 队列和交互机绑定关系 Binding\n    &#x2F;*\n        1. 知道哪个队列\n        2. 知道哪个交换机\n        3. routing key\n        noargs()：表示不指定参数\n     *&#x2F;\n    @Bean\n    public Binding bindQueueExchange(@Qualifier(&quot;bootQueue&quot;) Queue queue,\n                                     @Qualifier(&quot;bootExchange&quot;) Exchange exchange)&#123;\n        return BindingBuilder.bind(queue).to(exchange).with(&quot;boot.#&quot;).noargs();\n    &#125;\n&#125;\n\n生产者创建测试文件 com.atguigu.ProducerTest.java，并运行\npackage com.atguigu;\nimport com.atguigu.config.RabbitMQConfig;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.amqp.rabbit.core.RabbitTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\n\n@SpringBootTest\n@RunWith(SpringRunner.class)\npublic class ProducerTest &#123;\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    &#x2F;**\n * 第一个参数：交换机名字\n * 第二个参数：routingKey\n * 第三个参数：发送的消息\n *&#x2F;\n    @Test\n    public void testSend()&#123;\n        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_NAME,&quot;boot.haha&quot;,&quot;mq hello&quot;);\n    &#125;\n&#125;\n消费者创建监听器，需要==使用 @RabbitListener 注解==，不在需要 实现某些类\npackage com.atguigu.listener;\n\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class RabbimtMQListener &#123;\n    @RabbitListener(queues &#x3D; &quot;boot_queue&quot;)\n    public void listenerQueue(Message message)&#123;\n        System.out.println(new String(message.getBody()));\n    &#125;\n&#125;\n\n最后运行消费者的 入口程序\n6.4、小结\nSpringBoot提供了快速整合RabbitMQ的方式\n基本信息在yml中配置,队列交互机以及绑定关系在配置类中使用Bean的方式配置\n生产端直接注入RabbitTemplate完成消息发送\n消费端直接使用@RabbitListener完成消息接收\n\n07、消息百分百成功投递\n谈到消息的可靠性投递，无法避免的，在实际的工作中会经常碰到，比如一些核心业务需要保障消息不丢失，接下来我们看一个可靠性投递的流程图，说明可靠性投递的概念：\n \nStep 1： 首先把消息信息(业务数据）存储到数据库中，紧接着，我们再把这个消息记录也存储到一张消息记录表里（或者另外一个同源数据库的消息记录表）\nStep 2：发送消息到MQ Broker节点（采用confirm方式发送，会有异步的返回结果）\nStep 3、4：生产者端接受MQ Broker节点返回的Confirm确认消息结果，然后进行更新消息记录表里的消息状态。比如默认Status = 0 当收到消息确认成功后，更新为1即可！\nStep 5：但是在消息确认这个过程中可能由于网络闪断、MQ Broker端异常等原因导致 回送消息失败或者异常。这个时候就需要发送方（生产者）对消息进行可靠性投递了，保障消息不丢失，100%的投递成功！（有一种极限情况是闪断，Broker返回的成功确认消息，但是生产端由于网络闪断没收到，这个时候重新投递可能会造成消息重复，需要消费端去做幂等处理）所以我们需要有一个定时任务，（比如每5分钟拉取一下处于中间状态的消息，当然这个消息可以设置一个超时时间，比如超过1分钟 Status = 0 ，也就说明了1分钟这个时间窗口内，我们的消息没有被确认，那么会被定时任务拉取出来）\nStep 6：接下来我们把中间状态的消息进行重新投递 retry send，继续发送消息到MQ ，当然也可能有多种原因导致发送失败\nStep 7：我们可以采用设置最大努力尝试次数，比如投递了3次，还是失败，那么我们可以将最终状态设置为Status = 2 ，最后 交由人工解决处理此类问题（或者把消息转储到失败表中）。\n数据库文件\n-- ----------------------------\n-- Table structure for broker_message_log\n-- ----------------------------\nDROP TABLE IF EXISTS &#96;broker_message_log&#96;;\nCREATE TABLE &#96;broker_message_log&#96; (\n  &#96;message_id&#96; varchar(255) NOT NULL COMMENT &#39;消息唯一ID&#39;,\n  &#96;message&#96; varchar(4000) NOT NULL COMMENT &#39;消息内容&#39;,\n  &#96;try_count&#96; int(4) DEFAULT &#39;0&#39; COMMENT &#39;重试次数&#39;,\n  &#96;status&#96; varchar(10) DEFAULT &#39;&#39; COMMENT &#39;消息投递状态 0投递中,1投递成功,2投递失败&#39;,\n  &#96;next_retry&#96; timestamp NOT NULL DEFAULT &#39;0000-00-00 00：00：00&#39; ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;下一次重试时间&#39;,\n  &#96;create_time&#96; timestamp NOT NULL DEFAULT &#39;0000-00-00 00：00：00&#39; ON UPDATE CURRENT_TIMESTAMP,\n  &#96;update_time&#96; timestamp NOT NULL DEFAULT &#39;0000-00-00 00：00：00&#39; ON UPDATE CURRENT_TIMESTAMP,\n  PRIMARY KEY (&#96;message_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;\n\n-- ----------------------------\n-- Table structure for t_order\n-- ----------------------------\nDROP TABLE IF EXISTS &#96;t_order&#96;;\nCREATE TABLE &#96;t_order&#96; (\n  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,\n  &#96;name&#96; varchar(255) DEFAULT NULL,\n  &#96;message_id&#96; varchar(255) DEFAULT NULL,\n  PRIMARY KEY (&#96;id&#96;)\n) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;2018091102 DEFAULT CHARSET&#x3D;utf8;\n\n\n\n08、RabbitMQ 集群搭建\n摘要：实际生产应用中都会采用消息队列的集群方案，如果选择RabbitMQ那么有必要了解下它的集群方案原理\n一般来说，如果只是为了学习RabbitMQ或者验证业务工程的正确性那么在本地环境或者测试环境上使用其单实例部署就可以了，但是出于MQ中间件本身的可靠性、并发性、吞吐量和消息堆积能力等问题的考虑，在生产环境上一般都会考虑使用RabbitMQ的集群方案。\n8.1、集群方案的原理RabbitMQ这款消息队列中间件产品本身是基于Erlang编写，Erlang语言天生具备分布式特性（通过同步Erlang集群各节点的magic cookie来实现）。因此，RabbitMQ天然支持Clustering。这使得RabbitMQ本身不需要像ActiveMQ、Kafka那样通过ZooKeeper分别来实现HA方案和保存集群的元数据。集群是保证可靠性的一种方式，同时可以通过水平扩展以达到增加消息吞吐量能力的目的。\n\n    \n\n\n\n\n8.2、单机多实例部署由于某些因素的限制，有时候你不得不在一台机器上去搭建一个rabbitmq集群，这个有点类似zookeeper的单机版。真实生成环境还是要配成多机集群的。有关怎么配置多机集群的可以参考其他的资料，这里主要论述如何在单机中配置多个rabbitmq实例。\n主要参考官方文档：https://www.rabbitmq.com/clustering.html\n首先确保RabbitMQ运行没有问题\n[root@atguigu ~]# systemctl start rabbitmq-server.service\n[root@atguigu ~]# systemctl status rabbitmq-server.service\n\n停止rabbitmq服务\n[root@atguigu ~]# systemctl stop rabbitmq-server.service\n\n启动三个节点做集群演示：\n由于web管理插件端口占用,所以还要指定其web插件占用的端口号。\n[root@atguigu ~]# RABBITMQ_NODE_PORT&#x3D;5672 RABBITMQ_NODENAME&#x3D;rabbit1 RABBITMQ_SERVER_START_ARGS&#x3D;&quot;-rabbitmq_management listener [&#123;port,15672&#125;]&quot;  rabbitmq-server -detached\n\n[root@atguigu ~]# RABBITMQ_NODE_PORT&#x3D;5673 RABBITMQ_NODENAME&#x3D;rabbit2 RABBITMQ_SERVER_START_ARGS&#x3D;&quot;-rabbitmq_management listener [&#123;port,15673&#125;]&quot;  rabbitmq-server -detached\n\n[root@atguigu ~]# RABBITMQ_NODE_PORT&#x3D;5674 RABBITMQ_NODENAME&#x3D;rabbit3 RABBITMQ_SERVER_START_ARGS&#x3D;&quot;-rabbitmq_management listener [&#123;port,15674&#125;]&quot;  rabbitmq-server -detached\n\n启动三个节点后，分别访问三个节点，后台管理页面，看看是否OK.\n停止服务命令：\nrabbitmqctl -n rabbit1 stop\nrabbitmqctl -n rabbit2 stop\nrabbitmqctl -n rabbit3 stop\n\nrabbit1操作作为主节点：\n[root@atguigu ~]# rabbitmqctl -n rabbit1 stop_app  \nStopping node rabbit1@localhost ...\n[root@atguigu ~]# rabbitmqctl -n rabbit1 reset     \nResetting node rabbit1@localhost ...\n[root@atguigu ~]# rabbitmqctl -n rabbit1 start_app\nStarting node rabbit1@localhost ...\n\nrabbit2操作为从节点：\n[root@atguigu ~]# rabbitmqctl -n rabbit2 stop_app\nStopping node rabbit2@localhost ...\n[root@atguigu ~]# rabbitmqctl -n rabbit2 reset\nResetting node rabbit2@localhost ...\n[root@atguigu ~]# rabbitmqctl -n rabbit2 join_cluster rabbit1\nClustering node rabbit2@localhost with rabbit1 ...\n[root@atguigu ~]# rabbitmqctl -n rabbit2 start_app\nStarting node rabbit2@localhost ...\n\nrabbit3操作为从节点：\n[root@atguigu ~]# rabbitmqctl -n rabbit3 stop_app\nStopping node rabbit3@localhost ...\n[root@atguigu ~]# rabbitmqctl -n rabbit3 reset\nResetting node rabbit3@localhost ...\n[root@atguigu ~]# rabbitmqctl -n rabbit3 join_cluster rabbit1\nClustering node rabbit3@localhost with rabbit1@super ...\n[root@atguigu ~]# rabbitmqctl -n rabbit3 start_app\nStarting node rabbit3@localhost ...\n\n查看集群状态：\n[root@atguigu ~]# rabbitmqctl -n rabbit1 cluster_status\nCluster status of node rabbit1@localhost ...\nBasics\n \nCluster name: rabbit1@localhost\n \nDisk Nodes\n \nrabbit1@localhost\nrabbit2@localhost\nrabbit3@localhost\n \nRunning Nodes\n \nrabbit1@localhost\nrabbit2@localhost\nrabbit3@localhost\n \nVersions\n \nrabbit1@localhost: RabbitMQ 3.8.1 on Erlang 21.3.8.9\nrabbit2@localhost: RabbitMQ 3.8.1 on Erlang 21.3.8.9\nrabbit3@localhost: RabbitMQ 3.8.1 on Erlang 21.3.8.9\n \nAlarms\n \n(none)\n \nNetwork Partitions\n \n(none)\n \nListeners\n \nNode: rabbit1@localhost, interface: [::], port: 25672, protocol: clustering, purpose: inter-node and CLI tool communication\nNode: rabbit1@localhost, interface: [::], port: 5672, protocol: amqp, purpose: AMQP 0-9-1 and AMQP 1.0\nNode: rabbit1@localhost, interface: [::], port: 15672, protocol: http, purpose: HTTP API\nNode: rabbit2@localhost, interface: [::], port: 25673, protocol: clustering, purpose: inter-node and CLI tool communication\nNode: rabbit2@localhost, interface: [::], port: 5673, protocol: amqp, purpose: AMQP 0-9-1 and AMQP 1.0\nNode: rabbit2@localhost, interface: [::], port: 15673, protocol: http, purpose: HTTP API\nNode: rabbit3@localhost, interface: [::], port: 25674, protocol: clustering, purpose: inter-node and CLI tool communication\nNode: rabbit3@localhost, interface: [::], port: 5674, protocol: amqp, purpose: AMQP 0-9-1 and AMQP 1.0\nNode: rabbit3@localhost, interface: [::], port: 15674, protocol: http, purpose: HTTP API\n \nFeature flags\n \nFlag: drop_unroutable_metric, state: enabled\nFlag: empty_basic_get_metric, state: enabled\nFlag: implicit_default_bindings, state: enabled\nFlag: quorum_queue, state: enabled\nFlag: virtual_host_metadata, state: enabled\n\nweb监控：\n\n\n\n\n8.3、集群管理rabbitmqctl join_cluster {cluster_node} [–ram]\n将节点加入指定集群中。在这个命令执行前需要停止RabbitMQ应用并重置节点。\nrabbitmqctl cluster_status\n显示集群的状态。\nrabbitmqctl change_cluster_node_type {disc|ram}\n修改集群节点的类型。在这个命令执行前需要停止RabbitMQ应用。\nrabbitmqctl forget_cluster_node [–offline]\n将节点从集群中删除，允许离线执行。\nrabbitmqctl update_cluster_nodes {clusternode}\n在集群中的节点应用启动前咨询clusternode节点的最新信息，并更新相应的集群信息。这个和join_cluster不同，它不加入集群。考虑这样一种情况，节点A和节点B都在集群中，当节点A离线了，节点C又和节点B组成了一个集群，然后节点B又离开了集群，当A醒来的时候，它会尝试联系节点B，但是这样会失败，因为节点B已经不在集群中了。\nrabbitmqctl cancel_sync_queue [-p vhost] {queue}\n取消队列queue同步镜像的操作。\nrabbitmqctl set_cluster_name {name}\n设置集群名称。集群名称在客户端连接时会通报给客户端。Federation和Shovel插件也会有用到集群名称的地方。集群名称默认是集群中第一个节点的名称，通过这个命令可以重新设置。\n8.4、RabbitMQ 镜像集群配置上面已经完成RabbitMQ默认集群模式，但并不保证队列的高可用性，尽管交换机、绑定这些可以复制到集群里的任何一个节点，但是队列内容不会复制。虽然该模式解决一项目组节点压力，但队列节点宕机直接导致该队列无法应用，只能等待重启，所以要想在队列节点宕机或故障也能正常应用，就要复制队列内容到集群里的每个节点，必须要创建镜像队列。\n镜像队列是基于普通的集群模式的，然后再添加一些策略，所以你还是得先配置普通集群，然后才能设置镜像队列，我们就以上面的集群接着做。\n设置的镜像队列可以通过开启的网页的管理端Admin-&gt;Policies，也可以通过命令。\n\n    \n\n\n\n\n\nName:策略名称\nPattern：匹配的规则，如果是匹配所有的队列，是^.\nDefinition:使用ha-mode模式中的all，也就是同步所有匹配的队列。问号链接帮助文档。\n\n\n    \n\n\n\n\n09、负载均衡 HAProxyHAProxy提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案,包括Twitter，Reddit，StackOverflow，GitHub在内的多家知名互联网公司在使用。HAProxy实现了一种事件驱动、单一进程模型，此模型支持非常大的并发连接数。\n9.1、centos 7 安装 HAProxy&#x2F;&#x2F;下载依赖包\nyum install gcc vim wget\n&#x2F;&#x2F;上传haproxy源码包; -C解压到指定的目录\ntar -zxvf haproxy-1.6.5.tar.gz -C &#x2F;usr&#x2F;local\n&#x2F;&#x2F;进入目录、进行编译、安装\ncd &#x2F;usr&#x2F;local&#x2F;haproxy-1.6.5\n&#x2F;&#x2F; make 表示编译；TARGET&#x3D;linux31 表示CentOS7系统；PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;haproxy指定安装路径\n&#x2F;&#x2F; TARGET&#x3D;linux310，内核版本，使用uname -r查看内核，如：3.10.0-514.el7，此时该参数就为linux310；\nmake TARGET&#x3D;linux310 PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;haproxy\nmake install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;haproxy\nmkdir &#x2F;etc&#x2F;haproxy\n&#x2F;&#x2F;添加用户组：-r 创建一个系统组；-g 组ID\ngroupadd -r -g 149 haproxy\n&#x2F;&#x2F;添加用户：-g 新账户组的名称；-r 创建一个系统用户；-s 新用户的登录shell; -u 新账户的用户ID\nuseradd -g haproxy -r -s &#x2F;sbin&#x2F;nologin -u 149 haproxy\n&#x2F;&#x2F;创建haproxy配置文件\nvim &#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg\n\n配置 HAProxy，配置文件路径：vim /etc/haproxy/haproxy.cfg\n#全局配置\nglobal\n    #日志输出配置，所有日志都记录在本机，通过local0输出\n    log 127.0.0.1 local0 info\n    #最大连接数\n    maxconn 5120\n    #改变当前的工作目录\n    chroot &#x2F;usr&#x2F;local&#x2F;haproxy\n    #以指定的UID运行haproxy进程\n    uid 99\n    #以指定的GID运行haproxy进程\n    gid 99\n    #以守护进程方式运行haproxy\n    daemon\n    quiet\n    nbproc 20\n    #当前进程PID文件\n    pidfile &#x2F;var&#x2F;run&#x2F;haproxy.pid\n#默认配置\ndefaults\n    #应用全局的日志配置\n    log global\n    #默认的模式mode&#123;tcp|http|health&#125;\n    mode tcp\n    #日志类别\n    option tcplog\n    #不记录检查检查日志信息\n    option dontlognull\n    #3次失败则认为服务不可用\n    retries 3\n    option redispatch\n    #每个进程可用的最大连接数\n    maxconn 2000\n    #连接超时\n    contimeout 5s\n    #客户端超时\n    clitimeout 60s\n    #服务端超时\n    srvtimeout 15s    \n#绑定配置\nlisten rabbitmq_cluster\n    bind *:5677\n    #配置TCP模式\n    mode tcp\n    #balance url_param userid\n    #balance url_param session_id check_post 64\n    #balance hdr(User-Agent)\n    #balance hdr(host)\n    #balance hdr(Host) use_domain_only\n    #balance rdp-cookie\n    #balance leastconn\n    #balance source &#x2F;&#x2F;ip\n    #简单的轮询\n    balance roundrobin\n    #server rabbit1 定义服务内部标识，\n    #127.0.0.1:5672 服务连接IP和端口，\n    #check inter 5000 定义每隔多少毫秒检查服务是否可用，\n    #rise 2 服务故障后需要多少次检查才能被再次确认可用，\n    #fall 2 经历多次失败的检查检查后，haproxy才会停止使用此服务\n    #weight 1 定义服务权重\n    server rabbit1 192.168.137.118:5672 check inter 5000 rise 2 fall 2 weight 1\n    server rabbit2 192.168.137.118:5673 check inter 5000 rise 2 fall 2 weight 1\n    server rabbit3 192.168.137.118:5674 check inter 5000 rise 2 fall 2 weight 1\n#haproxy监控页面地址\nlisten stats\n    bind 192.168.137.118:8100\n    mode http\n    option httplog\n    stats enable\n    stats uri &#x2F;rabbitmq-stats\n    stats refresh 5s\n\n启动HAproxy负载\n&#x2F;usr&#x2F;local&#x2F;haproxy&#x2F;sbin&#x2F;haproxy -f &#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg\n\n查看haproxy进程状态\nps -ef | grep haproxy\n\n访问如下地址对mq节点进行监控\nhttp://192.168.137.118:8100/rabbitmq-stats\n9.2、centos 8 安装 HAProxysudo dnf install haproxy\n\nvim &#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg\n\n#---------------------------------------------------------------------\n# Example configuration for a possible web application.  See the\n# full configuration options online.\n#\n#   https:&#x2F;&#x2F;www.haproxy.org&#x2F;download&#x2F;1.8&#x2F;doc&#x2F;configuration.txt\n#\n#---------------------------------------------------------------------\n\n#---------------------------------------------------------------------\n# Global settings\n#---------------------------------------------------------------------\nglobal\n    # to have these messages end up in &#x2F;var&#x2F;log&#x2F;haproxy.log you will\n    # need to:\n    #\n    # 1) configure syslog to accept network log events.  This is done\n    #    by adding the &#39;-r&#39; option to the SYSLOGD_OPTIONS in\n    #    &#x2F;etc&#x2F;sysconfig&#x2F;syslog\n    #\n    # 2) configure local2 events to go to the &#x2F;var&#x2F;log&#x2F;haproxy.log\n    #   file. A line like the following can be added to\n    #   &#x2F;etc&#x2F;sysconfig&#x2F;syslog\n    #\n    #    local2.*                       &#x2F;var&#x2F;log&#x2F;haproxy.log\n    #\n    log         127.0.0.1 local2\n\n    chroot      &#x2F;var&#x2F;lib&#x2F;haproxy\n    pidfile     &#x2F;var&#x2F;run&#x2F;haproxy.pid\n    maxconn     4000\n    user        haproxy\n    group       haproxy\n    daemon\n\n    # turn on stats unix socket\n    stats socket &#x2F;var&#x2F;lib&#x2F;haproxy&#x2F;stats\n\n    # utilize system-wide crypto-policies\n    ssl-default-bind-ciphers PROFILE&#x3D;SYSTEM\n    ssl-default-server-ciphers PROFILE&#x3D;SYSTEM\n\n#---------------------------------------------------------------------\n# common defaults that all the &#39;listen&#39; and &#39;backend&#39; sections will\n# use if not designated in their block\n#---------------------------------------------------------------------\ndefaults\n    mode                    http\n    log                     global\n    option                  httplog\n    option                  dontlognull\n    option http-server-close\n    option forwardfor       except 127.0.0.0&#x2F;8\n    option                  redispatch\n    retries                 3\n    timeout http-request    10s\n    timeout queue           1m\n    timeout connect         10s\n    timeout client          1m\n    timeout server          1m\n    timeout http-keep-alive 10s\n    timeout check           10s\n    maxconn                 3000\n    \n    stats uri \t\t    &#x2F;admin&#x2F;stats\n#---------------------------------------------------------------------\n# main frontend which proxys to the backends\n#---------------------------------------------------------------------\nfrontend main\n    bind *:5000\n    acl url_static       path_beg       -i &#x2F;static &#x2F;images &#x2F;javascript &#x2F;stylesheets\n    acl url_static       path_end       -i .jpg .gif .png .css .js\n\n    use_backend static          if url_static\n    default_backend             app\n\n#---------------------------------------------------------------------\n# static backend for serving up images, stylesheets and such\n#---------------------------------------------------------------------\nbackend static\n    balance     roundrobin\n    server      static 127.0.0.1:4331 check\n\n#---------------------------------------------------------------------\n# round robin balancing between the various backends\n#---------------------------------------------------------------------\nbackend app\n    balance     roundrobin\n    server  app1 127.0.0.1:5001 check\n    server  app2 127.0.0.1:5002 check\n    server  app3 127.0.0.1:5003 check\n    server  app4 127.0.0.1:5004 check\n\n\nsystemctl start haproxy\n\nsystemctl stop haproxy\n\n访问地址：http://192.168.96.66:5000/admin/stats\n9.3、springboot yml文件中访问mq集群地址==访问一个就能访问全部，往一个里写入数据，所有的mq都能获取数据==\nspring: \n\trabbitmq: \n\t\thost: 192.168.137.118\n\t\tport: 5677\n\t\tusername: admin\n\t\tpassword: 123456\n\t\tvirtual-host: &#x2F;\n\t\t#addresses: 192.168.137.118:5672,192.168.137.118:5673,192.168.137.118:5674\n\n","slug":"67-RabbitMQ-高级部分","date":"2021-09-13T15:43:32.000Z","categories_index":"消息队列","tags_index":"消息队列","author_index":"大黄"},{"id":"c45f5a44aa5e1bceb86c7aa31b1d0a34","title":"RabbitMQ 基础内容","content":"01、什么是消息中间件MQ全称为Message Queue， 消息队列(MQ)是一种应用程序对应用程序的通信方法。\n介绍：消息队列就是基础数据结构中的 “先进先出” 的一种数据机构。想一下，生活中买东西，需要排队，先排的人先买消费，就是典型的“先进先出”。\n\n    \n\n\n\n消息传递：指的是程序之间通过消息发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。\n排队：指的是应用程序通过队列来通信。队列 的主要作用是 ==消除高并发访问高峰，加快网站的响应速度==。\n业务场景说明：为什么会产生消息队列？\n在不使用消息队列的情况下，用户的请求数据直接写入数据库，在高并发的情况下，会对数据库造成巨大的压力，同时也使得系统响应延迟加剧\n不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个；\n不同进程（process）之间传递消息时，为了实现标准化，将消息的格式规范化了，并且，某一个进程接受的消息太多，一下子无法处理完，并且也有先后顺序，必须对收到的消息进行排队，因此诞生了事实上的消息队列；\n\n\n\n:star: 在项目中，可将一些无需即时返回且耗时的操作提取出来，进行异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量。\n:star: ==“消息队列(Message Queue)” 是在消息的传输过程中保存消息的容器==。在消息队列中，通常有生产者和消费者两个角色。生产者只负责发送数据到消息队列，谁从消息队列中取出数据处理，他不管。消费者只负责从消息队列中取出数据处理，他不管这是谁发送的数据。\n02、为什么使用消息队列:star: 解耦\n如图所示。假设有系统B、C、D都需要系统A的数据，于是系统A调用三个方法发送数据到B、C、D。这时，系统D不需要了，那就需要在系统A把相关的代码删掉。假设这时有个新的系统E需要数据，这时系统A又要增加调用系统E的代码。为了降低这种强耦合，就可以使用MQ，系统A只需要把数据发送到MQ，其他系统如果需要数据，则从MQ中获取即可。\n\n    \n    \n\n\n\n\n:star: 异步\n如图所示。一个客户端请求发送进来，系统A会调用系统B、C、D三个系统，同步请求的话，响应时间就是系统A、B、C、D的总和，也就是 500ms。如果使用MQ，系统A发送数据到MQ，然后就可以返回响应给客户端，不需要再等待系统B、C、D的响应，可以大大地提高性能。对于一些非必要的业务，比如发送短信，发送邮件等等，就可以采用MQ。\n\n    \n\n\n\n\n\n:star: 削峰\n如图所示。这其实是MQ一个很重要的应用。假设系统A在某一段时间请求数暴增，有5000个请求发送过来，系统A这时就会发送5000条SQL进入MySQL进行执行，MySQL对于如此庞大的请求当然处理不过来，MySQL就会崩溃，导致系统瘫痪。如果使用MQ，系统A不再是直接发送SQL到数据库，而是把数据发送到MQ，MQ短时间积压数据是可以接受的，然后由消费者每次拉取2000条进行处理，防止在请求峰值时期大量的请求直接发送到MySQL导致系统崩溃。\n\n    \n    \n\n\n\n\n03、什么是QPS PV UV PRQPS即每秒查询率，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。\n\n每秒查询率\n因特网上，经常用每秒查询率来衡量域名系统服务器的机器的性能，即为QPS。\n或者理解：每秒的响应请求数，也即是最大吞吐能力。\n\n计算关系\nQPS = 并发量 / 平均响应时间\n并发量 = QPS * 平均响应时间\n\n\n原理：每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间。\n公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS) 。\n机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器 \n① 什么是pv　　\nPV(page view)，即页面浏览量，或点击量；通常是衡量一个网络新闻频道或网站甚至一条网络新闻的主要指标。\n对pv的解释是，一个访问者在24小时(0点到24点)内到底看了你网站几个页面。这里需要强调：同一个人浏览你网站同一个页面，不重复计算pv量，点100次也算1次。说白了，pv就是一个访问者打开了你的几个页面。\nPV之于网站，就像收视率之于电视，从某种程度上已成为投资者衡量商业网站表现的最重要尺度。\npv的计算：当一个访问者访问的时候，记录他所访问的页面和对应的IP，然后确定这个IP今天访问了这个页面没有。如果你的网站到了23点，单纯IP有60万条的话，每个访问者平均访问了3个页面，那么pv表的记录就要有180万条。\n② 什么是uv\nuv(unique visitor)，指访问某个站点或点击某条新闻的不同IP地址的人数。\n在同一天内，uv只记录第一次进入网站的具有独立IP的访问者，在同一天内再次访问该网站则不计数。独立IP访问者提供了一定时间内不同观众数量的统计指标，而没有反应出网站的全面活动。\n③ 什么是ＰＲ值\nPageRank，网页的级别技术，用来标识网页的等级/重要性。级别从1到10级，10级为满分。PR值越高说明该网页越受欢迎（越重要）。\n例如：一个PR值为1的网站表明这个网站不太具有流行度，而PR值为7到10则表明这个网站非常受欢迎（或者说极其重要）。\n04、AMQP 和 JMSMQ是消息通信的模型；实现MQ的大致有两种主流方式：AMQP、JMS。\n\n什么是 AMQP？\nAMQP是一种高级消息队列协议（Advanced Message Queuing Protocol），更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。\n\n什么是 JMS？\nJMS即Java消息服务（JavaMessage Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。\n\nAMQP 和 JMS 的区别\n\n JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式\nJMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。\nJMS规定了两种消息模式；而AMQP的消息模式更加丰富\n\n\n\n消息队列的产品\n\nActiveMQ：基于JMS\nZeroMQ：基于C语言开发\nRabbitMQ:基于AMQP协议，erlang语言开发，稳定性好\nRocketMQ：基于JMS，阿里巴巴产品\nKafka：类似MQ的产品；分布式消息系统，高吞吐量\n\n\n    \n\n\n\n\n05、RabbitMQ 简介RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列\nAdvanced Message Queue 高级消息队列协议\n\n是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。\n\n是一个网络协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。2006年，AMQP 规范发布。类比HTTP。\n\n\nRabbitMQ官方地址：http://www.rabbitmq.com/ \nRabbitMQ提供了6种模式：简单模式，work模式，Publish/Subscribe发布与订阅模式，Routing路由模式，Topics主题模式，RPC远程调用模式（远程调用，不太算MQ；暂不作介绍）；\n官网对应模式介绍：https://www.rabbitmq.com/getstarted.html \n\n    \n    \n\n\n\n\n06、RabbitMQ 的特点RabbitMQ是一款使用Erlang语言开发的，实现AMQP(高级消息队列协议)的开源消息中间件。首先要知道一些RabbitMQ的特点，官网可查：\n\n可靠性。支持持久化，传输确认，发布确认等保证了MQ的可靠性。\n灵活的分发消息策略。这应该是RabbitMQ的一大特点。在消息进入MQ前由Exchange(交换机)进行路由消息。分发消息策略有：简单模式、工作队列模式、发布订阅模式、路由模式、通配符模式。\n支持集群。多台RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker。\n多种协议。RabbitMQ支持多种消息队列协议，比如 STOMP、MQTT 等等。\n支持多种语言客户端。RabbitMQ几乎支持所有常用编程语言，包括 Java、.NET、Ruby 等等。\n可视化管理界面。RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker。\n插件机制。RabbitMQ提供了许多插件，可以通过插件进行扩展，也可以编写自己的插件。\n\n07、RabbitMQ 的基础结构\n    \n\n\n:star: RabbitMQ 中的消息发送引入了 Exchange（交换机）的概念，消息的发送首先到达交换机上，然后再根据既定的路由规则，由交换机将消息路由到不同的 Queue（队列）中，再由不同的消费者去消费。\n\n\n\n序号\n组件\n描述\n\n\n\n1\nPublisher\n生产者，应用客户端用于向服务端发送消息\n\n\n2\nConnection\n连接，生产者与消费者客户端都需要Connection连接消息应用服务端。Connection连接创建、销毁成本太高，衍生轻量级逻辑连接Channelpublisher／consumer 和 broker 之间的 TCP 连接\n\n\n3\nChannel\n轻量级逻辑连接，也称之为信道。Channel之间完全隔离，线程安全\n\n\n4\nBroker\n消息应用服务主体，客户端写代码不会涉及，相当于一个逻辑上的概念接收和分发消息的应用，RabbitMQ Server就是 Message Broker\n\n\n5\nVirtual Host\n相当于namespace，多用户时每个用户可以在自己分配的Virtual Host区域操作\n\n\n6\nExchange\n消息交换器，生产者不直接与队列耦合，通过交换器进行消息转发\n\n\n7\nBinding\n绑定关系，消息交换器与队列之间绑定的关系，通过与生产者传递消息携带的RoutingKey比较得知消息路由转发到哪个绑定队列  exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据\n\n\n8\nQueue\n队列，消息最后储存的位置，等待consumer取走\n\n\n9\nConsumer\n消费者，直接通过与队列耦合进行消费，这与生产者具备一定区别\n\n\n08、RabbitMQ 的安装Centos8，安装Erlang 23、rabbitmq 3.8.9，如果版本不一致的最好绕行，不然会有问题导致安装成功，但不能正常启动，尤其是Erlang版本与Rabbitmq的版本一定要匹配，查看版本匹配情况看这里 https://www.rabbitmq.com/which-erlang.html\nerlang下载地址：https://packagecloud.io/rabbitmq/ （这个里面有erlang，rabbitmq）\nrabbitmq下载地址：https://github.com/rabbitmq/rabbitmq-server/releases?after=v3.8.10\n下载完成后，将之发送到 Linux 中的 /opt/install 安装程序（自定义的）目录下\n在 Linux 的 /opt/install 目录下，开始安装\n安装 erlang：[root@localhost install]# yum install erlang-23.3.4-1.el7.x86_64.rpm\n\n安装 rabbitmq：[root@localhost install]# yum install rabbitmq-server-3.8.9-1.el8.noarch.rpm\n\n安装 web 管理插件：rabbitmq-plugins enable rabbitmq_management\n启动 rabbitmq：① service rabbitmq-server start       ② systemctl start rabbitmq-server\n查看 rabbitmq 服务状态：① service rabbitmq-server status    ② systemctl status rabbitmq-server\n关闭 rabbitmq：① service rabbitmq-server stop    ② systemctl stoprabbitmq-server\n\n关闭防火墙，外部浏览器访问：http://192.168.96.66:15672\n\n增加自定义账号\n\n添加管理员账号密码：rabbitmqctl add_user admin admin\n分配账号角色：rabbitmqctl set_user_tags admin administrator\n修改密码：rabbitmqctl change_password admin 123456\n查看用户列表：rabbitmqctl list_users\n\n\nrabbitmq 端口表示\n\n5672：rabbitMq 的编程语言客户端连接端口\n15672：rabbitMq 管理界面端口\n25672：rabbitMq 集群的端口\n\nrabbitmq 卸载\n\nrpm -qa | grep rabbitmq\nrpm -e rabbitmq-server\n\n09、RabbitMQ 浏览器界面9.1、rabbitmq 客户端登录成功页面\n9.2、rabbitmq 客户端页面信息解析\noverview：概览\nconnections：无论生产者还是消费者，都需要与RabbitMQ建立连接后才可以完成消息的生产和消费，在这里可以查看连接情况\nchannels：通道，建立连接后，会形成通道，消息的投递获取依赖通道。\nExchanges：交换机，用来实现消息的路由\nQueues：队列，即消息队列，消息存放在队列中，等待消费，消费后被移除队列。\n\n9.3、rabbitmq 浏览器中的管理界面\n上述添加用户时，需要添加 Tags，右侧是他的几种类型\n1、 超级管理员(administrator)：可登录管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。\n2、 监控者(monitoring)：可登录管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)\n3、 策略制定者(policymaker)：可登录管理控制台， 同时可以对policy进行管理。但无法查看节点的相关信息。\n4、 普通管理者(management)：仅可登录管理控制台，无法看到节点信息，也无法对策略进行管理。\n5、 其他：无法登录管理控制台，通常就是普通的生产者和消费者。\n==上述途中最右侧圈红的地方，分别是另外几种管理界面，我们讲一讲 virtual hosts==\n1、virtual hosts：虚拟主机，类似于mysql中的database。他们的 名字 都是以 “/” 开头\n\n2、给用户分配虚拟主机的相关权限，点击表格中虚拟主机的名字，可以进入管理界面\n\n10、RabbitMQ 入门案例1、创建项目① rabbitmq0.1（producer）    ② rabbitmq0.2（consumer）\n2、两个项目的 pom 文件中添加依赖&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.rabbitmq&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;amqp-client&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;5.6.0&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;3.8.0&lt;&#x2F;version&gt;\n            &lt;configuration&gt;\n                &lt;source&gt;1.8&lt;&#x2F;source&gt;\n                &lt;target&gt;1.8&lt;&#x2F;target&gt;\n            &lt;&#x2F;configuration&gt;\n        &lt;&#x2F;plugin&gt;\n    &lt;&#x2F;plugins&gt;\n&lt;&#x2F;build&gt;\n\n3、编写生产者com.atguigu.rabbitmq.simple.Producer\npackage com.atguigu.rabbitmq.simple;\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\nimport java.util.Map;\n\npublic class Producer &#123;\n\n    public static void main(String[] args) throws Exception &#123;\n        &#x2F;&#x2F;创建连接工厂\n        ConnectionFactory connectionFactory &#x3D; new ConnectionFactory();\n        &#x2F;&#x2F;主机地址\n        connectionFactory.setHost(&quot;192.168.137.118&quot;);\n        &#x2F;&#x2F;连接端口;默认为 5672\n        connectionFactory.setPort(5672);\n        &#x2F;&#x2F;虚拟主机名称;默认为 &#x2F;\n        connectionFactory.setVirtualHost(&quot;&#x2F;&quot;);\n        &#x2F;&#x2F;连接用户名；默认为guest\n        connectionFactory.setUsername(&quot;admin&quot;);\n        &#x2F;&#x2F;连接密码；默认为guest\n        connectionFactory.setPassword(&quot;123456&quot;);\n\n        &#x2F;&#x2F;创建连接\n        Connection connection &#x3D; connectionFactory.newConnection();\n\n        &#x2F;&#x2F;创建频道\n        Channel channel &#x3D; connection.createChannel();\n\n        &#x2F;&#x2F; 声明（创建）队列\n        &#x2F;**\n         * queue      参数1：队列名称\n         * durable    参数2：是否定义持久化队列,当mq重启之后,还在\n         * exclusive  参数3：是否独占本次连接\n         *            ① 是否独占,只能有一个消费者监听这个队列\n         *            ② 当connection关闭时,是否删除队列\n         * autoDelete 参数4：是否在不使用的时候自动删除队列,当没有consumer时,自动删除\n         * arguments  参数5：队列其它参数\n         *&#x2F;\n        channel.queueDeclare(&quot;simple_queue&quot;, true, false, false, null);\n\n        &#x2F;&#x2F; 要发送的信息\n        String message &#x3D; &quot;你好；小兔子！&quot;;\n        &#x2F;**\n         * 参数1：交换机名称,如果没有指定则使用默认Default Exchage\n         * 参数2：路由key,简单模式可以传递队列名称\n         * 参数3：配置信息\n         * 参数4：消息内容\n         *&#x2F;\n        channel.basicPublish(&quot;&quot;, &quot;simple_queue&quot;, null, message.getBytes());\n        System.out.println(&quot;已发送消息：&quot; + message);\n\n        &#x2F;&#x2F; 关闭资源\n        channel.close();\n        connection.close();\n    &#125;\n&#125;\n\n运行程序：http://192.168.137.118:15672 \n在执行上述的消息发送之后；可以登录rabbitMQ的管理控制台,可以发现队列和其消息：\n\n\n\n4、编写消费者com.atguigu.rabbitmq.simple.Consumer\npackage com.atguigu.rabbitmq.simple;\nimport com.rabbitmq.client.*;\nimport java.io.IOException;\nimport java.util.concurrent.TimeoutException;\n\n&#x2F;&#x2F;消费者\npublic class Consumer &#123;\n\n    public static void main(String[] args) throws IOException, TimeoutException &#123;\n        &#x2F;&#x2F;1.创建连接工厂\n        ConnectionFactory connectionFactory &#x3D; new ConnectionFactory();\n\n        &#x2F;&#x2F;2. 设置参数\n        connectionFactory.setHost(&quot;192.168.96.66&quot;);\n        connectionFactory.setPort(5672);\n        connectionFactory.setVirtualHost(&quot;&#x2F;&quot;);\n        connectionFactory.setUsername(&quot;admin&quot;);\n        connectionFactory.setPassword(&quot;admin&quot;);\n\n        &#x2F;&#x2F;3. 创建连接 Connection\n        Connection connection &#x3D; connectionFactory.newConnection();\n\n        &#x2F;&#x2F;4. 创建Channel\n        Channel channel &#x3D; connection.createChannel();\n\n        &#x2F;&#x2F;5. 创建队列Queue\n        &#x2F;*\n        queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)\n        参数：\n            1. queue：队列名称\n            2. durable：是否持久化,当mq重启之后,还在\n            3. exclusive：\n                * 是否独占。只能有一个消费者监听这队列\n                * 当Connection关闭时,是否删除队列\n            4. autoDelete：是否自动删除。当没有Consumer时,自动删除掉\n            5. arguments：参数。\n         *&#x2F;\n        &#x2F;&#x2F;如果没有一个名字叫simple_queue的队列,则会创建该队列,如果有则不会创建\n        channel.queueDeclare(&quot;simple_queue&quot;, true, false, false, null);\n\n        &#x2F;&#x2F; 接收消息\n        DefaultConsumer consumer &#x3D; new DefaultConsumer(channel) &#123;\n            &#x2F;*\n               回调方法,当收到消息后,会自动执行该方法\n               1. consumerTag：标识\n               2. envelope：获取一些信息,交换机,路由key...\n               3. properties：配置信息\n               4. body：数据\n            *&#x2F;\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;\n                System.out.println(&quot;consumerTag：&quot; + consumerTag);\n                System.out.println(&quot;Exchange：&quot; + envelope.getExchange());\n                System.out.println(&quot;RoutingKey：&quot; + envelope.getRoutingKey());\n                System.out.println(&quot;properties：&quot; + properties);\n                System.out.println(&quot;body：&quot; + new String(body));\n                ;\n            &#125;\n        &#125;;\n\n\n        &#x2F;*\n        basicConsume(String queue, boolean autoAck, Consumer callback)\n        参数：\n            1. queue：队列名称\n            2. autoAck：是否自动确认 ,类似咱们发短信,发送成功会收到一个确认消息\n            3. callback：回调对象\n         *&#x2F;\n        &#x2F;&#x2F; 消费者类似一个监听程序,主要是用来监听消息\n        channel.basicConsume(&quot;simple_queue&quot;, true, consumer);\n\n    &#125;\n&#125;\n\n运行程序\n\n\n5、小结上述案例使用的是以下简单的模式\n\n在上图的模型中，有以下概念：\n\nP：生产者，也就是要发送消息的程序\nC：消费者：消息的接受者，会一直等待消息到来。\nqueue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。\n\n11、AMQP 详解AMQP 一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。\nRabbitMQ 是 AMQP 协议的 Erlang 的实现。（RabbitMQ 的基础结构就是基于 AMQP 协议模型建立的）\n\n\n\n概念\n说明\n\n\n\n连接Connection\n一个网络连接，比如TCP/IP套接字连接。\n\n\n信道Channel\n多路复用连接中的一条独立的双向数据流通道。为会话提供物理传输介质。\n\n\n客户端Client\nAMQP连接或者会话的发起者。AMQP是非对称的，客户端生产和消费消息，服务器存储和路由这些消息。\n\n\n服务节点Broker\n消息中间件的服务节点；一般情况下可以将一个RabbitMQ Broker看作一台RabbitMQ 服务器。\n\n\n端点\nAMQP对话的任意一方。一个AMQP连接包括两个端点（一个是客户端，一个是服务器）。\n\n\n消费者Consumer\n一个从消息队列里请求消息的客户端程序。\n\n\n生产者Producer\n一个向交换机发布消息的客户端应用程序。\n\n\n12、RabbitMQ 运转流程在入门案例中：\n\n生产者发送消息\n生产者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker；\n声明队列并设置属性；如是否排它，是否持久化，是否自动删除；\n将路由键（空字符串）与队列绑定起来；\n发送消息至RabbitMQ Broker；\n关闭信道；\n关闭连接；\n\n\n消费者接收消息\n消费者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker\n向Broker 请求消费相应队列中的消息，设置相应的回调函数；\n等待Broker投递响应队列中的消息，消费者接收消息；\n确认（ack，自动确认）接收到的消息；\nRabbitMQ从队列中删除相应已经被确认的消息；\n关闭信道；\n关闭连接；\n\n\n\n13、RabbitMQ 工作模式13.1、相关概念\n\n\n标志\n中文名\n英文名\n描述\n\n\n\nP\n生产者\nProducer\n消息的发送者，可以将消息发送到交换机\n\n\nC\n消费者\nConsumer\n消息的接收者，从队列中获取消息并进行消费\n\n\nX\n交换机\nExchange\n接收生产者发送的消息，并根据路由键发送给指定队列\n\n\nQ\n队列\nQueue\n存储从交换机发来的消息\n\n\ntype\n交换机类型\ntype\n不同类型的交换机转发消息方式不同\n\n\nfanout\n发布/订阅模式\nfanout\n广播消息给所有绑定交换机的队列\n\n\ndirect\n路由模式\ndirect\n根据路由键发送消息\n\n\ntopic\n通配符模式\ntopic\n根据路由键的匹配规则发送消息\n\n\n13.2、simple模式 (最简单收发模式)\n     (C)\" style=\"zoom:80%;\" />\n\n\n生产者产生消息，将消息放入队列，使用信道进行发布\n消息的消费者(consumer) 监听 消息队列，如果队列中有消息，就消费，消息被拿走后，自动从队列中删除（隐患 消息可能没有被消费者正确处理，已经从队列中消失了，造成消息的丢失，这里可以设置成手动的 ack，但如果设置成手动 ack，处理完后要及时发送ack消息给队列，否则会造成内存溢出）。\n13.3、work queues 工作队列模式\n    \n\n\nWork Queues与入门程序的简单模式相比，多了一个或一些消费端，多个消费端 共同消费同一个队列中 的消息。C1 C2共同争抢当前的消息队列内容,谁先拿到谁负责消费消息(隐患：高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关(syncronize) 保证一条消息只能被一个消费者使用)。\n应用场景：对于 任务过重或任务较多情况使用工作队列可以 提高任务处理的速度。例如：短信服务部署多个，只需要有一个节点成功发送即可。\n13.4、Publish/Subscribe 模式中文为，发布订阅模式\n\n    \n\n\n而在订阅模型中，多了一个 exchange 角色，而且过程略有变化：\n\nP：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）\nC：消费者，消息的接受者，会一直等待消息到来。\nQueue：消息队列，接收消息、缓存消息。\nExchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。\n\nExchange有常见以下3种类型：\n\nFanout：广播，将消息交给所有绑定到交换机的队列\nDirect：定向，把消息交给符合指定routing key 的队列\nTopic：通配符，把消息交给符合routing pattern（路由模式） 的队列\n\nExchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！\n总结：\n\n每个消费者监听自己的队列；\n生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息。\n而每个消费者读取不同队列的信息，就可以读取到一样的信息或不一样的\n\n发布订阅模式与工作队列模式的区别\n\n工作队列模式不用定义交换机，而发布/订阅模式需要定义交换机。\n发布/订阅模式的生产方是面向交换机发送消息，工作队列模式的生产方是面向队列发送消息(底层使用默认交换机)。\n发布/订阅模式需要设置队列和交换机的绑定，工作队列模式不需要设置，实际上工作队列模式会将队列绑 定到默认的交换机 。\n\n13.5、Routing 路由模式\n    \n\n\n图解：\n\nP：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。\nX：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列\nC1：消费者，其所在队列指定了需要routing key 为 error 的消息\nC2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息\n\n1、消息生产者将消息发送给交换机按照路由判断，路由是字符串 (info) 当前产生的消息携带路由字符 (对象的方法)，交换机根据路由的key，只能匹配上路由key对应的消息队列，对应的消费者才能消费消息；(Routing模式要求队列在绑定交换机时要指定routing key，消息会转发到符合routing key的队列。)\n2、根据业务功能定义路由字符串\n3、从系统的代码逻辑中获取对应的功能字符串,将消息任务扔到对应的队列中。\n4、业务场景：error 通知；EXCEPTION；错误通知的功能；传统意义的错误通知；客户通知；利用key路由,可以将程序中的错误封装成消息传入到消息队列中,开发者可以自定义消费者,实时接收错误;\n13.6、Topic 通配符模式\n    \n\n\nTopic类型与Direct相比，都是可以根据 RoutingKey 把消息路由转发到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符！==(相当于路由功能添加模糊匹配)==\nRoutingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert\n通配符规则：\n\n#：匹配一个或多个词\n\n：匹配不多不少*恰好1个词\n\n\n举例：\n\nitem.#：能够匹配item.insert.abc 或者 item.insert\n\nitem.*：只能匹配item.insert\n\n\n\n    \n\n\n图解：\n\n红色Queue：绑定的是usa.# ，因此凡是以 usa.开头的routing key 都会被匹配到\n黄色Queue：绑定的是#.news ，因此凡是以 .news结尾的 routing key 都会被匹配\n\n13.7、总结简单收发模式：一个生产者、一个消费者，不需要设置交换机（使用默认的交换机）\n工作队列模式：一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机）\n发布订阅模式：需要设置类型为fanout的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息发送到绑定的队列\n路由模式：需要设置类型为direct的交换机，交换机和队列进行绑定，并且指定routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列\n通配符模式：需要设置类型为topic的交换机，交换机和队列进行绑定，并且指定通配符方式的routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列\n14、Spring 整合 RabbitMQ1、创建生产者，消费者模块① rabbitmq0.6_spring_producer        ② rabbitmq0.6_spring_consumer\n2、给两个模块添加依赖==这里是一样的依赖==\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;5.1.7.RELEASE&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.amqp&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-rabbit&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.1.8.RELEASE&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;4.12&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;5.1.7.RELEASE&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;3.8.0&lt;&#x2F;version&gt;\n            &lt;configuration&gt;\n                &lt;source&gt;1.8&lt;&#x2F;source&gt;\n                &lt;target&gt;1.8&lt;&#x2F;target&gt;\n            &lt;&#x2F;configuration&gt;\n        &lt;&#x2F;plugin&gt;\n    &lt;&#x2F;plugins&gt;\n&lt;&#x2F;build&gt;\n\n3、添加 rabbitmq.properties==两个模块都添加==，主要是提取的是创建 ConnectionFactory 的配置信息\nrabbitmq.host&#x3D;192.168.96.66\nrabbitmq.port&#x3D;5672\nrabbitmq.username&#x3D;admin\nrabbitmq.password&#x3D;admin\nrabbitmq.virtual-host&#x3D;&#x2F;\n\n4、生产者的 spring整合配置&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:rabbit&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;rabbit&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context\n       https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;rabbit\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;rabbit&#x2F;spring-rabbit.xsd&quot;&gt;\n    &lt;!--加载配置文件--&gt;\n    &lt;context:property-placeholder location&#x3D;&quot;classpath:rabbitmq.properties&quot;&#x2F;&gt;\n\n    &lt;!-- 定义rabbitmq connectionFactory --&gt;\n    &lt;rabbit:connection-factory id&#x3D;&quot;connectionFactory&quot; host&#x3D;&quot;$&#123;rabbitmq.host&#125;&quot;\n                               port&#x3D;&quot;$&#123;rabbitmq.port&#125;&quot;\n                               username&#x3D;&quot;$&#123;rabbitmq.username&#125;&quot;\n                               password&#x3D;&quot;$&#123;rabbitmq.password&#125;&quot;\n                               virtual-host&#x3D;&quot;$&#123;rabbitmq.virtual-host&#125;&quot;&#x2F;&gt;\n    &lt;!--定义管理交换机、队列--&gt;\n    &lt;rabbit:admin connection-factory&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;\n\n    &lt;!--定义持久化队列,不存在则自动创建；不绑定到交换机则绑定到默认交换机\n    默认交换机类型为direct,名字为：&quot;&quot;,路由键为队列的名称\n    --&gt;\n    &lt;rabbit:queue id&#x3D;&quot;spring_queue&quot; name&#x3D;&quot;spring_queue&quot; auto-declare&#x3D;&quot;true&quot;&#x2F;&gt;\n\n    &lt;!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~广播；所有队列都能收到消息~~~~~~~~~~~~~~~~~~~~~~~~~~~~ --&gt;\n    &lt;!--定义广播交换机中的持久化队列,不存在则自动创建--&gt;\n    &lt;rabbit:queue id&#x3D;&quot;spring_fanout_queue_1&quot; name&#x3D;&quot;spring_fanout_queue_1&quot; auto-declare&#x3D;&quot;true&quot;&#x2F;&gt;\n\n    &lt;!--定义广播交换机中的持久化队列,不存在则自动创建--&gt;\n    &lt;rabbit:queue id&#x3D;&quot;spring_fanout_queue_2&quot; name&#x3D;&quot;spring_fanout_queue_2&quot; auto-declare&#x3D;&quot;true&quot;&#x2F;&gt;\n\n    &lt;!--定义广播类型交换机；并绑定上述两个队列--&gt;\n    &lt;rabbit:fanout-exchange id&#x3D;&quot;spring_fanout_exchange&quot; name&#x3D;&quot;spring_fanout_exchange&quot; auto-declare&#x3D;&quot;true&quot;&gt;\n        &lt;rabbit:bindings&gt;\n            &lt;rabbit:binding queue&#x3D;&quot;spring_fanout_queue_1&quot;&#x2F;&gt;\n            &lt;rabbit:binding queue&#x3D;&quot;spring_fanout_queue_2&quot;&#x2F;&gt;\n        &lt;&#x2F;rabbit:bindings&gt;\n    &lt;&#x2F;rabbit:fanout-exchange&gt;\n\n    &lt;!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~通配符；*匹配一个单词,#匹配多个单词 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ --&gt;\n    &lt;!--定义广播交换机中的持久化队列,不存在则自动创建--&gt;\n    &lt;rabbit:queue id&#x3D;&quot;spring_topic_queue_star&quot; name&#x3D;&quot;spring_topic_queue_star&quot; auto-declare&#x3D;&quot;true&quot;&#x2F;&gt;\n    &lt;!--定义广播交换机中的持久化队列,不存在则自动创建--&gt;\n    &lt;rabbit:queue id&#x3D;&quot;spring_topic_queue_well&quot; name&#x3D;&quot;spring_topic_queue_well&quot; auto-declare&#x3D;&quot;true&quot;&#x2F;&gt;\n    &lt;!--定义广播交换机中的持久化队列,不存在则自动创建--&gt;\n    &lt;rabbit:queue id&#x3D;&quot;spring_topic_queue_well2&quot; name&#x3D;&quot;spring_topic_queue_well2&quot; auto-declare&#x3D;&quot;true&quot;&#x2F;&gt;\n\n    &lt;rabbit:topic-exchange id&#x3D;&quot;spring_topic_exchange&quot; name&#x3D;&quot;spring_topic_exchange&quot; auto-declare&#x3D;&quot;true&quot;&gt;\n        &lt;rabbit:bindings&gt;\n            &lt;rabbit:binding pattern&#x3D;&quot;atguigu.*&quot; queue&#x3D;&quot;spring_topic_queue_star&quot;&#x2F;&gt;\n            &lt;rabbit:binding pattern&#x3D;&quot;atguigu.#&quot; queue&#x3D;&quot;spring_topic_queue_well&quot;&#x2F;&gt;\n            &lt;rabbit:binding pattern&#x3D;&quot;guigu.#&quot; queue&#x3D;&quot;spring_topic_queue_well2&quot;&#x2F;&gt;\n        &lt;&#x2F;rabbit:bindings&gt;\n    &lt;&#x2F;rabbit:topic-exchange&gt;\n\n    &lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt;\n    &lt;rabbit:template id&#x3D;&quot;rabbitTemplate&quot; connection-factory&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;\n&lt;&#x2F;beans&gt;\n\n5、消费者的 spring整合配置&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:rabbit&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;rabbit&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;rabbit http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;rabbit&#x2F;spring-rabbit.xsd&quot;&gt;\n    &lt;context:property-placeholder location&#x3D;&quot;classpath:rabbitmq.properties&quot;&#x2F;&gt;\n\n    &lt;rabbit:connection-factory id&#x3D;&quot;connectionFactory&quot;  host&#x3D;&quot;$&#123;rabbitmq.host&#125;&quot;\n                               port&#x3D;&quot;$&#123;rabbitmq.port&#125;&quot;\n                               virtual-host&#x3D;&quot;$&#123;rabbitmq.virtual-host&#125;&quot;\n                               username&#x3D;&quot;$&#123;rabbitmq.username&#125;&quot;\n                               password&#x3D;&quot;$&#123;rabbitmq.password&#125;&quot;&#x2F;&gt;\n\n    &lt;!--如果mq中有了下面监听容器中的队列，则会根据这些bean对象，调用相关类中的方法，对消息进行消费--&gt;\n    &lt;bean id&#x3D;&quot;springQueueListener&quot; class&#x3D;&quot;com.atguigu.rabbitmq.listener.SpringQueueListener&quot;&#x2F;&gt;\n    &lt;bean id&#x3D;&quot;fanoutListener1&quot; class&#x3D;&quot;com.atguigu.rabbitmq.listener.FanoutListener1&quot;&#x2F;&gt;\n    &lt;bean id&#x3D;&quot;fanoutListener2&quot; class&#x3D;&quot;com.atguigu.rabbitmq.listener.FanoutListener2&quot;&#x2F;&gt;\n    &lt;bean id&#x3D;&quot;topicListenerStar&quot; class&#x3D;&quot;com.atguigu.rabbitmq.listener.TopicListenerStar&quot;&#x2F;&gt;\n    &lt;bean id&#x3D;&quot;topicListenerWell&quot; class&#x3D;&quot;com.atguigu.rabbitmq.listener.TopicListenerWell&quot;&#x2F;&gt;\n    &lt;bean id&#x3D;&quot;topicListenerWell2&quot; class&#x3D;&quot;com.atguigu.rabbitmq.listener.TopicListenerWell2&quot;&#x2F;&gt;\n\n    &lt;!--创建消息监听容器，监听所有的队列，并进行相关队列的消息消费代码--&gt;\n    &lt;rabbit:listener-container connection-factory&#x3D;&quot;connectionFactory&quot; auto-declare&#x3D;&quot;true&quot;&gt;\n        &lt;rabbit:listener ref&#x3D;&quot;springQueueListener&quot; queue-names&#x3D;&quot;spring_queue&quot;&#x2F;&gt;\n        &lt;rabbit:listener ref&#x3D;&quot;fanoutListener1&quot; queue-names&#x3D;&quot;spring_fanout_queue_1&quot;&#x2F;&gt;\n        &lt;rabbit:listener ref&#x3D;&quot;fanoutListener2&quot; queue-names&#x3D;&quot;spring_fanout_queue_2&quot;&#x2F;&gt;\n        &lt;rabbit:listener ref&#x3D;&quot;topicListenerStar&quot; queue-names&#x3D;&quot;spring_topic_queue_star&quot;&#x2F;&gt;\n        &lt;rabbit:listener ref&#x3D;&quot;topicListenerWell&quot; queue-names&#x3D;&quot;spring_topic_queue_well&quot;&#x2F;&gt;\n        &lt;rabbit:listener ref&#x3D;&quot;topicListenerWell2&quot; queue-names&#x3D;&quot;spring_topic_queue_well2&quot;&#x2F;&gt;\n    &lt;&#x2F;rabbit:listener-container&gt;\n&lt;&#x2F;beans&gt;\n\n6、创建各个 消息监听器6.1、队列监听器package com.atguigu.rabbitmq.listener;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.core.MessageListener;\n\npublic class SpringQueueListener implements MessageListener &#123;\n    public void onMessage(Message message) &#123;\n        try &#123;\n            String msg &#x3D; new String(message.getBody(), &quot;utf-8&quot;);\n\n            System.out.printf(&quot;接收路由名称为：%s,路由键为：%s,队列名为：%s的消息：%s \\n&quot;,\n                    message.getMessageProperties().getReceivedExchange(),\n                    message.getMessageProperties().getReceivedRoutingKey(),\n                    message.getMessageProperties().getConsumerQueue(),\n                    msg);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n6.2、广播监听器 1public class FanoutListener1 implements MessageListener &#123;\n    public void onMessage(Message message) &#123;\n        try &#123;\n            String msg &#x3D; new String(message.getBody(), &quot;utf-8&quot;);\n\n            System.out.printf(&quot;广播监听器1：接收路由名称为：%s,路由键为：%s,队列名为：%s的消息：%s \\n&quot;,\n                    message.getMessageProperties().getReceivedExchange(),\n                    message.getMessageProperties().getReceivedRoutingKey(),\n                    message.getMessageProperties().getConsumerQueue(),\n                    msg);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n6.3、广播监听器 2public class FanoutListener2 implements MessageListener &#123;\n    public void onMessage(Message message) &#123;\n        try &#123;\n            String msg &#x3D; new String(message.getBody(), &quot;utf-8&quot;);\n\n            System.out.printf(&quot;广播监听器2：接收路由名称为：%s,路由键为：%s,队列名为：%s的消息：%s \\n&quot;,\n                    message.getMessageProperties().getReceivedExchange(),\n                    message.getMessageProperties().getReceivedRoutingKey(),\n                    message.getMessageProperties().getConsumerQueue(),\n                    msg);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n6.4、* 号通配符监听器public class TopicListenerStar implements MessageListener &#123;\n    public void onMessage(Message message) &#123;\n        try &#123;\n            String msg &#x3D; new String(message.getBody(), &quot;utf-8&quot;);\n\n            System.out.printf(&quot;通配符*监听器：接收路由名称为：%s,路由键为：%s,队列名为：%s的消息：%s \\n&quot;,\n                    message.getMessageProperties().getReceivedExchange(),\n                    message.getMessageProperties().getReceivedRoutingKey(),\n                    message.getMessageProperties().getConsumerQueue(),\n                    msg);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n6.5、# 号通配符监听器 1public class TopicListenerWell implements MessageListener &#123;\n    public void onMessage(Message message) &#123;\n        try &#123;\n            String msg &#x3D; new String(message.getBody(), &quot;utf-8&quot;);\n\n            System.out.printf(&quot;通配符#监听器：接收路由名称为：%s,路由键为：%s,队列名为：%s的消息：%s \\n&quot;,\n                    message.getMessageProperties().getReceivedExchange(),\n                    message.getMessageProperties().getReceivedRoutingKey(),\n                    message.getMessageProperties().getConsumerQueue(),\n                    msg);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n6.6、# 号通配符监听器 2public class TopicListenerWell2 implements MessageListener &#123;\n    public void onMessage(Message message) &#123;\n        try &#123;\n            String msg &#x3D; new String(message.getBody(), &quot;utf-8&quot;);\n\n            System.out.printf(&quot;通配符#监听器2：接收路由名称为：%s,路由键为：%s,队列名为：%s的消息：%s \\n&quot;,\n                    message.getMessageProperties().getReceivedExchange(),\n                    message.getMessageProperties().getReceivedRoutingKey(),\n                    message.getMessageProperties().getConsumerQueue(),\n                    msg);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n7、创建 生产者测试方法import org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.amqp.rabbit.core.RabbitTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringRunner;\n\n&#x2F;**\n * @author hrenxiang\n * @create 2021&#x2F;8&#x2F;10 20:20\n *&#x2F;\n@RunWith(SpringRunner.class)\n@ContextConfiguration(locations &#x3D; &quot;classpath:spring-rabbit.xml&quot;)\npublic class ProducerTest &#123;\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    &#x2F;**\n     * 只发队列消息\n     * 默认交换机类型为 direct\n     * 交换机的名称为空,路由键为队列的名称\n     *&#x2F;\n    @Test\n    public void queueTest() &#123;\n        &#x2F;&#x2F;路由键与队列同名\n        rabbitTemplate.convertAndSend(&quot;spring_queue&quot;, &quot;只发队列spring_queue的消息。&quot;);\n    &#125;\n\n    &#x2F;**\n     * 发送广播\n     * 交换机类型为 fanout\n     * 绑定到该交换机的所有队列都能够收到消息\n     *&#x2F;\n    @Test\n    public void fanoutTest() &#123;\n        &#x2F;**\n         * 参数1：交换机名称\n         * 参数2：路由键名（广播设置为空）\n         * 参数3：发送的消息内容\n         *&#x2F;\n        rabbitTemplate.convertAndSend(&quot;spring_fanout_exchange&quot;, &quot;&quot;, &quot;发送到spring_fanout_exchange交换机的广播消息&quot;);\n    &#125;\n\n    &#x2F;**\n     * 通配符\n     * 交换机类型为 topic\n     * 匹配路由键的通配符,*表示一个单词,#表示多个单词\n     * 绑定到该交换机的匹配队列能够收到对应消息\n     *&#x2F;\n    @Test\n    public void topicTest() &#123;\n        &#x2F;**\n         * 参数1：交换机名称\n         * 参数2：路由键名\n         * 参数3：发送的消息内容\n         *&#x2F;\n        rabbitTemplate.convertAndSend(&quot;spring_topic_exchange&quot;, &quot;atguigu.bj&quot;, &quot;发送到spring_topic_exchange交换机atguigu.bj的消息&quot;);\n        rabbitTemplate.convertAndSend(&quot;spring_topic_exchange&quot;, &quot;atguigu.bj.1&quot;, &quot;发送到spring_topic_exchange交换机atguigu.bj.1的消息&quot;);\n        rabbitTemplate.convertAndSend(&quot;spring_topic_exchange&quot;, &quot;atguigu.bj.2&quot;, &quot;发送到spring_topic_exchange交换机atguigu.bj.2的消息&quot;);\n        rabbitTemplate.convertAndSend(&quot;spring_topic_exchange&quot;, &quot;guigu.cn&quot;, &quot;发送到spring_topic_exchange交换机guigu.cn的消息&quot;);\n    &#125;\n&#125;\n\n\n我们编写 生产者的测试类完成后，我们直接运行第一个测试方法，我们发现运行完成后，管理界面具有我们配置文件中所有的 队列信息\n并且也只有 一个方法中有信息，因为我们只给spring_queue队列发送了信息\n\n8、创建 消费者的测试方法消费者的测试方法，并没有进行相关的调用，这是因为 我们已经监听了消息队列，如果队列中有值存在，那我们的监听类中的方法会立即运行，根本不需要我们自己去调用\n:chestnut: 举个例子：我们注册账号，注册成功后需要发送短信告知我们成功，而我们使用了 mq技术，在注册成功的同时，把消息发送给了mq，然后我们能想到的是 mq肯定自己找到对应的消费者的方法（也就是监听此队列的监听器中的方法）进行调用，然后发送信息\n所以我们只需将这个项目启动，加载配置文件就可以达到测试的目的\nimport com.atguigu.rabbitmq.listener.SpringQueueListener;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.core.MessageProperties;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport java.nio.charset.StandardCharsets;\n\n&#x2F;**\n * @author hrenxiang\n * @create 2021&#x2F;8&#x2F;10 20:33\n *&#x2F;\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations &#x3D; &quot;classpath:spring-rabbit.xml&quot;)\npublic class ConsumerTeest &#123;\n\n    @Autowired\n    private SpringQueueListener springQueueListener;\n\n    @Test\n    public void testSpringQueueListener()&#123;\n        System.out.println(&quot;直接接收消息：&quot;);\n    &#125;\n\n&#125;\n\n","slug":"66-RabbitMQ-基础内容","date":"2021-09-13T15:42:32.000Z","categories_index":"消息队列","tags_index":"消息队列","author_index":"大黄"},{"id":"1622936a4b6ba96f2723411bb290759b","title":"SpringBoot 基础内容","content":"1、Spirng Boot 概念① Spring 框架\n最核心的特性就是依赖注入DI（Dependency Injecttion）和控制反转IOC（Inversion Of Control）。如果你能够合理的使用DI和IOC，可以开发出松耦合、扩展性好的的应用程序。\n② Spring MVC\nSpring MVC提供了一种友好的方式来开发Web应用程序。 通过使用诸如Dispatcher Servlet，ModelAndView和View Resolver，可以轻松开发Web应用程序。\n③ Spring Boot\nSpring 和 Spring MVC最大的弊病在于存在大量的配置，并且这些配置在不同的项目中具有很高的相似性。从而导致重复配置，繁琐而且杂乱！\nSpring Boot是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品，其最主要作用就是帮助开发人员快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让开发人员关注业务而非配置。\n\n    \n\n\n\n\n2、Spring Boot 特点及目的主要特点:\n\n自动配置 : 不需要再关注各个框架的整合配置, springboot全部已经配置好了\n\n起步依赖 : 我们在需要使用某个框架的时候, 直接添加这个框架的启动器依赖即可 , 不需要在关注jar包的冲突和整合\n\n\n设计目的： \n\n用来简化 Spring 应用的初始搭建以及开发过程。\n从最根本上来讲，Spring Boot 就是一些库的集合，它能够被任意项目所使用。\n它使用 “习惯优于配置”的理念让你的项目快速运行起来。\nspring boot 其实不是什么新的框架，它配置了很多框架的使用，像 maven 整合了所有的 jar 包，spring boot 整合了所有的框架\n\n总结一下及几点：\n\n为所有 Spring 开发提供一个更快更广泛的入门体验。\n零配置。无冗余代码生成和XML 强制配置，遵循“约定大于配置” 。\n集成了大量常用的第三方库的配置， Spring Boot 应用为这些第三方库提供了几乎可以零配置的开箱即用的能力。\n提供一系列大型项目常用的非功能性特征，如嵌入服务器等。\n\n好处：\n\n简单，快捷，方便\n不需要关注各种复杂的整合配置 , 也不用关注各个库之间的依赖及冲突问题，专注业务逻辑的开发。\n\n3、Spring Boot 快速入门1、创建一个 maven 工程2、导入依赖SpringBoot 可以帮我们方便的管理项目依赖 , 在 Spring Boot 提供了一个名为 **spring-boot-starter-parent ** 的工程，里面已经对各种常用依赖的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，==需要什么依赖，直接引入坐标(不需要添加版本)==即可！\n2.1、添加父工程依赖&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.2.2.RELEASE&lt;&#x2F;version&gt;\n    &lt;!--&lt;relativePath&#x2F;&gt;--&gt;\n&lt;&#x2F;parent&gt;\n\n注意：如果你先创建了一个 maven 工程 如，springboot 作为你接下来学习 spring boot 时的总代码目录，而又在 spring boot 下创建了目前的入门工程，虽然我们在创建入门工程时没有继承 作为总目录的工程，但是在添加 spring boot 启动器作为父工程时，还是会报错，这时我们只需要在 父工程的依赖中加入 &lt;relativePath/&gt;\n\n    \n\n\n\n\n2.2、添加 web启动器为了让Spring Boot帮我们完成各种自动配置，我们必须引入Spring Boot提供的自动配置依赖，我们称为启动器。因为我们是web项目，这里我们引入web启动器，在 pom.xml 文件中加入如下依赖\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n需要注意的是，我们并没有在这里指定版本信息 , 当我们添加好启动器之后我们发现项目中已经依赖了大量的Jar包\n2.3、配置JDK版本&lt;properties&gt;\n    &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;\n&lt;&#x2F;properties&gt;\n\n思考: 为什么我们这里仅仅配置了这么一个变量 , 项目的JDK版本就会改变呢 ?因为jdk插件已经在父工程中定义好了 , 默认会读取${java.version}变量值\n2.4、完整的pom.xml文件&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.2.2.RELEASE&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n\n    &lt;groupId&gt;com.atguigu&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;springboot_01&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n\n    &lt;properties&gt;\n        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;\n    &lt;&#x2F;properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;\n\n\n\n2.5 创建启动器，编写controllerpackage com.atguigu;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n&#x2F;&#x2F;启动类（启动tomcat加载springboot）\n@SpringBootApplication\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;Application.class 自己的类\n        &#x2F;&#x2F;args main方法中的参数\n        SpringApplication.run(Application.class,args);\n    &#125;\n&#125;\n\npackage com.atguigu.controller;\nimport com.atguigu.properties.DataSourceProperties;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class HelloController &#123;\n\n    @Autowired\n    private DataSourceProperties dataSourceProperties;\n\n    @RequestMapping(&quot;&#x2F;hello&quot;)\n    public String sayHello()&#123;\n        return &quot;hello spring boot&quot;;\n    &#125;\n&#125;\n\n根据控制台信息我们可以知道默认的端口号 是 8080，（我这里是因为 我在application.yaml 中修改了端口号，默认的确是8080）\n\n打开浏览器,访问：http://localhost:8080/hello\n4、Spring Boot 入门思考:question: 问题一：为什么我们在添加启动器的时候不需要在启动器的坐标中指定版本？\n答案：因为我们指定了项目的父工程，在spring-boot-starter-parent中已经通过Maven的版本锁定了Jar包的版本，所以就不需要再指定了。\n图片\n:question: 问题二：为什么我们就添加一个启动器依赖，项目就可以运行起来了，运行项目所需要的Jar包从何而来？\n答案：因为我们添加了这个启动器的依赖，它已经把自己运行所需要的必要包集成在这个启动器中，通过Maven的依赖传递性，将这些包都依赖到咱们的项目里了。\n图片\n5、配置文件详解5.1、属性配置文件5.2、YAML 配置文件5.3、多环境 profile 切换配置","slug":"65-SpringBoot-基础内容","date":"2021-09-13T15:41:32.000Z","categories_index":"SpringBoot","tags_index":"SpringBoot","author_index":"大黄"},{"id":"af6a277a1f79cc7652a602f9f57ed64f","title":"Nginx","content":"01、Nginx 的介绍Nginx 是开源、高性能、高可靠的 Web 和反向代理服务器\nNginx 支持热部署，几乎能做到 7*24 小时不间断运行，即使运行几个月也不需要重启，还能在不间断服务的情况下对软件进行热更新。\nNginx 最重要的考量是 性能 ，其占用内存少、并发能力强、能支持高达 5w 个并发连接数\nNginx 是免费的并可以商业化，配置使用也比较简单。\nNginx 的最重要的几个使用场景：\n\n静态资源服务，通过本地文件系统提供服务（就是作为静态页面的服务器）；\n反向代理服务，延伸出包括缓存、负载均衡等；\nAPI 服务，OpenResty ；\n\n02、简单和非简单请求==如果同时满足下面两个条件，就属于简单请求，凡是不同时满足这两个条件的，都属于非简单请求==\n\n请求方法是 HEAD、GET、POST 三种之一；\nHTTP 头信息不超过右边这几个字段：Accept、Accept-Language、Content-Language、Last-Event-ID 、Content-Type 只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain；\n\n浏览器处理简单请求和非简单请求的方式不一样\n\n简单请求\n对于简单请求，浏览器会在头信息中增加 Origin 字段后直接发出，Origin 字段用来说明，本次请求来自的哪个源（协议+域名+端口）。\n如果服务器发现 Origin 指定的源不在许可范围内，服务器会返回一个正常的 HTTP 回应，浏览器取到回应之后发现回应的头信息中没有包含 Access-Control-Allow-Origin 字段，就抛出一个错误给 XHR 的 error 事件；\n如果服务器发现 Origin 指定的域名在许可范围内，服务器返回的响应会多出几个 Access-Control- 开头的头信息字段。\n\n非简单请求\n非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 PUT 或 DELETE，或 Content-Type 值为 application/json。浏览器会在正式通信之前，发送一次 HTTP 预检 OPTIONS 请求，先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 请求方法和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XHR 请求，否则报错。\n\n\n03、跨域在浏览器上当前访问的网站向另一个网站发送请求获取数据的过程就是跨域请求。\n跨域是浏览器的同源策略决定的，是一个重要的浏览器安全策略，用于限制一个 origin 的文档或者它加载的脚本与另一个源的资源进行交互，它能够帮助阻隔恶意文档，减少可能被攻击的媒介，可以使用 CORS 配置解除这个限制。\n关于跨域网上已经有很多解释，这里就不啰嗦，也可以直接看 MDN 的 &lt;浏览器的同源策略&gt; 文档进一步了解，这里就列举几个同源和不同元的例子，相信程序员都能看得懂。\n# 同源的例子\nhttp:&#x2F;&#x2F;example.com&#x2F;app1&#x2F;index.html  # 只是路径不同\nhttp:&#x2F;&#x2F;example.com&#x2F;app2&#x2F;index.html\n\nhttp:&#x2F;&#x2F;Example.com:80  # 只是大小写差异\nhttp:&#x2F;&#x2F;example.com\n\n# 不同源的例子\nhttp:&#x2F;&#x2F;example.com&#x2F;app1   # 协议不同\nhttps:&#x2F;&#x2F;example.com&#x2F;app2\n\nhttp:&#x2F;&#x2F;example.com        # host 不同\nhttp:&#x2F;&#x2F;www.example.com\nhttp:&#x2F;&#x2F;myapp.example.com\n\nhttp:&#x2F;&#x2F;example.com        # 端口不同\nhttp:&#x2F;&#x2F;example.com:8080\n\n\n\n04、正向代理和反向代理反向代理（Reverse Proxy）对应的是正向代理（Forward Proxy），他们的区别：\n正向代理： 一般的访问流程是客户端直接向目标服务器发送请求并获取内容，使用正向代理后，客户端改为向代理服务器发送请求，并指定目标服务器（原始服务器），然后由代理服务器和原始服务器通信，转交请求并获得的内容，再返回给客户端。正向代理隐藏了真实的客户端，为客户端收发请求，使真实客户端对服务器不可见；\n举个具体的例子 🌰，你的浏览器无法直接访问谷哥，这时候可以通过一个代理服务器来帮助你访问谷哥，那么这个服务器就叫正向代理。\n反向代理： 与一般访问流程相比，使用反向代理后，直接收到请求的服务器是代理服务器，然后将请求转发给内部网络上真正进行处理的服务器，得到的结果返回给客户端。反向代理隐藏了真实的服务器，为服务器收发请求，使真实服务器对客户端不可见。一般在处理跨域请求的时候比较常用。现在基本上所有的大型网站都设置了反向代理。\n举个具体的例子 🌰，去饭店吃饭，可以点川菜、粤菜、江浙菜，饭店也分别有三个菜系的厨师 👨‍🍳，但是你作为顾客不用管哪个厨师给你做的菜，只用点菜即可，小二将你菜单中的菜分配给不同的厨师来具体处理，那么这个小二就是反向代理服务器。\n简单的说，一般给客户端做代理的都是正向代理，给服务器做代理的就是反向代理。\n正向代理和反向代理主要的原理区别可以参见下图：\n\n    \n    \n\n\n\n\n05、负载均衡一般情况下，客户端发送多个请求到服务器，服务器处理请求，其中一部分可能要操作一些资源比如数据库、静态资源等，服务器处理完毕后，再将结果返回给客户端。\n这种模式对于早期的系统来说，功能要求不复杂，且并发请求相对较少的情况下还能胜任，成本也低。随着信息数量不断增长，访问量和数据量飞速增长，以及系统业务复杂度持续增加，这种做法已无法满足要求，并发量特别大时，服务器容易崩。\n很明显这是由于服务器性能的瓶颈造成的问题，除了堆机器之外，最重要的做法就是负载均衡。\n请求爆发式增长的情况下​，单个机器性能再强劲也无法满足要求了，这个时候集群的概念产生了，单个服务器解决不了的问题，可以使用多个服务器，然后==将请求分发到各个服务器上，将负载分发到不同的服务器==，这就是负载均衡，核心是「分摊压力」。\n:star: ​Nginx 实现负载均衡，一般来说指的是将请求转发给服务器集群。\n:chestnut: 举个具体的例子，晚高峰乘坐地铁的时候，入站口经常会有地铁工作人员大喇叭“请走 B 口，B 口人少车空….”，这个工作人员的作用就是负载均衡。\n\n06、动静分离为了加快网站的解析速度，可以==把动态页面和静态页面由不同的服务器来解析，加快解析速度，降低原来单个服务器的压力==。\n\n一般来说，都需要将动态资源和静态资源分开，由于 ==Nginx 的高并发和静态资源缓存等特性==，经常将静态资源部署在 Nginx 上。如果请求的是静态资源，直接到静态资源目录获取资源，如果是动态资源的请求，则利用反向代理的原理，把请求转发给对应后台应用去处理，从而实现动静分离。\n使用前后端分离后，可以很大程度提升静态资源的访问速度，即使动态服务不可用，静态资源的访问也不会受到影响。\n07、Nginx 的安装1、到官网下载安装包：http://nginx.org/   nginx-1.12.2.tar.gz  （centos8 安装1.12版本并不可以，可以试试更高版本，比如1.17.6）\n2、下载所需依赖包：pcre-8.37.tar.gz        openssl-1.0.1t.tar.gz        zlib-1.2.8.tar.gz\n3、离线安装 nginx：\n\n解压缩 pcre-xx.tar.gz 包\n进入解压缩目录，执行 ./configure\n注意：如果提示错误，需要提前安装 gcc++：yum install -y gcc-c++\n./configure 完成后，回到pcre目录下执行make，再执行make install\n\n解压缩 openssl-xx.tar.gz 包\n进入解压缩目录，执行 ./config \nmake &amp;&amp; make install\n\n解压缩 zlib-xx.tar.gz 包\n进入解压缩目录，执行./configure\nmake &amp;&amp; make install\n\n解压缩 nginx-xx.tar.gz 包 \n进入解压缩目录，执行 ./configure \nmake &amp;&amp; make install\n\n\n4、关闭防火墙，访问nginx\n\n在windows系统中访问linux中nginx，默认不能访问的，因为防火墙问题\n\n关闭防火墙-开放访问的端口号，80端口\n\n查看开放的端口号\nfirewall-cmd --list-all\n\n开启防火墙\nsystemctl start firewalld\n\n关闭防火墙\nsystemctl stop firewalld\n\n设置开放的服务或端口号\nfirewall-cmd --add-service=http --permanent\nfirewall-cmd --add-port=80/tcp --permanent\n\n重启防火墙：firewall-cmd --reload\n\n\n5、扩展：在线安装\n\n第 1.0 步 安装openssl、zlib、gcc 依赖 yum -y install make zlib zlib-devel gcc-c++ libtool  openssl openssl-devel\n第 2.1 步 联网下载pcrewget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz\n第 2.2 步 解压压缩文件 tar -zxvf pcre-8.37.tar.gz\n第 2.3 步 ./configure 完成后，回到pcre目录下执行 make，最后执行 make install\n第 2.4 步 pcre-config --version  检查版本\n第 3.0 步，安装nginx，使用命令解压 然后进入解压缩目录，执行 ./configure 然后 make &amp;&amp; make install\n进入目录 /usr/local/nginx/sbin  执行 ./nginx 启动服务\n第 4.0 步，关闭防火墙，访问nginx\n\n08、Nginx 相关命令我们需要去相关目录下执行命令，下面我们一个命令直接到了相应目录并执行 nginx 相关操作\n# nginx版本检查\nnginx -v\n\n# nginx编译参数\nnginx -V\n\n# 启停方式\n- 启动\n\t[root@zls ~]# &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx\n\t[root@zls ~]# systemctl start nginx\n- 停止\n\t[root@zls ~]# &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s stop\n\t[root@zls ~]# systemctl stop nginx\n- 重启\n\t[root@zls ~]# systemctl restart nginx\n- 重载\n\t[root@zls ~]# &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload\n\t[root@zls ~]# systemctl reload nginx\n\n==上述 — 使用 systemctl start nginx 来启动 nginx 是需要配置的，下面我们来创建并配置 nginx.service 文件==\nSystemd服务文件以.service结尾，比如现在要建立nginx为开机启动，如果用yum install命令安装的，yum命令会自动创建nginx.service文件，可以直接使用systemctl相关命令。而用源码编译安装的，则需要手动创建nginx.service服务文件。\n配置nginx.service文件\nvim /usr/lib/systemd/system/nginx.service\n#配置文件内容\n[Unit]                                          \nDescription&#x3D;nginx \nAfter&#x3D;network.target \n\n[Service] \nType&#x3D;forking \nExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx \nExecReload&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload \nExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s quit\nPrivateTmp&#x3D;true \n\n[Install] \nWantedBy&#x3D;multi-user.target\n\n#[Unit]:服务的说明\n#Description:描述服务\n#After:描述服务类别\n#[Service]服务运行参数的设置\n#Type&#x3D;forking是后台运行的形式\n#ExecStart为服务的具体运行命令\n#ExecReload为重启命令\n#ExecStop为停止命令\n#PrivateTmp&#x3D;True表示给服务分配独立的临时空间\n#注意：[Service]的启动、重启、停止命令全部要求使用绝对路径\n#[Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3\n\n#查看nginx服务状态\nsystemctl status nginx.service\n#启动nginx服务\nsystemctl start nginx.service\n#停止nginx服务\nsystemctl stop nginx.service\n#重启nginx服务\nsystemctl restart nginx.service\n#重新读取nginx配置(这个最常用, 不用停止nginx服务就能使修改的配置生效)\nsystemctl reload nginx.service\n\n\n\n09、Nginx 配置语法Nginx 的主配置文件是 /usr/local/nginx/conf/nginx.conf，可以使用 vim /usr/local/nginx/conf/nginx.conf 来查看配置。\nnginx.conf 结构图可以这样概括：\nmain        # 全局配置，对全局生效\n├── events  # 配置影响 Nginx 服务器或与用户的网络连接\n├── http    # 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置\n│   ├── upstream # 配置后端服务器具体地址，负载均衡配置不可或缺的部分\n│   ├── server   # 配置虚拟主机的相关参数，一个 http 块中可以有多个 server 块\n│   ├── server\n│   │   ├── location  # server 块可以包含多个 location 块，location 指令用于匹配 uri\n│   │   ├── location\n│   │   └── ...\n│   └── ...\n└── ...\n\n一个 Nginx 配置文件的结构就像 nginx.conf 显示的那样，配置文件的语法规则：\n\n配置文件由指令与指令块构成；\n每条指令以 ; 分号结尾，指令与参数间以空格符号分隔；\n指令块以 &#123;&#125; 大括号将多条指令组织在一起；\ninclude 语句允许组合多个配置文件以提升可维护性；\n使用 # 符号添加注释，提高可读性；\n使用 $ 符号使用变量；\n部分指令的参数支持正则表达式；\n\n\n全局块\n从配置文件开始到 events 块之间的内容，主要会设置一些影响nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。\nworker_processes  1; 这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约。\n\nevents 块\nevents 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 work process 可以同时支持的最大连接数等\n上述例子就表示每个 work process 支持的最大连接数为 1024.\n这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。\n\nhttp 块\n这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。\n需要注意的是：http 块也可以包括 http全局块、server 块。\n①、http 全局块\n　　http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。\n​        最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置。\n②、server 块\n　　这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。\n　　:star: 每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。\n　　:star: 每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。\n③、location 块\n　　一个 server 块可以配置多个 location 块。\n​       这块的主要作用是基于 Nginx 服务器接收到的请求字符串\n​       :chestnut: 例如 server_name/uri-string ，对虚拟主机名称（也可以是IP别名）之外的字符串\n​      ​ :chestnut: 例如 前面的 /uri-string 进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的                     配置也在这里进行。\n\n\nlocation 指令用于匹配 uri，语法：\nlocation [ &#x3D; | ~ | ~* | ^~] uri &#123;\n\t...\n&#125;\n\n指令后面：\n\n= 精确匹配路径，用于不含正则表达式的 uri 前，如果匹配成功，不再进行后续的查找；\n^~ 用于不含正则表达式的 uri； 前，表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找；\n~ 表示用该符号后面的正则去匹配路径，区分大小写；\n~* 表示用该符号后面的正则去匹配路径，不区分大小写。跟 ~ 优先级都比较低，如有多个location的正则能匹配的话，则使用正则表达式最长的那个；\n\n如果 uri 包含正则表达式，则必须要有 ~ 或 ~* 标志。\n10、典型配置#user  nobody;  # 运行用户，默认即是nginx，可以不进行设置\nworker_processes  1;  # Nginx 进程数，一般设置为和 CPU 核数一样\n\n#error_log  logs&#x2F;error.log;  # Nginx 的错误日志存放目录\n#error_log  logs&#x2F;error.log  notice;\n#error_log  logs&#x2F;error.log  info;\n\n#pid        logs&#x2F;nginx.pid;  # Nginx 服务启动时的 pid 存放位置\n\n\nevents &#123;\n    use epoll;     # 使用epoll的I&#x2F;O模型(如果你不知道Nginx该使用哪种轮询方法，会自动选择一个最适合你操作系统的)\n    worker_connections  1024;  # 每个进程允许最大并发数\n&#125;\n\n# 配置使用最频繁的部分，代理、缓存、日志定义等绝大多数功能和第三方模块的配置都在这里设置\nhttp &#123;\n    include       mime.types;  # 文件扩展名与类型映射表\n    default_type  application&#x2F;octet-stream;  # 默认文件类型\n\n\t# 设置日志模式\n    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;\n    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;\n    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;\n\n    #access_log  logs&#x2F;access.log  main;  # Nginx访问日志存放位置\n  \n    sendfile        on;   # 开启高效传输模式\n    #tcp_nopush     on;  # 减少网络报文段的数量\n\n    #keepalive_timeout  0;\n    keepalive_timeout  65; # 保持连接的时间，也叫超时时间，单位秒\n\n\t#gzip  on;\n\n    # 这是负载均衡的配置，让两个服务器进行轮循，可以设置轮询的具体效果\n    upstream myserver &#123;\n        server 192.168.96.66:8080;\n        server 192.168.96.66:8081;\n    &#125;\n\n    server &#123;\n        listen       80;\n        server_name  192.168.96.66;\n\n        #charset koi8-r;\n\n        #access_log  logs&#x2F;host.access.log  main;\n\n        location &#x2F; &#123;\n            root   html;\n            #proxy_pass http:&#x2F;&#x2F;192.168.96.66:8080;\n            proxy_pass http:&#x2F;&#x2F;myserver;\n            index  index.html index.htm;\n        &#125;\n\n        #error_page  404              &#x2F;404.html;\n\n        # redirect server error pages to the static page &#x2F;50x.html\n        #\n        error_page   500 502 503 504  &#x2F;50x.html;\n        location &#x3D; &#x2F;50x.html &#123;\n            root   html;\n        &#125;\n\n        # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n        #\n        #location ~ \\.php$ &#123;\n        #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;\n        #&#125;\n\n        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n        #\n        #location ~ \\.php$ &#123;\n        #    root           html;\n        #    fastcgi_pass   127.0.0.1:9000;\n        #    fastcgi_index  index.php;\n        #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;\n        #    include        fastcgi_params;\n        #&#125;\n\n        # deny access to .htaccess files, if Apache&#39;s document root\n        # concurs with nginx&#39;s one\n        #\n        #location ~ &#x2F;\\.ht &#123;\n        #    deny  all;\n        #&#125;\n    &#125;\n\n    # another virtual host using mix of IP-, name-, and port-based configuration\n    #\n    #server &#123;\n    #    listen       8000;\n    #    listen       somename:8080;\n    #    server_name  somename  alias  another.alias;\n\n    #    location &#x2F; &#123;\n    #        root   html;\n    #        index  index.html index.htm;\n    #    &#125;\n    #&#125;\n\n\n    # HTTPS server\n    #\n    #server &#123;\n    #    listen       443 ssl;\n    #    server_name  localhost;\n\n    #    ssl_certificate      cert.pem;\n    #    ssl_certificate_key  cert.key;\n\n    #    ssl_session_cache    shared:SSL:1m;\n    #    ssl_session_timeout  5m;\n\n    #    ssl_ciphers  HIGH:!aNULL:!MD5;\n    #    ssl_prefer_server_ciphers  on;\n\n    #    location &#x2F; &#123;\n    #        root   html;\n    #        index  index.html index.htm;\n    #    &#125;\n    #&#125;       \n&#125; \n\n\n\n11、反向代理实例一：实现效果，使用nginx反向代理，根据访问的路径跳转到不同端口的服务中\nnginx监听端口为9000，\n访问 http://127.0.0.1:9000/edu/ 直接跳转到127.0.0.1:8080\n访问 http://127.0.0.1:9000/vod/ 直接跳转到127.0.0.1:8081\n\n    \n    \n\n\n# 在 nginx.conf 中配置如下信息\n   server &#123; \n       listen 9000; \n       server_name 192.168.96.66; \n       location ~ &#x2F;edu&#x2F; &#123; \n               proxy_pass http:&#x2F;&#x2F;192.168.96.66:8080; \n               &#125; \n       location ~ &#x2F;vod&#x2F; &#123; \n               proxy_pass http:&#x2F;&#x2F;192.168.96.66:8081; \n               &#125; \n       &#125; \n\n\n\n12、负载均衡实现效果：浏览器地址栏输入地址 http://192.168.137.129/edu/a.html，负载均衡效果，将请求平均分配到8080和8081两台服务器上。\n\n准备两台tomcat服务器，一台8080，一台8081\n在两台tomcat里面webapps目录中，创建名称是edu文件夹，在edu文件夹中创建页面a.html(让a.html内容不一样，查看效果)，用于测试\n\n在配置文件中进行负载均衡配置：\nupstream称为上游服务器，即真实处理请求的业务服务器。\n# 这是负载均衡的配置，让两个服务器进行轮循\n    upstream myserver &#123;\n        server 192.168.96.66:8080;\n        server 192.168.96.66:8081;\n        # server 192.168.96.66:8081 weight&#x3D;10;  # weight 方式，不写默认为 1 ,1 表示一个服务器一次依次循环\n    &#125;\n\nserver &#123;\n\tlisten       80;\n\tserver_name  192.168.96.66;\n\t\n\tlocation &#x2F; &#123;\n\t\troot   html;\n\t\t# proxy_pass http:&#x2F;&#x2F;192.168.96.66:8080;\n\t\t# 使用上游服务器进行分配，给真正的业务服务器\n\t\tproxy_pass http:&#x2F;&#x2F;myserver;\n\t\tindex  index.html index.htm;\n&#125;\n\nNginx 提供了好几种分配方式，默认为轮询，就是轮流来。有以下几种分配方式：\n\n轮询，默认方式，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务挂了，能自动剔除；\n\nweight，权重分配，指定轮询几率，权重越高，在被访问的概率越大，用于后端服务器性能不均的情况；\n# weight代表权,重默认为1,权重越高被分配的客户端越多\n\n# 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如：\n\nupstream server_pool&#123;  \n\n\tserver 192.168.5.21 weight&#x3D;1;  \n\n\tserver 192.168.5.22 weight&#x3D;2; \n\n\tserver 192.168.5.23 weight&#x3D;3;  \n\n&#125;\n\n\n\nip_hash，每个请求按访问 IP 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决动态网页 session 共享问题。负载均衡每次请求都会重新定位到服务器集群中的某一个，那么已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的；\n# 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 例如：\n\nupstream server_pool&#123;  \n\n\tip_hash;   \n\n\tserver 192.168.5.21:80;  \n\n\tserver 192.168.5.22:80;  \n\n&#125;\n\n\n\nfair（第三方），按后端服务器的响应时间分配，响应时间短的优先分配，依赖第三方插件 nginx-upstream-fair，需要先安装；\n\n\n13、Nginx 动静分离动静分离在之前也介绍过了，就是把动态和静态的请求分开。方式主要有两种，一种 是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案。另外一种方法就是动态跟静态文件混合在一起发布， 通过 Nginx 配置来分开。\n通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用 expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个URL，发送一个请求，比对服务器该文件最后更新时间没有变化。则不会从服务器抓取，返回状态码 304，如果有修改，则直接从服务器重新下载，返回状态码 200。\n项目静态资源准备：在任意一个tomcat的webapps中，新建data/www/a.html   与    data/img/2.jpg\nnginx.conf 配置\nlocation &#x2F;img&#x2F; &#123;\n\troot &#x2F;data&#x2F;;\n\tautoindex on;\n&#125;\n\nlocation &#x2F;www&#x2F; &#123;\n\troot &#x2F;data&#x2F;;\n\tautoindex on;\n\tindex index.html index.htm;\n&#125;\n\n\n\n14、Nginx 原理与优化参数配置\n\n# master-workers的机制的好处\n\n首先，对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。\n\n其次，采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master进程则很快启动新的worker进程。\n\n当然，worker进程的异常退出，肯定是程序有bug了，异常退出，会导致当前worker上的所有请求失败，不过不会影响到所有请求，所以降低了风险。\n\n# 需要设置多少个worker\nNginx 同redis类似都采用了io多路复用机制，每个worker都是一个独立的进程，但每个进程里只有一个主线程，通过异步非阻塞的方式来处理请求， 即使是千上万个请求也不在话下。每个worker的线程可以把一个cpu的性能发挥到极致。\n所以worker数和服务器的cpu数相等是最为适宜的。设少了会浪费cpu，设多了会造成cpu频繁切换上下文带来的损耗。\n\n#设置worker数量\nworker_processes 4\n\n#work绑定cpu(4 work绑定4cpu)。\nworker_cpu_affinity 0001 0010 0100 1000\n\n#work绑定cpu (4 work绑定8cpu中的4个) 。\nworker_cpu_affinity 00000001 00000010 00000100 00001000  00010000  00100000 01000000  10000000\n\n#连接数\nworker_connections 1024\n\n这个值是表示每个worker进程所能建立连接的最大值，所以，一个nginx能建立的最大连接数，应该是worker_connections * worker_processes。当然，这里说的是最大连接数，对于HTTP请求本地资源来说，能够支持的最大并发数量是worker_connections * worker_processes，如果是支持http1.1的浏览器每次访问要占两个连接，所以普通的静态访问最大并发数是： worker_connections * worker_processes &#x2F;2，而如果是HTTP作为反向代理来说，最大并发数量应该是worker_connections * worker_processes&#x2F;4。\n因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。\n\n#面试题：\n第一个：发送请求，占用了woker的几个连接数？\n第二个：nginx有一个master，有四个woker，每个woker支持最大的连接数1024，支持的最大并发数是多少？\n\n\n\n14.1 nginx.conf 配置详解#安全问题，建议用nobody,不要用root.\n#user  nobody;\n \n#worker数和服务器的cpu数相等是最为适宜\nworker_processes  2;\n \n#work绑定cpu(4 work绑定4cpu)\nworker_cpu_affinity 0001 0010 0100 1000\n \n#work绑定cpu (4 work绑定8cpu中的4个) 。\nworker_cpu_affinity 0000001 00000010 00000100 00001000  \n \n#error_log path(存放路径) level(日志等级) path表示日志路径，level表示日志等级，\n#具体如下：[ debug | info | notice | warn | error | crit ]\n#从左至右，日志详细程度逐级递减，即debug最详细，crit最少，默认为crit。 \n \n#error_log  logs&#x2F;error.log;\n#error_log  logs&#x2F;error.log  notice;\n#error_log  logs&#x2F;error.log  info;\n#pid        logs&#x2F;nginx.pid;\n \nevents &#123;\n    #这个值是表示每个worker进程所能建立连接的最大值，所以，一个nginx能建立的最大连接数，应该是worker_connections * worker_processes。\n    #当然，这里说的是最大连接数，对于HTTP请求本地资源来说，能够支持的最大并发数量是worker_connections * worker_processes，\n    #如果是支持http1.1的浏览器每次访问要占两个连接，\n    #所以普通的静态访问最大并发数是： worker_connections * worker_processes &#x2F;2，\n    #而如果是HTTP作为反向代理来说，最大并发数量应该是worker_connections * worker_processes&#x2F;4。\n    #因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。\n \n    worker_connections  1024;  \n \n    #这个值是表示nginx要支持哪种多路io复用。\n    #一般的Linux选择epoll, 如果是(*BSD)系列的Linux使用kquene。\n    #windows版本的nginx不支持多路IO复用，这个值不用配。\n    use epoll;\n \n    # 当一个worker抢占到一个链接时，是否尽可能的让其获得更多的连接,默认是off 。\n    multi_accept on; &#x2F;&#x2F;并发量大时缓解客户端等待时间。\n    # 默认是on ,开启nginx的抢占锁机制。\n    accept_mutex  on; &#x2F;&#x2F;master指派worker抢占锁\n&#125;\nhttp &#123;\n    #当web服务器收到静态的资源文件请求时，依据请求文件的后缀名在服务器的MIME配置文件中找到对应的MIME Type，再根据MIME Type设置HTTP Response的Content-Type，然后浏览器根据Content-Type的值处理文件。\n \n    include       mime.types;  #&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;mime.types\n \n    #如果 不能从mime.types找到映射的话，用以下作为默认值-二进制\n    default_type  application&#x2F;octet-stream;\n \n     #日志位置\n     access_log  logs&#x2F;host.access.log  main;\n \n     #一条典型的accesslog：\n     #101.226.166.254 - - [21&#x2F;Oct&#x2F;2013:20:34:28 +0800] &quot;GET &#x2F;movie_cat.php?year&#x3D;2013 HTTP&#x2F;1.1&quot; 200 5209 &quot;http:&#x2F;&#x2F;www.baidu.com&quot; &quot;Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident&#x2F;4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; MDDR; .NET4.0C; .NET4.0E; .NET CLR 1.1.4322; Tablet PC 2.0); 360Spider&quot;\n \n     #1）101.226.166.254:(用户IP)\n     #2）[21&#x2F;Oct&#x2F;2013:20:34:28 +0800]：(访问时间) \n     #3）GET：http请求方式，有GET和POST两种\n     #4）&#x2F;movie_cat.php?year&#x3D;2013：当前访问的网页是动态网页，movie_cat.php即请求的后台接口，year&#x3D;2013为具体接口的参数\n     #5）200：服务状态，200表示正常，常见的还有，301永久重定向、4XX表示请求出错、5XX服务器内部错误\n     #6）5209：传送字节数为5209，单位为byte\n     #7）&quot;http:&#x2F;&#x2F;www.baidu.com&quot;：refer:即当前页面的上一个网页\n     #8）&quot;Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident&#x2F;4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; #.NET CLR 3.0.30729; Media Center PC 6.0; MDDR; .NET4.0C; .NET4.0E; .NET CLR 1.1.4322; Tablet PC 2.0); 360Spider&quot;： agent字段：通常用来记录操作系统、浏览器版本、浏览器内核等信息\n \n    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;\n                       &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;\n                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;\n \n    #开启从磁盘直接到网络的文件传输，适用于有大文件上传下载的情况，提高IO效率。\n    sendfile        on; &#x2F;&#x2F;大文件传递优化，提高效率\n   \n    #一个请求完成之后还要保持连接多久, 默认为0，表示完成请求后直接关闭连接。\n    #keepalive_timeout  0;\n    keepalive_timeout  65; \n \n    #开启或者关闭gzip模块\n    #gzip  on ; &#x2F;&#x2F;文件压缩，再传输，提高效率\n \n    #设置允许压缩的页面最小字节数，页面字节数从header头中的Content-Length中进行获取。\n    #gzip_min_lenth 1k;&#x2F;&#x2F;超过该大小开始压缩，否则不用压缩\n \n    # gzip压缩比，1 压缩比最小处理速度最快，9 压缩比最大但处理最慢（传输快但比较消耗cpu）\n    #gzip_comp_level 4;\n \n    #匹配MIME类型进行压缩，（无论是否指定）&quot;text&#x2F;html&quot;类型总是会被压缩的。\n    #gzip_types types text&#x2F;plain text&#x2F;css application&#x2F;json  application&#x2F;x-javascript text&#x2F;xml   \n \n    #动静分离\n    #服务器端静态资源缓存，最大缓存到内存中的文件，不活跃期限\n    open_file_cache max&#x3D;655350 inactive&#x3D;20s;   \n   \n    #活跃期限内最少使用的次数，否则视为不活跃。\n    open_file_cache_min_uses 2;\n \n    #验证缓存是否活跃的时间间隔 \n    open_file_cache_valid 30s;\n    \nupstream  myserver&#123;\n    # 1、轮询（默认）\n    # 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\n    # 2、指定权重\n    # 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\n    #3、IP绑定 ip_hash\n    # 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\n    #4、备机方式 backup\n    # 正常情况不访问设定为backup的备机，只有当所有非备机全都宕机的情况下，服务才会进备机。当非备机启动后，自动切换到非备机\n# ip_hash;\nserver 192.168.161.132:8080 weight&#x3D;1;\nserver 192.168.161.132:8081 weight&#x3D;1 backup;\n    #5、fair（第三方）公平，需要安装插件才能用\n    #按后端服务器的响应时间来分配请求，响应时间短的优先分配。   \n    #6、url_hash（第三方）\n    #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。\n \n      # ip_hash;\n             server 192.168.161.132:8080 weight&#x3D;1;\n             server 192.168.161.132:8081 weight&#x3D;1;\n      \n      #fair\n \n      #hash $request_uri\n      #hash_method crc32\n      \n&#125;\n \n    server &#123;\n        #监听端口号\n        listen       80;\n \n        #服务名\n        server_name  192.168.161.130;\n \n        #字符集\n        #charset utf-8;\n \n#location [&#x3D;|~|~*|^~] &#x2F;uri&#x2F; &#123; … &#125;   \n# &#x3D; 精确匹配\n# ~ 正则匹配，区分大小写\n# ~* 正则匹配，不区分大小写\n# ^~  关闭正则匹配\n \n#匹配原则：\n \n# 1、所有匹配分两个阶段，第一个叫普通匹配，第二个叫正则匹配。\n# 2、普通匹配，首先通过“&#x3D;”来匹配完全精确的location\n        #   2.1、 如果没有精确匹配到， 那么按照最大前缀匹配的原则，来匹配location\n        #   2.2、 如果匹配到的location有^~,则以此location为匹配最终结果，如果没有那么会把匹配的结果暂存，继续进行正则匹配。\n        # 3、正则匹配，依次从上到下匹配前缀是~或~*的location, 一旦匹配成功一次，则立刻以此location为准，不再向下继续进行正则匹配。\n        # 4、如果正则匹配都不成功，则继续使用之前暂存的普通匹配成功的location.\n          #不是以波浪线开头的都是普通匹配。\n        location &#x2F; &#123;   # 匹配任何查询，因为所有请求都以 &#x2F; 开头。但是正则表达式规则和长的块规则将被优先和查询匹配。\n   \n    #定义服务器的默认网站根目录位置\n            root   html;&#x2F;&#x2F;相对路径，省略了.&#x2F;         &#x2F;user&#x2F;local&#x2F;nginx&#x2F;html  路径\n            \n    #默认访问首页索引文件的名称\n    index  index.html index.htm;\n \n    #反向代理路径\n            proxy_pass http:&#x2F;&#x2F;myserver;\n \n    #反向代理的超时时间\n            proxy_connect_timeout 10;\n \n            proxy_redirect default;\n         &#125;\n          #普通匹配\nlocation  &#x2F;images&#x2F; &#123;    \n    root images ;\n &#125;\n           # 反正则匹配\nlocation ^~ &#x2F;images&#x2F;jpg&#x2F; &#123;  # 匹配任何以 &#x2F;images&#x2F;jpg&#x2F; 开头的任何查询并且停止搜索。任何正则表达式将不会被测试。 \n    root images&#x2F;jpg&#x2F; ;\n&#125;\n#正则匹配\nlocation ~*.(gif|jpg|jpeg)$ &#123;       \n      #所有静态文件直接读取硬盘\n              root pic ;\n      \n      #expires定义用户浏览器缓存的时间为3天，如果静态页面不常更新，可以设置更长，这样可以节省带宽和缓解服务器的压力\n              expires 3d; #缓存3天\n         &#125;\n \n        #error_page  404              &#x2F;404.html;\n \n        # redirect server error pages to the static page &#x2F;50x.html\n        #\n        error_page   500 502 503 504  &#x2F;50x.html;\n        location &#x3D; &#x2F;50x.html &#123;\n            root   html;\n        &#125; \n    &#125;\n&#125;\n\n\n\n15、常用技巧1、静态服务\nserver &#123;\n  listen       80;\n  server_name  static.sherlocked93.club;\n  charset utf-8;    # 防止中文文件名乱码\n\n  location &#x2F;download &#123;\n    alias\t          &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;static;  # 静态资源目录\n    \n    autoindex               on;    # 开启静态资源列目录\n    autoindex_exact_size    off;   # on(默认)显示文件的确切大小，单位是byte；off显示文件大概大小，单位KB、MB、GB\n    autoindex_localtime     off;   # off(默认)时显示的文件时间为GMT时间；on显示的文件时间为服务器时间\n  &#125;\n&#125;\n\n2、图片防盗链\n最好将百度和 google 设置为白名单，利于 SEO\nserver &#123;\n  listen       80;        \n  server_name  *.sherlocked93.club;\n  \n  # 图片防盗链\n  location ~* \\.(gif|jpg|jpeg|png|bmp|swf)$ &#123;\n    valid_referers none blocked server_names ~\\.google\\. ~\\.baidu\\. *.qq.com;  # 只允许本机 IP 外链引用，将百度和谷歌也加入白名单\n    if ($invalid_referer)&#123;\n      return 403;\n    &#125;\n  &#125;\n&#125;\n\n3、请求过滤\n# 非指定请求全返回 403\nif ( $request_method !~ ^(GET|POST|HEAD)$ ) &#123;\n  return 403;\n&#125;\n\nlocation &#x2F; &#123;\n  # IP访问限制（只允许IP是 192.168.0.2 机器访问）\n  allow 192.168.0.2;\n  deny all;\n  \n  root   html;\n  index  index.html index.htm;\n&#125;\n\n4、配置图片字体等静态资源缓存\n由于图片、字体、音频、视频等静态文件在打包的时候通常会增加了 hash，所以缓存可以设置的长一点，先设置强制缓存，再设置协商缓存；如果存在没有 hash 值的静态文件，建议不设置强制缓存，仅通过协商缓存判断是否需要使用缓存。\n# 图片缓存时间设置\nlocation ~ .*\\.(css|js|jpg|png|gif|swf|woff|woff2|eot|svg|ttf|otf|mp3|m4a|aac|txt)$ &#123;\n\texpires 10d;\n&#125;\n\n# 如果不希望缓存\nexpires -1;\n\n5、HTTP 请求转发到 HTTPS\n配置完 HTTPS 后，浏览器还是可以访问 HTTP 的地址 http://sherlocked93.club/ 的，可以做一个 301 跳转，把对应域名的 HTTP 请求重定向到 HTTPS 上\nserver &#123;\n    listen      80;\n    server_name www.sherlocked93.club;\n\n    # 单域名重定向\n    if ($host &#x3D; &#39;www.sherlocked93.club&#39;)&#123;\n        return 301 https:&#x2F;&#x2F;www.sherlocked93.club$request_uri;\n    &#125;\n    # 全局非 https 协议时重定向\n    if ($scheme !&#x3D; &#39;https&#39;) &#123;\n        return 301 https:&#x2F;&#x2F;$server_name$request_uri;\n    &#125;\n\n    # 或者全部重定向\n    return 301 https:&#x2F;&#x2F;$server_name$request_uri;\n\n    # 以上配置选择自己需要的即可，不用全部加\n&#125;\n\n\n\n16、总结\n为了使 Nginx 配置更易于维护，建议为每个服务创建一个单独的配置文件，存储在 /etc/nginx/conf.d 目录，根据需求可以创建任意多个独立的配置文件。\n\n独立的配置文件，建议遵循以下命名约定 &lt;服务&gt;.conf，比如域名是 sherlocked93.club，那么你的配置文件的应该是这样的 /etc/nginx/conf.d/sherlocked93.club.conf，如果部署多个服务，也可以在文件名中加上 Nginx 转发的端口号，比如 sherlocked93.club.8080.conf，如果是二级域名，建议也都加上 fe.sherlocked93.club.conf。\n\n常用的、复用频率比较高的配置可以放到 /etc/nginx/snippets 文件夹，在 Nginx 的配置文件中需要用到的位置 include 进去，以功能来命名，并在每个 snippet 配置文件的开头注释标明主要功能和引入位置，方便管理。比如之前的 gzip、cors 等常用配置，我都设置了 snippet。\n\nNginx 日志相关目录，内以 域名.type.log 命名（比如 be.sherlocked93.club.access.log 和 be.sherlocked93.club.error.log ）位于 /var/log/nginx/ 目录中，为每个独立的服务配置不同的访问权限和错误日志文件，这样查找错误时，会更加方便快捷。\n\n\n","slug":"64-Nginx","date":"2021-09-13T15:40:32.000Z","categories_index":"Nginx","tags_index":"Nginx","author_index":"大黄"},{"id":"f2c49803fec94cd24a1c1407e5e84879","title":"SVN","content":"1. SVN是什么SVN的全称是subVersion，Svn版本控制软件可以解决协助开发，远程开发，和版本回退三个问题。\n特点：操作简单，入门简单，跨平台操作。\nSVN是输入 C/S服务类软件，有客户端和服务端。\n2. SVN服务端\n\n\n重要\n\n\n\n创建服务器项目仓库，复制仓库地址，在本机仓库checkOut（注意地址栏的地址）\n\n\n1. 安装visualSVNserver服务器\n\n2. 看透说不透，打开VisualSVN Server操作面板\n\n3. 点击仓库，右键create new respository，根据提示创建项目\n\n4. 创建完成的最后一步会生成一个服务器项目地址，在网站打开，进入项目点击checkout复制地址\n\n5. 在我们的本机仓库右键checkout，弹出的窗口自动填充了项目库地址和checkout目录，点击确定\n\n6. 若成功，在本机仓库中 出现服务器创建的项目库，文件夹上会有一个绿色对勾，并且文件夹中出现 .svn文件夹\n\n7. &lt;!--注意：可以直接使用网页上的服务器(如SVNBucket)，这样大大方便了我们的操作--&gt;\n\n3. SVN客户端\n\n\n重要\n\n\n\n从服务器复制项目库地址，在本机仓库进行checkout（检出）\n\n\n1. 安装TortoiseSVN客户端（记得下载汉化包）\n\n2. 安装完成后，在安装目录中创建工作空间\n\n3. 配置完成后，进行第一次牵手（checkout 检出）\n\n4. 检出后，若在工作空间看到检出的服务器项目库，且库中有 .svn文件，则证明成功\n\n4. SVN三大指令\n\n\n重要\n\n\n\ncheckout、update、commit（提交前update是一个好习惯）\n\n\n1. 检出指令（svn checkout）\n   1. 连接到SVN服务器端\n   2. 更新服务器数据到本地\n   3. 注意：checkout 只在第一次连接服务器时操作，后续的项目更新用SVN Update\n   \n2. 提交指令（svn commit）\n   1. 提交本地数据到服务端\n   2. 提交时会显示提交界面，空白部分为备注信息（必填）\n   3. 提交界面的变更列表中，一定要选上准备提交的数据\n   \n3. 更新指令（svn update）\n   1. 在相应项目库中，点击更新按钮即可\n\n5. SVN图表集与忽略操作\nSvn的忽略功能\n意思是解除版本控制，将文件放到一个虚拟的忽略列表中，这样在提交文件的时候，变更列表中不再显示已被忽略的文件\n6. 版本回退\n\n\n注意\n\n\n\n请确定你是要 复原到其他版本，还是要复原这个版本做出的修改\n\n\n如果修改了文件后发现错误，想要返回到上一个版本，或者是其他版本，则需要版本回退操作\n\n操作方法：\n\n\t1. 在对应的仓库中，右键 --&gt; 显示日志\n\t\n\t2. 在日志中，单击需要的版本 --&gt; 右键选择  复原此版本 &#x2F;\n\t\n\t3. 或则，点击你提交的版本，复原此版本做出的修改（也可以）\n\t\n\t4. 最后在仓库中，更新提交\n\n7. 版本冲突同时检出了一个版本的文件，一个人提交后，另外一个人在没有更新的情况下就进行提交，会造成版本冲突。\n\n&lt;!--解决之道--&gt;：\n\n1. 合理分配项目开发时间\n\n2. 合理分配项目开发模块\n\n3. 通过 svn解决版本冲突\n\n   * 提交前，先更新服务器端的最新数据到本地\n\n   * 会出现整合后的文件，以及其他几个文件（checkout时的文件，别人修改后的文件及文件版本\n     若还有其他冲突，右键修改冲突，出现一个界面\n     界面具有远程文件，我的文件，以及冲突框\n     在冲突框中的冲突行，右键选择用我的还是他人的即可\n\n   * 删除整合以外的文件，修改整合后的冲突文件\n\n   * 重新提交数据到服务端\n\n8. 分支trunk文件夹: 主干，我们一般把项目提交到此文件夹里面,在trunk中开发。\nbranches文件夹：分支，我们一般把那些需要打分支,但是有可能会修改的项目代码，打分支到此目录。\ntags文件夹：分支，我们一般把那些阶段性(如迭代各期)的项目代码,打分支到此目录。\n注：需要时,我们可以从SVN上同步分支中的任意时期的项目代码(注：我们当然也可以同步trunk主干下的最新的代码)。\n注：我们也可以直接检出  分支目录，这样每次提交或修改，就不会全部文件都要来一遍，使任务变得更加轻松\n​       例如，branches中存储的为 程序的分支——线上版本，那这个版本呢就只做一些线上问题的修复\n","slug":"63-Svn","date":"2021-09-13T15:39:32.000Z","categories_index":"Project Manager","tags_index":"Project Manager","author_index":"大黄"},{"id":"221a7ad001c03569112f684b2dfdc120","title":"Git","content":"1、版本控制\n1.1、什么是版本控制版本控制  (Revision control)：是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。\n①  本地版本控制系统：RCS\n记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。\n②  集中化的版本控制系统：CVS、SVN(Subversion)、VSS……\n优点：所有版本数据都保存在中央服务器上，协同开发者都通过客户端连接服务器，检出最新的文件或提交更新\n缺点：显而易见的缺点是中央服务器的单点故障，容错性差。 \n​            如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 \n​            如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问您将丢失所有数据\n③  分布式版本控制系统：  Git、Mercurial、Bazaar、Darcs……\n优点：客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 \n​            若任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。     \n​            因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份\n缺点：每个人都拥有全部的代码！安全隐患！可能带着代码投靠敌人\n\n    \n    \n    \n    \n\n\n\n\n1.2、版本控制的好处:o: 协同开发：团队协作共同完成同一个项目\n:o: 版本管理：包括版本的记录和还原，以不断提升项目版本的方式逐步完成项目，跟踪记录整个软件的开发过程\n:o: 数据备份：开发中以版本控制的形式保存每一个历史版本\n:o: 分支管理：允许团队在工作过程中多条线同时推进任务，提高效率（并行开发、提高开发效率）\n:o: 权限管理：对团队开发人员进行不同的权限分配\n:o: 代码审查：统计工作量，减轻开发人员的负担，节省时间，同时降低人为错误\n:o: 冲突解决：开发过程中，一个团队中若编写代码进行合并时，有冲突，方便解决冲突\n1.3、Git 和 Svn的区别:o: SVN\n\nSVN是集中式版本控制系统，版本库是集中放在中央服务器的。\n\n而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，\n\n完成工作后，需要把自己做完的活推送到中央服务器。\n\n集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。\n\n\n:o: Git\n\nGit是分布式版本控制系统，没有中央服务器，每个人的电脑就是完整的版本库，工作的时候不需要联网，版本都在自己电脑上。\n协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！\n&lt;最先进&gt;Git是目前世界上最先进的分布式版本控制系统。&lt;/最先进&gt;\n\n2、初识Git\n2.1、Git工作机制\n    \n    \n\n\n\n\n2.2、代码托管中心代码托管中心负责维护远程库\n:o: 局域网\n​      Gitlab\n:o: Internet\n​      GitHub\n​      码云(gitee)\n2.3、Git简述Git是分布式版本控制系统（Distributed Version Control System，简称 DVCS）\n:o: 仓库\n\n本地仓库：是在开发人员自己电脑上的Git仓库 \n\n远程仓库：是在远程服务器上的Git仓库\n​                    团队内协作\n​                    跨团队协作\n\n\n:o: 操作\n\nclone：克隆，就是将远程仓库复制到本地\npush：推送，就是将本地仓库代码上传到远程仓库\npull：拉取，就是将远程仓库代码下载到本地仓库\nCommit：提交，就是将本地工作区代码上传到本地仓库中\n\n:o: 优点\n\n容灾能力强\n本地版本管理\n异地协作、\n灵活分支\n\n3、安装Git，简单理解\n3.1、命令行工具：Git for windows下载地址：Git-2.23.0-64-bit.exe\nhttps://git-for-windows.github.io/ \nhttps://git-scm.com/download\n具体安装过程，百度即可\n安装完成之后\n\n在开始菜单栏中的 Git文件下有三个选项\nGit Bash：Unix与Linux风格的命令行，使用最多，推荐最多\nGit CMD：Windows风格的命令行\nGit GUI：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令\n\n3.2、可视化工具：TortoiseGit(了解)下载地址： https://tortoisegit.org/\n TortoiseGit 2.8.0-64-bit\n3.3、GitHub Gitee网站http://www.github.com\nhttps://gitee.com/\n3.4、安装完成：设置全局签名安装完成后，在任意的文件目录下，右键都可以开打Git的命令行窗口——Git Bash Here\nGit是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识——即：用户签名\n:o: 说明\n​    签名的作用是区分不同操作者身份。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。\n​    注意：这里设置用户签名和将来登录GitHub（或其他代码托管中心）的账号没有任何关系。\n:o: 命令：\ngit config --global user.name &quot;用户名&quot;\n\ngit config --global user.email &quot;用户邮箱&quot;\n\n查看不同等级的配置文件\ngit config -l  查看git的所有配置\ngit config --system -l 或  --list  查看系统\ngit config --global -l  或  --list 查看当前用户  \n\n–global 表示全局属性，所有的git项目都会共用属性\n在当前登录的系统用户路径下，生成~/.gitconfig隐含文件，里面可以看到设置的信息。若不用命令设置，也可以打开文件进行设置。\n4、工作区、版本库、暂存区\n4.1、基本概念\n工作区(Working Directory)：就是你电脑本地硬盘目录，一般是项目当前目录\n版本库(Repository)：工作区有个隐藏目录.git，它就是Git的本地版本库\n暂存区(stage)：一般存放在”git目录”下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）\n分支(Branch)：Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD\n\n \n4.2、提交Git版本库分两步执行\n第一步：用“git add”把文件纳入Git管理，实际是把本地文件修改添加到暂存区\n第二步：用“git commit”提交更改，实际上就是把暂存区的所有内容提交到当前分支 \n\n因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以commit就是往master分支上提交更改。\n可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。一旦提交完后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的。即：nothing to commit (working directory clean)。\n5、Git本地库实战\n5.1、本地库常用命令\n\n\n命令名称\n命令作用\n\n\n\ngit init\n初始化本地库\n\n\ngit config –global user.name 用户名\n设置用户签名的用户名部分\n\n\ngit config –global user.email 邮箱\n设置用户签名的邮箱部分\n\n\ngit status\n查看本地库状态\n\n\ngit add 文件名\n添加到暂存区\n\n\ngit commit -m “日志信息” 文件名\n提交到本地库\n\n\ngit reflog\n查看历史记录\n\n\ngit reset –hard 版本号\n版本穿梭\n\n\n5.2、实战 (初始化版本库)要使用Git对我们的代码进行版本控制，首先需要获得Git仓库，获取Git仓库通常有两种方式：\n\n在本地初始化一个Git仓库\n从远程仓库克隆\n\n本地初始化操作步骤：\n\n创建目录（用作本地版本库），例如：D:\\DevRepository\\GITRepository\\oa，oa表示办公自动化项目名称\n当前目录打开Git Bash窗口，初始化仓库\n\n命令：git init\n\n查看当前目录产生.git隐藏文件夹\n注意：当前的 .git 是一个隐藏文件夹，需要在电脑上面设置隐藏文件夹显示设置，否则，看不到这个.git目录\n\n5.3、实战 (新建\\提交\\状态):o: 新建文件\n\n命令：touch a.txt\n命令：vim a.txt\n\n:o: 查看文件状态命令：git status\n\nOn branch master ：表示主分支\n\nUntracked files：表示未跟踪状态\n\n\n:o: 使用 git status –s 使输出信息更加简洁\n\n?? : 表示未跟踪状态\n\n:o: Git工作目录下的文件状态信息\n\nUntracked 未跟踪（未被纳入版本控制）\n文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过 git add . 状态变为Staged\n\n\nTracked 已跟踪（被纳入版本控制）\nUnmodified 未修改状态\n文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处,如果它被修改, 而变为Modified. 如果使用 git rm 移出版本库, 则成为Untracked文件\n\n\nModified 已修改状态\n文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过 git add .可进入暂存staged状态,使用 git checkout 则丢弃修改过, 返回到unmodify状态.这个git checkout即从库中取出文件, 覆盖当前修改\n\n\nStaged 已暂存状态\n执行 git commit 则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态.执行 git reset HEAD filename取消暂存, 文件状态为Modified\n\n\n\n:o: 这些文件的状态会随着我们执行Git的命令发生变化\n\n红色表示新建文件或者新修改的文件,都在工作区. \n绿色表示文件在暂存区 \n\n新建的文件在工作区，需要添加到暂存区并提交到仓库区\n:o: 添加到暂存区命令：git add &lt;文件名称&gt;\n只是增加到栈空间（index文件）中，还没有添加到本地库中。初始化时没有这个index文件。这还是一个新文件，需要将栈空间文件提交到本地仓库。\n添加项目中所有文件：git add .\n添加未存在文件会出错：fatal: pathspec ‘hello.txt’ did not match any files\n:o: 撤销暂存区的文件命令：git  reset  &lt;文件名称&gt;\n撤销后，查看文件状态（git status）文件由绿色变为红色\n:o: 将暂存区文件提交到本地库  命令：git  commit\n执行命令时需要填写提交日志，进入编辑模式\ngit  commit  –m “注释内容”   \n直接用-m参数指定日志内容，推荐\ncommit 会生成一条版本记录，add只是添加暂存区，不会生成版本记录，建议多次add后，一次性commit，避免每次add都commit产生版本信息爆炸。\ngit commit -am “注释内容”\n代码编辑完成后即可进行 add 和 commit 操作\n提示：添加和提交合并命令\n编辑保存再提交，反复练习多次，修改提交3次(为接下来实验做准备)\n5.4、实战(查看日志)\n查看文件日志(查看所有日志或某个文件日志)命令：git log\nq退出\n\n如果日志很多,可以在一行显示：git log –pretty=oneline\n\n查看历史操作：git reflog\n\n\n5.5、实战(回退\\穿梭\\撤销)\n回退到历史版本命令\n一次回退一个版本，一个^代表一个版本数量：git reset –hard HEAD^\n回退n次操作：git  reset  –hard HEAD~n\n\n版本穿梭命令\n查看历史操作：git reflog a.txt\n回到最新的版本：git reset –hard 版本号\n\n撤销\n\n未add，未commit\n\nvim修改文件，没有add和commit，进行撤销\n撤销修改(还原原来的文件)：git checkout – a.txt\n\n\n已add，未commit\n\nvim修改文件，添加add，但没提交commit，进行撤销\n\n命令：git add a.txt\n​            git reset\n\n\n​                   软回退\n​                   查看文件内容：cat a.txt\n\n\n​                          查看日志：git reflog a.txt\n\n\n5.6、实战(删除)① 手动拷贝图片java.jpg到工作空间目录，并查看目录列表：ls -l\n② 添加：git add java.jpg\n③ 提交：git commit -m “新建图片” java.jpg\n④ 删除图片：rm java.jpg\n⑤ 添加：git add java.jpg\n⑥ 提交：git commit -m “新建图片” java.jpg\n⑦ 回退：git reset –hard HEAD^\n⑧ 文件不是被删除了吗？怎么又回来啦！呵呵…\n⑨ 处处留痕：git reflog\n5.7、实战(分支)几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。Git 的master分支并不是一个特殊分支。 它跟其它分支没有区别。 之所以几乎每一个仓库都有 master 分支，是因为git init 命令默认创建它，并且大多数人都懒得去改动它。\n:o: 开发流程，分支概念分支：在使用版本控制工具开发的过程中，同时推进多个任务\n\n    \n    \n\n\n:o: 分支好处同时并行推进多个功能开发，提高开发效率\n各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。 \n:o: 分支操作\n\n\n命令名称\n作用\n\n\n\ngit branch 分支名\n创建分支\n\n\ngit branch -v\n查看分支\n\n\ngit checkout 分支名\n切换分支\n\n\ngit merge 分支名\n把指定的分支合并到当前分支上\n\n\n:o: 创建分支和切换分支图解 \nmaster、hotfix其实都是指向具体版本记录的指针。当前所在的分支，其实是由HEAD决定的。\nHEAD如果指向master，那么我们现在就在master分支上。\nHEAD如果指向hotfix，那么我们现在就在hotfix分支上。\n所以切换分支的本质就是移动HEAD指针。\n:o: 合并分支合并分支时一定是涉及到两个分支。这两个分支一个是“当前所在分支”，一个是“目标分支”。\n命令写法：git merge 目标分支\n\n所以分支合并命令的本质就是把“目标分支”合并到“当前分支”。\n\n例如：把hotfix合并到master\n\ngit merge hotfx\n需要确保当前所在的分支是master\n\n例如：把master合并到hotfix\n\ngit merge master\n需要确保当前所在的分支是hotfix\n\n5.8、实战(版本冲突)Git使用“&lt;&lt;&lt;&lt;&lt;&lt;&lt;、&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;、&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;”符号帮我们标记出来，现在产生冲突的内容。\n\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nHello Git!I am very happy! &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;\nHello Git!I am very happy!\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n表示HEAD指针指向的位置在冲突中的内容\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nHello Git!I am very happy!\nHello Git!I am very happy! ************\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; hotfix\n表示hotfix指针指向的位置在冲突中的内容\n\n:o: 冲突产生的原因合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。Git无法替我们决定使用哪一个。必须人为决定新代码内容。\n:o: 冲突的解决① 编辑有冲突的文件，删除特殊符号，决定要使用的内容\n \n② 添加到暂存区\n \n③ 执行提交（注意：使用git commit命令时不能带文件名）\n \n:o: 避免冲突\n容易冲突的操作方式\n多个人同时操作了同一个文件\n一个人一直写不提交\n修改之前不更新最新代码\n提交之前不更新最新代码\n擅自修改同事代码\n\n减少冲突的操作方式\n养成良好的操作习惯，先pull在修改,修改完立即commit和push\n一定要确保自己正在修改的文件是最新版本的\n各自开发各自的模块\n如果要修改公共文件，一定要先确认有没有人正在修改\n下班前一定要提交代码,上班第一件事拉取最新代码\n一定不要擅自修改同事的代码\n\n\n6、Git远程库实战\n6.1、Git代码托管服务前面我们已经知道了Git中存在两种类型的仓库，即****本地仓库*和*远程仓库****。那么我们如何搭建Git远程仓库呢？我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有GitHub、码云、GitLab等。\n\ngitHub（ 地址：https://github.com/ ）\n是一个面向开源及私有软件项目的托管平台，因为只支持Git 作为唯一的版本库格式进行托管，故名gitHub\n\n码云（地址： https://gitee.com/ ）\n是国内的一个代码托管平台，由于服务器在国内，所以相比于GitHub，码云速度会更快\n\nGitLab （地址： https://about.gitlab.com/ ）\n是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务\n\n\n6.2、团队内协作 - 过程及命令一共9个步骤：我们完全按照9个步骤的流程来进行练习。做到熟练掌握。\n\n\n\n\n要点\n\n\n\n本地仓库关联远端仓库，git  commit -m /  git  push的使用\n\n\n命令大全：https://www.cnblogs.com/wf-linux/p/11009396.html\n\n\n* 在本机创建一个库（出现 .git文件夹）：git\tinit\n\n  从远端克隆一个库： git  clone  仓库地址\n\n* 创建文件：touch 文件名\n\n* 查看文件的状态（4种）：git  status\n\n* 将工作空间中的所有文件提交到暂存区：git  add  .\n\n* 将暂存区的文件提交到版本库：git  commit  -m [commit message]\n\n* 本地创建的库关联远端仓库：git remote add origin 仓库地址\n\n* 将本地文件提交到远端：git  push\n\n* 更新Git，输入git update-git-for-windows\n\n\n\n7、Git 忽略文件及SSH与码云连接\n7.1、创建忽略规则文件（git.ignore）这个文件的存放位置原则上在哪里都可以，为了便于让~/.gitconfig文件引用，建议也放在用户家目录下\n有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等\n\n在主目录下建立 &quot;.gitignore&quot; 文件，此文件有如下规则：\n\n1. 忽略文件中的空行或以井号（#）开始的行将会被忽略。\n\n2. 可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（&#123;string1,string2,...&#125;）代表可    选的字符串等。\n\n3. 如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。\n\n4. 如果名称的最前面是一个路径分隔符（&#x2F;），表示要忽略的文件在此目录下，而子目录中的文件不忽略。\n\n5. 如果名称的最后面是一个路径分隔符（&#x2F;），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。\n\n例子：\n\n    fd1&#x2F;* ：说明：忽略目录 fd1 下的全部内容，不管是根目录下的 &#x2F;fd1&#x2F; 目录，还是某个子目录 &#x2F;child&#x2F;fd1&#x2F; 目录，都会被忽略；\n\n    &#x2F;fd1&#x2F;* ：说明：忽略根目录下的 &#x2F;fd1&#x2F; 目录的全部内容；\n    \n    &#x2F;*    !.gitignore\n    说明：忽略全部内容，但是不忽略 .gitignore 文件；\n\n忽略文件\n# Compiled class file\n*.class\n \n# Log file\n*.log\n \n# BlueJ files\n*.ctxt\n \n# Mobile Tools for Java (J2ME)\n.mtj.tmp&#x2F;\n \n# Package Files #\n*.jar\n*.war\n*.nar\n*.ear\n*.zip\n*.tar.gz\n*.rar\n \n# virtual machine crash logs, see http:&#x2F;&#x2F;www.java.com&#x2F;en&#x2F;download&#x2F;help&#x2F;error_hotspot.xml\nhs_err_pid*\n \n.classpath\n.project\n.settings\ntarget\n.idea\n*.iml\n\n\n\n7.2、在.gitconfig中引用忽略文件[user]\nname &#x3D; peter\nemail &#x3D; peter@atguigu.com\n[core]\nexcludesfile &#x3D; C:&#x2F;Users&#x2F;Lenovo&#x2F;git.ignore\n\n注意：这里要使用“正斜线（/）”，不要使用“反斜线（\\）”\n7.3、SSH公钥实现与码云连接用户名邮箱和ssh公钥 必须配置，用户名邮箱代表你本机的信息，ssh公钥实现与码云连接，免密码登录\n设置本机绑定SSH公钥，实现免密码登录！\n\n   生成本机ssh公钥：ssh-keygen -t rsa -C “你的邮箱&quot;\n\n   查看生成的公钥：cat ~&#x2F;.ssh&#x2F;id_rsa.pub\n\n   公钥所在目录：C:\\Users\\Lenovo \\ .ssh \\ id_rsa.pub\n\n   最后将将公钥信息public key 添加到码云账户中即可！\n\n\n\n8、Git在 IDEA中的使用\n\n\n注意\n\n\n\n这里直接引用了一篇非常好的博客：https://www.cnblogs.com/Lyn4ever/p/10994093.html  外盘中有备份\n\n\n","slug":"62-Git","date":"2021-09-13T15:39:32.000Z","categories_index":"Project Manager","tags_index":"Project Manager","author_index":"大黄"},{"id":"a35ab763af39963a3c8e8b221affe22c","title":"Spring项目（1）","content":":one: spring整合mybatis时如果只使用&lt;mybatis:scan base-package=&quot;&quot;/&gt;时，mapper（dao）接口的 路径名 及 接口名 都要（必须）与mapper映射文件的 路径名 及 接口名 一样\n如果在整合的bean中（即org.mybatis.spring.SqlSessionFactoryBean中）使用了&lt;property name=&quot;mapperLocations&quot; value=&quot;mappers&quot;/&gt;无论下面使用的是&lt;mybatis:scan base-package=&quot;&quot;/&gt;，还是\n&lt;bean id&#x3D;&quot;mapperScannerConfigurer&quot; class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;\n    &lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;com.atguigu.mapper&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n路径名和接口名可以一样也可以不一样\n:two: scope.row传递给new的vue中时，row中包含了基本上所有的元素，即使没有显示id，也包含的有id\n:three: 常识性逻辑添加信息或者修改信息后，要将添加页面或者修改页面隐藏\n无论是否添加成功，我们都应该将页面中的数据重置为空（这个根据具体业务需求，登录时就可以有回显）\n无论添加，修改，删除，成功后我们都应该刷新数据\n无论是传递给前端还是发送给后端的数据，我们可以使用工具类对其进行归类，这样我们在返回数据的时候，能够做到统一\n我们在添加和修改时，肯定都是要在数据规则验证通过后进行，\nthis.$refs[&quot;dataEditForm&quot;].validate((valid) &#x3D;&gt; &#123;\n    if (valid) &#123;\n\n    &#125;else&#123;\n\n&#125;\n\n:four: 使用动态sql判断传入值要么使用value代替，要么使用@param进行别名设置\n==想清楚每一步，不要盲目的去写，对待键值对应这种的时候，一定要仔细，不要前后不一，前面写的，后面用的时候就变成了另外一种==\n==需要去了解的技术，elementUI，七牛云的上传下载==\n:five: 分页分页时，我们一般需要三个数据，当前页，每页显示条数，查询条件\n\n当前页：在前端可以直接获取\n\n每页显示条数：看情况，我们可以在前端进行设置，我们也可以在其他地方进行设置\n\n查询条件：不使用条件查询时，默认为空，就不在进行条件匹配，这里使用的技术是，动态sql \n&lt;select id&#x3D;&quot;findPage&quot; resultType&#x3D;&quot;setmeal&quot;&gt;\n    select * from t_setmeal\n    &lt;where&gt;\n        &lt;if test&#x3D;&quot;queryString!&#x3D;null and queryString.length&gt;0&quot;&gt;\n            code&#x3D;#&#123;queryString&#125; or name like concat(&#39;%&#39;,#&#123;queryString&#125;,&#39;%&#39;)\n        &lt;&#x2F;if&gt;\n    &lt;&#x2F;where&gt;\n&lt;&#x2F;select&gt;\n\n后端进行返回时\n\n从数据库获取到的数据，使用 Page&lt;E&gt; extends ArrayList&lt;E&gt; (Page)进行接收，泛型是返回数据的具体类型\nservice实现类中，将接收到的数据进一步解析分装，使用我们的工具类 PageResult 进行接收\n两个参数，total – 总行数，rows – 查询到的当前页的数据集合\n\n\ncontroller控制器中，直接将得到的PageResult进行返回\n在前端页面上的axios的then()中，进行数据挂载，因为数据是双向绑定的，是异步的，所以挂载后页面可以直接显示\n\n:six: 自由行的添加，修改，删除\n添加\n在弹出窗口前，我们应该重置弹出的表单，因为用户添加数据时，看到的表单应该为空，this.formData=&#123;&#125;;\n弹出添加窗口，使用的elementUI中的设置，在vue的data中维护了一个弹出开关 this.dialogFormVisible=false\ntrue为开，false为关 \n\n\n弹出添加窗口后我们应该去进行添加的操作，使用axios向后端发送请求，并发送表单中的数据（json数据）\n在controller中我们进行添加操作（接收数据时，记得使用@RequestBody），因为业务较为单一，到数据库都是层层调用就行，在mapper映射文件中写好sql语句\n在controller中调用添加方法完成后，我们应该返回 成功或者失败的结果，使用工具类Result进行封装\n三个参数\nflag – 是否成功(true或false)  \nmessage – 使用定义的常量(成功或失败的消息提示)  \ndata – 封装object类型数据（可写可不写）\n\n\n然后我们在前端进行数据的挂载，因为是添加，那我们只需进行判断flag是否为ture，进行相关消息提示即可\n\n\n修改\n弹出窗口（弹出前重置，重置也没有问题，因为我们后面会进行数据的查询，进行数据回显）\n根据id（ scope.row包含所有数据，虽然页面上没有显示id，但是包含的有id）查询相关自由行数据，大体方法也是层层调用，到数据库中查询\n在controller中得到数据后进行封装(Result) ，在前端页面上进行回显，在axios中给formData赋值 this.formData=res.data.data\n进行修改操作，将修改的数据使用axios传递给后端，使用后端代码对其数据库进行修改，修改成功后，在前端进行消息提示\n\n\n删除\n删除操作和添加操作大体一样\n\n\n\n:seven: 跟团游的添加，修改删除跟团游中有 自由行列表可以选择，所以我们不仅要关注跟团游的操作，还要关注自由行的操作\n\n添加\n弹出添加表单，表单由两部分组成，添加跟团游的选项卡一，选择自由行的选项卡二\n弹出前要进行重置操作，以免数据回显，跟团游需要重置的数据较多\nthis.dataForm={}; 重置表单\nthis.activeName=”first”; 重置为第一个选项卡\nthis.travelItemIds=[];重置自由行复选框\n\n\n弹出后，进行添加操作，此添加要密切关注自由行，因为我们需要把添加的跟团游的 id 和选中的有联系的自由行的 id添加到两者的关系表中\n在controller中我们应该接收 选中的自由行的id数组，以及添加的跟团游的formData，使用跟团游的类进行接收（不要忘记@RequestBody）\n将之传递给service中，我们在service的实现类中，先进行跟团游的添加，因为这样我们可以使用mybatis的自增id返回（keyProperty=“id”）进行id赋值，这样我们在service的实现类中就可以 获取到 添加进去的跟团游的id\n获取到后我们在service的实现类中添加一个方法，参数为 自由行的id数组，以及跟团游的id，将自由行的数据进行遍历，在遍历的内部，维护一个map集合，添加一个自由行的id键值对，就添加一个跟团游的id的键值对（从始至终就同一个），然后调用添加到数据库中的方法，map集合在mapper映射文件中，使用key得到值，这样就将每一个与之对应的自由行的id添加到了关系表中，还避免了在mapper映射文件使用foreach循环\n最后在前端进行返回数据的判断，返回相对应的消息通知\n\n\n修改\n修改与添加大概一样，先重置表单\n弹出表单后，获取所有的自由行，进行回显，紧接着根据id获取相关跟团游数据，并根据跟团游id获取关联的自由行id封装为list集合\n在service中将跟团游和id的list集合封装到map集合中，使用键对应值的方式（两个），然后controller封装为Result返回给前端\n前端拿到数据后，进行相关回显\n进行修改操作\n将修改的数据返回给后端，此时和添加的操作差不多，不过，我们应该先修改跟团游，然后根据跟团游的id删除之前与之有关联的自由行的数据\n将我们从前端拿到的新的自由行的id数组，使用添加操作时再service的实现类中添加的方法，将之再添加进去\n然后我们在controller中将成功还是失败封装为result返回给前端，在前端进行修改成功还是失败的消息通知\n\n\n删除\n删除操作，我们先根据id获取是否有与之关联的自由行，如果有自由行，那就不能删除，如果没有则进行删除操作\n\n\n\n:eight: 套餐的添加整体来说和跟团游的添加一样，但是套餐的添加涉及到了图片的上传，所以我们又多了一个关注点\n首先我们解决图片的上传问题\n\n我们使用七牛云进行上传\n在七牛云上添加工作空间，将仓库的公钥私钥复制到工具类qiniu的变量中，并把仓库名指定为自己的仓库名\n因为前端页面上传图片的html代码模块中，指定了访问后端的路径，所以我们要使用指定的路径，或者更改前端指定的路径用其他的\n在后端controller与之匹配的路径方法中，我们先获取文件的原始名，然后获取图片后缀名（.jpg 或 .png等，带点）\n我们进行上传后的文件名设置，一般使用UUID.randomUUID.toString+System.CurrtentMills+后缀名\n我们将上传的图片 解析为字节数组，然后使用QINIU工具类中参数为（ 文件字节数组，上传文件名）的上传方法进行上传\n在前端的上传成功后的方法中，已经有人给我们提供了返回数据response（上传文件名）\n所以我们直接 将imgUrl 设置为 this.imgUrl=”七牛云提供的测试域名/“+上传文件名，这样我们就可以让上传的文件在上传框中回显\n提示上传成功，然后将formData中的img属性的值设置为imgUrl，以便提交表单时，添加到数据库中\n\n添加套餐\n\n弹出添加表单，弹出前，重置表单，这里我们要多重置一个数据，那就是imgUrl，不然我们之前上传的图片可能还会在表单中显示\n然后的步骤就和\n\n","slug":"61-美年旅游易错点（未完）","date":"2021-09-13T15:38:32.000Z","categories_index":"Project","tags_index":"Project","author_index":"大黄"},{"id":"173956e689406289f575044308a994ef","title":"Spring 整合","content":"meinian — daojdbc.properties\njdbc.driverClassName&#x3D;com.mysql.jdbc.Driver\njdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;meinian\njdbc.username&#x3D;root\njdbc.password&#x3D;root\njdbc.initialSize&#x3D;5\njdbc.maxActive&#x3D;10\n\nmybatis-config.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE configuration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD SQL Map Config 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;\n&lt;!--\n |   plugins在配置文件中的位置必须符合要求，否则会报错，顺序如下:\n |   properties?, settings?,\n |   typeAliases?, typeHandlers?,\n |   objectFactory?,objectWrapperFactory?,\n |   plugins?,\n |   environments?, databaseIdProvider?, mappers?\n |--&gt;\n&lt;configuration&gt;\n    &lt;!--\n     | 全局配置设置（可以在spring中的 sqlSession中使用属性configuration的内部bean配置）\n     |\n     | 可配置选项                   默认值,     描述\n     |\n     | aggressiveLazyLoading       true,     当设置为‘true’的时候，懒加载的对象可能被任何懒属性全部加载。否则，每个属性都按需加载。\n     | multipleResultSetsEnabled   true,     允许和不允许单条语句返回多个数据集（取决于驱动需求）\n     | useColumnLabel              true,     使用列标签代替列名称。不同的驱动器有不同的作法。参考一下驱动器文档，或者用这两个不同的选项进行测试一下。\n     | useGeneratedKeys            false,    允许JDBC 生成主键。需要驱动器支持。如果设为了true，这个设置将强制使用被生成的主键，有一些驱动器不兼容不过仍然可以执行。\n     | autoMappingBehavior         PARTIAL,  指定MyBatis 是否并且如何来自动映射数据表字段与对象的属性。PARTIAL将只自动映射简单的，没有嵌套的结果。FULL 将自动映射所有复杂的结果。\n     | defaultExecutorType         SIMPLE,   配置和设定执行器，SIMPLE 执行器执行其它语句。REUSE 执行器可能重复使用prepared statements 语句，BATCH执行器可以重复执行语句和批量更新。\n     | defaultStatementTimeout     null,     设置一个时限，以决定让驱动器等待数据库回应的多长时间为超时\n     | mapUnderscoreToCamelCase    true,     开启驼峰命名\n     | logPrefix              com.hrenxiang.dao.      mybatis配置logback\n     | --&gt;\n    &lt;settings&gt;\n        &lt;!-- 这个配置使全局的映射器启用或禁用缓存 --&gt;\n        &lt;!--   &lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;--&gt;\n        &lt;!-- 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载 分步查询时最好不要开--&gt;\n        &lt;!--   &lt;setting name&#x3D;&quot;lazyLoadingEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;--&gt;\n        &lt;setting name&#x3D;&quot;multipleResultSetsEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n        &lt;setting name&#x3D;&quot;useColumnLabel&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n        &lt;setting name&#x3D;&quot;defaultExecutorType&quot; value&#x3D;&quot;REUSE&quot;&#x2F;&gt;\n        &lt;setting name&#x3D;&quot;defaultStatementTimeout&quot; value&#x3D;&quot;25000&quot;&#x2F;&gt;\n        &lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n        &lt;setting name&#x3D;&quot;useGeneratedKeys&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n        &lt;setting name&#x3D;&quot;logPrefix&quot; value&#x3D;&quot;com.hrenxiang.dao.&quot;&#x2F;&gt;\n    &lt;&#x2F;settings&gt;\n\n&lt;&#x2F;configuration&gt;\n\nspring-dao.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:mybatis&#x3D;&quot;http:&#x2F;&#x2F;mybatis.org&#x2F;schema&#x2F;mybatis-spring&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util&#x2F;spring-util.xsd http:&#x2F;&#x2F;mybatis.org&#x2F;schema&#x2F;mybatis-spring http:&#x2F;&#x2F;mybatis.org&#x2F;schema&#x2F;mybatis-spring.xsd&quot;&gt;\n\n    &lt;!-- 引入数据库属性文件 --&gt;\n    &lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot;&#x2F;&gt;\n\n    &lt;!-- 配置数据源 --&gt;\n    &lt;bean name&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;\n        &lt;!-- 连接数据库的驱动，连接字符串，用户名和登录密码--&gt;\n        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.driverClassName&#125;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;\n        &lt;!-- 初始化连接大小 --&gt;\n        &lt;property name&#x3D;&quot;initialSize&quot; value&#x3D;&quot;$&#123;jdbc.initialSize&#125;&quot;&#x2F;&gt;\n        &lt;!-- 连接池最大使用连接数量 --&gt;\n        &lt;property name&#x3D;&quot;maxActive&quot; value&#x3D;&quot;$&#123;jdbc.maxActive&#125;&quot;&#x2F;&gt;\n        &lt;!-- 连接池最小空闲 --&gt;\n        &lt;!-- 获取连接最大等待时间 --&gt;\n    &lt;&#x2F;bean&gt;\n\n    &lt;!-- Spring整合Mybatis --&gt;\n    &lt;bean class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;\n        &lt;!-- 注入连接池 --&gt;\n        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;\n        &lt;!-- 起别名（因为依赖关系，可以直接访问到pojo模块中的包） --&gt;\n        &lt;property name&#x3D;&quot;typeAliasesPackage&quot; value&#x3D;&quot;com.atguigu.pojo&quot;&#x2F;&gt;\n        &lt;!-- 扫描mybatis主配置文件 --&gt;\n        &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:mybatis-config.xml&quot;&#x2F;&gt;\n        &lt;!-- 扫描sql语句配置文件 --&gt;\n        &lt;!--&lt;property name&#x3D;&quot;mapperLocations&quot; value&#x3D;&quot;com.atguigu.mapper&quot;&#x2F;&gt;--&gt;\n        &lt;!-- mybatis插件 --&gt;\n        &lt;property name&#x3D;&quot;plugins&quot;&gt;\n            &lt;array&gt;\n                &lt;bean class&#x3D;&quot;com.github.pagehelper.PageHelper&quot;&gt;\n                    &lt;property name&#x3D;&quot;properties&quot;&gt;\n                        &lt;props&gt;\n                            &lt;!-- 设置 reasonable 为 true 表示将页码进行合理化修正。页码的有效范围：1~总页数 --&gt;\n                            &lt;prop key&#x3D;&quot;reasonable&quot;&gt;true&lt;&#x2F;prop&gt;\n\n                            &lt;!-- 数据库方言：同样都是 SQL 语句，拿到不同数据库中，在语法上会有差异 --&gt;\n                            &lt;!-- 默认情况下，按照 MySQL 作为数据库方言来运行 --&gt;\n                            &lt;prop key&#x3D;&quot;helperDialect&quot;&gt;mysql&lt;&#x2F;prop&gt;\n                        &lt;&#x2F;props&gt;\n                    &lt;&#x2F;property&gt;\n                &lt;&#x2F;bean&gt;\n            &lt;&#x2F;array&gt;\n        &lt;&#x2F;property&gt;\n    &lt;&#x2F;bean&gt;\n\n    &lt;!-- MyBatis 动态扫描  --&gt;\n    &lt;!-- Mapper接口MapperScannerConfigurer 为指定包下的Mapper接口批量生成代理实现类.bean的默认id是接口名首字母小写 --&gt;\n    &lt;!--&lt;bean id&#x3D;&quot;mapperScannerConfigurer&quot; class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;\n        &lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;com.atguigu.mapper&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;--&gt;\n    &lt;mybatis:scan base-package&#x3D;&quot;com.atguigu.mapper&quot; &#x2F;&gt;\n\n&lt;&#x2F;beans&gt;\n\n\n\n\n\nmeinian  —  servicelog4j.properties\n### direct log messages to stdout ###\nlog4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.Target&#x3D;System.err\nlog4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern&#x3D;%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n\n\n### direct messages to file mylog.log ###\nlog4j.appender.file&#x3D;org.apache.log4j.FileAppender\nlog4j.appender.file.File&#x3D;c:\\\\mylog.log\nlog4j.appender.file.layout&#x3D;org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern&#x3D;%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n\n\n### set log levels - for more verbose logging change &#39;info&#39; to &#39;debug&#39; ###\n\nlog4j.rootLogger&#x3D;debug, stdout\n\nspring-redis.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n                         http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n\n    &lt;!--Jedis连接池的相关配置--&gt;\n    &lt;bean id&#x3D;&quot;jedisPoolConfig&quot; class&#x3D;&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;\n        &lt;!--最大连接数, 默认8个--&gt;\n        &lt;property name&#x3D;&quot;maxTotal&quot; value&#x3D;&quot;300&quot;&#x2F;&gt;\n        &lt;!--最大空闲连接数, 默认8个--&gt;\n        &lt;property name&#x3D;&quot;maxIdle&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;\n        &lt;!--允许借调 在获取连接的时候检查有效性, 默认false--&gt;\n        &lt;property name&#x3D;&quot;testOnBorrow&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n        &lt;!--允许归还 在return给pool时，是否提前进行validate操作--&gt;\n        &lt;property name&#x3D;&quot;testOnReturn&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n    &lt;bean id&#x3D;&quot;jedisPool&quot; class&#x3D;&quot;redis.clients.jedis.JedisPool&quot;&gt;\n        &lt;constructor-arg name&#x3D;&quot;poolConfig&quot; ref&#x3D;&quot;jedisPoolConfig&quot; &#x2F;&gt;\n        &lt;constructor-arg name&#x3D;&quot;host&quot; value&#x3D;&quot;127.0.0.1&quot; &#x2F;&gt;\n        &lt;constructor-arg name&#x3D;&quot;port&quot; value&#x3D;&quot;6379&quot; type&#x3D;&quot;int&quot; &#x2F;&gt;\n        &lt;constructor-arg name&#x3D;&quot;timeout&quot; value&#x3D;&quot;30000&quot; type&#x3D;&quot;int&quot; &#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\nspring-tx.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;cache http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;cache&#x2F;spring-cache.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd&quot;&gt;\n\n    &lt;!-- 事务管理器  --&gt;\n    &lt;bean id&#x3D;&quot;transactionManager&quot;\n          class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;\n        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n    &lt;!--\n        开启事务控制的注解支持\n        注意：此处必须加入proxy-target-class&#x3D;&quot;true&quot;，\n              需要进行事务控制，会由Spring框架产生代理对象，\n              Dubbo需要将Service发布为服务，要求必须使用cglib创建代理对象。\n    --&gt;\n    &lt;tx:annotation-driven transaction-manager&#x3D;&quot;transactionManager&quot; proxy-target-class&#x3D;&quot;true&quot;&#x2F;&gt;\n\n&lt;&#x2F;beans&gt;\n\nspring-service.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:dubbo&#x3D;&quot;http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd&quot;&gt;\n    &lt;!-- 指定应用名称 --&gt;\n    &lt;dubbo:application name&#x3D;&quot;meinian_service&quot;&#x2F;&gt;\n    &lt;!--指定服务注册中心地址--&gt;\n    &lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;127.0.0.1:2181&quot;&#x2F;&gt;\n    &lt;!--指定暴露服务的端口，如果不指定默认为20880--&gt;\n    &lt;dubbo:protocol name&#x3D;&quot;dubbo&quot; port&#x3D;&quot;20881&quot;&#x2F;&gt;\n    &lt;!--批量扫描，发布服务--&gt;\n    &lt;dubbo:annotation package&#x3D;&quot;com.atguigu.service&quot;&#x2F;&gt;\n&lt;&#x2F;beans&gt;\n\nweb.xml   ——     这里扫描了前面所有的spring*.xml文件，将之加载到了ioc的父容器中\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;\n         version&#x3D;&quot;4.0&quot;&gt;\n\n    &lt;!-- 加载Spring配置文件 --&gt;\n    &lt;context-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n        &lt;param-value&gt;classpath*:spring*.xml&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;context-param&gt;\n\n    &lt;!-- Spring监听器 读取文件创建容器，并把容器放入servletContext作用域中--&gt;\n    &lt;listener&gt;\n        &lt;description&gt;spring 监听器&lt;&#x2F;description&gt;\n        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;\n    &lt;&#x2F;listener&gt;\n\n&lt;&#x2F;web-app&gt;\n\n\n\nmeinian  —  weblog4j.properties\n### direct log messages to stdout ###\nlog4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.Target&#x3D;System.err\nlog4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern&#x3D;%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n\n\n### direct messages to file mylog.log ###\nlog4j.appender.file&#x3D;org.apache.log4j.FileAppender\nlog4j.appender.file.File&#x3D;c:\\\\mylog.log\nlog4j.appender.file.layout&#x3D;org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern&#x3D;%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n\n\n### set log levels - for more verbose logging change &#39;info&#39; to &#39;debug&#39; ###\n\nlog4j.rootLogger&#x3D;debug, stdout\n\nspring-redis.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n    &lt;!--Jedis连接池的相关配置--&gt;\n    &lt;bean id&#x3D;&quot;jedisPoolConfig&quot; class&#x3D;&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;\n        &lt;!--最大连接数, 默认8个--&gt;\n        &lt;property name&#x3D;&quot;maxTotal&quot; value&#x3D;&quot;300&quot;&#x2F;&gt;\n        &lt;!--最大空闲连接数, 默认8个--&gt;\n        &lt;property name&#x3D;&quot;maxIdle&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;\n        &lt;!--允许借调 在获取连接的时候检查有效性, 默认false--&gt;\n        &lt;property name&#x3D;&quot;testOnBorrow&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n        &lt;!--允许归还 在return给pool时，是否提前进行validate操作--&gt;\n        &lt;property name&#x3D;&quot;testOnReturn&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n    &lt;bean id&#x3D;&quot;jedisPool&quot; class&#x3D;&quot;redis.clients.jedis.JedisPool&quot;&gt;\n        &lt;constructor-arg name&#x3D;&quot;poolConfig&quot; ref&#x3D;&quot;jedisPoolConfig&quot; &#x2F;&gt;\n        &lt;constructor-arg name&#x3D;&quot;host&quot; value&#x3D;&quot;127.0.0.1&quot; &#x2F;&gt;\n        &lt;constructor-arg name&#x3D;&quot;port&quot; value&#x3D;&quot;6379&quot; type&#x3D;&quot;int&quot; &#x2F;&gt;\n        &lt;constructor-arg name&#x3D;&quot;timeout&quot; value&#x3D;&quot;30000&quot; type&#x3D;&quot;int&quot; &#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\nspring-security.xml    ——-   需要定义SecurityUserServiceImpl认证提供者，实现UserDetailService\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:security&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security&#x2F;spring-security.xsd&quot;&gt;\n\n    &lt;!--开启注解扫描 dubbo已经扫描，如果dubbo中不扫描此包，那么引用将不可用--&gt;\n    &lt;!--&lt;context:component-scan base-package&#x3D;&quot;com.atguigu.security&quot;&#x2F;&gt;--&gt;\n    &lt;!--开启注解方式权限控制--&gt;\n    &lt;security:global-method-security pre-post-annotations&#x3D;&quot;enabled&quot;&#x2F;&gt;\n\n    &lt;!--开启匿名访问的资源--&gt;\n    &lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;css&#x2F;**&quot;&#x2F;&gt;\n    &lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;img&#x2F;**&quot;&#x2F;&gt;\n    &lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;js&#x2F;**&quot;&#x2F;&gt;\n    &lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;plugins&#x2F;**&quot;&#x2F;&gt;\n    &lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;login.html&quot;&#x2F;&gt;\n\n    &lt;security:http auto-config&#x3D;&quot;true&quot; use-expressions&#x3D;&quot;true&quot;&gt;\n        &lt;security:intercept-url access&#x3D;&quot;isAuthenticated()&quot; pattern&#x3D;&quot;&#x2F;pages&#x2F;**&quot;&#x2F;&gt;\n        &lt;!--\n            form-login：定义表单登录信息\n            login-page&#x3D;&quot;&#x2F;login.html&quot;：表示指定登录页面\n            username-parameter&#x3D;&quot;username&quot;：使用登录名的名称，默认值是username\n            password-parameter&#x3D;&quot;password&quot;：使用登录名的密码，默认值是password\n            login-processing-url&#x3D;&quot;&#x2F;login.do&quot;：表示登录的url地址\n            default-target-url&#x3D;&quot;&#x2F;index.html&quot;：登录成功后的url地址\n            authentication-failure-url&#x3D;&quot;&#x2F;login.html&quot;：认证失败后跳转的url地址，失败后指定&#x2F;login.html\n            always-use-default-target&#x3D;&quot;true&quot;：登录成功后，始终跳转到default-target-url指定的地址，即登录成功的默认地址\n            --&gt;\n        &lt;security:form-login login-page&#x3D;&quot;&#x2F;login.html&quot;\n                             login-processing-url&#x3D;&quot;&#x2F;login.do&quot;\n                             username-parameter&#x3D;&quot;username&quot;\n                             password-parameter&#x3D;&quot;password&quot;\n                             default-target-url&#x3D;&quot;&#x2F;pages&#x2F;main.html&quot;\n                             authentication-failure-url&#x3D;&quot;&#x2F;login.html&quot;\n                             always-use-default-target&#x3D;&quot;true&quot;\n        &#x2F;&gt;\n        &lt;!--禁用CsrfFilter过滤器--&gt;\n        &lt;security:csrf disabled&#x3D;&quot;true&quot;&#x2F;&gt;\n        &lt;!--登出--&gt;\n        &lt;security:logout logout-url&#x3D;&quot;&#x2F;logout.do&quot; invalidate-session&#x3D;&quot;true&quot; logout-success-url&#x3D;&quot;&#x2F;login.html&quot;&#x2F;&gt;\n\n        &lt;security:headers&gt;\n            &lt;!--设置在页面可以通过iframe访问受保护的页面，默认为不允许访问--&gt;\n            &lt;security:frame-options policy&#x3D;&quot;SAMEORIGIN&quot;&#x2F;&gt;\n        &lt;&#x2F;security:headers&gt;\n\n        &lt;security:access-denied-handler ref&#x3D;&quot;customAccessDeniedController&quot;&#x2F;&gt;\n    &lt;&#x2F;security:http&gt;\n\n    &lt;!--认证管理：定义登录账号名和密码，并授予访问的角色、权限--&gt;\n    &lt;security:authentication-manager&gt;\n        &lt;!--authentication-provider：认证提供者，执行具体的认证逻辑--&gt;\n        &lt;security:authentication-provider user-service-ref&#x3D;&quot;securityUserServiceImpl&quot;&gt;\n            &lt;!--指定密码加密策略--&gt;\n            &lt;security:password-encoder ref&#x3D;&quot;passwordEncoder&quot;&#x2F;&gt;\n        &lt;&#x2F;security:authentication-provider&gt;\n    &lt;&#x2F;security:authentication-manager&gt;\n\n    &lt;!--配置密码加密对象--&gt;\n    &lt;bean id&#x3D;&quot;passwordEncoder&quot;\n          class&#x3D;&quot;org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder&quot; &#x2F;&gt;\n\n&lt;&#x2F;beans&gt;\n\nspring-mvc.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:dubbo&#x3D;&quot;http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&quot; xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;\n\n    &lt;mvc:annotation-driven&gt;\n        &lt;!-- register-defaults&#x3D;&quot;true&quot;将我们配置文件创建的bean设置为默认的,springmvc就不会再后台创建了 --&gt;\n        &lt;!-- 属性解释:\n            1.register-defaults&#x3D;true:告诉Springmvc使用我们配置文件创建的对象,不再自己创建(框架自己创建,是通过无参构造,会使用默认的字符集)\n         --&gt;\n        &lt;mvc:message-converters register-defaults&#x3D;&quot;true&quot;&gt;\n            &lt;!--项目使用vue.js中的axios异步访问数据，传递json数据，响应json数据--&gt;\n            &lt;!--不需要视图解析器，项目中的所有的请求都返回json数据结构--&gt;\n            &lt;bean class&#x3D;&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt;\n                &lt;property name&#x3D;&quot;supportedMediaTypes&quot; value&#x3D;&quot;application&#x2F;json&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;features&quot;&gt;\n                    &lt;list&gt;\n                        &lt;!--Map类型格式化，接收参数允许空值--&gt;\n                        &lt;value&gt;WriteMapNullValue&lt;&#x2F;value&gt;\n                        &lt;!--日期类型格式化--&gt;\n                        &lt;value&gt;WriteDateUseDateFormat&lt;&#x2F;value&gt;\n                    &lt;&#x2F;list&gt;\n                &lt;&#x2F;property&gt;\n            &lt;&#x2F;bean&gt;\n        &lt;&#x2F;mvc:message-converters&gt;\n    &lt;&#x2F;mvc:annotation-driven&gt;\n\n    &lt;!-- 指定应用名称 --&gt;\n    &lt;dubbo:application name&#x3D;&quot;meinian_web&quot;&#x2F;&gt;\n    &lt;!--指定服务注册中心地址--&gt;\n    &lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;127.0.0.1:2181&quot;&#x2F;&gt;\n    &lt;!--批量扫描--&gt;\n    &lt;dubbo:annotation package&#x3D;&quot;com.atguigu&quot;&#x2F;&gt;\n\n    &lt;!--\n        超时全局设置 10分钟\n        check&#x3D;false 不检查服务提供方，开发阶段建议设置为false\n        check&#x3D;true 启动时检查服务提供方，如果服务提供方没有启动则报错\n    --&gt;\n    &lt;dubbo:consumer timeout&#x3D;&quot;600000&quot; check&#x3D;&quot;false&quot;&#x2F;&gt;\n\n    &lt;!--文件上传组件--&gt;\n    &lt;bean id&#x3D;&quot;multipartResolver&quot;\n          class&#x3D;&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;\n        &lt;!-- 设定文件上传的最大值为100MB，100*1024*1024 --&gt;\n        &lt;property name&#x3D;&quot;maxUploadSize&quot; value&#x3D;&quot;104857600&quot;&#x2F;&gt;\n        &lt;!-- 设定文件上传时写入内存的最大值，如果小于这个参数不会生成临时文件，默认为10240 --&gt;\n        &lt;property name&#x3D;&quot;maxInMemorySize&quot; value&#x3D;&quot;4096&quot;&#x2F;&gt;\n        &lt;!-- 设定默认编码 --&gt;\n        &lt;property name&#x3D;&quot;defaultEncoding&quot; value&#x3D;&quot;UTF-8&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n    &lt;!-- 导入spring整合的redis的配置 --&gt;\n    &lt;import resource&#x3D;&quot;spring-redis.xml&quot;&#x2F;&gt;\n    &lt;!--导入spring security 权限框架--&gt;\n    &lt;import resource&#x3D;&quot;spring-security.xml&quot;&#x2F;&gt;\n&lt;&#x2F;beans&gt;\n\nweb.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;\n         version&#x3D;&quot;4.0&quot;&gt;\n    \n    &lt;!--设置同一编码--&gt;\n    &lt;filter&gt;\n        &lt;filter-name&gt;CharacterEncodingFilter&lt;&#x2F;filter-name&gt;\n        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;\n            &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;\n        &lt;&#x2F;init-param&gt;\n        &lt;!--解决请求乱码--&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;forceRequestEncoding&lt;&#x2F;param-name&gt;\n            &lt;param-value&gt;true&lt;&#x2F;param-value&gt;\n        &lt;&#x2F;init-param&gt;\n        &lt;!--解决响应乱码--&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;forceResponseEncoding&lt;&#x2F;param-name&gt;\n            &lt;param-value&gt;true&lt;&#x2F;param-value&gt;\n        &lt;&#x2F;init-param&gt;\n    &lt;&#x2F;filter&gt;\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;CharacterEncodingFilter&lt;&#x2F;filter-name&gt;\n        &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n    &lt;&#x2F;filter-mapping&gt;\n\n    &lt;!--将 POST 请求，转化为PUT DELETE 请求 （写在编码过滤器后，否则会出现乱码）--&gt;\n    &lt;filter&gt;\n        &lt;filter-name&gt;HiddenHttpMethodFilter&lt;&#x2F;filter-name&gt;\n        &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;&#x2F;filter-class&gt;\n    &lt;&#x2F;filter&gt;\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;HiddenHttpMethodFilter&lt;&#x2F;filter-name&gt;\n        &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n    &lt;&#x2F;filter-mapping&gt;\n\n    &lt;!--spring security权限框架代理处理器，里面有12个基本的处理器--&gt;\n    &lt;filter&gt;\n        &lt;filter-name&gt;springSecurityFilterChain&lt;&#x2F;filter-name&gt;\n        &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;&#x2F;filter-class&gt;\n    &lt;&#x2F;filter&gt;\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;springSecurityFilterChain&lt;&#x2F;filter-name&gt;\n        &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n    &lt;&#x2F;filter-mapping&gt;\n\n    &lt;!-- 配置SpringMVC中负责处理请求的核心Servlet，也被称为SpringMVC的前端控制器 --&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt;\n\n        &lt;!-- DispatcherServlet的全类名 --&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;\n\n        &lt;!-- 通过初始化参数指定SpringMVC配置文件位置 --&gt;\n        &lt;init-param&gt;\n            &lt;!-- 如果不记得contextConfigLocation配置项的名称，可以到DispatcherServlet的父类FrameworkServlet中查找 --&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n\n            &lt;!-- 使用classpath:说明这个路径从类路径的根目录开始才查找 --&gt;\n            &lt;param-value&gt;classpath:spring-mvc.xml&lt;&#x2F;param-value&gt;\n        &lt;&#x2F;init-param&gt;\n\n        &lt;!-- 作为框架的核心组件，在启动过程中有大量的初始化操作要做，这些操作放在第一次请求时才执行非常不恰当 --&gt;\n        &lt;!-- 我们应该将DispatcherServlet设置为随Web应用一起启动 --&gt;\n        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;\n    &lt;&#x2F;servlet&gt;\n\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt;\n\n        &lt;!-- 对DispatcherServlet来说，url-pattern有两种方式配置 --&gt;\n        &lt;!-- 方式一：配置“&#x2F;”，表示匹配整个Web应用范围内所有请求。这里有一个硬性规定：不能写成“&#x2F;*”。只有这一个地方有这个特殊要求，以后我们再配置Filter还是可以正常写“&#x2F;*”。 --&gt;\n        &lt;!-- 方式二：配置“*.扩展名”，表示匹配整个Web应用范围内部分请求 --&gt;\n        &lt;url-pattern&gt;*.do&lt;&#x2F;url-pattern&gt;\n    &lt;&#x2F;servlet-mapping&gt;\n\n&lt;&#x2F;web-app&gt;\n\n\n\nmeinian   —   joblog4j.properties\n### direct log messages to stdout ###\nlog4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.Target&#x3D;System.err\nlog4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern&#x3D;%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n\n\n### direct messages to file mylog.log ###\nlog4j.appender.file&#x3D;org.apache.log4j.FileAppender\nlog4j.appender.file.File&#x3D;c:\\\\mylog.log\nlog4j.appender.file.layout&#x3D;org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern&#x3D;%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n\n\n### set log levels - for more verbose logging change &#39;info&#39; to &#39;debug&#39; ###\n\nlog4j.rootLogger&#x3D;debug, stdout\n\nspring-redis.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n    &lt;!--Jedis连接池的相关配置--&gt;\n    &lt;bean id&#x3D;&quot;jedisPoolConfig&quot; class&#x3D;&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;\n        &lt;!--最大连接数, 默认8个--&gt;\n        &lt;property name&#x3D;&quot;maxTotal&quot; value&#x3D;&quot;300&quot;&#x2F;&gt;\n        &lt;!--最大空闲连接数, 默认8个--&gt;\n        &lt;property name&#x3D;&quot;maxIdle&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;\n        &lt;!--允许借调 在获取连接的时候检查有效性, 默认false--&gt;\n        &lt;property name&#x3D;&quot;testOnBorrow&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n        &lt;!--允许归还 在return给pool时，是否提前进行validate操作--&gt;\n        &lt;property name&#x3D;&quot;testOnReturn&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n    &lt;bean id&#x3D;&quot;jedisPool&quot; class&#x3D;&quot;redis.clients.jedis.JedisPool&quot;&gt;\n        &lt;constructor-arg name&#x3D;&quot;poolConfig&quot; ref&#x3D;&quot;jedisPoolConfig&quot; &#x2F;&gt;\n        &lt;constructor-arg name&#x3D;&quot;host&quot; value&#x3D;&quot;127.0.0.1&quot; &#x2F;&gt;\n        &lt;constructor-arg name&#x3D;&quot;port&quot; value&#x3D;&quot;6379&quot; type&#x3D;&quot;int&quot; &#x2F;&gt;\n        &lt;constructor-arg name&#x3D;&quot;timeout&quot; value&#x3D;&quot;30000&quot; type&#x3D;&quot;int&quot; &#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\nspring-quartz.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n                  http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n                  http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context\n                  http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;\n\n    &lt;context:component-scan base-package&#x3D;&quot;com.atguigu&quot;&#x2F;&gt;\n\n    &lt;!-- 注册自定义Job --&gt;\n    &lt;bean id&#x3D;&quot;QiNiuJob&quot; class&#x3D;&quot;com.atguigu.QiNiuJob&quot;&#x2F;&gt;\n    &lt;!-- 1：创建JobDetail对象,作用是负责通过反射调用指定的Job，注入目标对象，注入目标方法 --&gt;\n    &lt;bean id&#x3D;&quot;jobDetail&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt;\n        &lt;!-- 注入目标对象 --&gt;\n        &lt;property name&#x3D;&quot;targetObject&quot; ref&#x3D;&quot;QiNiuJob&quot;&#x2F;&gt;\n        &lt;!-- 注入目标方法 --&gt;\n        &lt;property name&#x3D;&quot;targetMethod&quot; value&#x3D;&quot;run&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n    &lt;!-- 2：注册一个触发器，指定任务触发的时间 --&gt;\n    &lt;bean id&#x3D;&quot;myTrigger&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt;\n        &lt;!-- 注入JobDetail --&gt;\n        &lt;property name&#x3D;&quot;jobDetail&quot; ref&#x3D;&quot;jobDetail&quot;&#x2F;&gt;\n        &lt;!-- 指定触发的时间，基于Cron表达式（0&#x2F;10表示从0秒开始，每10秒执行一次） --&gt;\n        &lt;property name&#x3D;&quot;cronExpression&quot;&gt;\n            &lt;value&gt;0&#x2F;10 * * * * ?&lt;&#x2F;value&gt;\n        &lt;&#x2F;property&gt;\n    &lt;&#x2F;bean&gt;\n    &lt;!-- 3：注册一个统一的调度工厂，通过这个调度工厂调度任务 --&gt;\n    &lt;bean id&#x3D;&quot;scheduler&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;\n        &lt;!-- 注入多个触发器 --&gt;\n        &lt;property name&#x3D;&quot;triggers&quot;&gt;\n            &lt;list&gt;\n                &lt;ref bean&#x3D;&quot;myTrigger&quot;&#x2F;&gt;\n            &lt;&#x2F;list&gt;\n        &lt;&#x2F;property&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\n","slug":"60-Spring 整合各个模块","date":"2021-09-13T15:37:32.000Z","categories_index":"Spring","tags_index":"Spring","author_index":"大黄"},{"id":"29737e157e321f39ed60992860349925","title":"SpringSecurity 源码剖析","content":"我们在 spring_security.xml 中配置过后，为什么权限框架就能做到这些权限管理的事情呢，背后的执行流程到底又是什么呢？\n==Spring Security Filter 并不是直接嵌入到 Web Filter 中的，而是通过 FilterChainProxy 来统一管理 Spring Security Filter，FilterChainProxy 本身则通过 Spring 提供的 DelegatingFilterProxy 代理过滤器嵌入到 Web Filter 之中。==\n我们从 web.xml 中配置的 spring security的过滤器 org.springframework.web.filter.DelegatingFilterProxy 开始说起\n1、DelegatingFilterProxy==其实 DelegatingFilterProxy类主要作用就是一个代理模式的应用,可以把servlet 容器中的filter同spring容器中的bean关联起来。==\n使用过springSecurity，首先需要在web.xml进行以下配置，\n&lt;filter&gt;\n    &lt;filter-name&gt;springSecurityFilterChain&lt;&#x2F;filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;&#x2F;filter-class&gt; \n\n    &lt;init-param&gt;\n        &lt;param-name&gt;targetFilterLifecycle&lt;&#x2F;param-name&gt;\n        &lt;param-value&gt;true&lt;&#x2F;param-value&gt;  &lt;!-- 默认是false --&gt;\n    &lt;&#x2F;init-param&gt;\n\n&lt;&#x2F;filter&gt;\n\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;springSecurityFilterChain&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;filter-mapping&gt;\n\n从这个配置中，可能会给我们造成一个错觉，以为 DelegatingFilterProxy 类就是 springSecurity 的入口，但其实这个类位于 spring-web-3.0.5.RELEASE.jar这个jar下面，说明这个类本身是和 springSecurity 无关。\nDelegatingFilterProxy类继承于抽象类 GenericFilterBean，间接地 implement 了 javax.servlet.Filter 接口，Servlet 容器在启动时，首先会调用Filter的init方法,GenericFilterBean的作用主要是可以把Filter的初始化参数自动地set到继承于GenericFilterBean类的Filter中去。在 GenericFilterBean 中的 init 方法的就是做了这个事：\n public final void init(FilterConfig filterConfig) throws ServletException &#123;   \n  ...         \n  PropertyValues pvs &#x3D; new .FilterConfigPropertyValues(filterConfig, this.requiredProperties);\n  ...\n  BeanWrapper bw &#x3D; PropertyAccessorFactory.forBeanPropertyAccess(this);\n  ResourceLoader resourceLoader &#x3D; new ServletContextResourceLoader(filterConfig.getServletContext());\n  ...\n  bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, (PropertyResolver)env));\n  this.initBeanWrapper(bw);\n  bw.setPropertyValues(pvs, true);\n  ...\n  this.initFilterBean();\n&#125;\n\n 另外在init方法中调用了initFilterBean()方法，该方法是GenericFilterBean类是特地留给子类扩展用的，下面是DelegatingFilterProxy中重写的方法：\nprotected void initFilterBean() throws ServletException &#123;\n        synchronized(this.delegateMonitor) &#123;\n            if (this.delegate &#x3D;&#x3D; null) &#123;\n                if (this.targetBeanName &#x3D;&#x3D; null) &#123;\n                    this.targetBeanName &#x3D; this.getFilterName();\n                &#125;\n\n                WebApplicationContext wac &#x3D; this.findWebApplicationContext();\n                if (wac !&#x3D; null) &#123;\n                    this.delegate &#x3D; this.initDelegate(wac);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n 可以看出上述代码首先看Filter是否提供了targetBeanName初始化参数，如果没有提供则直接使用filter的name做为beanName\n产生了beanName后，由于我们在web.xml的filter的name是springSecurityFilterChain，从spring的IOC容器中取出bean的代码是initDelegate方法，下面是该方法代码：\nprotected Filter initDelegate(WebApplicationContext wac) throws ServletException &#123;\n    String targetBeanName &#x3D; this.getTargetBeanName();\n    Assert.state(targetBeanName !&#x3D; null, &quot;No target bean name set&quot;);\n    \n    &lt;!--取出的bean--&gt;\n    Filter delegate &#x3D; (Filter)wac.getBean(targetBeanName, Filter.class);\n    if (this.isTargetFilterLifecycle()) &#123;\n        delegate.init(this.getFilterConfig());\n    &#125;\n\n    return delegate;\n&#125;\n\n 通过跟踪代码，发现取出的bean是org.springframework.security.FilterChainProxy，该类也是继承于GenericFilterBean,取出bean后，判断targetFilterLifecycle属性是false还是true，决定是否调用该类的init方法。这个FilterChainProxy bean实例最终被保存在DelegatingFilterProxy类的 delegate  属性里\n\n下面看一下DelegatingFilterProxy类的doFilter方法\npublic void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;\n    Filter delegateToUse &#x3D; this.delegate;\n    if (delegateToUse &#x3D;&#x3D; null) &#123;\n        synchronized(this.delegateMonitor) &#123;\n            delegateToUse &#x3D; this.delegate;\n            if (delegateToUse &#x3D;&#x3D; null) &#123;\n                WebApplicationContext wac &#x3D; this.findWebApplicationContext();\n                if (wac &#x3D;&#x3D; null) &#123;\n                    throw new IllegalStateException(&quot;No WebApplicationContext found: no ContextLoaderListener or DispatcherServlet registered?&quot;);\n                &#125;\n\n                delegateToUse &#x3D; this.initDelegate(wac);\n            &#125;\n\n            this.delegate &#x3D; delegateToUse;\n        &#125;\n    &#125;\n\n    this.invokeDelegate(delegateToUse, request, response, filterChain);\n&#125;\n\n 真正要关注invokeDelegate(delegateToUse, request, response, filterChain);这句代码,在下面可以看出DelegatingFilterProxy类实际是用其delegate属性即org.springframework.security.FilterChainProxy实例的doFilter方法来响应请求。\nprotected void invokeDelegate(Filter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;\n    delegate.doFilter(request, response, filterChain);\n&#125;\n\n此外还要注意一个DelegatingFilterProxy的一个初始化参数：targetFilterLifecycle ，其默认值为false 。 但如果被其代理的filter的init()方法和destry()方法需要被调用时，需要设置targetFilterLifecycle为true。具体可见DelegatingFilterProxy中的如下代码：\nprotected Filter initDelegate(WebApplicationContext wac)throws ServletException &#123;\n    Filter delegate &#x3D; wac.getBean(getTargetBeanName(), Filter.class);\n    if (isTargetFilterLifecycle()) &#123;   &#x2F;&#x2F;注意这行\n        delegate.init(getFilterConfig());\n    &#125;\n    return delegate;\n&#125;\n\n\n\n2、FilterChainProxyFilterChainProxy 中可以存在多个过滤器链，当请求到达 FilterChainProxy 之后，FilterChainProxy 会根据请求的路径，将请求转发到不同的 Spring Security Filters 上面去，不同的 Spring Security Filters 对应了不同的过滤器，也就是不同的请求将经过不同的过滤器。\n先把 FilterChainProxy 源码亮出来，这个源码比较上，我们一部分一部分来，先从它声明的全局属性上开始：\nprivate final static String FILTER_APPLIED &#x3D; FilterChainProxy.class.getName().concat(\n        &quot;.APPLIED&quot;);\nprivate List&lt;SecurityFilterChain&gt; filterChains;\nprivate FilterChainValidator filterChainValidator &#x3D; new NullFilterChainValidator();\nprivate HttpFirewall firewall &#x3D; new StrictHttpFirewall();\n\n\nFILTER_APPLIED 变量是一个标记，用来标记过滤器是否已经执行过了。这个标记在 Spring Security 中很常见，松哥这里就不多说了。\nfilterChains 是过滤器链，注意，这个是过滤器链，而不是一个个的过滤器，配置多个过滤器链就保存在 filterChains 变量中，也就是，如果你有一个过滤器链，这个集合中就保存一条记录，你有两个过滤器链，这个记录中就保存两条记录，每一条记录又对应了过滤器链中的一个个过滤器。\nfilterChainValidator 是 FilterChainProxy 配置完成后的校验方法，默认使用的 NullFilterChainValidator 实际上对应了一个空方法，也就是不做任何校验。\nfirewall (Spring Security 自带防火墙！你都不知道自己的系统有多安全！)\n\n最重要的 doFilter 方法：\n@Override\npublic void doFilter(ServletRequest request, ServletResponse response,\n        FilterChain chain) throws IOException, ServletException &#123;\n    boolean clearContext &#x3D; request.getAttribute(FILTER_APPLIED) &#x3D;&#x3D; null;\n    if (clearContext) &#123;\n        try &#123;\n            request.setAttribute(FILTER_APPLIED, Boolean.TRUE);\n            doFilterInternal(request, response, chain);\n        &#125;\n        finally &#123;\n            SecurityContextHolder.clearContext();\n            request.removeAttribute(FILTER_APPLIED);\n        &#125;\n    &#125;\n    else &#123;\n        doFilterInternal(request, response, chain);\n    &#125;\n&#125;\n\n在 doFilter 方法中，正常来说，clearContext 参数每次都是 true，于是每次都先给 request 标记上 FILTER_APPLIED 属性，然后执行 doFilterInternal 方法去走过滤器，执行完毕后，最后在 finally 代码块中清除 SecurityContextHolder 中保存的用户信息，同时移除 request 中的标记。\n按着这个顺序，doFilterInternal 方法：\nprivate void doFilterInternal(ServletRequest request, ServletResponse response,\n        FilterChain chain) throws IOException, ServletException &#123;\n    FirewalledRequest fwRequest &#x3D; firewall\n            .getFirewalledRequest((HttpServletRequest) request);\n    HttpServletResponse fwResponse &#x3D; firewall\n            .getFirewalledResponse((HttpServletResponse) response);\n    List&lt;Filter&gt; filters &#x3D; getFilters(fwRequest);\n    if (filters &#x3D;&#x3D; null || filters.size() &#x3D;&#x3D; 0) &#123;\n        if (logger.isDebugEnabled()) &#123;\n            logger.debug(UrlUtils.buildRequestUrl(fwRequest)\n                    + (filters &#x3D;&#x3D; null ? &quot; has no matching filters&quot;\n                            : &quot; has an empty filter list&quot;));\n        &#125;\n        fwRequest.reset();\n        chain.doFilter(fwRequest, fwResponse);\n        return;\n    &#125;\n    VirtualFilterChain vfc &#x3D; new VirtualFilterChain(fwRequest, chain, filters);\n    vfc.doFilter(fwRequest, fwResponse);\n&#125;\nprivate List&lt;Filter&gt; getFilters(HttpServletRequest request) &#123;\n    for (SecurityFilterChain chain : filterChains) &#123;\n        if (chain.matches(request)) &#123;\n            return chain.getFilters();\n        &#125;\n    &#125;\n    return null;\n&#125;\n\ndoFilterInternal 方法就比较重要了：\n\n首先将请求封装为一个 FirewalledRequest 对象，在这个封装的过程中，也会判断请求是否合法。\n对响应进行封装。\n调用 getFilters 方法找到过滤器链。该方法根据当前请求，从 filterChains 中找到对应的过滤器链，然后由该过滤器链去处理请求。\n如果找出来的 filters 为 null，或者集合中没有元素，那就是说明当前请求不需要经过过滤器。直接执行 chain.doFilter ，这个就又回到原生过滤器中去了。那么什么时候会发生这种情况呢？那就是针对项目中的静态资源，如果我们配置了资源放行，那么当你请求 这些资源时就会走到这里来，也就是说这个不经过 Spring Security Filter。\n如果查询到的 filters 中是有值的，那么这个 filters 集合中存放的就是我们要经过的过滤器链了。此时它会构造出一个虚拟的过滤器链 VirtualFilterChain 出来，并执行其中的 doFilter 方法。\n\n\n   \n\n\n那么接下来我们就来看看 VirtualFilterChain：\n&#x2F;&#x2F;\n&#x2F;&#x2F; Source code recreated from a .class file by IntelliJ IDEA\n&#x2F;&#x2F; (powered by FernFlower decompiler)\n&#x2F;&#x2F;\n\npackage org.springframework.security.web;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.web.firewall.FirewalledRequest;\nimport org.springframework.security.web.firewall.HttpFirewall;\nimport org.springframework.security.web.firewall.StrictHttpFirewall;\nimport org.springframework.security.web.util.UrlUtils;\nimport org.springframework.web.filter.GenericFilterBean;\n\npublic class FilterChainProxy extends GenericFilterBean &#123;\n    private static final Log logger &#x3D; LogFactory.getLog(FilterChainProxy.class);\n    private static final String FILTER_APPLIED &#x3D; FilterChainProxy.class.getName().concat(&quot;.APPLIED&quot;);\n    private List&lt;SecurityFilterChain&gt; filterChains;\n    private FilterChainProxy.FilterChainValidator filterChainValidator;\n    private HttpFirewall firewall;\n\n    ...\n\n        public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException &#123;\n            if (this.currentPosition &#x3D;&#x3D; this.size) &#123;\n                if (FilterChainProxy.logger.isDebugEnabled()) &#123;\n                    FilterChainProxy.logger.debug(UrlUtils.buildRequestUrl(this.firewalledRequest) + &quot; reached end of additional filter chain; proceeding with original chain&quot;);\n                &#125;\n\n                this.firewalledRequest.reset();\n                this.originalChain.doFilter(request, response);\n            &#125; else &#123;\n                ++this.currentPosition;\n                Filter nextFilter &#x3D; (Filter)this.additionalFilters.get(this.currentPosition - 1);\n                if (FilterChainProxy.logger.isDebugEnabled()) &#123;\n                    FilterChainProxy.logger.debug(UrlUtils.buildRequestUrl(this.firewalledRequest) + &quot; at position &quot; + this.currentPosition + &quot; of &quot; + this.size + &quot; in additional filter chain; firing Filter: &#39;&quot; + nextFilter.getClass().getSimpleName() + &quot;&#39;&quot;);\n                &#125;\n\n                nextFilter.doFilter(request, response, this);\n            &#125;\n\n        &#125;\n    &#125;\n&#125;\n\n\n\nVirtualFilterChain 类中首先声明了 5 个全局属性，originalChain 表示原生的过滤器链，也就是 Web Filter；additionalFilters 表示 Spring Security 中的过滤器链；firewalledRequest 表示当前请求；size 表示过滤器链中过滤器的个数；currentPosition 则是过滤器链遍历时候的下标。\ndoFilter 方法就是 Spring Security 中过滤器挨个执行的过程，如果 currentPosition == size，表示过滤器链已经执行完毕，此时通过调用 originalChain.doFilter 进入到原生过滤链方法中，同时也退出了 Spring Security 过滤器链。否则就从 additionalFilters 取出 Spring Security 过滤器链中的一个个过滤器，挨个调用 doFilter 方法。\n\n最后，FilterChainProxy 中还定义了 FilterChainValidator 接口及其实现：\npublic interface FilterChainValidator &#123;\n    void validate(FilterChainProxy filterChainProxy);\n&#125;\nprivate static class NullFilterChainValidator implements FilterChainValidator &#123;\n    @Override\n    public void validate(FilterChainProxy filterChainProxy) &#123;\n    &#125;\n&#125;\n\n实际上这个实现并未做任何事情。\n（下面介绍的是FilterChainProxy 中12个过滤器的部分）\n3、用户名密码认证过滤器UsernamePasswordAuthenticationFilter\nusername中会加载数据库中的数据进行比较\n\n    \n\n\n加载数据库中的数据时，DaoAuthenticationProvider 中 retrieveUser（检索用户）方法会被调用\nprotected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123;\n    this.prepareTimingAttackProtection();\n\n    try &#123;\n        &lt;!--注意这里，获取用户--&gt;\n        UserDetails loadedUser &#x3D; this.getUserDetailsService().loadUserByUsername(username);\n        if (loadedUser &#x3D;&#x3D; null) &#123;\n            throw new InternalAuthenticationServiceException(&quot;UserDetailsService returned null, which is an interface contract violation&quot;);\n        &#125; else &#123;\n            return loadedUser;\n        &#125;\n    &#125; catch (UsernameNotFoundException var4) &#123;\n        this.mitigateAgainstTimingAttack(authentication);\n        throw var4;\n    &#125; catch (InternalAuthenticationServiceException var5) &#123;\n        throw var5;\n    &#125; catch (Exception var6) &#123;\n        throw new InternalAuthenticationServiceException(var6.getMessage(), var6);\n    &#125;\n&#125;\n\n它调用了自身的getUserDetailsService方法\nprotected UserDetailsService getUserDetailsService() &#123;\n    return this.userDetailsService;\n&#125;\n\n返回的userDetailsService是DaoAuthenticationProvider自身定义的UserDetailsService的对象\nprivate static final String USER_NOT_FOUND_PASSWORD &#x3D; &quot;userNotFoundPassword&quot;;\nprivate PasswordEncoder passwordEncoder;\nprivate volatile String userNotFoundEncodedPassword;\n&lt;!--这里--&gt;\nprivate UserDetailsService userDetailsService;\n\n而UserDetailsService，是一个接口，有一个抽象的方法\npublic interface UserDetailsService &#123;\n    UserDetails loadUserByUsername(String var1) throws UsernameNotFoundException;\n&#125;\n\n在我们的web中，我们实现了这个接口，因为我们在xml提供了认证者，也就是下面的类，所以说security会拿到认证者，然后进行调用\n@Component\npublic class SecurityUserServiceImpl implements UserDetailsService &#123;\n\n    @Reference\n    private UserService userService;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        &#x2F;&#x2F;根据名字获取用户信息\n        User user &#x3D; userService.getUserByName(username);\n\n        if (user &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n\n        &#x2F;&#x2F;新建用户权限集合\n        List&lt;GrantedAuthority&gt; authorityList &#x3D; new ArrayList&lt;&gt;();\n\n        &#x2F;&#x2F;查询用户相应权限\n        Set&lt;Role&gt; roles &#x3D; user.getRoles();\n        for (Role role : roles) &#123;\n            Set&lt;Permission&gt; permissions &#x3D; role.getPermissions();\n            for (Permission permission : permissions) &#123;\n                authorityList.add(new SimpleGrantedAuthority(permission.getKeyword()));\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F;将数据返回给权限框架，在内部进行比较\n        return new org.springframework.security.core.userdetails.User(username, user.getPassword(), authorityList);\n    &#125;\n&#125;\n\n\n\n\n4、LogoutFilter\n    \n\n\n\n\n","slug":"59-Spring Security-源码剖析","date":"2021-09-13T15:36:32.000Z","categories_index":"Spring","tags_index":"Spring","author_index":"大黄"},{"id":"57895ac4a5b71846b764434fcb138119","title":"SpringSecurity 权限管理","content":":open_umbrella: 权限控制\n1、认证和授权的概念前面我们已经完成了旅游后台管理系统的部分功能，例如自由行管理、跟团游管理、套餐管理、预约设置等。接下来我们需要思考2个问题：\n问题1：在生产环境下我们如果不登录后台系统就可以完成这些功能操作吗？\n答案显然是否定的，要操作这些功能必须首先登录到系统才可以。（用户登录系统–&gt;认证）\n问题2：是不是所有用户，只要登录成功就都可以操作所有功能呢？\n答案是否定的，并不是所有的用户都可以操作这些功能。不同的用户可能拥有不同的权限，这就需要进行授权了。（用户登录之后，对每个用户进行授权，通过授权去访问系统中不同的功能–&gt;授权）\n认证：系统提供的用于识别用户身份的功能，通常提供用户名和密码进行登录其实就是在进行认证，认证的目的是让系统知道你是谁。\n授权：用户认证成功后，需要为用户授权，其实就是指定当前用户可以操作哪些功能。\n2、权限模块的数据模型前面已经分析了认证和授权的概念，要实现最终的权限控制，需要有一套表结构支撑：\n用户表 t_user       权限表 t_permission       角色表 t_role        用户角色关系表 t_user_role       角色权限关系表 t_role_permission\nRBAC（Role-Based Access Control，基于角色的访问控制），就是用户通过角色与权限进行关联。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般者是多对多的关系。（如下图）\n\n    \n\n\n\n角色是什么？\n可以理解为一定数量的权限的集合，权限的载体。\n例如：一个论坛系统，“超级管理员”、“版主”都是角色。版主可管理版内的帖子、可管理版内的用户等，这些是权限。要给某个用户授予这些权限，不需要直接将权限授予用户，可将“版主”这个角色赋予该用户。\n权限表现成什么？\n在应用系统中，对功能模块的操作，对上传文件的删改，菜单的访问，甚至页面上某个按钮、某个图片的可见性控制，都可属于权限的范畴。\n具体过程？\n认证过程：只需要用户表就可以了，在用户登录时可以查询用户表t_user进行校验，判断用户输入的用户名和密码是否正确。\n授权过程：用户必须完成认证之后才可以进行授权，首先可以根据用户查询其角色t_role，再根据角色查询对应的权限t_permission以及资源(如：t_menu)。\n3、权限模块数据模型的扩展\n    \n\n\n\n权限表现成什么？\n​        在应用系统中，对功能模块的操作，对上传文件的删改，菜单的访问，甚至页面上某个按钮、某个图片的可见性控制，都可属于权限的范畴。有些权限设计，会把功能操作作为一类，而把文件、菜单、页面元素等作为另一类，这样构成“用户-角色-权限-资源”的授权模型。而在做数据表建模时，可把功能操作和资源统一管理，也就是都直接与权限表进行关联，这样可能更具便捷性和易扩展性。如“T_MENU”表示菜单的访问权限、“T_ELEMENT”表示页面元素的可见性、“T_FILE”表示文件的修改权限、“T_OPERATION”表示功能模块的操作权限控制等。\n以上模型作为基准模型，在实际的生产环境中可能会有变化，需要灵活掌握。如：\n​        建立角色组，对角色进行分类管理，但角色组不参与权限分配。\n​        建立用户组，对用户进行层级，分类管理。便于新增用户进行授权。\n​        建立用户和权限的多对多关联，实现ACL模型权限控制。\n​        本项目中将角色和菜单直接进行关联，便于查询该用户角色下的菜单权限集合。\n4、表之间关系用户和角色是多对多关系     权限和角色是多对多关系      菜单和权限是多对多关系\n\n\n\n:open_umbrella: Spring Security\n1、Spring Security简介Spring Security是 Spring提供的安全认证服务的框架。 使用Spring Security可以帮助我们来简化认证和授权的过程。\nSpringSecurity内部封装了Filter（只需要在web.xml容器中配置一个过滤器–代理过滤器，真实的过滤器在spring的容器中配置）\n官网：https://spring.io/projects/spring-security/  \n中文官网：https://www.w3cschool.cn/springsecurity/ \n&lt;!--maven坐标如下--&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.security&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;spring-security-web&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.security&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;spring-security-config&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n常见的安全框架：Spring的 SpringSecurity，Apache的Shiro http://shiro.apache.org/\n2、Spring Security初体验首先我们为 Spring Security 专门建立一个 Spring 的配置文件，该文件就专门用来作为 Spring Security 的配置。\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n  xmlns:security&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security&quot;\n  xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n  xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n          http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-3.1.xsd\n          http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security\n          http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security&#x2F;spring-security-3.1.xsd&quot;&gt;\n\n&lt;&#x2F;beans&gt;\n\nSpring Security 命名空间的引入可以简化我们的开发，它涵盖了大部分 Spring Security 常用的功能。它的设计是基于框架内大范围的依赖的，可以被划分为以下几块。\n\nWeb/Http 安全：这是最复杂的部分。通过建立 filter 和相关的 service bean 来实现框架的认证机制。当访问受保护的 URL 时会将用户引入登录界面或者是错误提示界面。\n业务对象或者方法的安全：控制方法访问权限的。\nAuthenticationManager：处理来自于框架其他部分的认证请求。\nAccessDecisionManager：为 Web 或方法的安全提供访问决策。会注册一个默认的，但是我们也可以通过普通 bean 注册的方式使用自定义的 AccessDecisionManager。\nAuthenticationProvider：AuthenticationManager 是通过它来认证用户的。\nUserDetailsService：跟 AuthenticationProvider 关系密切，用来获取用户信息的。\n\n① http 元素是用于定义 Web 相关权限控制的，security 只是我们使用命名空间的一个前缀。\n&lt;security:http auto-config&#x3D;&quot;true&quot;&gt;\n   &lt;security:intercept-url pattern&#x3D;&quot;&#x2F;**&quot; access&#x3D;&quot;ROLE_USER&quot;&#x2F;&gt;\n&lt;&#x2F;security:http&gt; \n\n可能你会奇怪，我们没有建立登录页面，为什么 Spring Security 会跳到登录页面呢？这是我们设置 http 的 auto-config=”true” 时 Spring Security 自动为我们生成的。\n当指定 http 元素的 auto-config=”true” 时，就相当于如下内容的简写。这些元素负责建立表单登录、基本的认证和登出处理。它们都可以通过指定对应的属性来改变它们的行为。\n&lt;security:http&gt;\n   &lt;security:form-login&#x2F;&gt;\n   &lt;security:http-basic&#x2F;&gt;\n   &lt;security:logout&#x2F;&gt;\n&lt;&#x2F;security:http&gt;\n\nintercept-url 定义了一个权限控制的规则。\npattern 属性表示我们将对哪些 url 进行权限控制，其也可以是一个正则表达式，如上的写法表示我们将对所有的 URL 进行权限控制\naccess 属性表示在请求对应的 URL 时需要什么权限，默认配置时它应该是一个以逗号分隔的角色列表，请求的用户只需拥有其中的一个角色就能成功访问对应的 URL。这里的 “ROLE_USER” 表示请求的用户应当具有 ROLEUSER 角色。\n“ROLE” 前缀是一个提示 Spring 使用基于角色的检查的标记。\n② 有了权限控制的规则，我们需要定义一个 AuthenticationManager 用于认证\n&lt;security:authentication-manager&gt;\n    &lt;security:authentication-provider&gt;\n        &lt;security:user-service&gt;\n            &lt;security:user name&#x3D;&quot;user&quot; password&#x3D;&quot;user&quot; authorities&#x3D;&quot;ROLE_USER&quot;&#x2F;&gt;\n            &lt;security:user name&#x3D;&quot;admin&quot; password&#x3D;&quot;admin&quot; authorities&#x3D;&quot;ROLE_USER, ROLE_ADMIN&quot;&#x2F;&gt;\n        &lt;&#x2F;security:user-service&gt;\n    &lt;&#x2F;security:authentication-provider&gt; \n&lt;&#x2F;security:authentication-manager&gt;\n\nauthentication-manager 元素指定了一个 AuthenticationManager\n其需要一个 AuthenticationProvider（对应 authentication-provider 元素）来进行真正的认证，默认情况下 authentication-provider 对应一个 DaoAuthenticationProvider，其需要 UserDetailsService（对应 user-service 元素）来获取用户信息 UserDetails（对应 user 元素）。这里我们只是简单的使用 user 元素来定义用户，而实际应用中这些信息通常都是需要从数据库等地方获取的，这个将放到后续再讲。我们可以看到通过 user 元素我们可以指定 user 对应的用户名、密码和拥有的权限。user-service 还支持通过 properties 文件来指定用户信息，如：\n&lt;security:user-service properties&#x3D;&quot;&#x2F;WEB-INF&#x2F;config&#x2F;users.properties&quot;&#x2F;&gt;\n\n其中属性文件应遵循如下格式：\nusername&#x3D;password,grantedAuthority[,grantedAuthority][,enabled|disabled]\n\n所以，对应上面的配置文件，我们的 users.properties 文件的内容应该如下所示：\n#username&#x3D;password,grantedAuthority[,grantedAuthority][,enabled|disabled]\nuser&#x3D;user,ROLE_USER\nadmin&#x3D;admin,ROLE_USER,ROLE_ADMIN\n\n至此，我们的 Spring Security 配置文件的配置就完成了。完整配置文件将如下所示。\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n  xmlns:security&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security&quot;\n  xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n  xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n          http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-3.1.xsd\n          http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security\n          http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security&#x2F;spring-security-3.1.xsd&quot;&gt;\n\n   &lt;security:http auto-config&#x3D;&quot;true&quot;&gt;\n      &lt;security:intercept-url pattern&#x3D;&quot;&#x2F;**&quot; access&#x3D;&quot;ROLE_USER&quot;&#x2F;&gt;\n   &lt;&#x2F;security:http&gt;    \n\n   &lt;security:authentication-manager&gt;\n      &lt;security:authentication-provider&gt;\n         &lt;security:user-service&gt;\n            &lt;security:user name&#x3D;&quot;user&quot; password&#x3D;&quot;user&quot; authorities&#x3D;&quot;ROLE_USER&quot;&#x2F;&gt;\n            &lt;security:user name&#x3D;&quot;admin&quot; password&#x3D;&quot;admin&quot; authorities&#x3D;&quot;ROLE_USER, ROLE_ADMIN&quot;&#x2F;&gt;\n         &lt;&#x2F;security:user-service&gt;\n      &lt;&#x2F;security:authentication-provider&gt;\n   &lt;&#x2F;security:authentication-manager&gt;\n\n&lt;&#x2F;beans&gt;\n\n之后我们告诉 Spring 加载这个配置文件。通常，我们可以在 web.xml 文件中通过 context-param 把它指定为 Spring 的初始配置文件，也可以在对应 Spring 的初始配置文件中引入它。这里我们采用前者。\n&lt;context-param&gt;\n   &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n   &lt;param-value&gt;&#x2F;WEB-INF&#x2F;config&#x2F;applicationContext.xml,&#x2F;WEB-INF&#x2F;config&#x2F;spring-security.xml&lt;&#x2F;param-value&gt;\n&lt;&#x2F;context-param&gt;\n\n&lt;listener&gt;\n   &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;\n&lt;&#x2F;listener&gt;\n\nSpring 的配置文件是通过对应的 ContextLoaderListener 来加载和初始化的，上述代码中的 applicationContext.xml 文件就是对应的 Spring 的配置文件，如果没有可以不用配置。\n接下来我们还需要在 web.xml 中定义一个 filter 用来拦截需要交给 Spring Security 处理的请求，需要注意的是该 filter 一定要定义在其它如 SpringMVC 等拦截请求之前。这里我们将拦截所有的请求，具体做法如下所示：\n\n\n\n\n\n\n\n\n\nDelegatingFilterProxy用于整合第三方框架（代理过滤器，非真正的过滤器，真正的过滤器需要在spring的配置文件）\n整合Spring Security时过滤器的名称必须为springSecurityFilterChain，否则会抛出NoSuchBeanDefinitionException异常\n&lt;filter&gt;\n   &lt;filter-name&gt;springSecurityFilterChain&lt;&#x2F;filter-name&gt;\n   &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;&#x2F;filter-class&gt;\n&lt;&#x2F;filter&gt;\n&lt;filter-mapping&gt;\n   &lt;filter-name&gt;springSecurityFilterChain&lt;&#x2F;filter-name&gt;\n   &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;filter-mapping&gt;\n\n\n\n总体代码（web.xml）\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_0.xsd&quot;\n         id&#x3D;&quot;WebApp_ID&quot; version&#x3D;&quot;3.0&quot;&gt;\n\n    &lt;filter&gt;\n        &lt;!--\n         1：DelegatingFilterProxy用于整合第三方框架（代理过滤器，非真正的过滤器，真正的过滤器需要在spring的配置文件）\n          整合Spring Security时过滤器的名称必须为springSecurityFilterChain，\n          否则会抛出NoSuchBeanDefinitionException异常\n        --&gt;\n        &lt;filter-name&gt;springSecurityFilterChain&lt;&#x2F;filter-name&gt;\n        &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;&#x2F;filter-class&gt;\n    &lt;&#x2F;filter&gt;\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;springSecurityFilterChain&lt;&#x2F;filter-name&gt;\n        &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n    &lt;&#x2F;filter-mapping&gt;\n    &lt;!-- 2：springmvc的核心控制器--&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;\n        &lt;!-- 指定加载的配置文件 ，通过参数contextConfigLocation加载 --&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n            &lt;param-value&gt;classpath:spring-security.xml&lt;&#x2F;param-value&gt;\n        &lt;&#x2F;init-param&gt;\n        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;\n    &lt;&#x2F;servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;\n        &lt;url-pattern&gt;*.do&lt;&#x2F;url-pattern&gt;\n    &lt;&#x2F;servlet-mapping&gt;\n&lt;&#x2F;web-app&gt;\n\n总体代码（spring-security.xml）\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:dubbo&#x3D;&quot;http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&quot;\n       xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;\n       xmlns:security&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n                  http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n                  http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc\n                  http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd\n                  http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo\n                  http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd\n                  http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context\n                  http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd\n                          http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security\n                          http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security&#x2F;spring-security.xsd&quot;&gt;\n\n     &lt;!--\n       ① 配置哪些链接可以放行(没有认证通过也可以访问的资源)\n       security&#x3D;&quot;none&quot;：没有权限\n       pattern&#x3D;&quot;&#x2F;login.html&quot;：没有任何权限，可以访问login.html\n     --&gt;\n    &lt;!--&lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;login.html&quot;&gt;&lt;&#x2F;security:http&gt;--&gt;\n\n    &lt;!--\n    ② 定义哪些链接不可以放行(必须通过认证才能访问的资源)，及需要有角色，有权限才可以放行访问资源\n    &lt;security:http auto-config&#x3D;&quot;true&quot; use-expressions&#x3D;&quot;true&quot;&gt;\n          auto-config&#x3D;&quot;true&quot;:开启自动配置 由springsecurity提供登录页面，提供登录的url地址，退出的url地址\n          use-expressions&#x3D;&quot;true&quot;：使用表达式的方式控制权限\n             security:intercept-url：定义哪些链接不可以放行，需要当前角色和权限才能放行\n                pattern&#x3D;&quot;&#x2F;**&quot;：要求系统中的所有资源，都必须通过角色和权限才能访问\n                access：指定角色和权限\n                   如果使用表达式use-expressions&#x3D;&quot;true&quot;\n                       access&#x3D;&quot;hasRole(&#39;ROLE_ADMIN&#39;)：表示具有ROLE_ADMIN的角色才能访问系统的资源\n                   如果不使用表达式use-expressions&#x3D;&quot;false&quot;\n                       access&#x3D;&quot;ROLE_ADMIN：表示具有ROLE_ADMIN的角色才能访问系统的资源\n    --&gt;\n    &lt;security:http auto-config&#x3D;&quot;true&quot; use-expressions&#x3D;&quot;true&quot;&gt;\n        &lt;security:intercept-url pattern&#x3D;&quot;&#x2F;**&quot; access&#x3D;&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot;&gt;&lt;&#x2F;security:intercept-url&gt;\n    &lt;&#x2F;security:http&gt;\n\n    &lt;!--\n      ③ 认证管理：定义登录账号和密码，并授予当前用户访问的角色或权限\n        （1）：将用户名和密码：当前用户具有的角色，写死到配置文件中（现在:入门）\n                security:user name&#x3D;&quot;admin&quot; :登录名\n                authorities&#x3D;&quot;ROLE_ADMIN&quot;   ：角色(ROLE_ADMIN),权限\n                password&#x3D;&quot;admin&quot;          ：密码\n         （2）：用户名和密码，当前用户具有的角色，从数据库中查询（后续）\n    --&gt;\n    &lt;security:authentication-manager&gt;\n        &lt;security:authentication-provider&gt;\n            &lt;security:user-service&gt;\n                &lt;security:user name&#x3D;&quot;admin&quot; authorities&#x3D;&quot;ROLE_ADMIN&quot; password&#x3D;&quot;admin&quot;&gt;&lt;&#x2F;security:user&gt;\n            &lt;&#x2F;security:user-service&gt;\n        &lt;&#x2F;security:authentication-provider&gt;\n    &lt;&#x2F;security:authentication-manager&gt;\n&lt;&#x2F;beans&gt;\n\n入门案例里面没有指定密码加密方式的. 配置密码的时候的加**{noop}**\nsecurity:user-service&gt;\n  &lt;security:user name&#x3D;&quot;admin&quot; password&#x3D;&quot;&#123;noop&#125;admin&quot; authorities&#x3D;&quot;ROLE_ADMIN&quot;&#x2F;&gt;\n&lt;&#x2F;security:user-service&gt;\n\n加密的方式\n&lt;security:authentication-manager&gt;\n    &lt;!-- authentication-provider：认证提供者，执行具体的认证逻辑  --&gt;\n    &lt;security:authentication-provider&gt;\n\t\t&lt;security:user name&#x3D;&quot;admin&quot; authorities&#x3D;&quot;ROLE_ADMIN&quot; password&#x3D;&quot;admin&quot;&gt;&lt;&#x2F;security:user&gt;\n        \n        &lt;!--指定密码加密策略--&gt;\n        &lt;security:password-encoder ref&#x3D;&quot;passwordEncoder&quot;&gt;&lt;&#x2F;security:password-encoder&gt;\n\n    &lt;&#x2F;security:authentication-provider&gt;\n\n&lt;&#x2F;security:authentication-manager&gt;\n\n&lt;!--配置密码加密对象--&gt;\n&lt;bean id&#x3D;&quot;passwordEncoder&quot; class&#x3D;&quot;org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder&quot; &#x2F;&gt;\n\npublic class UserService implements UserDetailsService &#123;\n\n    &#x2F;&#x2F;模拟数据库中的用户数据\n    static Map&lt;String, User&gt; map &#x3D; new HashMap&lt;String, User&gt;();\n\n    static &#123;\n        com.atguigu.pojo.User user1 &#x3D; new com.atguigu.pojo.User();\n        user1.setUsername(&quot;admin&quot;);\n        user1.setPassword(&quot;admin&quot;);\n        user1.setTelephone(&quot;123&quot;);\n\n        com.atguigu.pojo.User user2 &#x3D; new com.atguigu.pojo.User();\n        user2.setUsername(&quot;zhangsan&quot;);\n        user2.setPassword(&quot;123&quot;);\n        user2.setTelephone(&quot;321&quot;);\n\n        map.put(user1.getUsername(), user1);\n        map.put(user2.getUsername(), user2);\n    &#125;\n\n    @Override\n    public UserDetails loadUserByUsername(String name) throws UsernameNotFoundException &#123;\n        User userInDb &#x3D; map.get(name);\n        if (userInDb &#x3D;&#x3D; null) &#123;\n            &#x2F;&#x2F;根据用户名没有查询到用户，抛出异常，表示登录名输入有误\n            return null;\n        &#125;\n\n        String password &#x3D; userInDb.getPassword();\n\n        List&lt;GrantedAuthority&gt; list &#x3D; new ArrayList&lt;&gt;();\n        SimpleGrantedAuthority role_user &#x3D; new SimpleGrantedAuthority(&quot;ROLE_USER&quot;);\n        SimpleGrantedAuthority add &#x3D; new SimpleGrantedAuthority(&quot;ADD&quot;);\n        SimpleGrantedAuthority del &#x3D; new SimpleGrantedAuthority(&quot;DEL&quot;);\n        SimpleGrantedAuthority query &#x3D; new SimpleGrantedAuthority(&quot;QUERY&quot;);\n        list.add(role_user);\n        list.add(add);\n        list.add(del);\n        list.add(query);\n\n        &lt;!--对数据库中的密码进行加密--&gt;\n        &#x2F;&#x2F;String encodePassword &#x3D; new BCryptPasswordEncoder().encode(password);\n\n        &lt;!--若配置了加密，就使用者一句代码，没使用就不用，还要给encodePassword前加上&#123;noop&#125;--&gt;\n        return new org.springframework.security.core.userdetails.User(name, encodePassword, list);\n    &#125;\n&#125;\n\n\n\n3、Spring Security执行流程\n\n    \n\n\n\n\n\n4、问题在配置类中配置，我们就要指定 PasswordEncoder 了，这是一个非常关键的东西。\n考虑到有的小伙伴对于 PasswordEncoder 还不太熟悉，因此，我这里先稍微给大家介绍一下 PasswordEncoder 到底是干嘛用的。要说 PasswordEncoder ，就得先说密码加密。\n为什么要加密？2011 年 12 月 21 日，有人在网络上公开了一个包含 600 万个 CSDN 用户资料的数据库，数据全部为明文储存，包含用户名、密码以及注册邮箱。事件发生后 CSDN 在微博、官方网站等渠道发出了声明，解释说此数据库系 2009 年备份所用，因不明原因泄露，已经向警方报案，后又在官网发出了公开道歉信。在接下来的十多天里，金山、网易、京东、当当、新浪等多家公司被卷入到这次事件中。整个事件中最触目惊心的莫过于 CSDN 把用户密码明文存储，由于很多用户是多个网站共用一个密码，因此一个网站密码泄露就会造成很大的安全隐患。由于有了这么多前车之鉴，我们现在做系统时，密码都要加密处理。\n这次泄密，也留下了一些有趣的事情，特别是对于广大程序员设置密码这一项。人们从 CSDN 泄密的文件中，发现了一些好玩的密码，例如如下这些：\n\nppnn13%dkstFeb.1st 这段密码的中文解析是：娉娉袅袅十三余，豆蔻梢头二月初。\ncsbt34.ydhl12s 这段密码的中文解析是：池上碧苔三四点，叶底黄鹂一两声\n…\n\n等等不一而足，你会发现很多程序员的人文素养还是非常高的，让人啧啧称奇。\n加密方案密码加密我们一般会用到散列函数，又称散列算法、哈希函数，这是一种从任何数据中创建数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来，然后将数据打乱混合，重新创建一个散列值。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。我们常用的散列函数有 MD5 消息摘要算法、安全散列算法（Secure Hash Algorithm）。\n但是仅仅使用散列函数还不够，为了增加密码的安全性，一般在密码加密过程中还需要加盐，所谓的盐可以是一个随机数也可以是用户名，加密之后，即使密码明文相同的用户生成的密码密文也不相同，这可以极大的提高密码的安全性。但是传统的加盐方式需要在数据库中有专门的字段来记录盐值，这个字段可能是用户名字段（因为用户名唯一），也可能是一个专门记录盐值的字段，这样的配置比较繁琐。\nSpring Security 提供了多种密码加密方案，官方推荐使用 BCryptPasswordEncoder，BCryptPasswordEncoder 使用 BCrypt 强哈希函数，开发者在使用时可以选择提供 strength 和 SecureRandom 实例。strength 越大，密钥的迭代次数越多，密钥迭代次数为 2^strength。strength 取值在 4~31 之间，默认为 10。\n不同于 Shiro 中需要自己处理密码加盐，在 Spring Security 中，BCryptPasswordEncoder 就自带了盐，处理起来非常方便。\n而 BCryptPasswordEncoder 就是 PasswordEncoder 接口的实现类。\n:open_umbrella: ​Spring集成 Spring Security\n1、配置匿名访问资源 http：用于定义相关权限控制\nsecurity=”none”：没有权限\npattern=””：可以访问的地址，可以使用通配符\n&lt;!--开启匿名访问的资源--&gt;\n&lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;css&#x2F;**&quot;&#x2F;&gt;\n&lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;img&#x2F;**&quot;&#x2F;&gt;\n&lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;js&#x2F;**&quot;&#x2F;&gt;\n&lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;plugins&#x2F;**&quot;&#x2F;&gt;\n&lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;login.html&quot;&#x2F;&gt;\n\n\n\n2、form-login元素介绍http 元素下的 form-login 元素是用来定义表单登录信息的。当我们什么属性都不指定的时候 Spring Security 会为我们生成一个默认的登录页面。如果不想使用默认的登录页面，我们可以指定自己的登录页面。\n3、form-login的几个属性\n\n\n属性\n释义\n\n\n\nform-login\n定义表单登录信息\n\n\nlogin-page=”/login.html”\n表示指定登录页\n\n\nusername-parameter=”username”\n使用登录名的名称，默认值是username\n\n\npassword-parameter=”password”\n使用登录名的密码，默认值是password\n\n\nlogin-processing-url=”/login.do”\n表示登录的url地址\n\n\ndefault-target-url=”/index.html”\n登录成功后的url地址\n\n\nauthentication-failure-url=”/login.html”\n认证失败后跳转的url地址，失败后指定/login.html\n\n\nalways-use-default-target=”true”\n登录成功后，始终跳转到default-target-url指定的地址，即登录成功的默认地址\n\n\n&lt;security:form-login login-page&#x3D;&quot;&#x2F;login.html&quot;\n                     login-processing-url&#x3D;&quot;&#x2F;login.do&quot;\n                     username-parameter&#x3D;&quot;username&quot;\n                     password-parameter&#x3D;&quot;password&quot;\n                     default-target-url&#x3D;&quot;&#x2F;pages&#x2F;main.html&quot;\n                     authentication-failure-url&#x3D;&quot;&#x2F;login.html&quot;\n                     always-use-default-target&#x3D;&quot;true&quot;\n                     &#x2F;&gt;\n\n&lt;security:csrf disabled&#x3D;&quot;true&quot;&#x2F;&gt;\n\ncsrf：对应CsrfFilter过滤器\ndisabled：是否启用CsrfFilter过滤器，如果使用==自定义登录页面需要关闭此项==，否则登录操作会被禁用（403）\nSpring-security采用盗链机制，其中_csrf使用token标识和随机字符，每次访问页面都会随机生成，然后和服务器进行比较，成功可以访问，不成功不能访问。\n4、使用数据库查询的信息认证管理，定义登录账号名和密码，并授予访问的角色、权限\nauthentication-manager：认证管理器，用于处理认证操作\n&lt;!--对继承UserDetailsService的认证提供者使用注解，@component，进行扫描，就能直接注入--&gt;\n&lt;context:component-scan base-package&#x3D;&quot;com.atguigu&quot;&#x2F;&gt;\n\n&lt;security:authentication-manager&gt;\n\n    &lt;!-- authentication-provider：认证提供者，执行具体的认证逻辑 --&gt;\n\n    &lt;security:authentication-provider user-service-ref&#x3D;&quot;userService&quot;&#x2F;&gt;\n\n&lt;&#x2F;security:authentication-manager&gt;\n\n==下面代码中引用了 service，这个引用是dubbo中的注解，因为我们要使用userService，所以在配置中，我们一定要修改dubbo扫描的包，让其也扫描到SecurityUserServiceImpl所在的包==\n@Component\npublic class SecurityUserServiceImpl implements UserDetailsService &#123;\n\n    @Reference\n    private UserService userService;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        &#x2F;&#x2F;根据名字获取用户信息\n        User user &#x3D; userService.getUserByName(username);\n\n        if (user &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n\n        &#x2F;&#x2F;新建用户权限集合\n        List&lt;GrantedAuthority&gt; authorityList &#x3D; new ArrayList&lt;&gt;();\n\n        &#x2F;&#x2F;查询用户相应权限\n        Set&lt;Role&gt; roles &#x3D; user.getRoles();\n        for (Role role : roles) &#123;\n            Set&lt;Permission&gt; permissions &#x3D; role.getPermissions();\n            for (Permission permission : permissions) &#123;\n                authorityList.add(new SimpleGrantedAuthority(permission.getKeyword()));\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F;将数据返回给权限框架，在内部进行比较\n        return new org.springframework.security.core.userdetails.User(username, user.getPassword(), authorityList);\n    &#125;\n&#125;\n\n\ndao层进行具体查询逻辑处理时需要注意！！！使用分步查询，注意sql及resultMap的映射\n\n这里返回给框架的User 不是我们定义的pojo中的，而是框架提供的User类：org.springframework.security.core.userdetails.User\n\n\n5、密码加密解密前面我们使用的密码都是明文的，这是非常不安全的。一般情况下用户的密码需要进行加密后再保存到数据库中。\n常见的密码加密方式有：\n\n3DES、AES、DES：使用对称加密算法，可以通过解密来还原出原始密码\n\nMD5、SHA1：使用单向HASH算法，无法通过计算还原出原始密码，但是可以建立彩虹表进行查表破解\n\n\nMD5可进行加盐加密，保证安全\npublic class TestMD5 &#123;\n    @Test\n    public void testMD5()&#123;\n        &#x2F;&#x2F; 密码同样是1234却变成了密码不相同\n        System.out.println(MD5Utils.md5(&quot;1234xiaowang&quot;)); &#x2F;&#x2F;a8231077b3d5b40ffadee7f4c8f66cb7\n        System.out.println(MD5Utils.md5(&quot;1234xiaoli&quot;)); &#x2F;&#x2F;7d5250d8620fcdb53b25f96a1c7be591\n    &#125;\n&#125;\n\n同样的密码值，盐值不同，加密的结果不同。\nbcrypt：将salt随机并混入最终加密后的密码，验证时也无需单独提供之前的salt，从而无需单独处理salt问题\n==spring security中的BCryptPasswordEncoder方法采用SHA-256 +随机盐+密钥对密码进行加密==。SHA系列是Hash算法，不是加密算法，使用加密算法意味着可以解密（这个与编码/解码一样），但是采用Hash处理，其过程是不可逆的。\n\n加密(encode)：注册用户时，使用SHA-256+随机盐+密钥把用户输入的密码进行hash处理，得到密码的hash值，然后将其存入数据库中。\n密码匹配(matches)：用户登录时，密码匹配阶段并没有进行密码解密（因为密码经过Hash处理，是不可逆的），而是使用相同的算法把用户输入的密码进行hash处理，得到密码的hash值，然后将其与从数据库中查询到的密码hash值进行比较。如果两者相同，说明用户输入的密码正确。\n\n这正是为什么处理密码时要用hash算法，而不用加密算法。因为这样处理即使数据库泄漏，黑客也很难破解密码。\n在 meinian_common项目的 test 文件夹下面新建测试代码\npackage com.atguigu.security.test;\nimport org.junit.Test;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\n\npublic class TestSpringSecurity &#123;\n\n    &#x2F;&#x2F; SpringSecurity加盐加密\n    @Test\n    public void testSpringSecurity()&#123;\n\n        BCryptPasswordEncoder encoder &#x3D; new BCryptPasswordEncoder();\n\n        String s &#x3D; encoder.encode(&quot;abc&quot;);\n        System.out.println(s);\n\n        String s1 &#x3D; encoder.encode(&quot;abc&quot;);\n        System.out.println(s1);\n\n        &#x2F;&#x2F; 进行判断\n        boolean b &#x3D; encoder.matches(&quot;abc&quot;, &quot;$2a$10$dyIf5fOjCRZs&#x2F;pYXiBYy8uOiTa1z7I.mpqWlK5B&#x2F;0icpAKijKCgxe&quot;);\n        System.out.println(b);\n    &#125;\n&#125;\n\n加密后的格式一般为：\n$2a$10$&#x2F;bTVvqqlH9UiE0ZJZ7N2Me3RIgUCdgMheyTgV0B4cMCSokPa.6oCa\n\n加密后字符串的长度为固定的60位。其中：\n$是分割符，无意义；\n\n2a是bcrypt加密版本号；\n\n10是cost的值；\n\n而后的前22位是salt值；\n\n再然后的字符串就是密码的密文了。\n\n在spring-security.xml文件中指定密码加密对象\n&lt;security:authentication-manager&gt;\n    &lt;!-- authentication-provider：认证提供者，执行具体的认证逻辑  --&gt;\n    &lt;security:authentication-provider user-service-ref&#x3D;&quot;userService&quot;&gt;\n\n        &lt;!--指定密码加密策略--&gt;\n        &lt;security:password-encoder ref&#x3D;&quot;passwordEncoder&quot;&gt;&lt;&#x2F;security:password-encoder&gt;\n\n    &lt;&#x2F;security:authentication-provider&gt;\n\n&lt;&#x2F;security:authentication-manager&gt;\n\n&lt;!--配置密码加密对象--&gt;\n&lt;bean id&#x3D;&quot;passwordEncoder&quot; class&#x3D;&quot;org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder&quot; &#x2F;&gt;\n\n配置以后表示，以后每次登录，都会进行密码加密，然后再与数据库中取出的密码（已加密）进行匹配，匹配成功则证明认证成功\n6、配置多种校验规则（对页面）前提：&lt;security:http auto-config=“true” use-expressions=“true”&gt;\n&lt;security:http auto-config&#x3D;&quot;true&quot; use-expressions&#x3D;&quot;true&quot;&gt;\n\n    &lt;!--&lt;security:intercept-url pattern&#x3D;&quot;&#x2F;**&quot; access&#x3D;&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot;&gt;&lt;&#x2F;security:intercept-url&gt;--&gt;\n\n    &lt;!--只要认证通过就可以访问--&gt;\n    &lt;security:intercept-url pattern&#x3D;&quot;&#x2F;index.html&quot; access&#x3D;&quot;isAuthenticated()&quot; &#x2F;&gt;\n    &lt;security:intercept-url pattern&#x3D;&quot;&#x2F;a.html&quot; access&#x3D;&quot;isAuthenticated()&quot; &#x2F;&gt;\n\n    &lt;!--拥有add权限就可以访问b.html页面--&gt;\n    &lt;!--hasAnyAuthority(&#39;add&#39;,&#39;del&#39;,&#39;edit&#39;)：表示具有其中任何一个权限就可以访问--&gt;\n    &lt;security:intercept-url pattern&#x3D;&quot;&#x2F;b.html&quot; access&#x3D;&quot;hasAuthority(&#39;add&#39;)&quot; &#x2F;&gt;\n\n    &lt;!--拥有ROLE_ADMIN角色就可以访问c.html页面，注意：此处虽然写的是ADMIN角色，框架会自动加上前缀ROLE_--&gt;\n    &lt;security:intercept-url pattern&#x3D;&quot;&#x2F;c.html&quot; access&#x3D;&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot; &#x2F;&gt;\n\n    &lt;!--拥有ROLE_ADMIN角色就可以访问d.html页面--&gt;\n    &lt;security:intercept-url pattern&#x3D;&quot;&#x2F;d.html&quot; access&#x3D;&quot;hasRole(&#39;ABC&#39;)&quot; &#x2F;&gt;\n\n&lt;&#x2F;security:http&gt;\n\n\n\n7、注解方式权限控制（对类）Spring Security除了可以在配置文件中配置权限校验规则，还可以使用注解方式控制类中方法的调用。\n例如Controller中的某个方法要求必须具有某个权限才可以访问，此时就可以使用Spring Security框架提供的注解方式进行控制。\n1：在spring-security.xml文件中配置组件扫描，用于扫描Controller\n2：在spring-security.xml文件中开启权限注解支持\n3：创建Controller类并在Controller的方法上加入注解（@PreAuthorize）进行权限控制\n&lt;!--整合时，因为需要把spring-security.xml导入到spring-mvc.xml中进行加载，又因为mvc中配置了dubbo扫描，所以可知直接把这个去掉，让dubbo扫描到使用了@PreAuthorize的包，又因为SecurityUserServiceImpl中引用了dubbo中提供的service服务，所以让dubbo扫描到包，这一步必不可少--&gt;\n&lt;context:component-scan base-package&#x3D;&quot;com.atguigu&quot;&#x2F;&gt;\n\n&lt;!--开启全局的方法上注解方式权限控制--&gt;\n&lt;security:global-method-security pre-post-annotations&#x3D;&quot;enabled&quot; &#x2F;&gt;\n\n@RestController\n@RequestMapping(&quot;&#x2F;hello&quot;)\npublic class HelloController &#123;\n\n    @RequestMapping(&quot;&#x2F;add&quot;)\n    @PreAuthorize(&quot;hasAuthority(&#39;add&#39;)&quot;)&#x2F;&#x2F;表示用户必须拥有add权限才能调用当前方法\n    public String add()&#123;\n        return &quot;success&quot;;\n    &#125;\n\n    @RequestMapping(&quot;&#x2F;update&quot;)\n    @PreAuthorize(&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot;)&#x2F;&#x2F;表示用户必须拥有ROLE_ADMIN角色才能调用当前方法\n    public String update()&#123;\n        return &quot;success&quot;;\n    &#125;\n\n    @RequestMapping(&quot;&#x2F;delete&quot;)\n    @PreAuthorize(&quot;hasRole(&#39;ABC&#39;)&quot;)&#x2F;&#x2F;表示用户必须拥有ABC角色才能调用当前方法\n    public String delete()&#123;\n        return &quot;success&quot;;\n    &#125;\n&#125;\n\n\n\n8、logout退出登录&lt;a href&#x3D;&quot;&#x2F;logout.do&quot;&gt;退出登录&lt;&#x2F;a&gt;\n\n&lt;!--\n  logout：退出登录\n  logout-url：退出登录操作对应的请求路径\n  logout-success-url：退出登录后的跳转页面\n  invalidate-session&#x3D;&quot;true&quot; 默认为true,用户在退出后Http session失效\n--&gt;\n&lt;security:logout logout-url&#x3D;&quot;&#x2F;logout.do&quot; logout-success-url&#x3D;&quot;&#x2F;login.html&quot; invalidate-session&#x3D;&quot;true&quot;&#x2F;&gt;\n\n通过上面的配置可以发现，如果用户要退出登录，只需要请求/logout.do这个URL地址就可以，同时会将当前session失效，最后页面会跳转到login.html页面。\n9、登录后回显用户名&#x2F;&#x2F;发送请求获取当前登录用户的用户名\ncreated: function () &#123;\n    &#x2F;&#x2F;发送请求获取当前登录用户的用户名\n    axios(&#123;\n        method: &quot;post&quot;,\n        url: &quot;&#x2F;user&#x2F;getUserName.do&quot;\n    &#125;).then((res) &#x3D;&gt; &#123;\n        if (res.data.flag) &#123;\n            this.username &#x3D; res.data.data.username;\n        &#125; else &#123;\n            this.$message.error(res.data.message);\n        &#125;\n    &#125;)\n&#125;\n\n\n\n\n\n\n\n\n\n\n注意：获取到用户信息后，强转的User，不是pojo中自定义的，而==是security中提供的User==\n&#x2F;&#x2F;获取当前登录用户的用户名\n@RequestMapping(&quot;&#x2F;getUserName&quot;)\npublic Result getUsername() throws Exception &#123;\n    try &#123;\n        &#x2F;&#x2F;这里的User，是org.springframework.security.core.userdetails.User;\n        User user &#x3D; (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n        return new Result(true, MessageConstant.GET_USERNAME_SUCCESS, user);\n    &#125; catch (Exception e) &#123;\n        return new Result(false, MessageConstant.GET_USERNAME_FAIL);\n    &#125;\n&#125;\n\n\n\n10、403无权限异常消息提示在&lt;security:http&gt;标签中增加&lt;security:access-denied-handler&gt;\n&lt;!--自定义异常处理--&gt;\n&lt;security:access-denied-handler ref&#x3D;&quot;customAccessDeniedHandler&quot;&#x2F;&gt;\n\n@Component\npublic class CustomAccessDeniedController implements AccessDeniedHandler &#123;\n\n    &#x2F;**\n     * 在页面上没有权限时，设置页面回显的消息或要跳转的页面\n     * @param request 请求\n     * @param response 响应\n     * @param e 访问没有权限异常\n     * @throws IOException io异常\n     * @throws ServletException servlet异常\n     *&#x2F;\n    @Override\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException &#123;\n        if (isAjaxRequest(request))&#123;\n\n            Result result &#x3D; new Result(false ,&quot;您还没有此权限，请申请权限！！！&quot;);\n            String jsonStr &#x3D; JSON.toJSONString(result);\n            response.getWriter().print(jsonStr);\n        &#125;else &#123;\n            request.getRequestDispatcher(&quot;&#x2F;pages&#x2F;error&#x2F;403.html&quot;).forward(request,response);\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 判断是否为ajax请求\n     *&#x2F;\n    public static boolean isAjaxRequest(HttpServletRequest request) &#123;\n        return request.getHeader(&quot;accept&quot;).contains(&quot;application&#x2F;json&quot;)\n            || (request.getHeader(&quot;X-Requested-With&quot;) !&#x3D; null &amp;&amp; request.getHeader(&quot;X-Requested-With&quot;).equalsIgnoreCase(&quot;XMLHttpRequest&quot;));\n    &#125;\n&#125;\n\n\n\n11、总结\n\n\n\n\n\n\n\n\n注意：此时数据库中存储的密码是加密过后的\nweb.xml\n&lt;filter&gt;\n    &lt;!--\n         1：DelegatingFilterProxy用于整合第三方框架（代理过滤器，非真正的过滤器，真正的过滤器需要在spring的配置文件）\n          整合Spring Security时过滤器的名称必须为springSecurityFilterChain，\n          否则会抛出NoSuchBeanDefinitionException异常\n        --&gt;\n    &lt;filter-name&gt;springSecurityFilterChain&lt;&#x2F;filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;&#x2F;filter-class&gt;\n&lt;&#x2F;filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;springSecurityFilterChain&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;filter-mapping&gt;\n\nspring-security.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:security&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security&#x2F;spring-security.xsd&quot;&gt;\n\n    &lt;!--开启注解扫描 dubbo已经扫描，如果dubbo中不扫描此包，那么引用将不可用--&gt;\n    &lt;!--&lt;context:component-scan base-package&#x3D;&quot;com.atguigu.security&quot;&#x2F;&gt;--&gt;\n    &lt;!--开启注解方式权限控制--&gt;\n    &lt;security:global-method-security pre-post-annotations&#x3D;&quot;enabled&quot;&#x2F;&gt;\n\n    &lt;!--开启匿名访问的资源--&gt;\n    &lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;css&#x2F;**&quot;&#x2F;&gt;\n    &lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;img&#x2F;**&quot;&#x2F;&gt;\n    &lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;js&#x2F;**&quot;&#x2F;&gt;\n    &lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;plugins&#x2F;**&quot;&#x2F;&gt;\n    &lt;security:http security&#x3D;&quot;none&quot; pattern&#x3D;&quot;&#x2F;login.html&quot;&#x2F;&gt;\n\n    &lt;security:http auto-config&#x3D;&quot;true&quot; use-expressions&#x3D;&quot;true&quot;&gt;\n        &lt;security:intercept-url access&#x3D;&quot;isAuthenticated()&quot; pattern&#x3D;&quot;&#x2F;pages&#x2F;**&quot;&#x2F;&gt;\n        &lt;!--\n            form-login：定义表单登录信息\n            login-page&#x3D;&quot;&#x2F;login.html&quot;：表示指定登录页面\n            username-parameter&#x3D;&quot;username&quot;：使用登录名的名称，默认值是username\n            password-parameter&#x3D;&quot;password&quot;：使用登录名的密码，默认值是password\n            login-processing-url&#x3D;&quot;&#x2F;login.do&quot;：表示登录的url地址\n            default-target-url&#x3D;&quot;&#x2F;index.html&quot;：登录成功后的url地址\n            authentication-failure-url&#x3D;&quot;&#x2F;login.html&quot;：认证失败后跳转的url地址，失败后指定&#x2F;login.html\n            always-use-default-target&#x3D;&quot;true&quot;：登录成功后，始终跳转到default-target-url指定的地址，即登录成功的默认地址\n            --&gt;\n        &lt;security:form-login login-page&#x3D;&quot;&#x2F;login.html&quot;\n                             login-processing-url&#x3D;&quot;&#x2F;login.do&quot;\n                             username-parameter&#x3D;&quot;username&quot;\n                             password-parameter&#x3D;&quot;password&quot;\n                             default-target-url&#x3D;&quot;&#x2F;pages&#x2F;main.html&quot;\n                             authentication-failure-url&#x3D;&quot;&#x2F;login.html&quot;\n                             always-use-default-target&#x3D;&quot;true&quot;\n        &#x2F;&gt;\n        &lt;!--禁用CsrfFilter过滤器--&gt;\n        &lt;security:csrf disabled&#x3D;&quot;true&quot;&#x2F;&gt;\n        &lt;!--登出--&gt;\n        &lt;security:logout logout-url&#x3D;&quot;&#x2F;logout.do&quot; invalidate-session&#x3D;&quot;true&quot; logout-success-url&#x3D;&quot;&#x2F;login.html&quot;&#x2F;&gt;\n\n        &lt;security:headers&gt;\n            &lt;!--设置在页面可以通过iframe访问受保护的页面，默认为不允许访问--&gt;\n            &lt;security:frame-options policy&#x3D;&quot;SAMEORIGIN&quot;&#x2F;&gt;\n        &lt;&#x2F;security:headers&gt;\n\n        &lt;!--设置用户在没有权限时，进行消息提示--&gt;\n        &lt;security:access-denied-handler ref&#x3D;&quot;customAccessDeniedController&quot;&#x2F;&gt;\n    &lt;&#x2F;security:http&gt;\n\n    &lt;!--认证管理：定义登录账号名和密码，并授予访问的角色、权限--&gt;\n    &lt;security:authentication-manager&gt;\n        &lt;!--authentication-provider：认证提供者，执行具体的认证逻辑--&gt;\n        &lt;security:authentication-provider user-service-ref&#x3D;&quot;securityUserServiceImpl&quot;&gt;\n            &lt;!--指定密码加密策略--&gt;\n            &lt;security:password-encoder ref&#x3D;&quot;passwordEncoder&quot;&#x2F;&gt;\n        &lt;&#x2F;security:authentication-provider&gt;\n    &lt;&#x2F;security:authentication-manager&gt;\n\n    &lt;!--配置密码加密对象--&gt;\n    &lt;bean id&#x3D;&quot;passwordEncoder&quot;\n          class&#x3D;&quot;org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder&quot; &#x2F;&gt;\n\n&lt;&#x2F;beans&gt;\n\n从数据库获取用户信息\npackage com.atguigu.security;\n\nimport com.alibaba.dubbo.config.annotation.Reference;\nimport com.atguigu.pojo.Permission;\nimport com.atguigu.pojo.Role;\nimport com.atguigu.pojo.User;\nimport com.atguigu.service.UserService;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Component;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\n&#x2F;**\n * @author hrenxiang\n * @create 2021&#x2F;8&#x2F;3 15:00\n *&#x2F;\n\n@Component\npublic class SecurityUserServiceImpl implements UserDetailsService &#123;\n\n    @Reference\n    private UserService userService;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        &#x2F;&#x2F;根据名字获取用户信息\n        User user &#x3D; userService.getUserByName(username);\n\n        if (user &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n\n        &#x2F;&#x2F;新建用户权限集合\n        List&lt;GrantedAuthority&gt; authorityList &#x3D; new ArrayList&lt;&gt;();\n\n        &#x2F;&#x2F;查询用户相应权限\n        Set&lt;Role&gt; roles &#x3D; user.getRoles();\n        for (Role role : roles) &#123;\n            Set&lt;Permission&gt; permissions &#x3D; role.getPermissions();\n            for (Permission permission : permissions) &#123;\n                authorityList.add(new SimpleGrantedAuthority(permission.getKeyword()));\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F;将数据返回给权限框架，在内部进行比较\n        return new org.springframework.security.core.userdetails.User(username, user.getPassword(), authorityList);\n    &#125;\n&#125;\n\n403没有权限时消息提示\n@Component\npublic class CustomAccessDeniedController implements AccessDeniedHandler &#123;\n\n    &#x2F;**\n     * 在页面上没有权限时，设置页面回显的消息或要跳转的页面\n     * @param request 请求\n     * @param response 响应\n     * @param e 访问没有权限异常\n     * @throws IOException io异常\n     * @throws ServletException servlet异常\n     *&#x2F;\n    @Override\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException &#123;\n        if (isAjaxRequest(request))&#123;\n\n            Result result &#x3D; new Result(false ,&quot;您还没有此权限，请申请权限！！！&quot;);\n            String jsonStr &#x3D; JSON.toJSONString(result);\n            response.getWriter().print(jsonStr);\n        &#125;else &#123;\n            request.getRequestDispatcher(&quot;&#x2F;pages&#x2F;error&#x2F;403.html&quot;).forward(request,response);\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 判断是否为ajax请求\n     *&#x2F;\n    public static boolean isAjaxRequest(HttpServletRequest request) &#123;\n        return request.getHeader(&quot;accept&quot;).contains(&quot;application&#x2F;json&quot;)\n            || (request.getHeader(&quot;X-Requested-With&quot;) !&#x3D; null &amp;&amp; request.getHeader(&quot;X-Requested-With&quot;).equalsIgnoreCase(&quot;XMLHttpRequest&quot;));\n    &#125;\n&#125;\n\n进行用户名回显（从 SecurityContextHolder.getContext() 中获取数据）\npackage com.atguigu.controller;\n\nimport com.alibaba.dubbo.config.annotation.Reference;\nimport com.atguigu.constant.MessageConstant;\nimport com.atguigu.entity.Result;\nimport com.atguigu.service.UserService;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.core.userdetails.User;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n&#x2F;**\n * @author hrenxiang\n * @create 2021&#x2F;8&#x2F;3 20:51\n *&#x2F;\n@RestController\n@RequestMapping(&quot;&#x2F;user&quot;)\npublic class UserController &#123;\n    @Reference\n    private UserService userService;\n\n    &#x2F;&#x2F;获取当前登录用户的用户名\n    @RequestMapping(&quot;&#x2F;getUserName&quot;)\n    public Result getUsername() throws Exception &#123;\n        try &#123;\n            &#x2F;&#x2F;这里的User，是org.springframework.security.core.userdetails.User;\n            User user &#x3D; (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n            return new Result(true, MessageConstant.GET_USERNAME_SUCCESS, user);\n        &#125; catch (Exception e) &#123;\n            return new Result(false, MessageConstant.GET_USERNAME_FAIL);\n        &#125;\n    &#125;\n&#125;\n\n","slug":"58-Spring Security-权限管理","date":"2021-09-13T15:35:32.000Z","categories_index":"Spring","tags_index":"Spring","author_index":"大黄"},{"id":"fc61a710e2053b4421eaf30d8ac4fc38","title":"ApachePOI 文档读写","content":":whale: Apache POI基础\n① Apache POI简介Apache POI是一种流行的API，它允许程序员使用Java程序创建，修改和显示MS Office文件。这由Apache软件基金会开发使用Java分布式设计或修改Microsoft Office文件的开源库。它包含类和方法对用户输入数据或文件到MS Office文档进行解码。\n官方主页： http://poi.apache.org/index.html\nAPI文档： http://poi.apache.org/apidocs/index.html\n② Apache POI组件Apache POI包含类和方法，来将MS Office所有OLE 2文档复合。此API组件的列表如下。\nPOIFS (较差混淆技术实现文件系统) : 此组件是所有其他POI元件的基本因素。它被用来明确地读取不同的文件。\nHSSF (可怕的电子表格格式) : 它被用来读取和写入MS-Excel文件的xls格式。\nXSSF (XML格式) : 它是用于MS-Excel中XLSX文件格式。\nHPSF (可怕的属性设置格式) : 它用来提取MS-Office文件属性设置。\nHWPF (可怕的字处理器格式) : 它是用来读取和写入MS-Word的文档扩展名的文件。\nXWPF (XML字处理器格式) : 它是用来读取和写入MS-Word的docx扩展名的文件。\nHSLF (可怕的幻灯片版式格式) : 它是用于读取，创建和编辑PowerPoint演示文稿。\nHDGF (可怕的图表格式) : 它包含类和方法为MS-Visio的二进制文件。\nHPBF (可怕的出版商格式**) :** 它被用来读取和写入MS-Publisher文件。\n③ Excel包名称说明\n\n\n\nHSSF\nXSSF\nSXSSF\n\n\n\n对应Excel版本\n2003及2003版本以前\n2007后版本\n2007后版本\n\n\n扩展名\n.xls\n.xlsx\n.xlsx\n\n\n区别\n最常用的方式，但是不能超过65535行，超出65536条就会报错，此方式因不足7万行所以一般不会内存溢出（OOM）\n突破HSSF 65535行的局限(1048576行，16384列)，不过就伴随着一个问题内存溢出，原因是你创建的是存在内存的并没有持久化\nPOI 3.8 开始，提供基于XSSF低内存占用的SXSSF方式。它只会保存最新的excel rows在内存里供查看，在此之前的都会被写入到硬盘里。被写入硬盘的rows是不可见/不可访问的。只有内存里才可以访问到\n\n\n④ Maven坐标&lt;!--1.1 导入导出为.xls格式时，引入该依赖即可--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.poi&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;poi&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.14&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!--1.2 导入导出为.xlsx格式(07及以后版本)，引入该依赖即可--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.poi&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;poi-ooxml&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.14&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\n⑤ 简单的读取工具类（重要）==excle行和列的下标都是从0开始==\npackage com.atguigu.utils;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\nimport org.apache.poi.ss.usermodel.Cell;\nimport org.apache.poi.ss.usermodel.Row;\nimport org.apache.poi.ss.usermodel.Sheet;\nimport org.apache.poi.ss.usermodel.Workbook;\nimport org.apache.poi.xssf.usermodel.XSSFWorkbook;\nimport org.springframework.web.multipart.MultipartFile;\n\npublic class POIUtils &#123;\n    private final static String xls &#x3D; &quot;xls&quot;;\n    private final static String xlsx &#x3D; &quot;xlsx&quot;;\n    private final static String DATE_FORMAT &#x3D; &quot;yyyy&#x2F;MM&#x2F;dd&quot;;\n    &#x2F;**\n     * 读入excel文件，解析后返回\n     * @param file\n     * @throws IOException\n     *&#x2F;\n    public static List&lt;String[]&gt; readExcel(MultipartFile file) throws IOException &#123;\n        &#x2F;&#x2F;检查文件\n        checkFile(file);\n        &#x2F;&#x2F;获得Workbook工作薄对象\n        Workbook workbook &#x3D; getWorkBook(file);\n        &#x2F;&#x2F;创建返回对象，把每行中的值作为一个数组，所有行作为一个集合返回\n        List&lt;String[]&gt; list &#x3D; new ArrayList&lt;String[]&gt;();\n        if(workbook !&#x3D; null)&#123;\n            for(int sheetNum &#x3D; 0;sheetNum &lt; workbook.getNumberOfSheets();sheetNum++)&#123;\n                &#x2F;&#x2F;获得当前sheet工作表\n                Sheet sheet &#x3D; workbook.getSheetAt(sheetNum);\n                if(sheet &#x3D;&#x3D; null)&#123;\n                    continue;\n                &#125;\n                &#x2F;&#x2F;获得当前sheet的开始行\n                int firstRowNum  &#x3D; sheet.getFirstRowNum();\n                &#x2F;&#x2F;获得当前sheet的结束行\n                int lastRowNum &#x3D; sheet.getLastRowNum();\n                &#x2F;&#x2F;循环除了第一行的所有行\n                for(int rowNum &#x3D; firstRowNum+1;rowNum &lt;&#x3D; lastRowNum;rowNum++)&#123;\n                    &#x2F;&#x2F;获得当前行\n                    Row row &#x3D; sheet.getRow(rowNum);\n                    if(row &#x3D;&#x3D; null)&#123;\n                        continue;\n                    &#125;\n                    &#x2F;&#x2F;获得当前行的开始列\n                    int firstCellNum &#x3D; row.getFirstCellNum();\n                    &#x2F;&#x2F;获得当前行的列数\n                    int lastCellNum &#x3D; row.getPhysicalNumberOfCells();\n                    String[] cells &#x3D; new String[row.getPhysicalNumberOfCells()];\n                    &#x2F;&#x2F;循环当前行\n                    for(int cellNum &#x3D; firstCellNum; cellNum &lt; lastCellNum;cellNum++)&#123;\n                        Cell cell &#x3D; row.getCell(cellNum);\n                        cells[cellNum] &#x3D; getCellValue(cell);\n                    &#125;\n                    list.add(cells);\n                &#125;\n            &#125;\n            workbook.close();\n        &#125;\n        return list;\n    &#125;\n\n    &#x2F;&#x2F;校验文件是否合法\n    public static void checkFile(MultipartFile file) throws IOException&#123;\n        &#x2F;&#x2F;判断文件是否存在\n        if(null &#x3D;&#x3D; file)&#123;\n            throw new FileNotFoundException(&quot;文件不存在！&quot;);\n        &#125;\n        &#x2F;&#x2F;获得文件名\n        String fileName &#x3D; file.getOriginalFilename();\n        &#x2F;&#x2F;判断文件是否是excel文件\n        if(!fileName.endsWith(xls) &amp;&amp; !fileName.endsWith(xlsx))&#123;\n            throw new IOException(fileName + &quot;不是excel文件&quot;);\n        &#125;\n    &#125;\n    public static Workbook getWorkBook(MultipartFile file) &#123;\n        &#x2F;&#x2F;获得文件名\n        String fileName &#x3D; file.getOriginalFilename();\n        &#x2F;&#x2F;创建Workbook工作薄对象，表示整个excel\n        Workbook workbook &#x3D; null;\n        try &#123;\n            &#x2F;&#x2F;获取excel文件的io流\n            InputStream is &#x3D; file.getInputStream();\n            &#x2F;&#x2F;根据文件后缀名不同(xls和xlsx)获得不同的Workbook实现类对象\n            if(fileName.endsWith(xls))&#123;\n                &#x2F;&#x2F;2003\n                workbook &#x3D; new HSSFWorkbook(is);\n            &#125;else if(fileName.endsWith(xlsx))&#123;\n                &#x2F;&#x2F;2007\n                workbook &#x3D; new XSSFWorkbook(is);\n            &#125;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        return workbook;\n    &#125;\n    public static String getCellValue(Cell cell)&#123;\n        String cellValue &#x3D; &quot;&quot;;\n        if(cell &#x3D;&#x3D; null)&#123;\n            return cellValue;\n        &#125;\n        &#x2F;&#x2F;如果当前单元格内容为日期类型，需要特殊处理\n        String dataFormatString &#x3D; cell.getCellStyle().getDataFormatString();\n        if(dataFormatString.equals(&quot;m&#x2F;d&#x2F;yy&quot;))&#123;\n            cellValue &#x3D; new SimpleDateFormat(DATE_FORMAT).format(cell.getDateCellValue());\n            return cellValue;\n        &#125;\n        &#x2F;&#x2F;把数字当成String来读，避免出现1读成1.0的情况\n        if(cell.getCellType() &#x3D;&#x3D; Cell.CELL_TYPE_NUMERIC)&#123;\n            cell.setCellType(Cell.CELL_TYPE_STRING);\n        &#125;\n        &#x2F;&#x2F;判断数据的类型\n        switch (cell.getCellType())&#123;\n            case Cell.CELL_TYPE_NUMERIC: &#x2F;&#x2F;数字\n                cellValue &#x3D; String.valueOf(cell.getNumericCellValue());\n                break;\n            case Cell.CELL_TYPE_STRING: &#x2F;&#x2F;字符串\n                cellValue &#x3D; String.valueOf(cell.getStringCellValue());\n                break;\n            case Cell.CELL_TYPE_BOOLEAN: &#x2F;&#x2F;Boolean\n                cellValue &#x3D; String.valueOf(cell.getBooleanCellValue());\n                break;\n            case Cell.CELL_TYPE_FORMULA: &#x2F;&#x2F;公式\n                cellValue &#x3D; String.valueOf(cell.getCellFormula());\n                break;\n            case Cell.CELL_TYPE_BLANK: &#x2F;&#x2F;空值\n                cellValue &#x3D; &quot;&quot;;\n                break;\n            case Cell.CELL_TYPE_ERROR: &#x2F;&#x2F;故障\n                cellValue &#x3D; &quot;非法字符&quot;;\n                break;\n            default:\n                cellValue &#x3D; &quot;未知类型&quot;;\n                break;\n        &#125;\n        return cellValue;\n    &#125;\n&#125;\n\n\n\n\n⑥ 读取工具类的使用package com.atguigu.controller;\n\nimport com.alibaba.dubbo.config.annotation.Reference;\nimport com.atguigu.constant.MessageConstant;\nimport com.atguigu.entity.Result;\nimport com.atguigu.pojo.OrderSetting;\nimport com.atguigu.service.OrderSettingService;\nimport com.atguigu.util.POIUtils;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.IOException;\nimport java.util.Date;\nimport java.util.List;\n\n&#x2F;**\n * @author hrenxiang\n * @create 2021&#x2F;7&#x2F;30 15:50\n *&#x2F;\n@RestController\n@ResponseBody\n@RequestMapping(&quot;&#x2F;ordersetting&quot;)\npublic class OrderSettingController &#123;\n\n    @Reference\n    private OrderSettingService orderSettingService;\n\n    @RequestMapping(&quot;&#x2F;upload.do&quot;)\n    public Result upload(MultipartFile excelFile) throws IOException &#123;\n\n        &#x2F;&#x2F;使用POI工具类读取excel文件，得到每一条数据，封装到集合中\n        List&lt;String[]&gt; strings &#x3D; POIUtils.readExcel(excelFile);\n\n        &#x2F;&#x2F;遍历每一条数据的集合strings,将之封装为OrderSetting类型，进行逐条添加\n        for (String[] row : strings) &#123;\n            &#x2F;&#x2F;构建orderSetting实体类\n            OrderSetting orderSetting &#x3D; new OrderSetting();\n            &#x2F;&#x2F;将数据进行转换，给实体类赋值\n            orderSetting.setOrderDate(new Date(row[0]));\n            orderSetting.setNumber(Integer.parseInt(row[1]));\n            &#x2F;&#x2F;进行添加操作\n            orderSettingService.add(orderSetting);\n        &#125;\n\n        return new Result(true, MessageConstant.IMPORT_ORDERSETTING_SUCCESS);\n    &#125;\n\n&#125;\n\n\n\n\n:whale: HSSF的使用（了解）\n① HSSF概况HSSF 是Horrible SpreadSheet Format的缩写，通过HSSF，你可以用纯Java代码来读取、写入、修改Excel文件。HSSF 为读取操作提供了两类API：usermodel和eventusermodel，即“用户模型”和“事件-用户模型”。\n\n② POI EXCEL文档结构类HSSFWorkbook excel文档对象\nHSSFSheet excel的sheet HSSFRow excel的行\nHSSFCell excel的单元格 HSSFFont excel字体\nHSSFName 名称 HSSFDataFormat 日期格式\nHSSFHeader sheet头\nHSSFFooter sheet尾\nHSSFCellStyle cell样式\nHSSFDateUtil 日期\nHSSFPrintSetup 打印\n\n\n\n③ EXCEL常用操作方法1、 得到Excel常用对象             \nPOIFSFileSystem fs=newPOIFSFileSystem(new FileInputStream(&quot;d:/test.xls&quot;));   \n//得到Excel工作簿对象   \nHSSFWorkbook wb = new HSSFWorkbook(fs);  \n//得到Excel工作表对象   \nHSSFSheet sheet = wb.getSheetAt(0);   \n//得到Excel工作表的行   \nHSSFRow row = sheet.getRow(i);  \n//得到Excel工作表指定行的单元格   \nHSSFCell cell = row.getCell((short) j);  \ncellStyle = cell.getCellStyle();//得到单元格样式  \n\n2、建立Excel常用对象\nHSSFWorkbook wb = new HSSFWorkbook();//创建Excel工作簿对象  \nHSSFSheet sheet = wb.createSheet(&quot;new sheet&quot;);//创建Excel工作表对象    \nHSSFRow row = sheet.createRow((short)0); //创建Excel工作表的行  \ncellStyle = wb.createCellStyle();//创建单元格样式  \nrow.createCell((short)0).setCellStyle(cellStyle); //创建Excel工作表指定行的单元格  \nrow.createCell((short)0).setCellValue(1); //设置Excel工作表的值  \n\n3、设置sheet名称和单元格内容\nwb.setSheetName(1, &quot;第一张工作表&quot;,HSSFCell.ENCODING_UTF_16);          \ncell.setEncoding((short) 1);      \ncell.setCellValue(&quot;单元格内容&quot;); \n\n4、取得sheet的数目 \nwb.getNumberOfSheets()   \n\n\n\n5、  根据index取得sheet对象\nHSSFSheet sheet &#x3D; wb.getSheetAt(0);  \n\n\n\n6、取得有效的行数\nint rowcount &#x3D; sheet.getLastRowNum(); \n\n\n\n7、取得一行的有效单元格个数\nrow.getLastCellNum();  \n\n\n\n8、单元格值类型读写\ncell.setCellType(HSSFCell.CELL_TYPE_STRING); &#x2F;&#x2F;设置单元格为STRING类型  \ncell.getNumericCellValue();&#x2F;&#x2F;读取为数值类型的单元格内容  \n\n\n\n9、设置列宽、行高\nsheet.setColumnWidth((short)column,(short)width);      \nrow.setHeight((short)height);    \n\n10、添加区域，合并单元格\nRegion region = new Region((short)rowFrom,(short)columnFrom,(short)rowTo  \n,(short)columnTo);//合并从第rowFrom行columnFrom列  \nsheet.addMergedRegion(region);// 到rowTo行columnTo的区域     \n//得到所有区域      \nsheet.getNumMergedRegions()   \n\n11、保存Excel文件\nFileOutputStream fileOut = new FileOutputStream(path);   \nwb.write(fileOut);   \n\n12、根据单元格不同属性返回字符串数值\npublic String getCellStringValue(HSSFCell cell) &#123;      \n    String cellValue &#x3D; &quot;&quot;;      \n    switch (cell.getCellType()) &#123;      \n        case HSSFCell.CELL_TYPE_STRING:&#x2F;&#x2F;字符串类型  \n            cellValue &#x3D; cell.getStringCellValue();      \n            if(cellValue.trim().equals(&quot;&quot;)||cellValue.trim().length()&lt;&#x3D;0)      \n                cellValue&#x3D;&quot; &quot;;      \n            break;      \n        case HSSFCell.CELL_TYPE_NUMERIC: &#x2F;&#x2F;数值类型  \n            cellValue &#x3D; String.valueOf(cell.getNumericCellValue());      \n            break;      \n        case HSSFCell.CELL_TYPE_FORMULA: &#x2F;&#x2F;公式  \n            cell.setCellType(HSSFCell.CELL_TYPE_NUMERIC);      \n            cellValue &#x3D; String.valueOf(cell.getNumericCellValue());      \n            break;      \n        case HSSFCell.CELL_TYPE_BLANK:      \n            cellValue&#x3D;&quot; &quot;;      \n            break;      \n        case HSSFCell.CELL_TYPE_BOOLEAN:      \n            break;      \n        case HSSFCell.CELL_TYPE_ERROR:      \n            break;      \n        default:      \n            break;      \n    &#125;      \n    return cellValue;      \n&#125; \n\n\n\n13、常用单元格边框格式\nHSSFCellStyle style &#x3D; wb.createCellStyle();      \nstyle.setBorderBottom(HSSFCellStyle.BORDER_DOTTED);&#x2F;&#x2F;下边框       \nstyle.setBorderLeft(HSSFCellStyle.BORDER_DOTTED);&#x2F;&#x2F;左边框       \nstyle.setBorderRight(HSSFCellStyle.BORDER_THIN);&#x2F;&#x2F;右边框       \nstyle.setBorderTop(HSSFCellStyle.BORDER_THIN);&#x2F;&#x2F;上边框 \n\n\n\n14、设置字体和内容位置\nHSSFFont f  &#x3D; wb.createFont();      \nf.setFontHeightInPoints((short) 11);&#x2F;&#x2F;字号      \nf.setBoldweight(HSSFFont.BOLDWEIGHT_NORMAL);&#x2F;&#x2F;加粗      \nstyle.setFont(f);      \nstyle.setAlignment(HSSFCellStyle.ALIGN_CENTER);&#x2F;&#x2F;左右居中      \nstyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);&#x2F;&#x2F;上下居中      \nstyle.setRotation(short rotation);&#x2F;&#x2F;单元格内容的旋转的角度      \nHSSFDataFormat df &#x3D; wb.createDataFormat();      \nstyle1.setDataFormat(df.getFormat(&quot;0.00%&quot;));&#x2F;&#x2F;设置单元格数据格式      \ncell.setCellFormula(string);&#x2F;&#x2F;给单元格设公式      \nstyle.setRotation(short rotation);&#x2F;&#x2F;单元格内容的旋转的角度   \n\n\n\n15、插入图片\n//先把读进来的图片放到一个ByteArrayOutputStream中，以便产生ByteArray      \n      ByteArrayOutputStream byteArrayOut = new ByteArrayOutputStream();      \n      BufferedImage bufferImg = ImageIO.read(new File(&quot;ok.jpg&quot;));      \n      ImageIO.write(bufferImg,&quot;jpg&quot;,byteArrayOut);      \n//读进一个excel模版      \nFileInputStream fos = new FileInputStream(filePathName+&quot;/stencil.xlt&quot;);       \nfs = new POIFSFileSystem(fos);      \n//创建一个工作薄      \nHSSFWorkbook wb = new HSSFWorkbook(fs);      \nHSSFSheet sheet = wb.getSheetAt(0);      \nHSSFPatriarch patriarch = sheet.createDrawingPatriarch();      \nHSSFClientAnchor anchor = new HSSFClientAnchor(0,0,1023,255,(short) 0,0,(short)10,10);           \npatriarch.createPicture(anchor , wb.addPicture(byteArrayOut.toByteArray(),HSSFWorkbook.PICTURE_TYPE_JPEG));    \n\n16、调整工作表位置\nHSSFWorkbook wb = new HSSFWorkbook();     \nHSSFSheet sheet = wb.createSheet(&quot;format sheet&quot;);     \nHSSFPrintSetup ps = sheet.getPrintSetup();     \nsheet.setAutobreaks(true);     \nps.setFitHeight((short)1);     \nps.setFitWidth((short)1);   \n\n17、设置打印区域\nHSSFSheet sheet = wb.createSheet(&quot;Sheet1&quot;);     \nwb.setPrintArea(0, &quot;$A$1:$C$2&quot;);    \n\n18、标注脚注\nHSSFSheet sheet = wb.createSheet(&quot;format sheet&quot;);     \nHSSFFooter footer = sheet.getFooter()     \nfooter.setRight( &quot;Page &quot; + HSSFFooter.page() + &quot; of &quot; + HSSFFooter.numPages() );   \n\n19、在工作单中清空行数据，调整行位置\nHSSFWorkbook wb = new HSSFWorkbook();     \nHSSFSheet sheet = wb.createSheet(&quot;row sheet&quot;);     \n// Create various cells and rows for spreadsheet.     \n// Shift rows 6 - 11 on the spreadsheet to the top (rows 0 - 5)     \nsheet.shiftRows(5, 10, -5);    \n\n20、选中指定的工作表\nHSSFSheet sheet = wb.createSheet(&quot;row sheet&quot;);     \nheet.setSelected(true);     \n\n21、工作表的放大缩小\nHSSFSheet sheet1 = wb.createSheet(&quot;new sheet&quot;);     \nsheet1.setZoom(1,2);   // 50 percent magnification    \n\n22、头注和脚注\nHSSFSheet sheet = wb.createSheet(&quot;new sheet&quot;);     \nHSSFHeader header = sheet.getHeader();     \nheader.setCenter(&quot;Center Header&quot;);     \nheader.setLeft(&quot;Left Header&quot;);     \nheader.setRight(HSSFHeader.font(&quot;Stencil-Normal&quot;, &quot;Italic&quot;) +     \nHSSFHeader.fontSize((short) 16) + &quot;Right w/ Stencil-Normal Italic font and size 16&quot;);  \n\n23、自定义颜色  \nHSSFCellStyle style &#x3D; wb.createCellStyle();     \nstyle.setFillForegroundColor(HSSFColor.LIME.index);     \nstyle.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND);     \nHSSFFont font &#x3D; wb.createFont();     \nfont.setColor(HSSFColor.RED.index);     \nstyle.setFont(font);     \ncell.setCellStyle(style); \n\n24、填充和颜色设置\nHSSFCellStyle style = wb.createCellStyle();     \nstyle.setFillBackgroundColor(HSSFColor.AQUA.index);     \nstyle.setFillPattern(HSSFCellStyle.BIG_SPOTS);     \nHSSFCell cell = row.createCell((short) 1);     \ncell.setCellValue(&quot;X&quot;);     \nstyle = wb.createCellStyle();     \nstyle.setFillForegroundColor(HSSFColor.ORANGE.index);     \nstyle.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND);     \ncell.setCellStyle(style);   \n\n25、强行刷新单元格公式\nHSSFFormulaEvaluator eval&#x3D;new HSSFFormulaEvaluator((HSSFWorkbook) wb);    \nprivate static void updateFormula(Workbook wb,Sheet s,int row)&#123;     \n    Row r&#x3D;s.getRow(row);     \n    Cell c&#x3D;null;     \n    FormulaEcaluator eval&#x3D;null;     \n    if(wb instanceof HSSFWorkbook)     \n        eval&#x3D;new HSSFFormulaEvaluator((HSSFWorkbook) wb);     \n    else if(wb instanceof XSSFWorkbook)     \n        eval&#x3D;new XSSFFormulaEvaluator((XSSFWorkbook) wb);     \n    for(int i&#x3D;r.getFirstCellNum();i&lt;r.getLastCellNum();i++)&#123;     \n        c&#x3D;r.getCell(i);     \n        if(c.getCellType()&#x3D;&#x3D;Cell.CELL_TYPE_FORMULA)     \n            eval.evaluateFormulaCell(c);     \n    &#125;     \n&#125;    \n说明：FormulaEvaluator提供了evaluateFormulaCell(Cell cell)方法，计算公式保存结果，但不改变公式。而evaluateInCell(Cell cell) 方法是计算公式，并将原公式替换为计算结果，也就是说该单元格的类型不在是Cell.CELL_TYPE_FORMULA而是Cell.CELL_TYPE_NUMBERIC。HSSFFormulaEvaluator提供了静态方法evaluateAllFormu\nlaCells(HSSFWorkbook wb) ，计算一个Excel文件的所有公式，用起来很方便。\n:whale: 小结如果发现导出Excel有些复杂, 一般先把Excel制作一个模版. 把模版通过POI读取到内存里面. 获得数据, 动态的给模版里面填充数据, 再响应(Response)文件\n","slug":"57-ApachePOI-文档读写","date":"2021-09-13T15:34:32.000Z","categories_index":"文档读写","tags_index":"文档读写","author_index":"大黄"},{"id":"4ce484ce04054bf7a1c2a1b718c83b71","title":"Quartz 定时任务","content":":articulated_lorry: Quartz 简介\n① Quartz是什么Quartz是Job scheduling（作业调度）领域的一个开源项目，Quartz既可以单独使用也可以跟spring框架整合使用，在实际开发中一般会使用后者。使用Quartz可以开发一个或者多个定时任务，每个定时任务可以单独指定执行的时间，例如每隔1小时执行一次、每个月第一天上午10点执行一次、每个月最后一天下午5点执行一次等。完全由Java开发，可以用来执行定时任务，类似于java.util.Timer。但是相较于Timer， Quartz增加了很多功能：\n\n持久性作业 - 就是保持调度定时的状态;\n作业管理 - 对调度作业进行有效的管理;\n\n官网：https://www.w3cschool.cn/quartz_doc/\n简单来说，就是可以帮助我们设置一个有规律的或者在某个具体的时间点干点想干的事的一个开源框架。\n② Quartz的模块\n③ Quartz核心概念1. Job 表示一个工作，要执行的具体内容。此接口中只有一个方法，如下：\nvoid execute(JobExecutionContext context) \n\n2. JobDetail 表示一个具体的可执行的调度程序，Job 是这个可执行程调度程序所要执行的内容，另外 JobDetail 还包含了这个任务调度的方案和策略。\n3. Trigger 代表一个调度参数的配置，什么时候去调。\n4. Scheduler 代表一个调度容器，一个调度容器中可以注册多个 JobDetail 和 Trigger。当 Trigger 与 JobDetail 组合，就可以被 Scheduler 容器调度了。\n\n\n\n\n\n\n\n\n\n在使用Scheduler之前，需要实例化 scheduler实例化后，可以启动(start)、暂停(stand-by)、停止(shutdown)。\nQuartz API的关键接口是：\n\nScheduler：任务调度器，所有的任务都是从这里开始。\nTrigger：触发器，定义任务执行的方式、间隔。\nJobDetail &amp; Job ： 定义任务具体执行的逻辑。\n\nScheduler的生命期，从SchedulerFactory创建它时开始，到Scheduler调用shutdown()方法时结束；Scheduler被创建后，可以增加、删除和列举Job和Trigger，以及执行其它与调度相关的操作（如暂停Trigger）。但是，Scheduler只有在调用start()方法后，才会真正地触发trigger（即执行job）\n④ Quartz的运行环境\n\nQuartz 可以运行嵌入在另一个独立式应用程序。\nQuartz 可以在应用程序服务器(或 servlet 容器)内被实例化，并且参与 XA 事务。\nQuartz 可以作为一个独立的程序运行(其自己的 Java 虚拟机内)，可以通过 RMI 使用。\nQuartz 可以被实例化，作为独立的项目集群(负载平衡和故障转移功能)，用于作业的执行。\n\n⑤ Quartz的简单示例&lt;dependencies&gt;\n    &lt;!--引入Quartz的依赖--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.quartz-scheduler&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;quartz&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.2.1&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.quartz-scheduler&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;quartz-jobs&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.2.1&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n&#x2F;&#x2F;创建HelloQuartz\npublic class HelloQuartz implements Job &#123;\n    public void execute(JobExecutionContext jobExecutionContext) &#123;\n        JobDetail detail &#x3D; jobExecutionContext.getJobDetail();\n        String name &#x3D; detail.getJobDataMap().getString(&quot;name&quot;);\n        System.out.println(&quot;my job name is  &quot; + name + &quot; at &quot; + new Date());\n    &#125;\n&#125;\n\npublic class QuartzTest &#123;\n    public static void main(String[] args) &#123;\n            try &#123;\n                &#x2F;&#x2F;定义一个JobDetail\n                JobDetail jobDetail &#x3D; JobBuilder.newJob(HelloQuartz.class)\n                        &#x2F;&#x2F;定义name和group 给触发器一些属性 比如名字，组名。 （可以不写）\n                        .withIdentity(&quot;job1&quot;, &quot;group1&quot;)\n                        &#x2F;&#x2F;job需要传递的内容 具体job传递参数。  （可以不写）\n                        .usingJobData(&quot;name&quot;, &quot;sdas&quot;)\n                        .build();\n                \n                &#x2F;&#x2F;定义一个Trigger\n                Trigger trigger &#x3D; TriggerBuilder.newTrigger().withIdentity(&quot;trigger1&quot;, &quot;group1&quot;)\n                        &#x2F;&#x2F;加入 scheduler之后立刻执行 立刻启动\n                        .startNow()\n                        &#x2F;&#x2F;定时 ，每隔1秒钟执行一次 以某种触发器触发。  （可以不写）\n                        .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(1)\n                        &#x2F;&#x2F;重复执行\n                        .repeatForever())\n                        .build();\n                \n                &#x2F;&#x2F;创建scheduler\n                Scheduler scheduler &#x3D; StdSchedulerFactory.getDefaultScheduler();\n                scheduler.scheduleJob(jobDetail, trigger);\n                &#x2F;&#x2F; Scheduler只有在调用start()方法后，才会真正地触发trigger（即执行job）\n                scheduler.start(); &#x2F;&#x2F;运行一段时间后关闭\n                try &#123;\n                    Thread.sleep(8000);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                &#x2F;&#x2F;Scheduler调用shutdown()方法时结束\n                scheduler.shutdown();\n            &#125; catch (Exception e) &#123;\n                e.printStackTrace();\n            &#125;\n    &#125;\n&#125;\n\n\n\n:articulated_lorry: Quartz 整合 Spring\n① pom 文件&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n\n    &lt;groupId&gt;com.atguigu&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;quartz_demo&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n\n    &lt;packaging&gt;war&lt;&#x2F;packaging&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-context-support&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-tx&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-web&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.quartz-scheduler&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;quartz&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;2.2.1&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.quartz-scheduler&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;quartz-jobs&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;2.2.1&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.tomcat.maven&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;tomcat7-maven-plugin&lt;&#x2F;artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;!-- 指定端口 --&gt;\n                    &lt;port&gt;8080&lt;&#x2F;port&gt;\n                    &lt;!-- 请求路径 --&gt;\n                    &lt;path&gt;&#x2F;&lt;&#x2F;path&gt;\n                &lt;&#x2F;configuration&gt;\n            &lt;&#x2F;plugin&gt;\n        &lt;&#x2F;plugins&gt;\n    &lt;&#x2F;build&gt;\n&lt;&#x2F;project&gt;\n\n\n\n② Job 自定义&#x2F;&#x2F; 任务调度类\npublic class JobDemo &#123;\n    &#x2F;&#x2F; 提供方法（备份数据库，清理日志，清理图片）\n    public void run()&#123;\n        &#x2F;&#x2F; 完成业务\n        System.out.println(new Date());\n    &#125;\n&#125;\n\n\n\n③ 提供Spring配置文化&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;\n\n    &lt;!-- 注册自定义Job --&gt;\n    &lt;bean id&#x3D;&quot;jobDemo&quot; class&#x3D;&quot;com.atguigu.JobDemo&quot;&gt;&lt;&#x2F;bean&gt;\n    &lt;!-- 1：创建JobDetail对象,作用是负责通过反射调用指定的Job，注入目标对象，注入目标方法 --&gt;\n    &lt;bean id&#x3D;&quot;jobDetail&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt;\n        &lt;!-- 注入目标对象 --&gt;\n        &lt;property name&#x3D;&quot;targetObject&quot; ref&#x3D;&quot;jobDemo&quot;&#x2F;&gt;\n        &lt;!-- 注入目标方法 --&gt;\n        &lt;property name&#x3D;&quot;targetMethod&quot; value&#x3D;&quot;run&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n    &lt;!-- 2：注册一个触发器，指定任务触发的时间 --&gt;\n    &lt;bean id&#x3D;&quot;myTrigger&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt;\n        &lt;!-- 注入JobDetail --&gt;\n        &lt;property name&#x3D;&quot;jobDetail&quot; ref&#x3D;&quot;jobDetail&quot;&#x2F;&gt;\n        &lt;!-- 指定触发的时间，基于Cron表达式（0&#x2F;10表示从0秒开始，每10秒执行一次） --&gt;\n        &lt;property name&#x3D;&quot;cronExpression&quot;&gt;\n            &lt;value&gt;0&#x2F;10 * * * * ?&lt;&#x2F;value&gt;\n        &lt;&#x2F;property&gt;\n    &lt;&#x2F;bean&gt;\n\n    &lt;!-- 3：注册一个统一的调度工厂，通过这个调度工厂调度任务 --&gt;\n    &lt;bean id&#x3D;&quot;scheduler&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;\n        &lt;!-- 注入多个触发器 --&gt;\n        &lt;property name&#x3D;&quot;triggers&quot;&gt;\n            &lt;list&gt;\n                &lt;ref bean&#x3D;&quot;myTrigger&quot;&#x2F;&gt;\n            &lt;&#x2F;list&gt;\n        &lt;&#x2F;property&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\n\n\n④ web.xml中加载配置&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_0.xsd&quot;\n         id&#x3D;&quot;WebApp_ID&quot; version&#x3D;&quot;3.0&quot;&gt;\n\n    &lt;listener&gt;\n        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;\n    &lt;&#x2F;listener&gt;\n    &lt;context-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n        &lt;param-value&gt;classpath:application-jobs.xml&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;context-param&gt;\n&lt;&#x2F;web-app&gt;\n\n执行Tomcat观察控制台，可以发现每隔10秒会输出一次，说明每隔10秒自定义Job被调用一次。\n:articulated_lorry: Quartz核心详解\n下面就程序中出现的几个参数，看一下Quartz框架中的几个重要参数：\n\nJob和JobDetail\nJobExecutionContext\nJobDataMap\nTrigger、SimpleTrigger、CronTrigger\n\n① Job和JobDetailJob是Quartz中的一个接口，接口下只有execute方法，在这个方法中编写业务逻辑。\n接口中的源码：\n\nJobDetail用来绑定Job，为Job实例提供许多属性：\n\nname\ngroup\njobClass\njobDataMap\n\nJobDetail绑定指定的Job，每次Scheduler调度执行一个Job的时候，首先会拿到对应的Job，然后创建该Job实例，再去执行Job中的execute()的内容，任务执行结束后，关联的Job对象实例会被释放，且会被JVM GC清除。\n\n\n\n\n\n\n\n\n\n为什么设计成JobDetail + Job，不直接使用Job？\nJobDetail定义的是任务数据，而真正的执行逻辑是在Job中。\n这是因为任务是有可能并发执行，如果Scheduler直接使用Job，就会存在对同一个Job实例并发访问的问题。而JobDetail &amp; Job 方式，Sheduler每次执行，都会根据JobDetail创建一个新的Job实例，这样就可以规避并发访问的问题。\n② JobExecutionContextJobExecutionContext中包含了Quartz运行时的环境以及Job本身的详细数据信息。\n当Schedule调度执行一个Job的时候，就会将JobExecutionContext传递给该Job的execute()中，Job就可以通过JobExecutionContext对象获取信息。\n主要信息有：\n\n③ JobExecutionContextJobDataMap实现了JDK的Map接口，可以以Key-Value的形式存储数据。\nJobDetail、Trigger都可以使用JobDataMap来设置一些参数或信息，\nJob执行execute()方法的时候，JobExecutionContext可以获取到JobExecutionContext中的信息，如：\nJobDetail jobDetail &#x3D; JobBuilder.newJob(PrintWordsJob.class)                        .usingJobData(&quot;jobDetail1&quot;, &quot;这个Job用来测试的&quot;)\n                  .withIdentity(&quot;job1&quot;, &quot;group1&quot;).build();\n\n Trigger trigger &#x3D; TriggerBuilder.newTrigger().withIdentity(&quot;trigger1&quot;, &quot;triggerGroup1&quot;)\n      .usingJobData(&quot;trigger1&quot;, &quot;这是jobDetail1的trigger&quot;)\n      .startNow()&#x2F;&#x2F;立即生效\n      .withSchedule(SimpleScheduleBuilder.simpleSchedule()\n      .withIntervalInSeconds(1)&#x2F;&#x2F;每隔1s执行一次\n      .repeatForever()).build();&#x2F;&#x2F;一直执行\n12345678910\n\nJob执行的时候，可以获取到这些参数信息：\n@Override\npublic void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123;\n\n    System.out.println(jobExecutionContext.getJobDetail().getJobDataMap().get(&quot;jobDetail1&quot;));\n    System.out.println(jobExecutionContext.getTrigger().getJobDataMap().get(&quot;trigger1&quot;));\n    String printTime &#x3D; new SimpleDateFormat(&quot;yy-MM-dd HH-mm-ss&quot;).format(new Date());\n    System.out.println(&quot;PrintWordsJob start at:&quot; + printTime + &quot;, prints: Hello Job-&quot; + new Random().nextInt(100));\n\n\n&#125;12345678910\n\n\n\n④ TriggerTrigger\nTrigger是Quartz的触发器，会去通知Scheduler何时去执行对应Job。\nnew Trigger().startAt():表示触发器首次被触发的时间;\nnew Trigger().endAt():表示触发器结束触发的时间;12\n\nSimpleTrigger\nSimpleTrigger可以实现在一个指定时间段内执行一次作业任务或一个时间段内多次执行作业任务。\n下面的程序就实现了程序运行5s后开始执行Job，执行Job 5s后结束执行：\nDate startDate &#x3D; new Date();\nstartDate.setTime(startDate.getTime() + 5000);\n\n Date endDate &#x3D; new Date();\n endDate.setTime(startDate.getTime() + 5000);\n\n        Trigger trigger &#x3D; TriggerBuilder.newTrigger().withIdentity(&quot;trigger1&quot;, &quot;triggerGroup1&quot;)\n                .usingJobData(&quot;trigger1&quot;, &quot;这是jobDetail1的trigger&quot;)\n                .startNow()&#x2F;&#x2F;立即生效\n                .startAt(startDate)\n                .endAt(endDate)\n                .withSchedule(SimpleScheduleBuilder.simpleSchedule()\n                .withIntervalInSeconds(1)&#x2F;&#x2F;每隔1s执行一次\n                .repeatForever()).build();&#x2F;&#x2F;一直执行\n123456789101112131415\n\nCronTrigger\nCronTrigger功能非常强大，是基于日历的作业调度，而SimpleTrigger是精准指定间隔，所以相比SimpleTrigger，CroTrigger更加常用。CroTrigger是基于Cron表达式的，先了解下Cron表达式：\n由7个子表达式组成字符串的，格式如下：\n==[秒] [分] [小时] [日] [月] [周] [年]==\n:articulated_lorry: cron表达式\n① cron表达式简介上面的入门案例中我们指定了一个表达式：0/10 * * * * ?\n这种表达式称为cron表达式，通过cron表达式可以灵活的定义出符合要求的程序执行的时间。本小节我们就来学习一下cron表达式的使用方法。如下表：\n\n\n\n字段\n允许值\n允许的特殊字符\n\n\n\n秒（Seconds）\n0~59的整数\n, - * /   四个字符\n\n\n分（Minutes）\n0~59的整数\n, - * /   四个字符\n\n\n小时（Hours）\n0~23的整数\n, - * /   四个字符\n\n\n日期（DayofMonth）\n1~31的整数（但是你需要考虑你月的天数）\n,- * ? / L W C   八个字符\n\n\n月份（Month）\n1~12的整数或者 JAN-DEC\n, - * /   四个字符\n\n\n星期（DayofWeek）\n1~7的整数或者 SUN-SAT （1=SUN）\n, - * ? / L C #   八个字符\n\n\n年(可选，留空)（Year）\n1970~2099\n, - * /   四个字符\n\n\ncron表达式分为七个域，之间使用空格分隔。其中最后一个域（年）可以为空。每个域都有自己允许的值和一些特殊字符构成。使用这些特殊字符可以使我们定义的表达式更加灵活。\n② 特殊字符的介绍逗号（,）：指定一个值列表，例如使用在月域上1,4,5,7表示1月、4月、5月和7月\n横杠（-）：指定一个范围，例如在时域上3-6表示3点到6点（即3点、4点、5点、6点）\n星号（*）：表示这个域上包含所有合法的值。例如，在月份域上使用星号意味着每个月都会触发\n斜线（/）：表示递增，例如使用在秒域上0/15表示每15秒\n问号（?）：只能用在日和周域上，但是不能在这两个域上同时使用。表示不指定，例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用 *，如果使用 * 表示不管星期几都会触发，实际上并不是这样。\n井号（#）：只能使用在周域上，用于指定月份中的第几周的哪一天，例如6#3，意思是某月的第三个周五 (6=星期五，3意味着月份中的第三周)\nL：某域上允许的最后一个值。只能使用在日和周域上。当用在日域上，表示的是在月域上指定的月份的最后一天。用于周域上时，表示周的最后一天，就是星期六\nW：W 字符代表着工作日 (星期一到星期五)，只能用在日域上，它用来指定离指定日的最近的一个工作日\n③ 常用表达式（1）0 0 2 1 * ? *   表示在每月的1日的凌晨2点调整任务\n\n（2）0 15 10 ? * MON-FRI   表示周一到周五每天上午10:15执行作业\n\n（3）0 0 10,14,16 * * ?   每天上午10点，下午2点，4点 \n\n（4）0 0 12 ? * WED    表示每个星期三中午12点 \n\n（5）0 0 12 * * ?   每天中午12点触发 \n\n（6）0 15 10 ? * *    每天上午10:15触发 \n\n（7）0 15 10 * * ?     每天上午10:15触发 \n\n（8）0 15 10 * * ? *    每天上午10:15触发 \n\n（9）0 15 10 * * ? 2005    2005年的每天上午10:15触发 \n\n（10）0 * 14 * * ?     在每天下午2点到下午2:59期间的每1分钟触发 \n\n（11）0 0&#x2F;5 14 * * ?    在每天下午2点到下午2:55期间的每5分钟触发 \n\n（12）0 0&#x2F;5 14,18 * * ?     在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 \n\n（13）0 0-5 14 * * ?    在每天下午2点到下午2:05期间的每1分钟触发 \n\n（14）0 10,44 14 ? 3 WED    每年三月的星期三的下午2:10和2:44触发 \n\n（15）0 15 10 ? * MON-FRI    周一至周五的上午10:15触发 \n\n（16）0 15 10 15 * ?    每月15日上午10:15触发 \n\n（17）0 15 10 L * ?    每月最后一日的上午10:15触发 \n\n（18）0 15 10 ? * 6L    每月的最后一个星期五上午10:15触发 \n\n（19）0 15 10 ? * 6L 2002-2005   2002年至2005年的每月的最后一个星期五上午10:15触发 \n\n（20）0 15 10 ? * 6#3   每月的第三个星期五上午10:15触发\n\n（21）0 15 10 ? 6L 2002-2006   表示2002-2006年的每个月的最后一个星期五上午10:15执行作\n\n（22）0 0&#x2F;30 9-17 * * ?   朝九晚五工作时间内每半小时\n\n\n\n④ cron表达式在线生成器前面介绍了cron表达式，但是自己编写表达式还是有一些困难的，我们可以借助一些cron表达式在线生成器来根据我们的需求生成表达式即可。\nhttp://cron.qqe2.com/\n:articulated_lorry: 定时清理云上垃圾（结合项目）\n前面我们已经完成了旅游套餐的管理，在新增套餐时套餐的基本信息和图片是分两次提交到后台进行操作的。也就是用户首先将图片上传到七牛云服务器，然后再提交新增窗口中录入的其他信息。如果用户只是上传了图片而没有提交录入的其他信息，此时的图片就变为了垃圾图片，因为在数据库中并没有记录它的存在。此时我们要如何处理这些垃圾图片呢？\n解决方案就是通过定时任务组件定时清理这些垃圾图片。为了能够区分出来哪些图片是垃圾图片，我们在文件上传成功后将图片保存到了一个 redis 集合中，当套餐数据插入到数据库后我们又将图片名称保存到了另一个redis集合中，通过计算这两个集合的差值就可以获得所有垃圾图片的名称。\n本章节我们就会基于Quartz 定时任务，通过计算 redis 两个集合的差值找出所有的垃圾图片，就可以将垃圾图片清理掉。\n① 创建maven聚合工程meinian_jobs ，打包方式为war，导入Quartz等相关坐标\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;meinian_parent&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;com.atguigu&lt;&#x2F;groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n \n    &lt;artifactId&gt;meinian_jobs&lt;&#x2F;artifactId&gt;\n \n    &lt;packaging&gt;war&lt;&#x2F;packaging&gt;\n \n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;\n        &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;\n        &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;\n    &lt;&#x2F;properties&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.atguigu&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;meinian_interface&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.quartz-scheduler&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;quartz&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.quartz-scheduler&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;quartz-jobs&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.tomcat.maven&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;tomcat7-maven-plugin&lt;&#x2F;artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;!-- 指定端口 --&gt;\n                    &lt;port&gt;83&lt;&#x2F;port&gt;\n                    &lt;!-- 请求路径 --&gt;\n                    &lt;path&gt;&#x2F;&lt;&#x2F;path&gt;\n                &lt;&#x2F;configuration&gt;\n            &lt;&#x2F;plugin&gt;\n        &lt;&#x2F;plugins&gt;\n    &lt;&#x2F;build&gt;\n&lt;&#x2F;project&gt;\n\n\n\n② 配置web.xml&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_0.xsd&quot;\n         id&#x3D;&quot;WebApp_ID&quot; version&#x3D;&quot;3.0&quot;&gt;\n    &lt;display-name&gt;Archetype Created Web Application&lt;&#x2F;display-name&gt;\n    &lt;!-- 加载spring容器 --&gt;\n    &lt;context-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n        &lt;param-value&gt;classpath*:spirng*.xml&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;context-param&gt;\n    &lt;listener&gt;\n        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;\n    &lt;&#x2F;listener&gt;\n&lt;&#x2F;web-app&gt;\n\n\n\n③ 配置log4j.properties### direct log messages to stdout ###\nlog4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.Target&#x3D;System.err\nlog4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern&#x3D;%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n\n \n### direct messages to file mylog.log ###\nlog4j.appender.file&#x3D;org.apache.log4j.FileAppender\nlog4j.appender.file.File&#x3D;c:\\\\mylog.log\nlog4j.appender.file.layout&#x3D;org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern&#x3D;%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n\n \n### set log levels - for more verbose logging change &#39;info&#39; to &#39;debug&#39; ###\n \nlog4j.rootLogger&#x3D;debug, stdout\n\n\n\n④ 配置spirng-redis.xml&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:dubbo&#x3D;&quot;http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&quot;\n       xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n                         http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n                        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc\n                         http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd\n                        http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo\n                         http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd\n                        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context\n                         http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;\n \n    &lt;!--Jedis连接池的相关配置--&gt;\n    &lt;bean id&#x3D;&quot;jedisPoolConfig&quot; class&#x3D;&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;\n        &lt;!--在指定时刻通过pool能够获取到的最大的连接的jedis个数--&gt;\n        &lt;property name&#x3D;&quot;maxTotal&quot;&gt;\n            &lt;value&gt;200&lt;&#x2F;value&gt;\n        &lt;&#x2F;property&gt;\n         &lt;!--最大能够保持idle的数量--&gt;\n        &lt;property name&#x3D;&quot;maxIdle&quot;&gt;\n            &lt;value&gt;50&lt;&#x2F;value&gt;\n        &lt;&#x2F;property&gt;\n        &lt;!--表示连接池在创建链接的时候会先测试一下链接是否可用，这样可以保证连接池中的链接都可用的。--&gt;\n        &lt;property name&#x3D;&quot;testOnBorrow&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;testOnReturn&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n    &lt;bean id&#x3D;&quot;jedisPool&quot; class&#x3D;&quot;redis.clients.jedis.JedisPool&quot;&gt;\n        &lt;constructor-arg name&#x3D;&quot;poolConfig&quot; ref&#x3D;&quot;jedisPoolConfig&quot; &#x2F;&gt;\n        &lt;constructor-arg name&#x3D;&quot;host&quot; value&#x3D;&quot;127.0.0.1&quot; &#x2F;&gt;\n        &lt;constructor-arg name&#x3D;&quot;port&quot; value&#x3D;&quot;6379&quot; type&#x3D;&quot;int&quot; &#x2F;&gt;\n        &lt;constructor-arg name&#x3D;&quot;timeout&quot; value&#x3D;&quot;30000&quot; type&#x3D;&quot;int&quot; &#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\n\n\n⑤ 配置 spirng-jobs.xml&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n                  http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n                  http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context\n                  http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;\n    &lt;!--开启注解配置支持，否则在ClearImgJob不能使用@Autowired--&gt;\n    &lt;context:component-scan base-package&#x3D;&quot;com.atguigu&quot;&gt;&lt;&#x2F;context:component-scan&gt;\n \n    &lt;!-- 注册自定义Job --&gt;\n    &lt;bean id&#x3D;&quot;jobDemo&quot; class&#x3D;&quot;com.atguigu.job.ClearImgJob&quot;&gt;&lt;&#x2F;bean&gt;\n    &lt;!-- 注册JobDetail,作用是负责通过反射调用指定的Job --&gt;\n    &lt;bean id&#x3D;&quot;jobDetail&quot;\n          class&#x3D;&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt;\n        &lt;!-- 注入目标对象 --&gt;\n        &lt;property name&#x3D;&quot;targetObject&quot; ref&#x3D;&quot;jobDemo&quot;&#x2F;&gt;\n        &lt;!-- 注入目标方法 --&gt;\n        &lt;property name&#x3D;&quot;targetMethod&quot; value&#x3D;&quot;clearImg&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n    &lt;!-- 注册一个触发器，指定任务触发的时间 --&gt;\n    &lt;bean id&#x3D;&quot;myTrigger&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt;\n        &lt;!-- 注入JobDetail --&gt;\n        &lt;property name&#x3D;&quot;jobDetail&quot; ref&#x3D;&quot;jobDetail&quot;&#x2F;&gt;\n        &lt;!-- 指定触发的时间，基于Cron表达式（0 0 2 * * ?表示凌晨2点执行） --&gt;\n        &lt;!-- 指定触发的时间，基于Cron表达式（0 25 12 * * ?表示12点25分执行） --&gt;\n        &lt;property name&#x3D;&quot;cronExpression&quot;&gt;\n            &lt;value&gt;0 0 2 * * ?&lt;&#x2F;value&gt;\n        &lt;&#x2F;property&gt;\n    &lt;&#x2F;bean&gt;\n    &lt;!-- 注册一个统一的调度工厂，通过这个调度工厂调度任务 --&gt;\n    &lt;bean id&#x3D;&quot;scheduler&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;\n        &lt;!-- 注入多个触发器 --&gt;\n        &lt;property name&#x3D;&quot;triggers&quot;&gt;\n            &lt;list&gt;\n                &lt;ref bean&#x3D;&quot;myTrigger&quot;&#x2F;&gt;\n            &lt;&#x2F;list&gt;\n        &lt;&#x2F;property&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\n\n\n⑥ 创建Job定时任务类package com.atguigu.job;\n \nimport com.atguigu.constant.RedisConstant;\nimport com.atguigu.utils.QiniuUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport redis.clients.jedis.JedisPool;\n \nimport java.util.Iterator;\nimport java.util.Set;\n \npublic class ClearImgJob &#123;\n    @Autowired\n    private JedisPool jedisPool;\n    &#x2F;&#x2F;清理图片\n    public void clearImg()&#123;\n        &#x2F;&#x2F;计算redis中两个集合的差值，获取垃圾图片名称\n        &#x2F;&#x2F; 需要注意：在比较的时候，数据多的放到前面，如果pic多，那么pic放到前面，db多，db放到前面\n        Set&lt;String&gt; set &#x3D; jedisPool.getResource().sdiff(\n                RedisConstant.SETMEAL_PIC_RESOURCES,\n                RedisConstant.SETMEAL_PIC_DB_RESOURCES);\n        \n        Iterator&lt;String&gt; iterator &#x3D; set.iterator();\n        \n        while(iterator.hasNext())&#123;\n            String pic &#x3D; iterator.next();\n            System.out.println(&quot;删除图片的名称是：&quot;+pic);\n            &#x2F;&#x2F;删除图片服务器中的图片文件\n            QiniuUtils.deleteFileFromQiniu(pic);\n            &#x2F;&#x2F;删除redis中的数据\n            jedisPool.getResource().srem(RedisConstant.SETMEAL_PIC_RESOURCES,pic);\n        &#125;\n    &#125;\n&#125;\n\n测试如下：\n\n    \n    \n\n\n注意：如果 redis 服务端启动如上，不需要担心，直接使用 , 只是没有图标而已。\n","slug":"56-Quartz-定时任务","date":"2021-09-13T15:33:32.000Z","categories_index":"定时任务","tags_index":"定时任务","author_index":"大黄"},{"id":"6cf45a5bd6abd2bbf495c5388d2d047e","title":"Dubbo Zookeeper","content":":basketball: 软件架构的发展过程\n① 单体架构一个归档包（例如war格式或者Jar格式）包含了应用所有功能的应用程序，我们通常称之为单体应用。架构单体应用的方法论，我们称之\n为单体应用架构，这是一种比较传统的架构风格。\n1. 架构说明：全部功能集中在一个项目内（All in one）。\n2. 架构优点：架构简单，前期开发成本低、开发周期短，适合小型项目。\n3. 架构缺点：复杂性高，技术债务逐渐上升，部署速度逐渐变慢，扩展能力受限，无法按需伸缩，阻碍技术创新\n① 复杂性高\n\n\t 整个项目包含的模块非常多，模块的边界模糊，依赖关系不清晰，代码质量参差不齐,整个项目非常复杂。每次修改代码都心惊胆战，甚至添加一个简单的功能，或者修改一个BUG都会造成隐含的缺陷。\n\n② 技术债务逐渐上升\n\n\t 随着时间推移、需求变更和人员更迭，会逐渐形成应用程序的技术债务，并且越积越多。已使用的系统设计或代码难以修改，因为应用程序的其他模块可能会以意料之外的方式使用它。\n\n③ 部署速度逐渐变慢\n\n\t 随着代码的增加，构建和部署的时间也会增加。而在单体应用中，每次功能的变更或缺陷的修复都会导致我们需要重新部署整个应用。全量部署的方式耗时长、影响范围大、风险高，这使得单体应用项目上线部署的频率较低，从而又导致两次发布之间会有大量功能变更和缺陷修复，出错概率较高。\n\n④ 扩展能力受限，无法按需伸缩\n\n \t单体应用只能作为一个整体进行扩展，无法结合业务模块的特点进行伸缩。\n \t\n⑤ 阻碍技术创新\n\n\t 单体应用往往使用统一的技术平台或方案解决所有问题，团队的每个成员都必须使用相同的开发语言和架构，想要引入新的框架或技术平台非常困难。\n\n4. 总结\n​    全部功能集成在一个工程中，对于大型项目不易开发、扩展和维护。\n​    技术栈受限，只能使用一种语言开发。\n​    系统性能扩展只能通过扩展集群节点，成本高。\n② 垂直架构1. 架构说明：\n​    按照业务进行切割，形成小的单体项目。\n​    垂直MVC项目主要有表现层，业务逻辑层，数据访问层组成的MVC架构，整个项目打包放在一个tomcat里面。适合于 访问量小，用户数不多的业务。\n2. 架构优点\n​    技术栈可扩展（不同的系统可以用不同的编程语言编写）。\n3. 架构缺点：\n① 这是一个大而全的项目，项目的部署效率很低，代码全量编译和部署一次发布需要很长时间，更重要的是 如果某个功能出错有问题，所有的功能都需要再重新打包编译，部署效率极低。\n\n ② 团队协作难度高，如多人使用 git 很可能在同一个功能上，多人同时进行了修改，作为一个大而全的项目，可能个人只是需要开发其中一个小的模块的需求，却需要导入整个项目全量的代码。\n\n4. 总结\n​    功能集中在一个项目中，不利于开发、扩展、维护。\n​    系统扩张只能通过集群的方式。\n​    项目之间功能冗余、数据冗余、耦合性强。\n③ SOA架构SOA 全称为 Service-Oriented Architecture，即面向服务的架构。它可以根据需求通过网络对松散耦合的粗粒度应用组件(服务)进行分布式部署、组合和使用。一个服务通常以独立的形式存在于操作系统进程中。\n站在功能的角度，把业务逻辑抽象成可复用的服务，通过服务的编排实现业务的快速再生，目的：把原先固有的业务功能转变为通用的业务服务，实现业务逻辑的快速复用。\n1. 架构说明\n​    将重复功能或模块抽取成组件的形式，对外提供服务，在项目与服务之间使用ESB（企业服务总线）的形式作为通信的桥梁。\n2. ESB\n​    简单 来说 ESB 就是一根管道，用来连接各个服务节点。为了集 成不同系统，不同协议的服务，ESB 做了消息的转化解释和路由工作，让不同的服务互联互通；\n3. 架构优点\n​    重复功能或模块抽取为服务，提高开发效率。可重用性高，可维护性高。\n4. 架构缺点\n​    各系统之间业务不同，很难确认功能或模块是重复的。\n​    抽取服务的粒度大。\n​    系统和服务之间耦合度高。\n④ 微服务架构1. 微服务架构\n其实和 SOA 架构类似,微服务是在 SOA 上做的升华，微服务架构强调的一个重点是“业务需要彻底的组件化和服务化”，原有的单个业务系统会拆分为多个可以独立开发、设计、运行的小应用。这些小应用之间通过服务完成交互和集成。\n2. 架构说明\n​    将系统服务层完全独立出来，抽取为一个一个的微服务。\n​    抽取的粒度更细，遵循单一原则。\n​    采用轻量级框架协议传输。\n3. API 服务网关\nAPI网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。服务端通过API-GW注册和管理服务。\n4. 架构优点\n​    服务拆分粒度更细，有利于提高开发效率。\n​    可以针对不同服务制定对应的优化方案。\n​    适用于互联网时代，产品迭代周期更短。\n5. 架构缺点\n​    粒度太细导致服务太多，维护成本高。\n​    分布式系统开发的技术成本高，对团队的挑战大。\n:basketball: dubbo 概述\n① dubbo简介Apache Dubbo是一款高性能的Java RPC框架。其前身是阿里巴巴公司开源的一个高性能、轻量级的开源Java RPC框架，可以和Spring框架无缝集成。\n② RPC是什么RPC全称为remote procedure call，即远程过程调用，对标的是 本地过程调用。\n\n简单的说本机上内部的方法调用都可以称为本地过程调用，而远程过程调用实际上就指的是你本地调用了远程机子上的某个方法，这就是远程过程调用。\n比如两台服务器A和B，A服务器上部署一个应用，B服务器上部署一个应用，A服务器上的应用想调用B服务器上的应用提供的方法，由于两个应用不在一个内存空间，不能直接调用，所以需要通过网络来表达调用的语义和传达调用的数据。\n==需要注意的是RPC并不是一个具体的技术，而是指整个网络远程调用过程。==\nRPC是一个泛化的概念，严格来说一切远程过程调用手段都属于RPC范畴。各种开发语言都有自己的RPC框架。Java中的RPC框架比较多，广泛使用的有RMI、Hessian、Dubbo等。\n③ dubbo架构==Dubbo提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。==\n\n    \n    \n\n\n虚线都是异步访问，实线都是同步访问            蓝色虚线:在启动时完成的功能        红色虚线(实线)都是程序运行过程中执行的功能\n调用关系说明：\n\n服务容器负责启动，加载，运行服务提供者。\n服务提供者在启动时，向注册中心注册自己提供的服务。\n服务消费者在启动时，向注册中心订阅自己所需的服务。\n注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。\n服务消费者，从提供者地址列表中，基于负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。\n\n:basketball: 服务注册中心zookeeper\n① zookeeper简介通过前面的Dubbo架构图可以看到，Registry（服务注册中心）在其中起着至关重要的作用。Dubbo官方推荐使用Zookeeper作为服务注册中心。\nZookeeper 是 Apache Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用 。\n\n\n\n\n\n\n\n\n\n树形目录服务：我们电脑的文件系统(也是一个树型目录结构\nZooKeeper 的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。\n\n\n\n\n\n\n\n\n\n原语： 操作系统或计算机网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程。具有不可分割性·即原语的执行必须是连续的，在执行过程中不允许被中断。\n\n    \n    \n\n\n流程说明：\n\n服务提供者(Provider)启动时: 向 /dubbo/com.foo.BarService/providers 目录下写入自己的 URL 地址\n服务消费者(Consumer)启动时: 订阅 /dubbo/com.foo.BarService/providers 目录下的提供者 URL 地址。并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址\n监控中心(Monitor)启动时: 订阅 /dubbo/com.foo.BarService 目录下的所有提供者和消费者 URL 地址\n\n② zookeeper安装（win）下载 zookeeper 压缩包 \nbin ---&gt; 包括了linux和window的运行程序的运行目录\nconf ---&gt; zookeeper的配置zoo.cfg\ncontrib ---&gt; 其他一些组件和发行版本\ndist-maven ---&gt; maven发布下的一些jar包\ndocs ---&gt; 文档\nlib ---&gt; 库\nrecipe ---&gt; 一些应用实例\nsrc ---&gt; zookeeper的源码，因为zookeeper是java写出来的\n\nZookeeper在Windows下启动只需要运行zkServer.cmd双击即可（需保证运行环境中正确安装了Java运行环境）\n但是在有的时候会出现双击闪退的情况。针对闪退，可按照以下步骤进行解决：\n1. 编辑zkServer.cmd文件末尾添加pause 。这样运行出错就不会退出，会提示错误信息，方便找到原因。例如原因如下：\n\n2. 重新双击运行zkServer.cmd（错误原因 ，找不到zoo.cfg配置文件）\n\n3. 在conf目录中复制一份 zoo_sample.cfg 文件，起名为zoo.cfg\n4. 打开zoo.cfg文件，修改dataDir属性值，在上级目录下增加data目录\n\n5. 重新双击启动就行了\n③ zookeeper安装（linux）④ zookeeper详解（了解）https://juejin.cn/post/6919487002417037319\nhttps://juejin.cn/post/6844904045283377165\nhttps://juejin.cn/post/6844903677367418893\n:basketball: dubbo入门\nDubbo作为一个RPC框架，其最核心的功能就是要实现跨网络的远程调用。本小节就是要创建两个应用，一个作为服务的提供方，一个作为服务的消费方。通过Dubbo来实现服务消费方远程调用服务提供方的方法。\n① 服务提供方开发1. 创建maven工程（打包方式为war）dubbodemo_provider，在pom.xml文件中导入如下坐标\n&lt;packaging&gt;war&lt;&#x2F;packaging&gt;\n&lt;properties&gt;\n  &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;\n  &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;\n  &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;\n  &lt;spring.version&gt;5.0.5.RELEASE&lt;&#x2F;spring.version&gt;\n&lt;&#x2F;properties&gt;\n&lt;dependencies&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;\n  &lt;&#x2F;dependency&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-beans&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;\n  &lt;&#x2F;dependency&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;\n  &lt;&#x2F;dependency&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;\n  &lt;&#x2F;dependency&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-aspects&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;\n  &lt;&#x2F;dependency&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-jms&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;\n  &lt;&#x2F;dependency&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-context-support&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;\n  &lt;&#x2F;dependency&gt;\n  &lt;!-- dubbo相关 --&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;dubbo&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.6.0&lt;&#x2F;version&gt;\n  &lt;&#x2F;dependency&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;org.apache.zookeeper&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;zookeeper&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.4.7&lt;&#x2F;version&gt;\n  &lt;&#x2F;dependency&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;com.github.sgroschupf&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;zkclient&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;0.1&lt;&#x2F;version&gt;\n  &lt;&#x2F;dependency&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;javassist&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;javassist&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.12.1.GA&lt;&#x2F;version&gt;\n  &lt;&#x2F;dependency&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.2.47&lt;&#x2F;version&gt;\n  &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n&lt;build&gt;\n  &lt;plugins&gt;\n    &lt;plugin&gt;\n      &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;2.3.2&lt;&#x2F;version&gt;\n      &lt;configuration&gt;\n        &lt;source&gt;1.8&lt;&#x2F;source&gt;\n        &lt;target&gt;1.8&lt;&#x2F;target&gt;\n      &lt;&#x2F;configuration&gt;\n    &lt;&#x2F;plugin&gt;\n    &lt;plugin&gt;\n      &lt;groupId&gt;org.apache.tomcat.maven&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;tomcat7-maven-plugin&lt;&#x2F;artifactId&gt;\n      &lt;configuration&gt;\n        &lt;!-- 指定端口 --&gt;\n        &lt;port&gt;8081&lt;&#x2F;port&gt;\n        &lt;!-- 请求路径 --&gt;\n        &lt;path&gt;&#x2F;&lt;&#x2F;path&gt;\n      &lt;&#x2F;configuration&gt;\n    &lt;&#x2F;plugin&gt;\n  &lt;&#x2F;plugins&gt;\n&lt;&#x2F;build&gt;\n\n2. 配置web.xml文件创建 webapp/WEB-INF/web.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_1.xsd&quot;\n         version&#x3D;&quot;3.1&quot;&gt;\n    &lt;context-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n        &lt;param-value&gt;classpath:applicationContext*.xml&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;context-param&gt;\n    &lt;listener&gt;\n        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;\n    &lt;&#x2F;listener&gt;\n&lt;&#x2F;web-app&gt;\n\n3. 创建服务接口\npackage com.atguigu.service;\npublic interface HelloService &#123;\n    public String sayHello(String name);\n&#125;\n\n4. 创建服务实现类\npackage com.atguigu.service.impl;\nimport com.alibaba.dubbo.config.annotation.Service;\nimport com.atguigu.service.HelloService;\n@Service\npublic class HelloServiceImpl implements HelloService &#123;\n    @Override\n    public String sayHello(String name) &#123;\n        return &quot;hello &quot; + name;\n    &#125;\n&#125;\n\n==注意：服务实现类上使用的 Service 注解是Dubbo提供的，用于对外发布服务==5. 在src/main/resources下创建 applicationContext-service.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:dubbo&#x3D;&quot;http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&quot;\n       xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n\t\thttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n         http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc\n         http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd\n         http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo\n         http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd\n         http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context\n         http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;\n    &lt;!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --&gt;\n    &lt;dubbo:application name&#x3D;&quot;dubbodemo_provider&quot; &#x2F;&gt;\n    &lt;!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--&gt;\n    &lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;127.0.0.1:2181&quot;&#x2F;&gt;\n    &lt;!-- 注册  协议和port   端口默认是20880 --&gt;\n    &lt;dubbo:protocol name&#x3D;&quot;dubbo&quot; port&#x3D;&quot;20881&quot;&gt;&lt;&#x2F;dubbo:protocol&gt;\n    &lt;!-- 扫描指定包，加入@Service注解的类会被发布为服务  --&gt;\n    &lt;dubbo:annotation package&#x3D;&quot;com.atguigu.service.impl&quot; &#x2F;&gt;\n&lt;&#x2F;beans&gt;\n\n（6）启动服务\n② 服务消费方开发1. 创建 maven 工程（打包方式为war）dubbodemo_consumer，pom.xml 配置和上面服务提供者相同，只需要将 Tomcat 插件的端口号改为8082即可\n3. 配置web/WEB-INF/web.xml文件\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_1.xsd&quot;\n         version&#x3D;&quot;3.1&quot;&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;\n        &lt;!-- 指定加载的配置文件 ，通过参数contextConfigLocation加载 --&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n            &lt;param-value&gt;classpath:applicationContext-web.xml&lt;&#x2F;param-value&gt;\n        &lt;&#x2F;init-param&gt;\n        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;\n    &lt;&#x2F;servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;\n        &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;\n    &lt;&#x2F;servlet-mapping&gt;\n&lt;&#x2F;web-app&gt;\n\n3. 将服务提供者工程中的HelloService接口复制到当前工程\npackage com.atguigu.service;\npublic interface HelloService &#123;\n    public String sayHello(String name);\n&#125;\n\n4. 编写Controller\npackage com.atguigu.controller;\n\nimport com.alibaba.dubbo.config.annotation.Reference;\nimport com.atguigu.service.HelloService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n@Controller\n@RequestMapping(&quot;&#x2F;demo&quot;)\npublic class HelloController &#123;\n    @Reference\n    private HelloService helloService;\n\n    @RequestMapping(&quot;&#x2F;hello&quot;)\n    @ResponseBody\n    public String getName(String name)&#123;\n        &#x2F;&#x2F;远程调用\n        String result &#x3D; helloService.sayHello(name);\n        System.out.println(result);\n        return result;\n    &#125;\n\n&#125;\n\n==注意：Controller中注入HelloService使用的是Dubbo提供的@Reference注解==5. 在src/main/resources下创建applicationContext-web.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:dubbo&#x3D;&quot;http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&quot;\n       xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd\n                           http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo\n                           http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;\n\n    &lt;!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --&gt;\n    &lt;dubbo:application name&#x3D;&quot;dubbodemo-consumer&quot; &#x2F;&gt;\n    &lt;!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--&gt;\n    &lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;127.0.0.1:2181&quot;&#x2F;&gt;\n    &lt;!-- 扫描的方式暴露接口  --&gt;\n    &lt;dubbo:annotation package&#x3D;&quot;com.atguigu.controller&quot; &#x2F;&gt;\n    &lt;!-- 运行dubbo不检查提供者是否提前开启  --&gt;\n    &lt;!-- &lt;dubbo:consumer check&#x3D;&quot;false&quot;&gt;&lt;&#x2F;dubbo:consumer&gt; --&gt;\n\n&lt;&#x2F;beans&gt;\n\n6. 运行测试在浏览器输入http://localhost:8082/demo/hello?name=Jack，查看浏览器输出结果\n③ 思考（进行优化）思考一：上面的Dubbo入门案例中我们是将HelloService接口从服务提供者工程(dubbodemo_provider)复制到服务消费者工程(dubbodemo_consumer)中，这种做法是否合适？还有没有更好的方式？\n答：这种做法显然是不好的，同一个接口被复制了两份，不利于后期维护。更好的方式是单独创建一个maven工程，将此接口创建在这个maven工程中。需要依赖此接口的工程只需要在自己工程的pom.xml文件中引入maven坐标即可。\n思考二：在服务消费者工程(dubbodemo_consumer)中只是引用了HelloService接口，并没有提供实现类，Dubbo是如何做到远程调用的？\n答：==Dubbo底层是基于代理技术为HelloService接口创建代理对象，远程调用是通过此代理对象完成的。==\n思考三：上面的Dubbo入门案例中我们使用Zookeeper作为服务注册中心，服务提供者需要将自己的服务信息注册到Zookeeper，服务消费者需要从Zookeeper订阅自己所需要的服务，此时Zookeeper服务就变得非常重要了，那如何防止Zookeeper单点故障呢？\n答：Zookeeper其实是支持集群模式的，可以配置Zookeeper集群来达到Zookeeper服务的高可用，防止出现单点故障。\n\n\n\n\n\n\n\n\n\n点单故障：通常分布式系统采用主从模式，一个主机连接多个处理节点，主节点负责分发任务，而子节点负责处理业务，当主节点发生故障时，会导致整个系统发故障，我们把这种故障叫做单点故障。\n④ 代码重构1. 创建项目：dubbodemo_interface\n2. 把 项目dubbodemo_consumer 和 项目dubbodemo_provider当中的 接口 HelloService 拷贝到dubbodemo_interface工程里面\n3. 删除工程dubbodemo_consumer 和 工程dubbodemo_provider当中的 接口 HelloService\n4. dubbodemo_consumer 工程和dubbodemo_provider添加pom文件的依赖\n&lt;dependency&gt;\n\n  &lt;groupId&gt;com.atguigu&lt;&#x2F;groupId&gt;\n\n  &lt;artifactId&gt;dubbodemo_interface&lt;&#x2F;artifactId&gt;\n\n  &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n\n&lt;&#x2F;dependency&gt;\n\n5. 运行程序：http://localhost:8082/demo/hello?name=haha\n⑤ 加入log4j 日志运行程序发现dubbo建议大家使用 log4j日志，我们就需要在 resources 文件夹下面引入log4j.properties日志文件\n### direct log messages to stdout ###\n\nlog4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.Target&#x3D;System.err\nlog4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern&#x3D;%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n\n\n### direct messages to file mylog.log ###\n\nlog4j.appender.file&#x3D;org.apache.log4j.FileAppender\nlog4j.appender.file.File&#x3D;c:\\\\mylog.log\nlog4j.appender.file.layout&#x3D;org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern&#x3D;%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n\n\n### set log levels - for more verbose logging change &#39;info&#39; to &#39;debug&#39; ###\n\nlog4j.rootLogger&#x3D;debug, stdout\n\n\n\n:basketball: dubbo相关配置说明\n① 包扫描&lt;dubbo:annotation package&#x3D;&quot;com.atguigu.service&quot; &#x2F;&gt;\n\n服务提供者和服务消费者都需要配置，表示包扫描，作用是扫描指定包(包括子包)下的类。如果不使用包扫描，也可以通过如下配置的方式来发布服务：\n&lt;bean id&#x3D;&quot;helloService&quot; class&#x3D;&quot;com.atguigu.service.impl.HelloServiceImpl&quot; &#x2F;&gt;\n&lt;dubbo:service interface&#x3D;&quot;com.atguigu.api.HelloService&quot; ref&#x3D;&quot;helloService&quot; &#x2F;&gt;\n\n作为服务消费者，可以通过如下配置来引用服务：\n&lt;!-- 生成远程服务代理，可以和本地bean一样使用helloService --&gt;\n&lt;dubbo:reference id&#x3D;&quot;helloService&quot; interface&#x3D;&quot;com.atguigu.api.HelloService&quot; &#x2F;&gt;\n\n上面这种方式发布和引用服务，一个配置项(dubbo:service、dubbo:reference)只能发布或者引用一个服务，如果有多个服务，这种方式就比较繁琐了。推荐使用包扫描方式。\n② 协议&lt;dubbo:protocol name&#x3D;&quot;dubbo&quot; port&#x3D;&quot;20880&quot;&#x2F;&gt;\n\n一般在服务提供者一方配置，可以指定使用的协议名称和端口号。其中Dubbo支持的协议有：dubbo、rmi、hessian、http、webservice、rest、redis等。推荐使用的是dubbo协议。dubbo 协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。也可以在同一个工程中配置多个协议，不同服务可以使用不同的协议，例如：\n&lt;!-- 多协议配置 --&gt;\n&lt;dubbo:protocol name&#x3D;&quot;dubbo&quot; port&#x3D;&quot;20880&quot; &#x2F;&gt;\n&lt;dubbo:protocol name&#x3D;&quot;rmi&quot; port&#x3D;&quot;1099&quot; &#x2F;&gt;\n&lt;!-- 使用dubbo协议暴露服务 --&gt;\n&lt;dubbo:service interface&#x3D;&quot;com.atguigu.service.HelloService&quot; ref&#x3D;&quot;helloService&quot; protocol&#x3D;&quot;dubbo&quot; &#x2F;&gt;\n&lt;!-- 使用rmi协议暴露服务 --&gt;\n&lt;dubbo:service interface&#x3D;&quot;com.atguigu.service.DemoService&quot; ref&#x3D;&quot;demoService&quot; protocol&#x3D;&quot;rmi&quot; &#x2F;&gt; \n\n③ 启动时检查&lt;dubbo:consumer check&#x3D;&quot;false&quot;&#x2F;&gt;\n\n上面这个配置需要配置在服务消费者一方，如果不配置默认check值为true。Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题。可以通过将check值改为false来关闭检查。建议在开发阶段将check值设置为false，在生产环境下改为true。\n:basketball: dubbo控制台管理\n我们在开发时，需要知道Zookeeper注册中心都注册了哪些服务，有哪些消费者来消费这些服务。我们可以通过部署一个管理中心来实现。其实管理中心就是一个web应用，部署到tomcat即可。\n① 安装1. 下载dubbo-admin-2.6.0.war文件到tomcat的webapps目录下\n2. 启动tomcat，此war文件会自动解压\n3. 修改WEB-INF下的dubbo.properties文件，注意dubbo.registry.address对应的值需要对应当前使用的Zookeeper的ip地址和端口号\ndubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;192.168.134.129:2181\n\ndubbo.admin.root.password&#x3D;root\n\ndubbo.admin.guest.password&#x3D;guest\n\n4. 重启tomcat\n② 使用1. 开启tomcat\n2. 访问http://localhost:8080/dubbo-admin-2.6.0/ ，输入用户名(root)和密码(root),切换简体中文\n\n3. 启动服务提供者工程和服务消费者工程，可以在查看到对应的信息\n\n:basketball: Dubbo无法发布被事务代理的Service问题前面我们已经完成了Dubbo的入门案例，通过入门案例我们可以看到通过Dubbo提供的标签配置就可以进行包扫描，扫描到@Service注解的类就可以被发布为服务。\n但是我们如果在服务提供者类上加入@Transactional事务控制注解后，服务就发布不成功了。原因是事务控制的底层原理是为服务提供者类创建代理对象，而默认情况下Spring是基于JDK动态代理方式创建代理对象，而此代理对象的完整类名为com.sun.proxy.$Proxy42（最后两位数字不是固定的），导致Dubbo在发布服务前进行包匹配时无法完成匹配，进而没有进行服务的发布。\n① 问题展示在入门案例的服务提供者dubbodemo_provider工程基础上进行展示，操作步骤如下：1. 在pom.xml文件中增加maven坐标\n&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.1.47&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.1.6&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.3.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n2. 在applicationContext-service.xml配置文件中加入数据源、事务管理器、开启事务注解的相关配置\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:dubbo&#x3D;&quot;http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&quot;\n       xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot; xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd\n                           http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo\n                           http:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd&quot;&gt;\n    &lt;!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --&gt;\n    &lt;dubbo:application name&#x3D;&quot;dubbodemo_provider&quot; &#x2F;&gt;\n    &lt;!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--&gt;\n    &lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;127.0.0.1:2181&quot;&#x2F;&gt;\n    &lt;!-- 注册  协议和port   端口默认是20880 --&gt;\n    &lt;dubbo:protocol name&#x3D;&quot;dubbo&quot; port&#x3D;&quot;20882&quot;&gt;&lt;&#x2F;dubbo:protocol&gt;\n    &lt;!-- 扫描指定包，加入@Service注解的类会被发布为服务  --&gt;\n    &lt;dubbo:annotation package&#x3D;&quot;com.atguigu.service.impl&quot; &#x2F;&gt;\n    &lt;!--数据源--&gt;\n    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method&#x3D;&quot;close&quot;&gt;\n        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot; &#x2F;&gt;\n        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot; &#x2F;&gt;\n        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot; &#x2F;&gt;\n        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test&quot; &#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n    &lt;!-- 事务管理器  --&gt;\n    &lt;bean id&#x3D;&quot;transactionManager&quot;\n          class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;\n        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n    &lt;!--开启事务控制的注解支持--&gt;\n    &lt;tx:annotation-driven transaction-manager&#x3D;&quot;transactionManager&quot;&#x2F;&gt;\n&lt;&#x2F;beans&gt;\n\n上面连接的数据库可以自行创建3. 在HelloServiceImpl类上加入@Transactional注解\npackage com.atguigu.service.impl;\nimport com.alibaba.dubbo.config.annotation.Service;\nimport com.atguigu.service.HelloService;\nimport org.springframework.transaction.annotation.Transactional;\n@Service\n@Transactional\npublic class HelloServiceImpl implements HelloService &#123;\n    @Override\n    public String sayHello(String name) &#123;\n        return &quot;8086 hello &quot; + name;\n    &#125;\n&#125;\n\n4. 启动服务提供者和服务消费者，并访问\n\n上面的错误为没有可用的服务提供者\n5. 查看dubbo管理控制台发现服务并没有发布\n6. 可以通过断点调试的方式查看Dubbo执行过程，Dubbo通过AnnotationBean的postProcessAfterInitialization方法进行处\n\n② 解决方案通过上面的断点调试可以看到，在HelloServiceImpl类上加入事务注解后，Spring会为此类基于JDK动态代理技术创建代理对象，创建的代理对象完整类名为com.sun.proxy.$Proxy35，导致Dubbo在进行包匹配时没有成功（因为我们在发布服务时扫描的包为com.atguigu.service），所以后面真正发布服务的代码没有执行。解决方式操作步骤如下：1. 修改applicationContext-service.xml配置文件，开启事务控制注解支持时指定proxy-target-class属性，值为true。其作用是使用cglib代理方式为Service类创建代理对象，添加如下配置：\n&lt;!--开启事务控制的注解支持--&gt;\n&lt;tx:annotation-driven transaction-manager&#x3D;&quot;transactionManager&quot; proxy-target-class&#x3D;&quot;true&quot;&#x2F;&gt;\n\n2. 修改HelloServiceImpl类，在Service注解中加入interfaceClass属性，值为HelloService.class，作用是指定服务的接口类型\npackage com.atguigu.service.impl;\nimport com.alibaba.dubbo.config.annotation.Service;\nimport com.atguigu.service.HelloService;\nimport org.springframework.transaction.annotation.Transactional;\n@Service(interfaceClass &#x3D; HelloService.class)\n@Transactional\npublic class HelloServiceImpl implements HelloService &#123;\n    @Override\n    public String sayHello(String name) &#123;\n        return &quot;8086 hello &quot; + name;\n    &#125;\n&#125;\n\n\n\n:basketball: 一些运行过程\n① 消费者过程\n首先消费者启动会向注册中心拉取服务提供者的元信息，然后调用流程也是从 Proxy 开始，毕竟都需要代理才能无感知。\nProxy 持有一个 Invoker 对象，调用 invoke 之后需要通过 Cluster 先从 Directory 获取所有可调用的远程服务的 Invoker 列表，如果配置了某些路由规则，比如某个接口只能调用某个节点的那就再过滤一遍 Invoker 列表。\n剩下的 Invoker 再通过 LoadBalance 做负载均衡选取一个。然后再经过 Filter 做一些统计什么的，再通过 Client 做数据传输，比如用 Netty 来传输。\n传输需要经过 Codec 接口做协议构造，再序列化。最终发往对应的服务提供者。\n服务提供者接收到之后也会进行 Codec 协议处理，然后反序列化后将请求扔到线程池处理。某个线程会根据请求找到对应的 Exporter ，而找到 Exporter 其实就是找到了 Invoker，但是还会有一层层 Filter，经过一层层过滤链之后最终调用实现类然后原路返回结果。\n完成整个调用过程！\n","slug":"55-Dubbo Zookeeper","date":"2021-09-13T15:32:32.000Z","categories_index":"微服务","tags_index":"微服务","author_index":"大黄"},{"id":"39dbbffa03a8d8ee66fd7af853996d07","title":"SpringMVC 源码分析","content":":green_book: SpringMVC 运行原理① 总体情形\n\n用户发送请求至DispatcherServlet。\nDispatcherServlet收到请求调用HandlerMapping查询具体的Handler。\nHandlerMapping找到具体的处理器(具体配置的是哪个处理器的实现类)，生成处理器对象及处理器拦截器(HandlerExcutorChain包含了Handler以及拦截器集合)返回给DispatcherServlet。\nDispatcherServlet接收到HandlerMapping返回的HandlerExcutorChain后，调用HandlerAdapter(处理器适配器)请求执行具体的Handler(Controller)。\nHandlerAdapter经过适配调用拦截器链。然后经过拦截器后在分发给具体的Handler(Controller即后端控制器)。   \nController执行完成返回ModelAndView(其中包含逻辑视图和数据)给HandlerAdaptor。\nHandlerAdaptor再将ModelAndView返回给DispatcherServlet。\nDispatcherServlet请求视图解析器ViewReslover解析ModelAndView。\nViewReslover解析后返回具体View(物理视图)到DispatcherServlet。\nDispatcherServlet请求渲染视图(即将模型数据填充至视图中) 根据View进行渲染视图。\n将渲染后的视图返回给DispatcherServlet。\nDispatcherServlet将响应结果返回给用户。\n\n② 核心组件\n前端控制器DispatcherServlet（配置即可）\n功能: 中央处理器,接收请求,自己不做任何处理,而是将请求发送给其他组件进行处理。DispatcherServlet 是整个流程的控制中心。\n\n处理器映射器HandlerMapping(配置即可)\n功能: 根据DispatcherServlet发送的url请求路径查找Handler\n常见的处理器映射器:BeanNameUrlHandlerMapping,SimpleUrlHandlerMapping,\nControllerClassNameHandlerMapping,DefaultAnnotationHandlerMapping(不建议使用)\n\n处理器适配器HandlerAdapter（配置即可）\n功能: 按照特定规则（HandlerAdapter要求的规则）去执行Handler。\n通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展多个适配器对更多类型的处理器进行执行。\n常见的处理器适配器:HttpRequestHandlerAdapter，SimpleControllerHandlerAdapter，AnnotationMethodHandlerAdapter\n\n处理器Handler即Controller(程序猿编写)\n功能: 编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler。\n\n视图解析器ViewReslover(配置即可)\n功能: 进行视图解析，根据逻辑视图名解析成真正的视图。\nViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。\nspringmvc框架提供了多种View视图类型,如:jstlView、freemarkerView、pdfView…\n\n视图View(程序猿编写)\nView是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）\n\n\n③ 常见API\nDispatcherServlet：发现他的上级类中有HttpServlet，而Servlet的执行入口是service()，一会就从这个方法入手开始SpringMVC执行过程的讲解。\n\n    \n        图一、DispatcherServlet   图二、HandlerMapping\n    \n    \n    \n\nHandlerMapping：项目中会有多个@RequestMapping，每个RequestMapping对应一个类或者一个方法。用户给一个请求路径，如何获取该路径所对应的方法呢？这就要通过HandlerMapping来实现了。返回的结果就是访问路径所对应的处理器。\n查看源码，发现HandlerMapping是一个接口，有多个实现类。该接口只有一个方法。当使用注解方式时，使用的处理器映射器是RequestMappingHandlerMapping。\n\nHandlerExecutionChain：为什么请求Handler，要返回HandlerExecutionChain呢。因为Handler的执行前后会有一个或者多个拦截器执行，并且拦截器是链式执行的。所有HandlerExecutionChain中就包含了要执行的一个处理器和多个拦截器的信息。\n处理器就是我们开发的使用@Controller标记的控制器。而拦截器也己经经过，要实现三个方法，分别在不同的时机执行。以后都会看到三个方法执行的代码的。\n\n\nHandlerAdapter：处理器的执行是通过处理器适配器来执行的。因为会有XML方式、注解方式等处理器形式，具体执行会有不同，通过不同的HandlerAdapter来实现。这里用到了适配器设计模式。HandlerAdapter在SpringMVC中是一个接口。其中的handle()就是执行处理器。当使用注解方式时，使用的处理器映射器是RequestMappingHandlerAdapter。\n\n\nViewResolver：ViewResolver实现逻辑视图到物理视图的解析，比如：对于如下视图解析器，”main”是逻辑视图，而添加了后缀前缀的“/WEB-INF/jsp/main.jsp”就是物理视图。\n在SpringMVC中ViewResolver作为一个接口存在，可以有不同的实现类，比如上面的InternalResourceViewResolver。\n&lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;\n    &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;&gt;&lt;&#x2F;property&gt;\n    &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&gt;&lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n\n:green_book: DispatcherServlet请求处理过程整个请求处理过程都是 doDispatch() 方法在宏观上协调和调度，把握了这个方法就理解了 SpringMVC 总体上是如何处理请求的。\n所在类：org.springframework.web.servlet.DispatcherServlet\n所在方法：doDispatch()\n① 入口点：FrameworkServlet\n分析:    FrameworkServlet重写了HttpServlet的service方法, 请求进来的时候, 首先是进入到了这个service方法,    通过从请求中拿到请求方法, 将其转为枚举类HttpMethod, 最后还是调用了HttpServlet的service方法。\n之所以重写这个方法, 原因是增加了对请求方法类型为patch的处理, 在HttpServlet的service中是没有对这个类型 的请求进行处理的, 我们先不理会processRequest方法是做啥的, 首先需要知道, 当请求是其他类型的时候, 最终会调用到HttpServlet的service方法的, 在这个方法中有各种doXXX方法, 然而!!FrameworkServlet重写了这些doXXX方法, 以doPost为例:\nprotected final void doPost(HttpServletRequest request, HttpServletResponse response) &#123;           \n    processRequest(request, response);       \n&#125;     \n\nok, 到这里为止, 大家应该就清楚了, 真正处理请求的是这个processRequest方法, 所有的请求最终都会到    FrameworkServlet中的doXX方法, 最终用processRequest方法来调用\n② 真正处理请求：processRequest\n 第一部分，就是构建LocaleContext、ServletRequestAttributes, 然后将他们保    存到ThreadLocal中, 这样我们在整个请求的任何地方都能获取到这两个对象了。\n第二部分doService方法才是真正用来处理请求的, 这 个方法里面做的事情对执行流程的分析也没多大意义。他会跳转到DispatcherServlet中的 doService方法中，然后调用 doDispatch() 方法\n③ 处理请求的核心：doDispatchprocessedRequest表示真正的请求对象,\nmappedHandler就 是之前我们分析的, 将handler和HandlerInterceptor封装起来的对象,\nmultipartRequestParsed表示是否对文件 上传这样的功能进行了解析\n第六步，将handler和HandlerIntercepter进行合并, 变成一个HandlerExecutionChain 对象\n\nmappedHandler.getHandler()获取对应的handler, 利用这个handler来遍历所有的HandlerAdapter, 找到合适的 HandlerAdapter并返回\n\n遍历HandlerExecutionChain中的所有拦截器, 调用其preHandle方法(正序), 如果返回true, 那么就继续执行, 返回 false则就不执行了。\n调用HandlerAdapter的handle方法, 若是**@RequestMapping的情况, 则调用的是 AbstractHandlerMethodAdapter的hanlde方法**，返回一个ModelAndView对象。\napplyDefaultViewName是因为当我们返回的ModelAndView中没有View的时候, 比如我们@RequestMapping标注的方 法返回的是void或者有被@ResponseBody标注的时候, 就是没有视图的, 此时会赋予一个默认的视图,。\n 最后调用HandlerExecutionChain中所有拦截器的**postHandle方法(逆序)**，在doDispatch的代码中, 我们可以看到在异常捕获后调用了triggerAfterCompletion方法, 里面其实就是对 HandlerExecutionChain中所有拦截器的afterCompletion方法的调用。\n\n\n\n\n\n\n\n\n\n\n调用 **processDispatchResult，解析和渲染视图，执行拦截器的afterComplation()[逆序]**就全靠它了，第二个红框没用\n\nrender方法其实就是利用ViewResolver解析viewName, 获取到一个视图View对 象, 然后对http的状态进行一下设置, 最后调用视图对象View的render方法完成渲染, 对于JSP文件来说, 其实就是 forward到对应的jsp文件而已\n\n④ 所有断点总结断点位置基准：SpringMVC 版本采用 5.3.1 且源码已经下载，包含注释。\n\n\n\n所在类\n所在方法\n断点行数\n作用\n\n\n\nDispatcherServlet\ndoDispatch()\n1037\n创建调用链对象\n\n\nDispatcherServlet\ndoDispatch()\n1044\n创建 HandlerAdapter 对象\n\n\nDispatcherServlet\ndoDispatch()\n1056\n调用拦截器 preHandle()方法\n\n\nDispatcherServlet\ndoDispatch()\n1061\n执行目标 handler 方法\n\n\nDispatcherServlet\ndoDispatch()\n1068\n调用拦截器 postHandle()方法\n\n\nDispatcherServlet\ndoDispatch()\n1078\n执行所有后续操作\n\n\nAbstractHandlerMapping\ngetHandlerExecutionChain()\n592\n创建调用链对象\n\n\nAbstractHandlerMapping\ngetHandlerExecutionChain()\n599\n在调用链中添加拦截器\n\n\nHandlerExecutionChain\napplyPreHandle()\n146\n调用拦截器 preHandle()方法\n\n\nHandlerExecutionChain\napplyPostHandle()\n163\n调用拦截器 postHandle()方法\n\n\nHandlerExecutionChain\ntriggerAfterCompletion\n175\n调用拦截器 afterCompletion()方法\n\n\nDataBinder\ndoBind()\n747\n执行数据绑定\n\n\nRequestMappingHandlerAdapter\ninvokeHandlerMethod()\n868\n创建 ModelAndViewContainer 对象\n\n\nRequestMappingHandlerAdapter\ninvokeHandlerMethod()\n893\n将ModelAndViewContainer 对象传入调用目标 handler 的方法\n\n\nDispatcherServlet\nprocessDispatchResult()\n1125\n处理异常\n\n\nDispatcherServlet\nprocessDispatchResult()\n1139\n渲染视图\n\n\nDispatcherServlet\nprocessDispatchResult()\n1157\n调用拦截器 afterCompletion()方法\n\n\nWebEngineContext的内部类： RequestAttributesVariablesMap\nsetVariable()\n783\n将模型数据存入请求域\n\n\n:green_book: 启动过程① Servlet生命周期回顾\n\n\n生命周期环节\n调用的方法\n时机\n次数\n\n\n\n创建对象\n无参构造器\n默认：第一次请求 修改：Web应用启动时\n一次\n\n\n初始化\ninit(ServletConfig servletConfig)\n创建对象后\n一次\n\n\n处理请求\nservice(ServletRequest servletRequest, ServletResponse servletResponse)\n接收到请求后\n多次\n\n\n清理操作\ndestroy()\nWeb应用卸载之前\n一次\n\n\n② 初始化调用路线\n③ 创建 IOC 容器对象并存入应用域所在类：org.springframework.web.servlet.FrameworkServlet\nprotected WebApplicationContext initWebApplicationContext() &#123;\n    WebApplicationContext rootContext &#x3D;\n            WebApplicationContextUtils.getWebApplicationContext(getServletContext());\n    WebApplicationContext wac &#x3D; null;\n\n    if (this.webApplicationContext !&#x3D; null) &#123;\n        wac &#x3D; this.webApplicationContext;\n        if (wac instanceof ConfigurableWebApplicationContext) &#123;\n            ConfigurableWebApplicationContext cwac &#x3D; (ConfigurableWebApplicationContext) wac;\n            if (!cwac.isActive()) &#123;\n                if (cwac.getParent() &#x3D;&#x3D; null) &#123;\n                    cwac.setParent(rootContext);\n                &#125;\n                configureAndRefreshWebApplicationContext(cwac);\n            &#125;\n        &#125;\n    &#125;\n    if (wac &#x3D;&#x3D; null) &#123;\n        wac &#x3D; findWebApplicationContext();\n    &#125;\n    if (wac &#x3D;&#x3D; null) &#123;\n        &#x2F;&#x2F; 创建 IOC 容器\n        wac &#x3D; createWebApplicationContext(rootContext);\n    &#125;\n\n    if (!this.refreshEventReceived) &#123;\n        synchronized (this.onRefreshMonitor) &#123;\n            onRefresh(wac);\n        &#125;\n    &#125;\n\n    if (this.publishContext) &#123;\n        &#x2F;&#x2F; 获取存入应用域时专用的属性名\n        String attrName &#x3D; getServletContextAttributeName();\n        \n        &#x2F;&#x2F; 存入\n        getServletContext().setAttribute(attrName, wac);\n    &#125;\n\n    return wac;\n&#125;\n\n看到这一点的意义：SpringMVC 有一个工具方法，可以从应用域获取 IOC 容器对象的引用。\n工具类：org.springframework.web.context.support.WebApplicationContextUtils\n工具方法：getWebApplicationContext()\n@Nullable\npublic static WebApplicationContext getWebApplicationContext(ServletContext sc) &#123;\n    return getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);\n&#125;\n\n\n④ IOC容器创建所在类：org.springframework.web.servlet.FrameworkServlet\nprotected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) &#123;\n    Class&lt;?&gt; contextClass &#x3D; getContextClass();\n    if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;\n        throw new ApplicationContextException(\n                &quot;Fatal initialization error in servlet with name &#39;&quot; + getServletName() +\n                &quot;&#39;: custom WebApplicationContext class [&quot; + contextClass.getName() +\n                &quot;] is not of type ConfigurableWebApplicationContext&quot;);\n    &#125;\n    \n    &#x2F;&#x2F; 通过反射创建 IOC 容器对象\n    ConfigurableWebApplicationContext wac &#x3D;\n            (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);\n\n    wac.setEnvironment(getEnvironment());\n    \n    &#x2F;&#x2F; 设置父容器\n    wac.setParent(parent);\n    String configLocation &#x3D; getContextConfigLocation();\n    if (configLocation !&#x3D; null) &#123;\n        wac.setConfigLocation(configLocation);\n    &#125;\n    configureAndRefreshWebApplicationContext(wac);\n\n    return wac;\n&#125;\n\n注意：创建DispatcherServlet中创建IoC容器时会去应用域中查询已经存在的IoC容器，并作为父容器。如果不存在，父容器就是null，表示没有父容器。这个操作并不多余，下节讲解ContextLoaderListener后就会明白原由。\n\n⑤ 获取SpringMVC配置文件名称&lt;servlet&gt;\n    &lt;servlet-name&gt;dispatcherServlet&lt;&#x2F;servlet-name&gt;\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;\n    &lt;init-param&gt;\n        &lt;!--指定SpringMVC配置文件的名称和位置，有默认位置 --&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n        &lt;param-value&gt;classpath:springmvc.xml&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;init-param&gt;\n    &lt;!-- 启动服务器时就加载总控制器--&gt;\n    &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;\n&lt;&#x2F;servlet&gt;\n\n\n⑥ 配置文件内容解析\n\n\n\n\n\n\n\n\n&lt;mvc:annotation-driven&gt; \n&lt;bean id=&quot;viewResolver&quot; class=&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt;\n @RequestMapping(&quot;user/save1&quot;)\n\n\n⑦ 小结\nDispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。\nDispatcherServlet 的父类是 FrameworkServlet。\nFrameworkServlet 负责框架本身相关的创建和初始化。\nDispatcherServlet 负责请求处理相关的初始化。\n\n\nFrameworkServlet 创建 IOC 容器对象之后会存入应用域。\nFrameworkServlet 完成初始化会调用 IOC 容器的刷新方法。\n刷新方法完成触发刷新事件，在刷新事件的响应函数中，调用 DispatcherServlet 的初始化方法。\n在 DispatcherServlet 的初始化方法中初始化了请求映射等。\n\n\n:green_book: ContextLoaderListener\n\n\n方法名\n执行时机\n作用\n\n\n\ncontextInitialized()\nWeb 应用启动时执行\n创建并初始化 IOC 容器\n\n\ncontextDestroyed()\nWeb 应用卸载时执行\n关闭 IOC 容器\n\n\n① 问题引入SSM整合后，配置文件内容过多，可以分到两个配置文件中。这两个配置文件夹如何加载\n方法1：DispatcherServlet加载所有的配置文件（用 * 匹配后缀），此方法只有一个Ioc容器，存放所有的Bean\n&lt;!--配置SpringMVC总控制器，唯一的Servlet --&gt;  \n\n&lt;servlet&gt;   \n\n    &lt;servlet-name&gt;dispatcherServlet&lt;&#x2F;servlet-name&gt;   \n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;   \n\n    &lt;init-param&gt;     \n        &lt;!--指定SpringMVC配置文件的名称和位置，有默认位置 --&gt;     \n        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;     \n        &lt;param-value&gt;classpath:spring*.xml&lt;&#x2F;param-value&gt;   \n    &lt;&#x2F;init-param&gt;   \n\n    &lt;!-- 启动服务器时就加载总控制器--&gt;   \n    &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;  \n\n&lt;&#x2F;servlet&gt;\n\n\n\n方法2：DispatcherServlet加载springmvc的配置文件，使用ContextLoaderListener加载另外一个配置文件\n会有两个Ioc容器\n使用ContextLoaderListener加载另外一个配置文件创建的IoC容器是父容器。\nDispatcherServlet加载springmvc的配置文件创建的IoC容器是子容器。\n注意：Servlet、Filter、Listener的加载顺序：Listener、Filter、Servlet\n② 使用Lister创建IOC容器在web.xml 中引入 监听器\n&lt;context-param&gt;\n    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n    &lt;param-value&gt;classpath:spring-persist.xml&lt;&#x2F;param-value&gt;\n&lt;&#x2F;context-param&gt;\n&lt;listener&gt;\n    &lt;!-- 该监听器加载的spring配置文件有默认的位置和名称，默认在WEB-INF--&gt;\n    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;\n&lt;&#x2F;listener&gt;\n\nServletContextListener中 只有两个方法，分别在服务器启动和关闭的时候执行\npublic interface ServletContextListener extends EventListener &#123;\n&#x2F;&#x2F;服务器启动时执行\n    void contextInitialized(ServletContextEvent var1);\n    &#x2F;&#x2F;服务器关闭时执行\n    void contextDestroyed(ServletContextEvent var1);\n&#125;\n\n\n③ 探讨两个IoC容器的关系结论：两个组件分别创建的 IOC 容器是父子关系。\n\n父容器：ContextLoaderListener 创建的 IOC 容器\n子容器：DispatcherServlet 创建的 IOC 容器\n\n父子关系是如何决定的？\n\nContextLoaderListener 初始化时如果检查到有已经存在的根级别 IOC 容器，那么会抛出异常。\nDispatcherServlet 创建的 IOC 容器会在初始化时先检查当前环境下是否存在已经创建好的 IOC 容器。\n如果有：则将已存在的这个 IOC 容器设置为自己的父容器\n如果没有：则将自己设置为 root 级别的 IOC 容器\n\n\n同时 Tomcat 在读取 web.xml 之后，加载组件的顺序就是监听器、过滤器、Servlet。\n\nDispatcherServlet 创建的 IOC 容器设置父容器的源码截图：\n所在类：org.springframework.web.servlet.FrameworkServlet\n所在方法：createWebApplicationContext()\n\n\n④ 出现的问题及其解决如果&lt;context:component-scan &gt;的路径设置不合理，就会重复的创建Bean。如何查看：将logback的总的日志级别改为DEBUG\n缺点：\n\n重复的bean会多占用资源\n\nSpringMVC创建的Controller肯定是调用SpringMVC自己创建的Service和Dao，但是在SpringMVC的配置文件中并没有关于事务的设置，所以调用SpringMVC自己创建的Service和Dao，将无法使用到事务。这绝对不可以。\n\n\n⑤ 解决方案1【建议使用】==让两个配置文件配置自动扫描的包时，各自扫描各自的组件。==\n\nSpringMVC 就扫描 XxxHandler\nSpring 扫描 XxxService 和 XxxDao\n\n&lt;!-- 配置注解扫描基准路径--&gt;\n&lt;context:component-scan base-package&#x3D;&quot;com.atguigu.controller&quot;&gt;&lt;&#x2F;context:component-scan&gt;\n\n&lt;!-- 配置注解扫描基准路径--&gt;\n&lt;context:component-scan base-package&#x3D;&quot;com.atguigu.service,com.atguigu.dao&quot;&gt;&lt;&#x2F;context:component-scan&gt;\n\n结果：SpringMVC中创建了Controller，Listener中创建了Service并应用了事务。当SpringMVC在自己的IoC容器中找不到Service的时候，就会到父容器中去找Service。问题解决。\n⑥ 解决方案2具体spring-mvc.xml配置文件中的配置方式如下： \n&lt;!-- 两个Spring的配置文件扫描相同的包 --&gt;\n&lt;!-- 为了解决重复创建对象的问题，需要进一步制定扫描组件时的规则 --&gt;\n&lt;!-- 目标：『仅』包含@Controller注解标记的类 --&gt;\n&lt;!-- use-default-filters&#x3D;&quot;false&quot;表示关闭默认规则，表示什么都不扫描，此时不会把任何组件加入IOC容器；\n        再配合context:include-filter实现“『仅』包含”效果 --&gt;\n&lt;context:component-scan base-package&#x3D;&quot;com.atguigu.spring.component&quot; use-default-filters&#x3D;&quot;false&quot;&gt;\n\n    &lt;!-- context:include-filter标签配置一个“扫描组件时要包含的类”的规则，追加到默认规则中 --&gt;\n    &lt;!-- type属性：指定规则的类型，根据什么找到要包含的类，现在使用annotation表示基于注解来查找 --&gt;\n    &lt;!-- expression属性：规则的表达式。如果type属性选择了annotation，那么expression属性配置注解的全类名 --&gt;\n    &lt;context:include-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Controller&quot;&#x2F;&gt;\n&lt;&#x2F;context:component-scan&gt;\n\n具体spring-persist.xml配置文件中的配置方式如下：\n&lt;!-- 两个Spring的配置文件扫描相同的包 --&gt;\n&lt;!-- 在默认规则的基础上排除标记了@Controller注解的类 --&gt;\n&lt;context:component-scan base-package&#x3D;&quot;com.atguigu.spring.component&quot;&gt;\n\n    &lt;!-- 配置具体排除规则：把标记了@Controller注解的类排除在扫描范围之外 --&gt;\n    &lt;context:exclude-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Controller&quot;&#x2F;&gt;\n&lt;&#x2F;context:component-scan&gt;\n\n","slug":"54-SpringMVC-源码分析","date":"2021-09-13T15:31:32.000Z","categories_index":"SpringMVC","tags_index":"SpringMVC","author_index":"大黄"},{"id":"a17a011b39e721d63806f9eabda18a53","title":"SpringMVC 特定功能","content":":cactus: 拦截器① 拦截器前言\nSpringMVC提供的拦截器类似于JavaWeb中的过滤器，只不过SpringMVC拦截器只拦截被前端控制器拦截的请求，而过滤器拦截从前端发送的任意请求。\n熟练掌握SpringMVC拦截器对于我们开发非常有帮助，在没使用权限框架(shiro，spring security)之前，一般使用拦截器进行认证和授权操作。\nSpringMVC拦截器有许多应用场景，比如：登录认证拦截器，字符过滤拦截器，日志操作拦截器等等。\n\n② 拦截器 VS 过滤器\n相似点\n\n三要素相同\n拦截：必须先把请求拦住，才能执行后续操作\n过滤：拦截器或过滤器存在的意义就是对请求进行统一处理\n放行：对请求执行了必要操作后，放请求过去，让它访问原本想要访问的资源\n\n\n\n不同点\n\n工作平台不同\n过滤器工作在 Servlet 容器中\n==拦截器工作在 SpringMVC 的基础上==\n\n拦截的范围不同\n过滤器：能够拦截到的最大范围是整个 Web 应用\n拦截器：能够拦截到的最大范围是整个 SpringMVC 负责的请求（看DispatcherServlet的&lt;url-pattern&gt;的设置是/还是*.action）\n\nIOC 容器支持\n过滤器：想得到 IOC 容器需要调用专门的工具方法，是间接的\n拦截器：它自己就在 IOC 容器中，所以可以直接从 IOC 容器中装配组件，也就是可以直接得到 IOC 容器的支持\n\n\n\n选择上：功能需要如果用 SpringMVC 的拦截器能够实现，就不使用过滤器。\n\n\n③ SpringMVC拦截器的实现\n自定义的Interceptor类要实现了Spring的HandlerInterceptor接口。（一般使用实现此接口的方式，接口中为默认方法，可实现也可不实现，但一般都实现）\n继承实现了HandlerInterceptor接口的类，比如Spring已经提供的实现了HandlerInterceptor接口的抽象类HandlerInterceptorAdapter。(Spring5支持JDK8。HandlerInterceptor中已经没有抽象方法了，所以该方法已经过时。)\n\n④ 三个方法的概念HandlerInterceptor接口中定义了三个方法，我们就是通过这三个方法来对用户的请求进行拦截处理的。\n\n**preHandle()**： 这个方法在Controller处理请求之前被调用，SpringMVC中的Interceptor是链式的调用的，在一个应用中或者说是在一个请求中可以同时存在多个Interceptor 。每个Interceptor的调用会依据它的声明顺序依次执行，而且最先执行的都是Interceptor 中的preHandle方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求的一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。该方法的返回值是布尔值Boolean 类型的，当它返回为false 时，表示请求结束，后续的Interceptor和Controller都不会再执行；当返回值为true时就会继续调用下一个Interceptor的preHandle 方法，如果已经是最后一个Interceptor的时候就会是调用当前请求的Controller方法。\npostHandle()：这个方法在Controller方法处理当前请求之后执行，但是它会在DispatcherServlet进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller处理之后的ModelAndView对象进行操作。postHandle方法被调用的方向跟preHandle 是相反的，也就是说先声明的Interceptor的postHandle方法反而会后执行。\n**afterCompletion()**：这个方法也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行。顾名思义，该方法将在整个请求结束之后，也就是在DispatcherServlet渲染了对应的视图之后执行。这个方法的主要作用是用于进行资源清理工作的。\n\n⑤ 拦截器执行流程图\n\n\n\n\n⑥ 拦截器执行规则我们可以配置多个拦截器，每个拦截器中都有三个方法。下面将总结多个拦截器中的方法执行规律。\n\npreHandle：Controller方法处理请求前执行，根据拦截器定义的顺序，正向执行。\npostHandle：Controller方法处理请求后执行，根据拦截器定义的顺序，逆向执行。需要所有的preHandle方法都返回true时才会调用。\nafterCompletion：View视图渲染后处理方法：根据拦截器定义的顺序，逆向执行。preHandle返回true就会调用。\n\n⑦ 配置拦截器路径\n```xmlmvc:mapping：拦截的路径/**：是指所有文件夹及其子孙文件夹/*：是指所有文件夹，但不包含子孙文件夹/：Web项目的根目录\nmvc:exclude-mapping：不拦截的路径,不拦截登录路径\n\n+ 默认拦截全部请求（**是interceptor&#x3D;&#x3D;s&#x3D;&#x3D;**）\n\n  &#96;&#96;&#96;xml\n  &lt;!-- 注册拦截器 --&gt;\n  &lt;mvc:interceptors&gt;\n      &lt;!-- 直接通过内部 bean 配置的拦截器默认拦截全部请求（SpringMVC 范围内） --&gt;\n      &lt;!--创建bean是因为我们的拦截器是通过代码实现的，而配置中的配置是我们启动拦截器，并配置拦截的相关路径--&gt;\n      &lt;bean class&#x3D;&quot;com.atguigu.mvc.interceptor.Process01Interceptor&quot;&#x2F;&gt;\n  &lt;&#x2F;mvc:interceptors&gt;\n配置拦截路径（精确匹配）\n&lt;!-- 具体配置拦截器可以指定拦截的请求地址 --&gt;\n&lt;mvc:interceptor&gt;\n    &lt;!-- 精确匹配 --&gt;\n    &lt;mvc:mapping path&#x3D;&quot;&#x2F;common&#x2F;request&#x2F;one&quot;&#x2F;&gt;\n    &lt;bean class&#x3D;&quot;com.atguigu.mvc.interceptor.Process03Interceptor&quot;&#x2F;&gt;\n&lt;&#x2F;mvc:interceptor&gt;\n配置拦截路径（模糊匹配：匹配单层路径）\n&lt;mvc:interceptor&gt;\n    &lt;!-- &#x2F;*匹配路径中的一层 --&gt;\n    &lt;mvc:mapping path&#x3D;&quot;&#x2F;common&#x2F;request&#x2F;*&quot;&#x2F;&gt;\n    &lt;bean class&#x3D;&quot;com.atguigu.mvc.interceptor.Process04Interceptor&quot;&#x2F;&gt;\n&lt;&#x2F;mvc:interceptor&gt;\n配置拦截路径（模糊匹配：匹配多层路径）\n&lt;mvc:interceptor&gt;\n    &lt;!-- &#x2F;**匹配路径中的多层 --&gt;\n    &lt;mvc:mapping path&#x3D;&quot;&#x2F;common&#x2F;request&#x2F;**&quot;&#x2F;&gt;\n    &lt;bean class&#x3D;&quot;com.atguigu.mvc.interceptor.Process05Interceptor&quot;&#x2F;&gt;\n&lt;&#x2F;mvc:interceptor&gt;\n配置不拦截路径\n&lt;mvc:interceptor&gt;\n    &lt;!-- &#x2F;**匹配路径中的多层 --&gt;\n    &lt;mvc:mapping path&#x3D;&quot;&#x2F;common&#x2F;request&#x2F;**&quot;&#x2F;&gt;\n\n    &lt;!-- 使用 mvc:exclude-mapping 标签配置不拦截的地址 --&gt;\n    &lt;mvc:exclude-mapping path&#x3D;&quot;&#x2F;common&#x2F;request&#x2F;two&#x2F;bbb&quot;&#x2F;&gt;\n\n    &lt;bean class&#x3D;&quot;com.atguigu.mvc.interceptor.Process05Interceptor&quot;&#x2F;&gt;\n&lt;&#x2F;mvc:interceptor&gt;\n\n\n:cactus: 类型转换① 类型转换前言SpringMVC 将『把请求参数注入到 POJO 对象』这个操作称为『数据绑定』，英文单词是 binding。数据类型的转换和格式化就发生在数据绑定的过程中。 类型转换和格式化是密不可分的两个过程，很多带格式的数据必须明确指定格式之后才可以进行类型转换。最典型的就是日期类型。\n② 自动类型转换HTTP 协议是一个无类型的协议，我们在服务器端接收到请求参数等形式的数据时，本质上都是字符串类型。请看 javax.servlet.ServletRequest 接口中获取全部请求参数的方法：\npublic Map&lt;String, String[]&gt; getParameterMap();\n\n而我们在实体类当中需要的类型是非常丰富的。对此，SpringMVC 对基本数据类型提供了自动的类型转换。例如：请求参数传入“100”字符串，我们实体类中需要的是 Integer 类型，那么 SpringMVC 会自动将字符串转换为 Integer 类型注入实体类。\n③ 日期和数值类型通过@DateTimeFormat 注解来指定日期转换参数，可以通过pattern属性来指定日期格式，或者设置iso来指定日期格式，内置了两种iso：Date(yyyy-MM-dd),TIME(yyyy-MM-dd HH:mm:ss.SSSZ)。\n在实体类中\n    \n@DateTimeFormat(pattern &#x3D; &quot;yyyy-MM-dd HH:mm:ss&quot;)\nprivate Date productDate;\n\n@NumberFormat(pattern &#x3D; &quot;###,###,###.###&quot;)\nprivate Double productPrice;\n\n在方法上\n\n@RequestMapping(&quot;date&#x2F;&#123;value&#125;&quot;)\npublic @ResponseBody String date(@PathVariable @DateTimeFormat(iso&#x3D;ISO.DATE) Date value) &#123;\n    return &quot;Converted date &quot; + value;\n&#125;\n\n\n\n\n\n\n\n\n\n\n测试表单\n&lt;form th:action&#x3D;&quot;@&#123;&#x2F;save&#x2F;product&#125;&quot; method&#x3D;&quot;post&quot;&gt;\n    生产日期：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;productDate&quot; value&#x3D;&quot;1992-10-15 17:15:06&quot; &#x2F;&gt;&lt;br&#x2F;&gt;\n    产品价格：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;productPrice&quot; value&#x3D;&quot;111,222,333.444&quot; &#x2F;&gt;&lt;br&#x2F;&gt;\n    &lt;button type&#x3D;&quot;submit&quot;&gt;保存&lt;&#x2F;button&gt;\n&lt;&#x2F;form&gt;\n\n\n\n\n\n\n\n\n\n\n测试方法\n@RequestMapping(&quot;&#x2F;save&#x2F;product&quot;)\npublic String saveProduct(Product product) &#123;\n \n    logger.debug(product.toString());\n \n    return &quot;target&quot;;\n&#125;\n\n\n\n\n\n\n\n\n\n\n注解背后是相应的 类型转换器发生了作用\n④ 显示友好错误提示默认结果：400，错误的请求\nBindingResult 接口和它的父接口 Errors 中定义了很多和数据绑定相关的方法，如果在数据绑定过程中发生了错误，那么通过这个接口类型的对象就可以获取到相关错误信息。\n\n    \n    \n\n\n重构handler方法（方法参数中添加BindingResult参数，在实体类参数和 BindingResult 之间不能有任何其他参数）\n@RequestMapping(&quot;&#x2F;save&#x2F;product&quot;)\npublic String saveProduct(\n        Product product,\n\n        &#x2F;&#x2F; 在实体类参数和 BindingResult 之间不能有任何其他参数\n        &#x2F;&#x2F; 封装数据绑定结果的对象\n        BindingResult bindingResult) &#123;\n \n    &#x2F;&#x2F; 判断数据绑定过程中是否发生了错误\n    if (bindingResult.hasErrors()) &#123;\n        &#x2F;&#x2F; 如果发生了错误，则跳转到专门显示错误信息的页面\n        &#x2F;&#x2F; 相关错误信息会自动被放到请求域\n        return &quot;error&quot;;\n    &#125;\n    logger.debug(product.toString());\n    return &quot;target&quot;;\n&#125;\n\n页面上显示错误信息（th:errors获取   错误信息是具体的某个  字段可能会出错）\n&lt;!-- 从请求域获取实体类信息时，属性名是按照类名首字母小写的规则 --&gt;\n&lt;!-- $&#123;注入请求参数的实体类.出问题的字段&#125; --&gt;\n&lt;p th:errors&#x3D;&quot;$&#123;product.productDate&#125;&quot;&gt;这里显示具体错误信息&lt;&#x2F;p&gt;\n\n⑤ 自定义类型转换器在实际开发过程中，难免会有某些情况需要使用自定义类型转换器。因为我们自己自定义的类型在 SpringMVC 中没有对应的内置类型转换器。此时需要我们提供自定义类型来执行转换。\n我们学习的知识点可以分成：拼死学会    以防万一    增长见闻。自定义类型转换器的定位就是以防万一\n\n\n\n\n\n\n\n\n\n创建实体类\npublic class Address &#123;\n    private String province;\n    private String city;\n    private String street;\n    ……\n\npublic class Student &#123;\n    private Address address;\n    ……\n\n\n\n\n\n\n\n\n\n\n表单\n现在我们希望通过一个文本框输入约定格式的字符串，然后转换为我们需要的类型，所以必须通过自定义类型转换器来实现，否则 SpringMVC 无法识别。（逗号前后台也要一样）\n&lt;h3&gt;自定义类型转换器&lt;&#x2F;h3&gt;\n&lt;form th:action&#x3D;&quot;@&#123;&#x2F;save&#x2F;student&#125;&quot; method&#x3D;&quot;post&quot;&gt;\n    地址：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;address&quot; value&#x3D;&quot;aaa,bbb,ccc&quot; &#x2F;&gt;&lt;br&#x2F;&gt;\n&lt;&#x2F;form&gt;\n\n\n\n\n\n\n\n\n\n\ncontroller方法\n@RequestMapping(&quot;&#x2F;save&#x2F;student&quot;)\npublic String saveStudent(Student student) &#123;\n \n    logger.debug(student.getAddress().toString());\n \n    return &quot;target&quot;;\n&#125;\n\n\n\n\n\n\n\n\n\n\n自定义类型转换器\n实现接口：org.springframework.core.convert.converter.Converter&lt;S,T&gt;\n泛型 S：源类型（本例中是 String 类型）\n泛型 T：目标类型（本例中是 Address 类型）\npublic class AddressConverter implements Converter&lt;String, Address&gt; &#123;\n    @Override\n    public Address convert(String source) &#123;\n  \n        &#x2F;&#x2F; 1.按照约定的规则拆分源字符串\n        String[] split &#x3D; source.split(&quot;,&quot;);\n         \n        String province &#x3D; split[0];\n        String city &#x3D; split[1];\n        String street &#x3D; split[2];\n \n        &#x2F;&#x2F; 2.根据拆分结果创建 Address 对象\n        Address address &#x3D; new Address(province, city, street);\n         \n        &#x2F;&#x2F; 3.返回转换得到的对象\n        return address;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n在springmvc中注册\n&lt;!-- 在 mvc:annotation-driven 中注册 FormattingConversionServiceFactoryBean --&gt;\n&lt;mvc:annotation-driven conversion-service&#x3D;&quot;formattingConversionService&quot;&#x2F;&gt;\n \n&lt;!-- 在 FormattingConversionServiceFactoryBean 中注册自定义类型转换器 --&gt;\n&lt;bean id&#x3D;&quot;formattingConversionService&quot;\n      class&#x3D;&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;\n\n    &lt;!-- 在 converters 属性中指定自定义类型转换器 --&gt;\n    &lt;property name&#x3D;&quot;converters&quot;&gt;\n        &lt;set&gt;\n            &lt;bean class&#x3D;&quot;com.atguigu.mvc.converter.AddressConverter&quot;&#x2F;&gt;\n        &lt;&#x2F;set&gt;\n    &lt;&#x2F;property&gt;\n \n&lt;&#x2F;bean&gt;\n\n\n\n\n:cactus: 数据校验① 数据校验前言在 Web 应用三层架构体系中，表述层负责接收浏览器提交的数据，业务逻辑层负责数据的处理。为了能够让业务逻辑层基于正确的数据进行处理，我们需要在表述层对数据进行检查，将错误的数据隔绝在业务逻辑层之外。\n② 校验概述JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 标准中。JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。\n\n\n\n注解\n规则\n\n\n\n@Null\n标注值必须为 null\n\n\n@NotNull\n标注值不可为 null\n\n\n@AssertTrue\n标注值必须为 true\n\n\n@AssertFalse\n标注值必须为 false\n\n\n@Min(value)\n标注值必须大于或等于 value\n\n\n@Max(value)\n标注值必须小于或等于 value\n\n\n@DecimalMin(value)\n标注值必须大于或等于 value\n\n\n@DecimalMax(value)\n标注值必须小于或等于 value\n\n\n@Size(max,min)\n标注值大小必须在 max 和 min 限定的范围内\n\n\n@Digits(integer,fratction)\n标注值值必须是一个数字，且必须在可接受的范围内\n\n\n@Past\n标注值只能用于日期型，且必须是过去的日期\n\n\n@Future\n标注值只能用于日期型，且必须是将来的日期\n\n\n@Pattern(value)\n标注值必须符合指定的正则表达式\n\n\nJSR 303 只是一套标准，需要提供其实现才可以使用。Hibernate Validator 是 JSR 303 的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解：\n\n\n\n注解\n规则\n\n\n\n@Email\n标注值必须是格式正确的 Email 地址\n\n\n@Length\n标注值字符串大小必须在指定的范围内\n\n\n@NotEmpty\n标注值字符串不能是空字符串\n\n\n@Range\n标注值必须在指定的范围内\n\n\n Spring 4.0 版本已经拥有自己独立的数据校验框架，同时支持 JSR 303 标准的校验框架。Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。\n在SpringMVC 中，可直接通过注解驱动 mvc:annotation-driven 的方式进行数据校验。\nSpring 的 LocalValidatorFactoryBean 既实现了 Spring 的 Validator 接口，也实现了 JSR 303 的 Validator 接口。只要在Spring容器中定义了一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean中。\nSpring本身并没有提供JSR 303的实现，所以必须将JSR 303的实现者的jar包放到类路径下。\n配置 mvc:annotation-driven 后，SpringMVC 会默认装配好一个 LocalValidatorFactoryBean，通过在处理方法的入参上标注 @Validated 注解即可让 SpringMVC 在完成数据绑定后执行数据校验的工作。\n③ 导入依赖\n\n\n\n\n\n\n\n\n注：需要 Tomcat 版本至少是 8。\n&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.hibernate.validator&#x2F;hibernate-validator --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.hibernate.validator&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;hibernate-validator&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;6.2.0.Final&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.hibernate.validator&#x2F;hibernate-validator-annotation-processor --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.hibernate.validator&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;hibernate-validator-annotation-processor&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;6.2.0.Final&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n④ 标记规则注解\n\n\n\n\n\n\n\n\n实体类（最少长度，指的是总字符数）\n&#x2F;&#x2F; 字符串长度：[3,6]\n@Size(min &#x3D; 3, max &#x3D; 6)\n&#x2F;&#x2F; 字符串必须满足Email格式\n@Email\nprivate String email;\n\n⑤ 方法形参标记注解@RequestMapping(&quot;&#x2F;save&#x2F;president&quot;)\npublic String savePresident(@Validated President president) &#123;\n    logger.debug(president.getEmail());\n    return &quot;target&quot;;\n&#125;\n\n\n\n\n\n\n\n\n\n\n显示友好错误提示与类型转换相同\n\n:cactus: 异常映射① 异常映射概念\n\n\n\n\n\n\n\n\n微观\n将异常类型和某个具体的视图关联起来，建立映射关系。好处是可以通过 SpringMVC 框架来帮助我们管理异常。\n\n声明式管理异常：在配置文件中指定异常类型和视图之间的对应关系。在配置文件或注解类中统一管理。\n编程式管理异常：需要我们自己手动 try … catch … 捕获异常，然后再手动跳转到某个页面。\n\n\n\n\n\n\n\n\n\n\n宏观\n一个项目中会包含很多个模块，各个模块需要分工完成。如果张三负责的模块按照 A 方案处理异常，李四负责的模块按照 B 方法处理异常……各个模块处理异常的思路、代码、命名细节都不一样，那么就会让整个项目非常混乱。\n② 异常映射的好处\n使用声明式代替编程式来实现异常管理\n让异常控制和核心业务解耦，二者各自维护，结构性更好\n\n\n整个项目层面使用同一套规则来管理异常\n整个项目代码风格更加统一、简洁\n便于团队成员之间的彼此协作\n\n\n\n③ 基于xml的异常映射SpringMVC 会根据异常映射信息，在捕获到指定异常对象后，将异常对象存入请求域，然后转发到和异常类型关联的视图。\n&lt;bean id&#x3D;&quot;exceptionResolver&quot;\n      class&#x3D;&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;\n \n    &lt;!-- 配置异常映射关系 --&gt;\n    &lt;property name&#x3D;&quot;exceptionMappings&quot;&gt;\n        &lt;props&gt;\n            &lt;!-- key属性：指定异常类型 --&gt;\n            &lt;!-- 文本标签体：和异常类型对应的逻辑视图 --&gt;\n            &lt;prop key&#x3D;&quot;java.lang.ArithmeticException&quot;&gt;error-arith&lt;&#x2F;prop&gt;\n        &lt;&#x2F;props&gt;\n    &lt;&#x2F;property&gt;\n \n    &lt;!-- 使用 exceptionAttribute 属性配置将异常对象存入请求域时使用的属性名 --&gt;\n    &lt;!-- 这个属性名默认是exception --&gt;\n    &lt;property name&#x3D;&quot;exceptionAttribute&quot; value&#x3D;&quot;atguiguException&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n==页面获取数据 （html的名称就是 上面定义的逻辑视图的名称）==\n&lt;p th:text&#x3D;&quot;$&#123;atguiguException&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n④ 异常范围如果在配置文件中，发现有多个匹配的异常类型，那么 SpringMVC 会采纳范围上最接近的异常映射关系。\n&lt;prop key&#x3D;&quot;java.lang.ArithmeticException&quot;&gt;error-arith&lt;&#x2F;prop&gt;\n&lt;prop key&#x3D;&quot;java.lang.RuntimeException&quot;&gt;error-runtime&lt;&#x2F;prop&gt;\n\n⑤ 基于注解的异常映射\n\n\n\n\n\n\n\n\n当同一个异常类型在基于 XML 和注解的配置中都能够找到对应的映射，那么以注解为准。\n创建异常处理器类\ncom.hrenxiang.exception.MyExceptionHandler\n\n异常处理器类加入 IOC容器\n&lt;context:component-scan base-package&#x3D;&quot;com.hrenxiang.exception.MyExceptionHandler&quot;&#x2F;&gt;\n\n给异常处理器类标记注解\n&#x2F;&#x2F; 异常处理器类需要使用 @ControllerAdvice 注解标记\n@ControllerAdvice\npublic class MyExceptionHandler &#123;\n    \n&#125;\n\n给类中的方法标记注解\n&#x2F;&#x2F; @ExceptionHandler注解：标记异常处理方法\n&#x2F;&#x2F; value属性：指定匹配的异常类型\n&#x2F;&#x2F; 异常类型的形参：SpringMVC 捕获到的异常对象\n@ExceptionHandler(value &#x3D; NullPointerException.class)\npublic String resolveNullPointerException(Exception e, Model model) &#123;\n \n    &#x2F;&#x2F; 我们可以自己手动将异常对象存入模型\n    model.addAttribute(&quot;atguiguException&quot;, e);\n \n    &#x2F;&#x2F; 返回逻辑视图名称\n    return &quot;error-nullpointer&quot;;\n&#125;\n\n⑥ 区分请求类型:accept:分析：异常处理机制和拦截器机制都面临这样的问题\n\n判断依据：查看请求消息头中是否包含 Ajax 请求独有的特征\n\nAccept 请求消息头：包含 application/json\nX-Requested-With 请求消息头：包含 XMLHttpRequest\n\n两个条件满足一个即可。\n&#x2F;**\n * 判断当前请求是否为Ajax请求\n * @param request 请求对象\n * @return\n *      true：当前请求是Ajax请求\n *      false：当前请求不是Ajax请求\n *&#x2F;\npublic static boolean judgeRequestType(HttpServletRequest request) &#123;\n    \n    &#x2F;&#x2F; 1.获取请求消息头\n    String acceptHeader &#x3D; request.getHeader(&quot;Accept&quot;);\n    String xRequestHeader &#x3D; request.getHeader(&quot;X-Requested-With&quot;);\n    \n    &#x2F;&#x2F; 2.判断\n    return (acceptHeader !&#x3D; null &amp;&amp; acceptHeader.contains(&quot;application&#x2F;json&quot;)) ||\n            (xRequestHeader !&#x3D; null &amp;&amp; xRequestHeader.equals(&quot;XMLHttpRequest&quot;));\n&#125;\n\n兼容两种的处理办法\n@ExceptionHandler(value &#x3D; Exception.class)\npublic String resolveException(Exception e, HttpServletRequest request, HttpServletResponse response) throws IOException &#123;\n \n    &#x2F;&#x2F; 调用工具方法判断当前请求是否是 Ajax 请求\n    boolean judgeResult &#x3D; MVCUtil.judgeRequestType(request);\n \n    if (judgeResult) &#123;\n \n        &#x2F;&#x2F; 对 Ajax 请求返回字符串作为响应体\n        String message &#x3D; e.getMessage();\n \n        response.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);\n        response.getWriter().write(message);\n \n        &#x2F;&#x2F; 上面已经使用原生 response 对象返回了响应，这里就不返回视图名称了\n        return null;\n    &#125;\n \n    &#x2F;&#x2F; 对普通请求返回逻辑视图名称\n    return &quot;error-exception&quot;;\n&#125;\n\n\n\n\n:cactus: 文件上传① 前端页面(设置enctype)第一点：请求方式必须是 POST第二点：请求体的编码方式必须是 ==multipart/form-data==（通过 form 标签的 ==enctype== 属性设置）第三点：使用 input 标签、type 属性设置为 file 来生成文件上传框\n&lt;form th:action&#x3D;&quot;@&#123;&#x2F;atguigu&#x2F;upload&#125;&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;\n    \n    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;picture&quot; &#x2F;&gt;\n    &lt;button type&#x3D;&quot;submit&quot;&gt;上传头像&lt;&#x2F;button&gt;\n     \n&lt;&#x2F;form&gt;\n\n② SpringMVC 环境配置:point_right: 添加依赖&lt;!--文件上传依赖--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;commons-fileupload&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;commons-fileupload&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.3.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n:point_right: ​配置spring-mvc.xml在 SpringMVC 的配置文件中加入 multipart 类型数据的解析器：\n&lt;bean id&#x3D;&quot;multipartResolver&quot; \n      class&#x3D;&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;\n    \n    &lt;!-- 由于上传文件的表单请求体编码方式是 multipart&#x2F;form-data 格式，所以要在解析器中指定字符集 --&gt;\n    &lt;property name&#x3D;&quot;defaultEncoding&quot; value&#x3D;&quot;UTF-8&quot;&#x2F;&gt;\n    \n&lt;&#x2F;bean&gt;\n\n③ 获取多媒体类型请求参数@RequestMapping(&quot;&#x2F;simple&#x2F;upload&quot;)\npublic String doUpload(\n \n        &#x2F;&#x2F; 表单提交的数据仍然是请求参数，所以使用 @RequestParam 注解接收\n        @RequestParam(&quot;nickName&quot;) String nickName,\n \n        &#x2F;&#x2F; 对于上传的文件使用 MultipartFile 类型接收其相关数据\n        @RequestParam(&quot;picture&quot;) MultipartFile picture\n        ) throws IOException &#123;\n \n    String inputName &#x3D; picture.getName();\n    logger.debug(&quot;文件上传表单项的 name 属性值：&quot; + inputName);\n \n    &#x2F;&#x2F; 获取这个数据通常都是为了获取文件本身的扩展名\n    String originalFilename &#x3D; picture.getOriginalFilename();\n    logger.debug(&quot;文件在用户本地原始的文件名：&quot; + originalFilename);\n \n    String contentType &#x3D; picture.getContentType();\n    logger.debug(&quot;文件的内容类型：&quot; + contentType);\n \n    boolean empty &#x3D; picture.isEmpty();\n    logger.debug(&quot;文件是否为空：&quot; + empty);\n \n    long size &#x3D; picture.getSize();\n    logger.debug(&quot;文件大小：&quot; + size);\n \n    byte[] bytes &#x3D; picture.getBytes();\n    logger.debug(&quot;文件二进制数据的字节数组：&quot; + Arrays.asList(bytes));\n \n    InputStream inputStream &#x3D; picture.getInputStream();\n    logger.debug(&quot;读取文件数据的输入流对象：&quot; + inputStream);\n \n    Resource resource &#x3D; picture.getResource();\n    logger.debug(&quot;代表当前 MultiPartFile 对象的资源对象&quot; + resource);\n \n    return &quot;target&quot;;\n&#125;\n\n④ 文件转存(3种)\n    \n    \n\n\n:point_right: 本地转存\n\n\n\n\n\n\n\n\n\n\n\n\n@Controller\n@Slf4j\npublic class UploadController2 &#123;\n\n    @Autowired\n    private ServletContext servletContext;\n\n    &#x2F;&#x2F; 文件上传页面\n    @RequestMapping(&quot;&#x2F;toUpload2&quot;)\n    public String toUpload() &#123;\n        return &quot;fileUpload2&quot;;\n    &#125;\n\n    @RequestMapping(&quot;&#x2F;fileUpload2&quot;)\n    public String fileUpload(MultipartFile file, Model model, HttpSession session) throws IOException &#123;\n\n        &#x2F;&#x2F; 0、准备好保存文件的目标目录\n        &#x2F;&#x2F; ①File 对象要求目标路径是一个物理路径（在硬盘空间里能够直接找到文件的路径）\n        &#x2F;&#x2F; ②项目在不同系统平台上运行，要求能够自动兼容、适配不同系统平台的路径格式\n        &#x2F;&#x2F;      例如：Window系统平台的路径是 D:&#x2F;aaa&#x2F;bbb 格式\n        &#x2F;&#x2F;      例如：Linux系统平台的路径是 &#x2F;ttt&#x2F;uuu&#x2F;vvv 格式\n        &#x2F;&#x2F;      所以我们需要根据『不会变的虚拟路径』作为基准动态获取『跨平台的物理路径』\n        &#x2F;&#x2F; ③虚拟路径：浏览器通过 Tomcat 服务器访问 Web 应用中的资源时使用的路径\n        &#x2F;*ServletContext servletContext &#x3D; session.getServletContext();*&#x2F;\n        String path &#x3D; &quot;&#x2F;upload&quot;;\n        String realPath &#x3D; servletContext.getRealPath(path);\n\n\n        &#x2F;&#x2F; 1.判断资源上传地址是否存在,不存在就创建\n        File fileAddress &#x3D; new File(realPath);\n        if (!fileAddress.exists()) &#123;\n            log.debug(&quot;创建文件夹！！！&quot;);\n            fileAddress.mkdirs();\n        &#125;\n\n        &#x2F;&#x2F; 2. 判断传入的文件不是空，保证文件名唯一，不会被覆盖\n        if (file &#x3D;&#x3D; null || file.getOriginalFilename() &#x3D;&#x3D; null) &#123;\n            return &quot;error&quot;;\n        &#125;\n        String originalFilename &#x3D; file.getOriginalFilename();\n        &#x2F;&#x2F; 获取后缀名\n        String extName &#x3D; originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));\n        &#x2F;&#x2F; 生成唯一名\n        String uuid &#x3D; UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);\n        &#x2F;&#x2F; 添加后缀\n        String fileName &#x3D; uuid + extName;\n\n        &#x2F;&#x2F; 3. 判断后缀是否为 .jpg或 .png\n        if (!&quot;.jpg&quot;.equals(extName) &amp;&amp; !&quot;.png&quot;.equals(extName)) &#123;\n            log.debug(&quot;后缀名不正确！！&quot;);\n        &#x2F;&#x2F; &lt;prop key&#x3D;&quot;java.lang.RuntimeException&quot;&gt;error-upload&lt;&#x2F;prop&gt;界面上使用xml中存储异常值的对象进行获取\n            throw new RuntimeException(&quot;运行错误！！！&quot;);\n        &#125;\n\n        &#x2F;&#x2F; 4. 限制文件上传大小，通过xml配置\n        &#x2F;*\n        &lt;!--文件上传的最大大小  单位：字节   1024*1024&#x3D;1M--&gt;\n        &lt;property name&#x3D;&quot;maxUploadSize&quot; value&#x3D;&quot;102400&quot;&#x2F;&gt;\n        &lt;!--内存中的最大值--&gt;\n        &lt;property name&#x3D;&quot;maxInMemorySize&quot; value&#x3D;&quot;102400&quot;&#x2F;&gt;\n        *&#x2F;\n\n        File file1 &#x3D; new File(fileAddress, fileName);\n        file.transferTo(file1);\n\n        log.debug(&quot;---------&quot; + file.getOriginalFilename() + &quot;------------&quot;);\n        model.addAttribute(&quot;msg&quot;, &quot;上传成功&quot;);\n        model.addAttribute(&quot;fileName&quot;,fileName);\n        return &quot;result&quot;;\n    &#125;\n\n\n\n\n\n\n\n\n\n\n图1：本地转存        图2：此方式的缺陷\n\n    \n    \n\n\n缺陷\n\nWeb 应用重新部署时通常都会清理旧的构建结果，此时用户以前上传的文件会被删除，导致数据丢失。\n项目运行很长时间后，会导致上传的文件积累非常多，体积非常大，从而拖慢 Tomcat 运行速度。\n当服务器以集群模式运行时，文件上传到集群中的某一个实例，其他实例中没有这个文件，就会造成数据不一致。\n不支持动态扩容，一旦系统增加了新的硬盘或新的服务器实例，那么上传、下载时使用的路径都需要跟着变化，导致 Java 代码需要重新编写、重新编译，进而导致整个项目重新部署。\n\n:point_right: 文件服务器（采纳）\n    \n        图一、总体机制    图二、好处\n    \n    \n    \n\n\n好处\n\n不受 Web 应用重新部署影响\n在应用服务器集群环境下不会导致数据不一致\n针对文件读写进行专门的优化，性能有保障\n能够实现动态扩容\n\n文件服务器类型\n\n第三方平台：\n阿里的 OSS 对象存储服务\n七牛云\n\n\n自己搭建服务器：FastDFS等\n\n:point_right:  上传到其他模块这种情况肯定出现在分布式架构中，常规业务功能不会这么做，采用这个方案的一定是特殊情况。\n\n在 MultipartFile 接口中有一个对应的方法：\n注释中说：这个 Resource 对象代表当前 MultipartFile 对象，输入给 RestTemplate 或 WebClient。而 RestTemplate 或 WebClient 就是用来在 Java 程序中向服务器端发出请求的组件。\n&#x2F;**\n * Return a Resource representation of this MultipartFile. This can be used\n * as input to the &#123;@code RestTemplate&#125; or the &#123;@code WebClient&#125; to expose\n * content length and the filename along with the InputStream.\n * @return this MultipartFile adapted to the Resource contract\n * @since 5.1\n *&#x2F;\ndefault Resource getResource() &#123;\n    return new MultipartFileResource(this);\n&#125;\n\n\n\n\n:cactus: 文件下载① 初始形态使用链接地址指向要下载的文件。此时浏览器会尽可能解析对应的文件，只要是能够在浏览器窗口展示的，就都会直接显示，而不是提示下载。\n&lt;a href&#x3D;&quot;download&#x2F;hello.atguigu&quot;&gt;下载&lt;&#x2F;a&gt;&lt;br&#x2F;&gt;\n&lt;a href&#x3D;&quot;download&#x2F;tank.jpg&quot;&gt;下载&lt;&#x2F;a&gt;&lt;br&#x2F;&gt;\n&lt;a href&#x3D;&quot;download&#x2F;chapter04.zip&quot;&gt;下载&lt;&#x2F;a&gt;&lt;br&#x2F;&gt;\n\n上面例子中，只有 chapter04.zip 文件是直接提示下载的，其他两个都是直接显示。\n② ​我的前端代码&lt;a th:href&#x3D;&quot;@&#123;&#x2F;download&#x2F;00b8541c8c8849ca9fc1ff3be01f2aa0.jpg&#125;&quot;&gt;下载&lt;&#x2F;a&gt;\n\n③ 后端明确要求浏览器下载==内部明确浏览器提示下载，封装响应消息头,设置下载的响应头==\n@Controller\n@Slf4j\npublic class DownloadController &#123;\n\n    @Autowired\n    private ServletContext servletContext;\n\n    @RequestMapping(&quot;&#x2F;toDownload&quot;)\n    public String toDownload()&#123;\n        return &quot;download&quot;;\n    &#125;\n\n    @RequestMapping(&quot;&#x2F;download&#x2F;&#123;fileName&#125;&quot;)\n    public String downloadImg(@PathVariable(&quot;fileName&quot;) String fileName, HttpServletResponse response) throws IOException &#123;\n        &#x2F;&#x2F; 获取图片\n        String realPath &#x3D; servletContext.getRealPath(&quot;&#x2F;upload&#x2F;&quot;+fileName);\n\n        &#x2F;&#x2F; 输入流，进行读取\n        InputStream inputStream &#x3D; new FileInputStream(realPath);\n\n        &#x2F;&#x2F; 输出流，进行写入\n        ServletOutputStream outputStream &#x3D; response.getOutputStream();\n\n        &#x2F;&#x2F; 封装响应消息头,设置下载的响应头\n        response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment; filename&#x3D;&quot;+fileName);\n\n        &#x2F;&#x2F; 使用jar中封装好的工具类进行 读取下载\n        IOUtils.copy(inputStream,outputStream);\n\n        &#x2F;&#x2F; 关闭输入输出流\n        inputStream.close();\n        outputStream.close();\n\n        return &quot;result&quot;;\n    &#125;\n\n&#125;\n\n\n\n\n:cactus: 其他内容① 根据请求参数情况映射使用 @RequestMapping 注解的 params 参数实现，表达式语法参见下面的例子：\n\n\n\n需求\n映射方式\n\n\n\n请求参数中必须包含userName\n@RequestMapping(value = “/xxx”, params=”userName”)\n\n\n请求参数中不能包含userName\n@RequestMapping(value = “/xxx”, params=”!userName”)\n\n\n请求参数中必须包含userName 且值必须为Tom2015\n@RequestMapping(value = “/xxx”, params=”userName=Tom2015”)\n\n\n请求参数中必须包含userName 但值不能为Tom2015\n@RequestMapping(value = “/xxx”, params=”userName=!Tom2015”)\n\n\n请求参数中必须包含userName 且值为Tom2015， 同时必须包含userPwd但值不限\n@RequestMapping(value = “/xxx”, params={“userName=Tom2015”,”userPwd”} )\n\n\n② 根据请求消息头内容映射使用 @RequestMapping 注解的 headers 参数实现，表达式语法参见下面的例子：\n\n\n\n需求\n映射方式\n\n\n\n根据 Accept-Language:zh-CN,zh;q=0.8 映射\n@RequestMapping ( value=”/xxx”, headers= “Accept-Language=zh-CN,en;q=0.8” )\n\n\n③ Ant 风格通配符\n英文问号：匹配一个字符\n一个星号：匹配路径中的一层\n两个连续星号：匹配路径中的多层\n\n④ @ModelAttribute 注解handler 类中，选定一个方法标记 @ModelAttribute 注解。\n\n效果1：在每个 handler 方法前执行\n效果2：可以将某些数据提前存入请求域\n\n@Controller\npublic class ModelAttrHandler &#123;\n \n    @ModelAttribute\n    public void doSthBefore(Model model) &#123;\n        model.addAttribute(&quot;initAttr&quot;, &quot;initValue&quot;);\n    &#125;\n \n    @RequestMapping(&quot;&#x2F;test&#x2F;model&#x2F;attr&#x2F;one&quot;)\n    public String testModelAttrOne(Model model) &#123;\n \n        Object modelAttribute &#x3D; model.getAttribute(&quot;initAttr&quot;);\n        System.out.println(&quot;modelAttribute &#x3D; &quot; + modelAttribute);\n \n        return &quot;target&quot;;\n    &#125;\n\n    @RequestMapping(&quot;&#x2F;test&#x2F;model&#x2F;attr&#x2F;two&quot;)\n    public String testModelAttrTwo(Model model) &#123;\n \n        Object modelAttribute &#x3D; model.getAttribute(&quot;initAttr&quot;);\n        System.out.println(&quot;modelAttribute &#x3D; &quot; + modelAttribute);\n \n        return &quot;target&quot;;\n    &#125;\n\n&#125;\n\n","slug":"53-SpringMVC-特定功能","date":"2021-09-13T15:30:32.000Z","categories_index":"SpringMVC","tags_index":"SpringMVC","author_index":"大黄"},{"id":"0873bab37682d9a4ef349b4c3c9c31a9","title":"SpringMVC 基础功能","content":"01、springMVC 入门① 传统 MVC 架构使用MVC架构（JSP/Thymeleaf+Servlet+JavaBean）进行分层开发，可以实现分工协作、可以实现组件重用、可以利于后期维护。\n\n\n\n\n\n\n\n\n\n缺点如下\n\n每个功能都要声明对应的Servlet，Servlet数量多。即使让一个Servlet包括多个方法，也无法从根本上解决Servlet数量多的问题。\n在Servlet中获取请求数据较麻烦： 需要大量的request.getParameter(“name”)。\n手动的类型转换：比如int age = Integer.parseInt(request.getParameter(“age”))\n响应的方式的代码其实只想声明对应的响应数据。比如：request.getRequestDispatcher(path).forward(request,response); 中最关键的还是path。\n\n\n\n\n\n\n\n\n\n\n解决方案（就是SpringMVC的解决方案）。\n\n项目只声明一个Servlet，该Servlet作为项目请求的公共入口。并且在该Servlet中根据请求地址调用对应的控制代码处理请求。\n如果将控制方法（之前Servlet接收请求参数、调用业务层、实现视图跳转等功能)全部声明在Servlet中造成代码的体系结构不清晰。\n\n**将控制方法单独声明到控制类中(Controller类)**。然后Servlet中根据请求动态的调用对应的控制类中的控制方法处理请求即可。\n\n如何在Servlet中获取控制类对象呢？\n使用Spring容器的子容器，在子容器中存储所有的Controller的实例化对象，然后Servlet一次性从子容器中获取所有的对象即可。在init方法中实现即可。\n\n这其实就引出了MVC框架的概念。常见的JavaEE开发领域 MVC框架: SpringMVC, Struts2,JFinal(中国人写的)。\nSpringMVC3.0 后全面超越 Struts2，成为最优秀的 MVC 框架。\n主流的JavaEE开源框架已经从SSH，SSH2（Spring+Struts2+Hibernate）发展到了SSM（Spring+SpringMVC+MyBatis）。\n\n\n\n\n\n\n\n\n\n\n\n图一：传统 mvc    图二：改进后的 mvc\n\n    \n    \n\n\n\n\n② SpringMVC 简介SpringMVC (全称Spring Web MVC)是Spring提供给Web应用的框架设计，其实是Spring的一部分。它是一种基于Servlet的技术，提供了核心控制器和相关的组件，并制定了松散的结构，以适合各种灵活的需要。\n只不过在实际开发中、培训中一般都是当做 一个单独的框架来学习,位于软件三层架构中的表示层。\n\n\n\n\n\n\n\n\n\nM、V、C 释义\n\n\n\n字母\n代表\n\n\n\nM 代表 模型（Model）\n模型就是数据，如：dao，bean\n\n\nV 代表 视图（View）\n视图就是数据的可视化的表现，如：网页，JSP，用来展示模型中的数据\n\n\nC 代表 控制器（Controller）\n控制器就是作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开\n\n\n\n\n\n\n\n\n\n\n\nSpirngMVC 解决的问题\n请求映射    数据输入    视图界面    请求分发    表单回显    会话控制    过滤拦截    异步交互    文件上传    文件下载    数据校验    类型转换\n③ SpringMVC 优势SpringMVC 已经成为目前最主流的 MVC 框架之一。自从Spring 2.5版本发布后，由于支持注解配置，易用性有了大幅度的提高。随着 Spring3.0 的发布，全面超越 Struts2，成为最优秀的 MVC 框架。目前普遍选择 SpringMVC 作为 Java EE 项目表述层开发的首选方案。\n\n\n\n\n\n\n\n\n\nSpringMVC 具备如下显著优势\n\nSpring 家族原生产品，与 IOC 容器等基础设施无缝对接\n\n表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案\n\n代码清新简洁，大幅度提升开发效率\n\n内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可\n\n性能卓著，尤其适合现代大型、超大型互联网项目要求\n\n支持RESTful 编程风格的请求。\n\n轻量级的框架，简单易学，进行更简洁的Web层开发\n\n可适配、非侵入：可以根据不同的应用场景，选择合适的控制器子类(simple型、command型、from型、wizard型、multi-action型或者自定义)，而不是一个单一控制器(比如Action/ActionForm)\n\n非常容易与其他视图技术集成，如:Velocity、FreeMarker等等\n\n因为模型数据不存放在特定的API里，而是放在一个Model里(Map数据结构实现，因此很容易被其他框架使用)\n\n非常灵活的数据验证、格式化和数据绑定机制、能使用任何对象进行数据绑定，不必实现特定框架的API\n\n更加简单、强大的异常处理\n\n对静态资源的支持\n\n支持灵活的本地化、主题等解析\n总之，简单易用，性能优良，同类技术中市场占有率最高，不用犹豫，就是它了。\n\n\n④ SpringMVC 代码对比\n\n\n\n\n\n\n\n\n原生代码\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;   \n    \n    String userName &#x3D; request.getParameter(&quot;userName&quot;);\n    int age  &#x3D; Integer.parseInt(request.getParameter(&quot;age&quot;));\n    System.out.println(&quot;userName&#x3D;&quot;+userName+&quot;,age&#x3D;&quot;+age);\n    \n    request.getRequestDispatcher(&quot;&#x2F;templates&#x2F;result.html&quot;).forward(request,response);\n&#125;\n\n\n\n\n\n\n\n\n\n\nspringmvc 代码\n@RequestMapping(&quot;&#x2F;user&#x2F;login&quot;)\npublic String login(String userName,Integer age)&#123;\n    \n    System.out.println(&quot;userName&#x3D;&quot;+userName+&quot;,age&#x3D;&quot;+age);\n    \n    return &quot;result&quot;;\n&#125;\n\n\n\n⑤ 跟踪 SpringMVC 的请求每当用户在 Web 浏览器中点击链接或者提交表单的时候，请求就开始工作了，像是邮递员一样，从离开浏览器开始到获取响应返回，它会经历很多站点，在每一个站点都会留下一些信息同时也会带上其他信息，下图为 Spring MVC 的请求流程：\n\n    \n\n\n第一站：DispatcherServlet从请求离开浏览器以后，第一站到达的就是 DispatcherServlet，看名字这是一个 Servlet，通过 J2EE 的学习，我们知道 Servlet 可以拦截并处理 HTTP 请求，DispatcherServlet 会拦截所有的请求，并且将这些请求发送给 Spring MVC 控制器。\nDispatcherServlet 的任务就是拦截请求发送给 Spring MVC 控制器。\n\n第二站：HandlerMapping\n\n\n\n\n\n\n\n\n处理器映射\n问题：典型的应用程序中可能会有多个控制器，这些请求到底应该发给哪一个控制器呢？\n所以 DispatcherServlet 会查询一个或多个处理器映射来确定请求的下一站在哪里，处理器映射会根据请求所携带的 URL 信息来进行决策，例如下面的例子中，我们通过注解配置 RequestMapping 来将 /register/registerSuccess 地址交给 RegisterController处理：\n@Controller\npublic class RegisterController &#123;\n\t@RequestMapping(&quot;&#x2F;register&#x2F;registerSuccess&quot;)\n    public String toRegisterSuccess()&#123;\n        \n    &#125;\n&#125;\n\n第三站：控制器\n\n\n\n\n\n\n\n\n各种controller类中定义的方法内部执行的语句\n一旦选择了合适的控制器， DispatcherServlet 会将请求发送给选中的控制器，到了控制器，请求会卸下其负载（用户提交的请求）等待控制器处理完这些信息：\n&#x2F;**\n* 注册成功页面\n* 参数与html上的参数名不相同\n* @param name     注册的用户名\n* @param password 注册的密码\n* @return\n*&#x2F;\n@RequestMapping(&quot;&#x2F;register&#x2F;registerSuccess&quot;)\npublic String showRegister(@RequestParam(&quot;uname&quot;) String name, @RequestParam(&quot;pwd&quot;) String password) &#123;\n\n\tlogger.debug(&quot;uname：&quot; + name + &quot;，pwd:&quot; + password);\n\n    return &quot;resultSuccess&quot;;\n&#125;\n\n第四站：返回 DispatcherServlet\n\n\n\n\n\n\n\n\n执行完要去访问的页面\n当控制器在完成逻辑处理后，通常会产生一些信息，这些信息就是需要返回给用户并在浏览器上显示的信息，它们被称为模型（Model）。仅仅返回原始的信息时不够的——这些信息需要以用户友好的方式进行格式化，一般会是 HTML，所以，信息需要发送给一个视图（view），通常会是 JSP，html。\n控制器所做的最后一件事就是将模型数据打包，并且表示出用于渲染输出的视图名（逻辑视图名）。它接下来会将请求连同模型和视图名发送回 DispatcherServlet。\n第五站：视图解析器这样以来，控制器就不会和特定的视图相耦合，传递给 DispatcherServlet 的视图名并不直接表示某个特定的html。（实际上，它甚至不能确定视图就是 html）相反，它传递的仅仅是一个逻辑名称，这个名称将会用来查找产生结果的真正视图。\nDispatcherServlet 将会使用视图解析器（view resolver）来将逻辑视图名匹配为一个特定的视图实现，它可能是也可能不是 html\n现在一般使用 thymeleaf视图解析（上述代码直接定位到 /WEB-INF/pages/resultSuccess.html 页面）\n\n第六站：视图既然 DispatcherServlet 已经知道由哪个视图渲染结果了，那请求的任务基本上也就完成了。\n它的最后一站是视图的实现，在这里它交付模型数据，请求的任务也就完成了。视图使用模型数据渲染出结果，这个输出结果会通过响应对象传递给客户端。\n⑥ 入门案例 :game_die:\n\n\n准备工作\n\n\n\n1、导入依赖           2、web.xml配置           3、spring.xml配置           4、logback.xml配置           5、创建controller和html\n\n\n⑦ 配置中的问题:point_right: ​maven 传递性由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。\n:point_right: ​加入日志记录仪在 handler 类中声明一个成员变量：\nprivate Logger logger &#x3D; LoggerFactory.getLogger(this.getClass());\n\n\nLogger：org.slf4j.Logger\nLoggerFactory：org.slf4j.LoggerFactory\n\n使用日志而不是 sysout 的方式在控制台打印，好处在于：根据日志的级别可以非常方便的控制某些日志是否打印。\n不管 sysout 还是日志，只要是在控制台打印数据，底层都是 I/O 操作。在项目中，访问数据库和 I/O 都是典型的高消耗型的操作。\n在控制台打印的数据，用户看不到，打印它肯定是为了调试程序等类似需求。所以在项目上线的时候，用于调试程序的控制台打印都应该去掉。\n如果我们是通过 sysout 方式打印，那么它们会分散在项目中的各个地方，想要通过手动方式删除会很繁琐也可能会有遗漏。\n而使用日志的方式，只要在配置文件中修改一下日志级别，就能全面控制某个级别的日志打印或者不打印。\n而且日志框架通常都能够指定日志保存的位置，如果有需要可以将日志数据保存到数据库等位置。\n:point_right: DispatcherServlet配置SpringMVC中负责处理请求的核心Servlet，也被称为SpringMVC的前端控制器，DispatcherServlet\n关于DispatcherServlet的&lt;url-pattern&gt;拦截路径配置问题\n\n第一种：*.action（或者*.do，都是从Struts延续过来的写法）。最传统的方式，最简单也最实用。只有.action结尾的请求会由DispatcherServlet进行解析。\n\n第二种：/* 这种配置方式不对，使用这种配置，当我们访问到一个JSP、HTML、CSS等时，也会经过DispatcherServlet进行解析，将不能正常显示，会报错。 \n\n第三种：**/ 所有访问地址**(除.jsp、.jspx之外)都由DispatcherServlet进行解析，使用这种方法可以实现越来越流行的RESTful风格。这种使用越来越多了。\n\n如果采用 / 这种方式，对于静态文件解析需要配置，不让DispatcherServlet进行解析，否则将无法访问到。\n\n配置方式有多种，最简单的方式就是在springmvc.xml中添加注解：\n**&lt;mvc:annotation-driven&gt;**（springmvc 必须配置的注解驱动）\n**&lt;mvc:default-servlet-handler/&gt;**（不解析静态资源的配置）\n\n作用详解：配置&lt;mvc:default-servlet-handler/&gt;后，会在SpringMVC上下文中定义一个org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler。它会像一个检查员，对进入DispatcherServlet的URL进行筛查。\n如果发现是静态资源的请求，就将该请求转由Web应用服务器默认的Servlet（对应Tomcat是org.apache.catalina.servlets.DefaultServlet）处理。如果不是静态资源的请求，才由DispatcherServlet继续处理。\n\ndefault-servlet-handler所在类：org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler\n关键方法：handleRequest()方法\n大体机制：SpringMVC 首先查找是否存在和当前请求对应的 @RequestMapping；如果没有，则调用handleRequest()方法转发到目标资源。\n\n\n\n\n:point_right: POST 请求乱码问题到 web.xml 中配置 CharacterEncodingFilter 即可：\n&lt;!-- 配置过滤器解决 POST 请求的字符乱码问题 --&gt;\n&lt;filter&gt;\n    &lt;filter-name&gt;CharacterEncodingFilter&lt;&#x2F;filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;\n    \n    &lt;!-- encoding参数指定要使用的字符集名称 --&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;\n        &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;init-param&gt;\n    \n    &lt;!-- 请求强制编码 --&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;forceRequestEncoding&lt;&#x2F;param-name&gt;\n        &lt;param-value&gt;true&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;init-param&gt;\n        \n    &lt;!-- 响应强制编码 --&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;forceResponseEncoding&lt;&#x2F;param-name&gt;\n        &lt;param-value&gt;true&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;init-param&gt;\n&lt;&#x2F;filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;CharacterEncodingFilter&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;filter-mapping&gt;\n\n\n\n\n\n\n\n\n\n\n注1：在较低版本的 SpringMVC 中，forceRequestEncoding 属性、forceResponseEncoding 属性没有分开，它们是一个 forceEncoding 属性。这里需要注意一下。\n注2：由于 CharacterEncodingFilter 是通过 request.setCharacterEncoding(encoding); 来设置请求字符集，所以在此操作前不能有任何的 request.getParameter() 操作。在设置字符集之前获取过请求参数，那么设置字符集的操作将无效。\n⑧ 整体流程分析图\n02、重要注解① @RequestMapping:point_right: 前言@RequestMapping注解的作用就是将请求的 URL 地址和处理请求的方式关联起来，建立映射关系。\nSpringMVC 接收到指定的请求，就会来找到在映射关系中对应的方法来处理这个请求。\n:point_right: 配 *.do 不加 .dorequestMapping 中可不加 .do（默认自动加 .do）如果在 web.xml 中配置的 *.do，则会拦截所有的 .do 请求去匹配\n&lt;!-- Map all requests to the DispatcherServlet for handling --&gt;\n\t&lt;servlet-mapping&gt;\n\t\t&lt;servlet-name&gt;springDispatcherServlet&lt;&#x2F;servlet-name&gt;\n\t\t&lt;url-pattern&gt;*.do&lt;&#x2F;url-pattern&gt;\n\t&lt;&#x2F;servlet-mapping&gt;\n但是在 Controller 中的 RequestMapping 的 Value 如果是字符串没有不是 .do 结尾，那么 Spring MVC 会默认的加上 .do，\n\nweb.xml 中配置了url-pattern后，会起到两个作用：（1）是限制 url 的后缀名，只能为”.do”。（2）就是在没有填写后缀时，默认在你配置的 Controller 的 RequestMapping 中添加”.do”的后缀\n:point_right: ​匹配方式\n\n\n\n\n\n\n\n\n精确匹配：在@RequestMapping注解指定 URL 地址时，不使用任何通配符，按照请求地方进行精确匹配。\n@RequestMapping(&quot;&#x2F;register&#x2F;showRegister.do&quot;)\n\n@PostMapping(&quot;&#x2F;register&#x2F;registerSuccess&quot;)\n    public String showRegister(@RequestParam(&quot;uname&quot;) String name, @RequestParam(&quot;pwd&quot;) String password) &#123;\n\n        logger.debug(&quot;uname：&quot; + name + &quot;，pwd:&quot; + password);\n\n        return &quot;resultSuccess&quot;;\n    &#125;\n\n\n\n\n\n\n\n\n\n\n模糊匹配：在@RequestMapping注解指定 URL 地址时，通过使用通配符，匹配多个类似的地址。\n@RequestMapping(&quot;&#x2F;fruit&#x2F;*&quot;)\n\n&lt;h3&gt;测试@RequestMapping注解匹配方式&lt;&#x2F;h3&gt;\n&lt;a th:href&#x3D;&quot;@&#123;&#x2F;fruit&#x2F;apple&#125;&quot;&gt;@RequestMapping模糊匹配[apple]&lt;&#x2F;a&gt;&lt;br&#x2F;&gt;\n&lt;a th:href&#x3D;&quot;@&#123;&#x2F;fruit&#x2F;orange&#125;&quot;&gt;@RequestMapping模糊匹配[orange]&lt;&#x2F;a&gt;&lt;br&#x2F;&gt;\n&lt;a th:href&#x3D;&quot;@&#123;&#x2F;fruit&#x2F;banana&#125;&quot;&gt;@RequestMapping模糊匹配[banana]&lt;&#x2F;a&gt;&lt;br&#x2F;&gt;\n\n:point_right: ​抽取重复路径到类上在类级别：抽取各个方法上@RequestMapping注解地址中前面重复的部分\n@RequestMapping(&quot;&#x2F;user&quot;)\n\n在方法级别：省略被类级别抽取的部分\n@RequestMapping(&quot;&#x2F;login&quot;)\n@RequestMapping(&quot;&#x2F;register&quot;)\n@RequestMapping(&quot;&#x2F;logout&quot;)\n\n:point_right: ​附加请求方式八种类型：GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE\n\n\n\n\n\n\n\n\n\n页面表单\n&lt;h3&gt;测试@RequestMapping注解限定请求方式&lt;&#x2F;h3&gt;\n&lt;a th:href&#x3D;&quot;@&#123;&#x2F;emp&#125;&quot;&gt;同地址GET请求&lt;&#x2F;a&gt;&lt;br&#x2F;&gt;\n&lt;form th:action&#x3D;&quot;@&#123;&#x2F;emp&#125;&quot; method&#x3D;&quot;post&quot;&gt;\n    &lt;button type&#x3D;&quot;submit&quot;&gt;同地址POST请求&lt;&#x2F;button&gt;\n&lt;&#x2F;form&gt;\n&lt;br&#x2F;&gt;\n\n\n\n\n\n\n\n\n\n\n处理post请求 （参数中添加 method）\n@RequestMapping(value &#x3D; &quot;&#x2F;emp&quot;, method &#x3D; RequestMethod.POST)\npublic String empPost() &#123;\n    \n    logger.debug(&quot;POST 请求&quot;);\n    \n    return &quot;target&quot;;\n&#125;\n\n\n\n\n\n\n\n\n\n\n进阶版（另外需要注意：进阶版的这几个注解是从 4.3 版本才开始有，低于 4.3 版本无法使用。）\n\n\n\n原版\n进阶版\n\n\n\n@RequestMapping(value = “/emp”, method = RequestMethod.GET)\n@GetMapping(“/emp”)\n\n\n@RequestMapping(value = “/emp”, method = RequestMethod.POST)\n@PostMapping(“/emp”)\n\n\n\n\n\n\n\n\n\n\n\nAmbiguous mapping异常\n出现原因：多个 handler 方法映射了同一个地址，导致 SpringMVC 在接收到这个地址的请求时该找哪个 handler 方法处理。\n② @RequestParam:point_right: 前言使用@RequestParam注解标记handler方法的形参，SpringMVC 会将获取到的请求参数从形参位置给我们传进来\n 当请求参数名和形参名一致，可以省略@RequestParam(“userName”)注解，但是，省略后代码可读性下降而且将来在SpringCloud中不能省略，所以建议还是不要省略\n==如果传入的参数 我们在后端获取时直接用 对象 , map , list 进行封装，那我们就不能在对其进行 使用 @RequestParam，get 没有请求体==\n:point_right: RequestParam的属性@RequestParam 注解的 required 属性：默认值为true，表示请求参数默认必须提供\n&#x2F;&#x2F; required 属性设置为 false 表示这个请求参数可有可无\n    \n@RequestParam(value &#x3D; &quot;userName&quot;, required &#x3D; false)\n\n使用 defaultValue 属性给请求参数设置默认值：\n@RequestParam(value &#x3D; &quot;userName&quot;, required &#x3D; false, defaultValue &#x3D; &quot;missing&quot;)\n\n此时 required 属性可以继续保持默认值：\n@RequestParam(value &#x3D; &quot;userName&quot;, defaultValue &#x3D; &quot;missing&quot;)\n\n:point_right: 一名一值&lt;h4&gt;一名一值&lt;&#x2F;h4&gt;\n&lt;form action&#x3D;&quot;&#x2F;spring0.2&#x2F;register&#x2F;registerSuccess&quot; method&#x3D;&quot;post&quot;&gt;\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;uname&quot;&#x2F;&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;\n&lt;&#x2F;form&gt;\n\n&#x2F;**\n * 注册成功页面\n * 参数与html上的参数名不相同\n * @param name     注册的用户名\n *&#x2F;\n@PostMapping(&quot;&#x2F;register&#x2F;registerSuccess&quot;)\npublic String showRegister(@RequestParam(&quot;uname&quot;) String name) &#123;\n\n    logger.debug(&quot;uname：&quot; + name);\n\n    return &quot;resultSuccess&quot;;\n&#125;\n\n忽略注解\n@PostMapping(&quot;&#x2F;register&#x2F;registerSuccess&quot;)\npublic String showRegister(String uname) &#123;\n\n    logger.debug(&quot;uname：&quot; + name);\n\n    return &quot;resultSuccess&quot;;\n&#125;\n\n:point_right: 一名多值在服务器端 handler 方法中，使用一个能够存储多个数据的容器就能接收一个名字对应的多个值请求参数\n&lt;h4&gt;一名多值&lt;&#x2F;h4&gt;\n&lt;form th:action&#x3D;&quot;@&#123;&#x2F;hobby&#x2F;toHobby&#125;&quot; method&#x3D;&quot;get&quot;&gt;\n    &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;music&quot;&gt;音乐\n    &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;sport&quot;&gt;运动\n    &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;art&quot;&gt;艺术\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;\n&lt;&#x2F;form&gt;\n\n@RequestMapping(&quot;&#x2F;hobby&#x2F;toHobby&quot;)\npublic String showHobby(@RequestParam(&quot;hobby&quot;) List&lt;String&gt; hobbyList) &#123;\n\n    logger.debug(&quot;hobby列表：&quot; + hobbyList);\n\n    return &quot;resultSuccess&quot;;\n&#125;\n\n:point_right: 表单模型（实体类）@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Student &#123;\n    private String name;\n    private Integer age;\n    private String sex;\n    &#x2F;*private Date date;*&#x2F;\n&#125;\n\n&lt;h4&gt;实体类&lt;&#x2F;h4&gt;\n&lt;form th:action&#x3D;&quot;@&#123;&#x2F;student&#x2F;toStudent&#125;&quot; method&#x3D;&quot;get&quot;&gt;\n    姓名: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot;&gt;\n    年龄: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;age&quot;&gt;\n    性别: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;sex&quot;&gt;\n    &lt;!--日期: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;date&quot;&gt;--&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;\n&lt;&#x2F;form&gt;\n\n@RequestMapping(&quot;&#x2F;student&#x2F;toStudent&quot;)\npublic String showStudent(Student student) &#123;\n\n    logger.debug(&quot;学生实体：&quot; + student);\n\n    return &quot;resultSuccess&quot;;\n&#125;\n\n:point_right: 复杂实体类@Data\n@AllArgsConstructor\npublic class Student2 &#123;\n    private String stuName;\n    private School school;\n    private List&lt;Subject&gt; subjectList;\n    private Subject[] subjectArray;\n    private Set&lt;Teacher&gt; teacherSet;\n    private Map&lt;String, Double&gt; scores;\n\n    public Student2()&#123;\n        teacherSet &#x3D; new HashSet&lt;&gt;();\n        teacherSet.add(new Teacher());\n        teacherSet.add(new Teacher());\n        teacherSet.add(new Teacher());\n    &#125;\n&#125;\n\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Subject &#123;\n    private String suName;\n&#125;\n\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Teacher &#123;\n    private Integer tId;\n    private String tName;\n\n    public Teacher(Integer tId)&#123;\n        this.tId &#x3D; tId;\n    &#125;\n\n    &#x2F;*hashCode  重写hashCode方法，会通过tid tname 的hash值进行比较两个对象是否一样，这样向set集合中添加属性为空的teacher对象，那就不行了*&#x2F;\n    @Override\n    public int hashCode() &#123;\n        return Objects.hash(new Date(),tName);\n    &#125;\n&#125;\n\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class School &#123;\n    private String scName;\n&#125;\n\n&lt;h4&gt;表单对应实体类包含级联属性&lt;&#x2F;h4&gt;\n&lt;form th:action&#x3D;&quot;@&#123;&#x2F;student2&#x2F;toStudent2&#125;&quot; method&#x3D;&quot;get&quot;&gt;\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;stuName&quot; value&#x3D;&quot;黄任翔&quot;&gt;\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;school.scName&quot; value&#x3D;&quot;尚硅谷&quot;&gt;\n\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;subjectList[0].suName&quot; value&#x3D;&quot;java&quot;&gt;\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;subjectList[1].suName&quot; value&#x3D;&quot;c++&quot;&gt;\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;subjectList[2].suName&quot; value&#x3D;&quot;python&quot;&gt;\n\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;subjectArray[0].suName&quot; value&#x3D;&quot;mybatis&quot;&gt;\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;subjectArray[1].suName&quot; value&#x3D;&quot;spring&quot;&gt;\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;subjectArray[2].suName&quot; value&#x3D;&quot;sql&quot;&gt;\n\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;teacherSet[0].tName&quot; value&#x3D;&quot;张益桃&quot;&gt;\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;teacherSet[1].tName&quot; value&#x3D;&quot;刘凯丽&quot;&gt;\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;teacherSet[2].tName&quot; value&#x3D;&quot;张丽芳&quot;&gt;\n\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;scores[&#39;java&#39;]&quot; value&#x3D;&quot;100&quot;&gt;\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;scores[&#39;c++&#39;]&quot; value&#x3D;&quot;90&quot;&gt;\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;scores[&#39;python]&quot; value&#x3D;&quot;80&quot;&gt;\n\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;\n&lt;&#x2F;form&gt;\n\n@RequestMapping(&quot;&#x2F;student2&#x2F;toStudent2&quot;)\npublic String showStudent2(Student2 student2) &#123;\n\n    logger.debug(&quot;学生实体：&quot; + student2);\n\n    return &quot;resultSuccess&quot;;\n&#125;\n\n:point_right: 发送list集合@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class EmployeeParam &#123;\n    private List&lt;Student&gt; studentList;\n&#125;\n\n@RequestMapping(&quot;&#x2F;list&#x2F;employee&quot;)\npublic String showStudent2(EmployeeParam studentList) &#123;\n\n    List&lt;Student&gt; list &#x3D; studentList.getStudentList();\n\n    logger.debug(&quot;学生列表：&quot; + list);\n\n    return &quot;resultSuccess&quot;;\n&#125;\n\n&lt;h4&gt;要发送的数据是 List&lt;&#x2F;h4&gt;\n&lt;form th:action&#x3D;&quot;@&#123;&#x2F;list&#x2F;employee&#125;&quot; method&#x3D;&quot;post&quot;&gt;\n    1号学生姓名：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;studentList[0].name&quot; &#x2F;&gt;&lt;br&#x2F;&gt;\n    1号学生年龄：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;studentList[0].age&quot; &#x2F;&gt;&lt;br&#x2F;&gt;\n    1号学生性别：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;studentList[0].sex&quot; &#x2F;&gt;&lt;br&#x2F;&gt;\n    2号学生姓名：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;studentList[1].name&quot; &#x2F;&gt;&lt;br&#x2F;&gt;\n    2号学生年龄：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;studentList[1].age&quot; &#x2F;&gt;&lt;br&#x2F;&gt;\n    2号学生性别：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;studentList[1].sex&quot; &#x2F;&gt;&lt;br&#x2F;&gt;\n    &lt;button type&#x3D;&quot;submit&quot;&gt;提交&lt;&#x2F;button&gt;\n&lt;&#x2F;form&gt;\n\n③ @RequestHeader&lt;h4&gt;获取请求头&lt;&#x2F;h4&gt;\n&lt;a th:href&#x3D;&quot;@&#123;&#x2F;header&#x2F;getAccept&#125;&quot;&gt;获取请求头：Accept&lt;&#x2F;a&gt;\n&lt;a th:href&#x3D;&quot;@&#123;&#x2F;header&#x2F;getUserAgent&#125;&quot;&gt;获取请求头：User-Agent&lt;&#x2F;a&gt;\n&lt;a th:href&#x3D;&quot;@&#123;&#x2F;header&#x2F;getGET&#125;&quot;&gt;获取请求头：RequestMethod &lt;&#x2F;a&gt;\n&lt;a th:href&#x3D;&quot;@&#123;&#x2F;header&#x2F;getJSESSIONID&#125;&quot;&gt;获取请求头：JSESSIONID&lt;&#x2F;a&gt;\n\n@RequestMapping(&quot;&#x2F;header&#x2F;getAccept&quot;)\npublic String showStudent2(@RequestHeader(name &#x3D; &quot;Accept&quot;, defaultValue &#x3D; &quot;missing&quot;) String accept) &#123;\n    logger.debug(&quot;获取到的请求头Accept是：&quot; + accept);\n    return &quot;resultSuccess&quot;;\n&#125;\n\n@RequestMapping(&quot;&#x2F;header&#x2F;getUserAgent&quot;)\npublic String showStudent3(@RequestHeader(name &#x3D; &quot;User-Agent&quot;, defaultValue &#x3D; &quot;missing&quot;) String UserAgent) &#123;\n    logger.debug(&quot;获取到的请求头User-Agent是：&quot; + UserAgent);\n    return &quot;resultSuccess&quot;;\n&#125;\n\n@RequestMapping(&quot;&#x2F;header&#x2F;getRequestMethod&quot;)\npublic String showStudent4(@RequestHeader(name &#x3D; &quot;RequestMethod&quot;, defaultValue &#x3D; &quot;missing&quot;) String RequestMethod) &#123;\n    logger.debug(&quot;获取到的请求头RequestMethod是：&quot; + RequestMethod);\n    return &quot;resultSuccess&quot;;\n&#125;\n\n@RequestMapping(&quot;&#x2F;header&#x2F;getJSESSIONID&quot;)\npublic String showStudent5(@RequestHeader(name &#x3D; &quot;JSESSIONID&quot;, defaultValue &#x3D; &quot;missing&quot;) String JSESSIONID, HttpSession session) &#123;\n    Object jsessionid &#x3D; session.getAttribute(&quot;JSESSIONID&quot;);\n    logger.debug(&quot;获取到的请求头JSESSIONID是：&quot; + JSESSIONID);\n    logger.debug(&quot;获取到的请求头jsessionid是：&quot; + jsessionid);\n    return &quot;resultSuccess&quot;;\n&#125;\n\n④ @CookieValue@RequestMapping(&quot;&#x2F;request&#x2F;cookie&quot;)\npublic String getCookie(\n    \n        &#x2F;&#x2F; 使用 @CookieValue 注解获取指定名称的 Cookie 数据\n        &#x2F;&#x2F; name 或 value 属性：指定Cookie 名称\n        &#x2F;&#x2F; defaultValue 属性：设置默认值\n        @CookieValue(value &#x3D; &quot;JSESSIONID&quot;, defaultValue &#x3D; &quot;missing&quot;) String cookieValue,\n    \n        &#x2F;&#x2F; 形参位置声明 HttpSession 类型的参数即可获取 HttpSession 对象\n        HttpSession session\n) &#123;\n    \n    logger.debug(&quot;cookieValue &#x3D; &quot; + cookieValue);\n    \n    return &quot;target&quot;;\n&#125;\n\n⑤ 页面跳转控制@RequestMapping(&quot;&#x2F;forward&#x2F;forward1&quot;)\npublic String showStudent7() &#123;\n\n    logger.debug(&quot;转发WEB-INF下&quot;);\n\n    return &quot;forward:&#x2F;WEB-INF&#x2F;templates&#x2F;resultSuccess.html&quot;;\n&#125;\n\n@RequestMapping(&quot;&#x2F;forward&#x2F;forward2&quot;)\npublic String showStudent8() &#123;\n\n    logger.debug(&quot;转发WEB-INF外&quot;);\n\n    return &quot;forward:&#x2F;index.html&quot;;\n&#125;\n\n@RequestMapping(&quot;&#x2F;redirect&#x2F;redirect1&quot;)\npublic String showStudent9() &#123;\n\n    logger.debug(&quot;重定向WEB-INF外&quot;);\n\n    return &quot;redirect:&#x2F;index.html&quot;;\n&#125;\n\n@RequestMapping(&quot;&#x2F;redirect&#x2F;redirect2&quot;)\npublic String showStudent10() &#123;\n\n    logger.debug(&quot;从定向外网&quot;);\n\n    return &quot;redirect:http:&#x2F;&#x2F;www.baidu.com&quot;;\n&#125;\n\n\n\n03、其他基础功能① 获取原生ServletAPI&lt;h3&gt;结果页面&lt;&#x2F;h3&gt;\nmsg:&lt;span th:text&#x3D;&quot;$&#123;msg&#125;&quot;&gt;&lt;&#x2F;span&gt;&lt;br&#x2F;&gt;\nrequest:&lt;span th:text&#x3D;&quot;$&#123;servletRequest&#125;&quot;&gt;&lt;&#x2F;span&gt;&lt;br&#x2F;&gt;\nrequestMsg:&lt;span th:text&#x3D;&quot;$&#123;requestMsg&#125;&quot;&gt;&lt;&#x2F;span&gt;&lt;br&#x2F;&gt;\nsession:&lt;span th:text&#x3D;&quot;$&#123;session.session&#125;&quot;&gt;&lt;&#x2F;span&gt;&lt;br&#x2F;&gt;\nusername:&lt;span th:text&#x3D;&quot;$&#123;session.username&#125;&quot;&gt;&lt;&#x2F;span&gt;&lt;br&#x2F;&gt;\n\nmsg:abc\nrequest:org.apache.catalina.connector.RequestFacade@748930b1\nrequestMsg:你好，黄任翔！！！\nsession:org.apache.catalina.session.StandardSessionFacade@412ef064\nusername:hh\n\n@Controller\n@Slf4j\n@RequestMapping(&quot;&#x2F;servlet&quot;)\npublic class ServletController &#123;\n\n    @RequestMapping(&quot;&#x2F;original&quot;)\n    public String getOriginalAPI(\n            HttpServletRequest servletRequest,\n            HttpServletResponse servletResponse,\n            HttpSession session,\n            Model model\n    )&#123;\n        log.debug(&quot;request&quot;+servletRequest.toString());\n        log.debug(&quot;request&quot;+servletResponse.toString());\n        log.debug(&quot;request&quot;+session.toString());\n\n        model.addAttribute(&quot;msg&quot;,&quot;abc&quot;);\n        servletRequest.setAttribute(&quot;servletRequest&quot;,servletRequest.toString());\n        servletRequest.setAttribute(&quot;requestMsg&quot;,&quot;你好，黄任翔！！！&quot;);\n\n        servletResponse.setHeader(&quot;response&quot;,servletResponse.toString());\n\n        session.setAttribute(&quot;session&quot;,session.toString());\n        session.setAttribute(&quot;username&quot;,&quot;hh&quot;);\n\n        return &quot;result&quot;;\n    &#125;\n&#125;\n\n:point_right: 获取 ServletContext 对象\n方法一：通过HttpSession获取\n@RequestMapping(&quot;&#x2F;original&#x2F;servlet&#x2F;context&#x2F;first&#x2F;way&quot;)\npublic String originalServletContextFirstWay(HttpSession session) &#123;\n    \n    &#x2F;&#x2F; 获取ServletContext对象的方法一：通过HttpSession对象获取\n    ServletContext servletContext &#x3D; session.getServletContext();\n    logger.debug(servletContext.toString());\n    \n    return &quot;target&quot;;\n&#125;\n\n方法二：通过 IOC 容器注入 \n&#x2F;&#x2F; 获取ServletContext对象的方法二：从 IOC 容器中直接注入\n@Autowired\nprivate ServletContext servletContext;\n\n@RequestMapping(&quot;&#x2F;original&#x2F;servlet&#x2F;context&#x2F;second&#x2F;way&quot;)\npublic String originalServletContextSecondWay() &#123;\n    logger.debug(this.servletContext.toString());\n\n    return &quot;target&quot;;\n&#125;\n:point_right: 原生对象与IOC容器的关系​\n\n② 属性域:point_right: 属性域的重要作用\n:point_right: ​请求域的操作方式Model 类型    ModelMap 类型    Map 类型    ModelAndView 类型    原生request对象\n&lt;h3&gt;Model 类型的形参&lt;&#x2F;h3&gt;\n&lt;span th:text&#x3D;&quot;$&#123;loveModel&#125;&quot;&gt;&lt;&#x2F;span&gt;&lt;br&#x2F;&gt;\n\n&lt;h3&gt;ModelMap 类型的形参&lt;&#x2F;h3&gt;\n&lt;span th:text&#x3D;&quot;$&#123;loveModelMap&#125;&quot;&gt;&lt;&#x2F;span&gt;&lt;br&#x2F;&gt;\n\n&lt;h3&gt;Map 类型的形参&lt;&#x2F;h3&gt;\n&lt;span th:text&#x3D;&quot;$&#123;loveMap&#125;&quot;&gt;&lt;&#x2F;span&gt;&lt;br&#x2F;&gt;\n\n&lt;h3&gt;原生 request 对象&lt;&#x2F;h3&gt;\n&lt;span th:text&#x3D;&quot;$&#123;loveRequest&#125;&quot;&gt;&lt;&#x2F;span&gt;&lt;br&#x2F;&gt;\n\n&lt;h3&gt;ModelAndView 对象&lt;&#x2F;h3&gt;\n&lt;span th:text&#x3D;&quot;$&#123;loveModelAndView&#125;&quot;&gt;&lt;&#x2F;span&gt;&lt;br&#x2F;&gt;\n\n@RequestMapping(&quot;&#x2F;model&quot;)\npublic String testAttributeRequestModel(Model model)&#123;\n    model.addAttribute(&quot;loveModel&quot;,&quot;I Love You!!!&quot;);\n    return &quot;result&quot;;\n&#125;\n\n@RequestMapping(&quot;&#x2F;modelMap&quot;)\npublic String testAttributeRequestModelMap(ModelMap modelMap)&#123;\n    modelMap.addAttribute(&quot;loveModelMap&quot;,&quot;I love You!!!&quot;);\n    return &quot;result&quot;;\n&#125;\n\n@RequestMapping(&quot;&#x2F;map&quot;)\npublic String testAttributeRequestMap(Map&lt;String , String&gt; map)&#123;\n    map.put(&quot;loveMap&quot;,&quot;I Love You!!!&quot;);\n    return &quot;result&quot;;\n&#125;\n\n@RequestMapping(&quot;&#x2F;request&quot;)\npublic String testAttributeRequest(HttpServletRequest request)&#123;\n    request.setAttribute(&quot;loveRequest&quot;,&quot;I Love You!!!&quot;);\n    return &quot;result&quot;;\n&#125;\n\n@RequestMapping(&quot;&#x2F;modelView&quot;)\npublic ModelAndView testAttributeRequestModelView()&#123;\n\n    ModelAndView modelAndView &#x3D; new ModelAndView();\n    modelAndView.addObject(&quot;loveModelAndView&quot;,&quot;I Love You!!!&quot;);\n    modelAndView.setViewName(&quot;result&quot;);\n    return modelAndView;\n&#125;\n\n:point_right: 模型的本质SpringMVC 传入的 Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的。\n它们之间的关系如下图 1            \n框架底层将模型存入请求域，源码所在位置，所在类：org.thymeleaf.context.WebEngineContext    所在方法：setVariable() 图 2\n\n    \n    \n\n\n过程中值得关注的点:\n\n    \n\n\n③ 会话域使用会话域最简单直接的办法就是使用原生的 HttpSession 对象\n@RequestMapping(&quot;&#x2F;attr&#x2F;session&quot;)\npublic String attrSession(\n        &#x2F;&#x2F; 使用会话域最简单直接的办法就是使用原生的 HttpSession 对象\n        HttpSession session) &#123;\n    \n    session.setAttribute(&quot;sessionScopeMessage&quot;, &quot;i am haha ...&quot;);\n    \n    return &quot;target&quot;;\n&#125;\n\n④ 应用域应用域同样是使用原生对象来操作：\n@Autowired\nprivate ServletContext servletContext;\n\n@RequestMapping(&quot;&#x2F;attr&#x2F;application&quot;)\npublic String attrApplication() &#123;\n    \n    servletContext.setAttribute(&quot;appScopeMsg&quot;, &quot;i am hungry...&quot;);\n    \n    return &quot;target&quot;;\n&#125;\n\n⑤ mvc:view-controller在一个 handler 方法中，仅仅只是完成 @RequestMapping 映射，将请求转发到目标视图，除此之外没有任何其他代码。此时可以使用 SpringMVC 配置文件中的配置代替这样的 handler 方法。（就是所谓的跳转到 WEB-INF下的主页）\n在springmvc配置文件中配置 此标签，同时，handler 类中就可以去掉被代替的方法。\n&lt;mvc:view-controller path&#x3D;&quot;&#x2F;springmvc0.3&quot; view-name&#x3D;&quot;index&quot;&#x2F;&gt;\n\n如果没有 mvc:annotation-driven，加入 mvc:view-controller 配置后，其他正常 @RequestMapping 将失效。此时还是需要加入 mvc:annotation-driven 来解决。\n同时加几个path 不一样的跳转主页的 配置，也是可以的\n⑥ 表单标签（回显）主要的目的是在页面上实现表单回显。最典型的情况是在修改数据时，把之前旧的数据重新显示出来供用户参考。\n:point_right: 回显简单标签&lt;form th:action&#x3D;&quot;@&#123;&#x2F;tiger&#x2F;update&#125;&quot;&gt;\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;tigerId&quot; th:value&#x3D;&quot;$&#123;tiger.tigerId&#125;&quot; readonly&gt;&lt;br&#x2F;&gt;\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;tigerName&quot; th:value&#x3D;&quot;$&#123;tiger.tigerName&#125;&quot;&gt;&lt;br&#x2F;&gt;\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;tigerSalary&quot; th:value&#x3D;&quot;$&#123;tiger.tigerSalary&#125;&quot;&gt;&lt;br&#x2F;&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;\n&lt;&#x2F;form&gt;\n\n@Slf4j\n@Controller\n@RequestMapping(&quot;&#x2F;tiger&quot;)\npublic class UpdateTigerController &#123;\n\n    @RequestMapping(&quot;&#x2F;toUpdate&quot;)\n    public String simpleTagRedisplay(Model model) &#123;\n\n        Tiger tiger &#x3D; new Tiger();\n        tiger.setTigerId(5);\n        tiger.setTigerName(&quot;nihao&quot;);\n        tiger.setTigerSalary(888.88);\n\n        model.addAttribute(&quot;tiger&quot;, tiger);\n\n        return &quot;tiger&quot;;\n    &#125;\n\n    @RequestMapping(&quot;&#x2F;update&quot;)\n    public String update(Tiger tiger)&#123;\n        log.debug(tiger.toString());\n        return &quot;index&quot;;\n    &#125;\n&#125;\n\n:point_right: 回显带选择功能的标签@Slf4j\n@Controller\n@RequestMapping(&quot;&#x2F;tiger2&quot;)\npublic class UpdateTigerController2 &#123;\n    @RequestMapping(&quot;&#x2F;toUpdate&quot;)\n    public String simpleTagRedisplay(Model model) &#123;\n\n        &#x2F;&#x2F; 1.准备用来显示标签的数据\n        List&lt;Season&gt; seasonList &#x3D; new ArrayList&lt;&gt;();\n        seasonList.add(new Season(1, &quot;春天&quot;));\n        seasonList.add(new Season(2, &quot;夏天&quot;));\n        seasonList.add(new Season(3, &quot;秋天&quot;));\n        seasonList.add(new Season(4, &quot;冬天&quot;));\n\n        model.addAttribute(&quot;seasonList&quot;, seasonList);\n\n        Tiger2 tiger &#x3D; new Tiger2();\n        tiger.setTigerId(5);\n        tiger.setTigerName(&quot;nihao&quot;);\n        tiger.setTigerSalary(888.88);\n\n        tiger.setSeason(new Season(2,&quot;夏天&quot;));\n        model.addAttribute(&quot;tiger&quot;, tiger);\n\n        Tiger3 tiger3 &#x3D; new Tiger3();\n        List&lt;Season&gt; seasonList1 &#x3D; new ArrayList&lt;&gt;();\n        seasonList1.add(new Season(1,&quot;春天&quot;));\n        seasonList1.add(new Season(3,&quot;秋天&quot;));\n        seasonList1.add(new Season(4,&quot;冬天&quot;));\n\n        tiger3.setSeasonList(seasonList1);\n\n        model.addAttribute(&quot;seasonList1&quot;,seasonList1);\n\n        return &quot;tiger2&quot;;\n    &#125;\n\n    @RequestMapping(&quot;&#x2F;update&quot;)\n    public String update(Tiger2 tiger)&#123;\n        log.debug(tiger.toString());\n        return &quot;index&quot;;\n    &#125;\n&#125;\n\n&lt;form th:action&#x3D;&quot;@&#123;&#x2F;tiger2&#x2F;update&#125;&quot;&gt;\n    &lt;!--普通表单项--&gt;\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;tigerId&quot; th:value&#x3D;&quot;$&#123;tiger.tigerId&#125;&quot; readonly&gt;&lt;br&#x2F;&gt;\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;tigerName&quot; th:value&#x3D;&quot;$&#123;tiger.tigerName&#125;&quot;&gt;&lt;br&#x2F;&gt;\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;tigerSalary&quot; th:value&#x3D;&quot;$&#123;tiger.tigerSalary&#125;&quot;&gt;&lt;br&#x2F;&gt;\n\n    &lt;!--单选框--&gt;\n    &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;$&#123;season.seasonId&#125;&quot;\n           th:each&#x3D;&quot;season : $&#123;seasonList&#125;&quot;\n           th:value&#x3D;&quot;$&#123;season.seasonId&#125;&quot;\n           th:text&#x3D;&quot;$&#123;season.seasonName&#125;&quot;\n           th:checked&#x3D;&quot;$&#123;tiger.season.seasonId&#x3D;&#x3D;season.seasonId&#125;&quot;&gt;\n    &lt;br&#x2F;&gt;\n\n    &lt;!--下拉列表--&gt;\n    &lt;select name&#x3D;&quot;$&#123;season.seasonId&#125;&quot;&gt;\n        &lt;option th:each&#x3D;&quot;season : $&#123;seasonList&#125;&quot;\n                th:value&#x3D;&quot;$&#123;season.seasonId&#125;&quot;\n                th:text&#x3D;&quot;$&#123;season.seasonName&#125;&quot;\n                th:selected&#x3D;&quot;$&#123;tiger.season.seasonId&#x3D;&#x3D;season.seasonId&#125;&quot;&gt;\n        &lt;&#x2F;option&gt;\n    &lt;&#x2F;select&gt;\n    &lt;br&#x2F;&gt;\n\n    &lt;!--复选框--&gt;\n    &lt;!--注意：此时需要判断一个对象是否在集合中，那就需要重写equals()和hashCode()方法。--&gt;\n    &lt;!--用包含回显数据的集合调用contains()方法判断是否应该被选中；\n    传入contains()方法的是生成具体每一个标签时遍历得到的对象--&gt;\n    &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;$&#123;season.seasonId&#125;&quot;\n           th:each&#x3D;&quot;season : $&#123;seasonList&#125;&quot;\n           th:value&#x3D;&quot;$&#123;season.seasonId&#125;&quot;\n           th:text&#x3D;&quot;$&#123;season.seasonName&#125;&quot;\n           th:checked&#x3D;&quot;$&#123;seasonList1.contains(season)&#125;&quot;&gt;\n    &lt;br&#x2F;&gt;\n\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;\n&lt;&#x2F;form&gt;\n\n04、RESTFul 讲解① RESTFul 风格概述REST：Representational State Transfer，表现层资源状态转移。\n\n定位：互联网软件架构风格\n倡导者：Roy Thomas Fielding\n文献：Roy Thomas Fielding的博士论文\n\n② 挑战与应对传统的软件系统仅在本地工作，但随着项目规模的扩大和复杂化，不但整个项目会拓展为分布式架构，很多功能也会通过网络访问第三方接口来实现。在通过网络访问一个功能的情况下，我们不能轻易假设网络状况文档可靠。所以当一个请求发出后没有接收到对方的回应，那我们该如何判定本次操作成功与否？\n下面以保存操作为例来说明一下针对功能和针对资源进行操作的区别：\n\n针对功能设计系统\n保存一个 Employee 对象，没有接收到返回结果，判定操作失败，再保存一次。但是其实在服务器端保存操作已经成功了，只是返回结果在网络传输过程中丢失了。而第二次的补救行为则保存了重复、冗余但 id 不同的数据，这对整个系统数据来说是一种破坏。\n\n针对资源设计系统\n针对 id 为 3278 的资源执行操作，服务器端会判断指定 id 的资源是否存在。如果不存在，则执行保存操作新建数据；如果存在，则执行更新操作。所以这个操作不论执行几次，对系统的影响都是一样的。在网络状态不可靠的情况下可以多次重试，不会破坏系统数据。\n\n\n==幂等性：若一个操作执行一次和执行 N 次对系统的影响相同，那么我们就说这个操作满足幂等性。而幂等性正是 REST 规范所倡导的==\n确立 HTTP 协议作为项目架构设计规范和统一标准后，无论系统内部的远程方法还是系统外部的第三方接口，对我们当前所在模块来说都是网络上的资源，完全可以使用相同（或类似）的方式来访问和调用。这非常有利于我们建构大型、超大型互联网项目体系。\n③ RESTFul 规范的内涵:point_right: 资源URL：Uniform Resource Locator 统一资源定位器。意思是网络上的任何资源都可以通过 URL 来定位。但是在实际开发中，我们往往是使用 URL 来对应一个具体的功能，而不是资源本身。REST 规范则倡导使用 URL 对应网络上的各种资源，任何一个资源都可以通过一个 URL 访问到，为实现操作幂等性奠定基础。\n:point_right: 状态转移REST 倡导针对资源本身操作，所以对资源的操作如果满足幂等性，那么操作只会导致资源本身的状态发生变化而不会破坏整个系统数据。\n④ RESTFul 规范具体要求:point_right: 四种请求方式对应四种风格REST 风格主张在项目设计、开发过程中，具体的操作符合 HTTP 协议定义的请求方式的语义。\n\n\n\n操作\n请求方式\n\n\n\n查询操作\nGET\n\n\n保存操作\nPOST\n\n\n删除操作\nDELETE\n\n\n更新操作\nPUT\n\n\n另有一种说法：\n\nPOST 操作针对功能执行，没有锁定资源 id，是非幂等性操作。\nPUT 操作锁定资源 id，即使操作失败仍然可以针对原 id 重新执行，对整个系统来说满足幂等性。\nid 对应的资源不存在：执行保存操作\nid 对应的资源存在：执行更新操作\n\n\n\n这个说法更加深刻\n:point_right: URL 地址风格REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。还有一点是不要使用请求扩展名。\n\n\n\n传统 URL 地址\nREST 风格地址\n\n\n\n/remove/emp?id=5\n/emp/5\n\n\n⑤ RESTFul 风格好处:point_right: 含蓄，安全使用问号键值对的方式给服务器传递数据太明显，容易被人利用来对系统进行破坏。使用 REST 风格携带数据不再需要明显的暴露数据的名称。\n:point_right: 风格统一URL 地址整体格式统一，从前到后始终都使用斜杠划分各个内容部分，用简单一致的格式表达语义。\n:point_right: 无状态在调用一个接口（访问、操作资源）的时候，可以不用考虑上下文，不用考虑当前状态，极大的降低了系统设计的复杂度。\n:point_right: 严谨，规范严格按照 HTTP1.1 协议中定义的请求方式本身的语义进行操作。\n:point_right: 简洁，优雅过去做增删改查操作需要设计4个不同的URL，现在一个就够了。\n\n\n\n操作\n传统风格\nREST 风格\n\n\n\n保存\n/CRUD/saveEmp\nURL 地址：/CRUD/emp 请求方式：POST\n\n\n删除\n/CRUD/removeEmp?empId=2\nURL 地址：/CRUD/emp/2 请求方式：DELETE\n\n\n更新\n/CRUD/updateEmp\nURL 地址：/CRUD/emp 请求方式：PUT\n\n\n查询（表单回显）\n/CRUD/editEmp?empId=2\nURL 地址：/CRUD/emp/2 请求方式：GET\n\n\n:point_right: 丰富的语义通过 URL 地址就可以知道资源之间的关系。它能够把一句话中的很多单词用斜杠连起来，反过来说就是可以在 URL 地址中用一句话来充分表达语义。\n\n\n\n\n\n\n\n\n\nhttp://localhost:8080/shop\nhttp://localhost:8080/shop/product\nhttp://localhost:8080/shop/product/cellPhone\nhttp://localhost:8080/shop/product/cellPhone/iPhone\n⑥ 四种请求方式映射 :star::point_right: HHMF 类HiddenHttpMethodFilter\n在 HTML 中，GET 和 POST 请求可以天然实现，但是 DELETE 和 PUT 请求无法直接做到。SpringMVC 提供了 HiddenHttpMethodFilter 帮助我们将 POST 请求转换为 DELETE 或 PUT 请求。\n\n\n\n\n\n\n\n\n\n源码要点\n[1]默认请求参数名常量\npublic static final String DEFAULT_METHOD_PARAM &#x3D; &quot;_method&quot;;\n\n在 HiddenHttpMethodFilter 中，声明了一个常量：DEFAULT_METHOD_PARAM，常量值是”_method”。\n[2]和常量配套的成员变量\nprivate String methodParam &#x3D; DEFAULT_METHOD_PARAM;\n\n之所以会提供这个成员变量和配套的 setXxx() 方法，是允许我们在配置 Filter 时，通过初始化参数来修改这个变量。如果不修改，默认就是前面常量定义的值。\n[3]以常量值为名称获取请求参数\n \n:point_right: 装饰者模式装饰者模式也是二十三种设计模式之一，属于结构型模式，主要特点就是借助原始对象实现和原始对象一样的接口，同时通过重写父类方法修改被包装对象的行为。\n:point_right: ​原始请求对象的包装困难\n\n\n\n\n\n\n\n\n\n\n包装对象必须和原始对象是同一个类型\n保证同一个类型不能通过子类继承父类实现\n子类对象：希望改变行为、属性的对象\n父类对象：随着 Servlet 容器的不同，各个容器对 HttpServletRequest 接口给出的实现不同。如果继承了 A 容器给出的实现类，那么将来就不能再迁移到 B 容器。\n\n\n只能让包装对象和被包装对象实现相同接口\n虽然使用动态代理技术大致上应该能实现，但是一旦应用代理就必须为被包装的对象的每一个方法都进行代理，操作过于繁琐。\n\n\n如果我们自己创建一个类实现 HttpServletRequest 接口\n困难1：我们其实并不知道具体该怎么做\n困难2：抽象方法实在太多\n\n\n\nHttpServletRequestWrapper 类\n\n\n\n\n\n\n\n\n\nHttpServletRequestWrapper 类能够非常好的帮助我们对原始 request 对象进行包装。它为什么能帮我们解决上面的困难呢？\n\nHttpServletRequestWrapper  类替我们实现了HttpServletRequest 接口\n为了让包装得到的新对象在任何 Servlet 容器平台上都能够正常工作，HttpServletRequestWrapper  类此处的设计非常巧妙：它借助原始的 request 对象本身来实现所有的具体功能\n在我们想通过包装的方式来修改原始对象的行为或属性时，只需要在 HttpServletRequestWrapper  类的子类中重写对应的方法即可 \n\nHttpMethodRequestWrapper 类\n\n\n\n\n\n\n\n\n\nHttpMethodRequestWrapper 类就是 HiddenHttpMethodFilter 的一个内部类，在 HttpMethodRequestWrapper 类中有如下行为实现了对原始对象的包装：\n\n继承了官方包装类：HttpServletRequestWrapper\n在构造器中将原始 request 对象传给了父类构造器\n将我们指定的新请求方式传给了成员变量\n重写了父类（官方包装类）的 getMethod() 方法\n外界想知道新包装对象的请求方式时，会来调用被重写的 getMethod() 方法，从而得到我们指定的请求方式\n\n&#x2F;**\n * Simple &#123;@link HttpServletRequest&#125; wrapper that returns the supplied method for\n * &#123;@link HttpServletRequest#getMethod()&#125;.\n *&#x2F;\nprivate static class HttpMethodRequestWrapper extends HttpServletRequestWrapper &#123;\n    \n    private final String method;\n    \n    public HttpMethodRequestWrapper(HttpServletRequest request, String method) &#123;\n        &#x2F;&#x2F; 在构造器中将原始 request 对象传给了父类构造器\n        super(request);\n        \n        &#x2F;&#x2F; 将我们指定的新请求方式传给了成员变量\n        this.method &#x3D; method;\n    &#125;\n    \n    @Override\n    public String getMethod() &#123;\n        return this.method;\n    &#125;\n&#125;\n⑦ PUT请求以下操作需要在已有的 SpringMVC 环境基础上执行，并配置 web.xml\n&lt;!--将 POST 请求，转化为PUT DELETE 请求 （写在编码过滤器后，否则会出现乱码）--&gt;\n&lt;filter&gt;\n    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;&#x2F;filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;&#x2F;filter-class&gt;\n&lt;&#x2F;filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;filter-mapping&gt;\n\n&lt;h3&gt;PUT 请求&lt;&#x2F;h3&gt;\n&lt;!-- 原请求方式必须是 post --&gt;\n&lt;form th:action&#x3D;&quot;@&#123;&#x2F;user&#125;&quot; method&#x3D;&quot;post&quot;&gt;\n    &lt;!-- 通过表单隐藏域携带一个请求参数 --&gt;\n    &lt;!-- 请求参数名：_method --&gt;\n    &lt;!-- 请求参数值：put --&gt;\n    &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;_method&quot; value&#x3D;&quot;PUT&quot;&gt;\n    &lt;input name&#x3D;&quot;userId&quot; type&#x3D;&quot;text&quot;&#x2F;&gt;\n    &lt;input name&#x3D;&quot;userName&quot; type&#x3D;&quot;text&quot;&#x2F;&gt;\n    &lt;input name&#x3D;&quot;userSalary&quot; type&#x3D;&quot;text&quot;&#x2F;&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;修改&quot;&gt;\n&lt;&#x2F;form&gt;\n\n&#x2F;&#x2F; PUT 请求，修改用户信息\n@PutMapping(value &#x3D; &quot;&#x2F;user&quot;)\npublic  String putUser(User user)&#123;\n    log.debug(&quot;----------putUser---&quot;+user.getUserName()+&quot;,&quot;+user.getUserSalary()+&quot;-------------&quot;);\n    return &quot;result&quot;;\n&#125;\n\n⑧ DELETE 请求&lt;h3&gt;DELETE 请求&lt;&#x2F;h3&gt;\n&lt;div id&#x3D;&quot;delete&quot;&gt;\n    &lt;a th:href&#x3D;&quot;@&#123;&#x2F;user&#x2F;2&#125;&quot; @click.prevent&#x3D;&quot;doConvert&quot;&gt;删除&lt;&#x2F;a&gt;\n&lt;&#x2F;div&gt;\n&lt;!-- 创建一个通用表单，在删除超链接的单击响应函数中通过这个表单把GET请求转换为POST，进而再转DELETE --&gt;\n&lt;form method&#x3D;&quot;post&quot; id&#x3D;&quot;convertForm&quot;&gt;\n    &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;_method&quot; value&#x3D;&quot;delete&quot;&#x2F;&gt;\n&lt;&#x2F;form&gt;\n\n&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; th:src&#x3D;&quot;@&#123;&#x2F;js&#x2F;vue.js&#125;&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n        new Vue(&#123;\n            el: &quot;#delete&quot;,\n            methods: &#123;\n                &quot;doConvert&quot;: function (event) &#123;\n\n                    &#x2F;&#x2F; 1.先根据id获取到表单的元素对象\n                    var formEle &#x3D; document.getElementById(&quot;convertForm&quot;);\n                    &#x2F;&#x2F; 2.将表单的action属性设置为当前超链接的href属性\n                    &#x2F;&#x2F; ①之所以要这样赋值就是为了将来提交表单的时候访问的还是原超链接要访问的地址\n                    &#x2F;&#x2F; ②event对象：当前事件对象\n                    &#x2F;&#x2F; ③event.target对象：发生事件的元素对象，现在是我们点击的超链接\n                    &#x2F;&#x2F; ④event.target.href属性：超链接的href属性值\n                    &#x2F;&#x2F; ⑤formEle.action属性：表单的action属性的值\n                    formEle.action &#x3D; event.target.href;\n                    &#x2F;&#x2F; 3.提交表单\n                    formEle.submit();\n                    &#x2F;&#x2F; 阻止超链接的默认行为（跳转页面）\n                    &#x2F;*event.preventDefault();*&#x2F;\n                &#125;\n            &#125;\n        &#125;);\n    &lt;&#x2F;script&gt;\n\n&#x2F;&#x2F; DELETE 请求，删除用户信息\n@DeleteMapping(value &#x3D; &quot;&#x2F;user&#x2F;&#123;userId&#125;&quot;)\npublic  String deleteUser(@PathVariable(&quot;userId&quot;) Integer id)&#123;\n    log.debug(&quot;----------deleteUser---&quot;+id+&quot;-------------&quot;);\n    return &quot;result&quot;;\n&#125;\n\n⑨ 请求方式Filter对字符集Filter影响:point_right: ​结论当 web.xml 中两个 Filter 并存，一定要让 CharacterEncodingFilter 先执行。\n:point_right: ​原因\n在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的\nrequest.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作\n而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作：\n\nString paramValue &#x3D; request.getParameter(this.methodParam);\n\n⑩ @PathVariable:point_right: REST风格路径参数请看下面链接：\n\n\n\n\n\n\n\n\n\n/emp/20\n/shop/product/iphone\n如果我们想要获取链接地址中的某个部分的值，就可以使用 @PathVariable 注解，例如上面地址中的20、iphone部分。\n:point_right: ​操作\n\n\n\n\n\n\n\n\n传一个值： &lt;a th:href=&quot;@&#123;/emp/20&#125;&quot;&gt;传一个值&lt;/a&gt;\nhandler 方法：实际访问地址：/emp/20        映射地址：/emp/{empId}是把变量部分用大括号标记出来，写入变量名\n@RequestMapping(&quot;&#x2F;emp&#x2F;&#123;empId&#125;&quot;)\npublic String getEmpById(@PathVariable(&quot;empId&quot;) Integer empId) &#123;\n    logger.debug(&quot;empId &#x3D; &quot; + empId);\n\n    return &quot;target&quot;;\n&#125;\n\n传多个值：&lt;a th:href=&quot;@&#123;/emp/tom/18/50&#125;&quot;&gt;传多个值&lt;/a&gt;\nhandler 方法：实际地址：/emp/tom/18/50\n@RequestMapping(&quot;&#x2F;emp&#x2F;&#123;empName&#125;&#x2F;&#123;empAge&#125;&#x2F;&#123;empSalary&#125;&quot;)\npublic String queryEmp(\n    @PathVariable(&quot;empName&quot;) String empName,\n    @PathVariable(&quot;empAge&quot;) Integer empAge,\n    @PathVariable(&quot;empSalary&quot;) Double empSalary\n) &#123;\n    logger.debug(&quot;empName &#x3D; &quot; + empName);\n    logger.debug(&quot;empAge &#x3D; &quot; + empAge);\n    logger.debug(&quot;empSalary &#x3D; &quot; + empSalary);\n\n    return &quot;target&quot;;\n&#125;\n05、AJAX① 实验一（普通）\n\n\n\n\n\n\n\n\n请求：发送普通请求参数\nhandler 方法：使用 @RequestParam 注解接收请求参数\n响应：服务器端返回普通文本\n引入JavaScript库\n&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;script&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;script&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;\n\n前台代码（普通数据用   params）\n&lt;span id&#x3D;&quot;testSpan&quot;&gt;\n    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;实验一&quot; @click&#x3D;&quot;demo1&quot;&gt;\n&lt;&#x2F;span&gt;\n\n&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    new Vue(&#123;\n        el: &quot;#testSpan&quot;,\n        methods: &#123;\n            demo1() &#123;\n                axios(&#123;\n                    method: &quot;post&quot;,\n                    url: &quot;axios&#x2F;demo1&quot;,\n                    params: &#123;\n                        username: &quot;奥巴马&quot;,\n                        password: &quot;222222&quot;\n                    &#125;\n                &#125;).then(response &#x3D;&gt; &#123;\n                    console.log(response.data)\n                &#125;).catch(error &#x3D;&gt; &#123;\n                    console.log(error)\n                &#125;)\n            &#125;\n&lt;&#x2F;script&gt;\n\n后台代码\n\n\n\n\n\n\n\n\n\n注意：使用@ResponseBody注解告诉 SpringMVC：请你拿当前方法的返回值作为响应体，不要再找视图了\n方法返回值类型有两种情况：\n​        情况一：简单类型。SpringMVC 会直接作为响应体数据。\n​        情况二：复杂类型。SpringMVC 会把它转换为 JSON 然后再作为响应体。此时需要 Jackson 的支持。\n@ResponseBody\n@RequestMapping(&quot;&#x2F;ajax&#x2F;experiment&#x2F;one&quot;)\npublic String experimentOne(\n \n        &#x2F;&#x2F; Ajax请求发过来的请求参数，对服务器端来说没有区别，还是像以前一样正常接收\n        @RequestParam(&quot;userName&quot;) String userName,\n        @RequestParam(&quot;password&quot;) String password\n) &#123;\n \n    logger.debug(&quot;userName &#x3D; &quot; + userName);\n    logger.debug(&quot;password &#x3D; &quot; + password);\n \n    &#x2F;&#x2F; 服务器端给Ajax程序的响应数据通过handler方法的返回值提供\n    return &quot;message from handler as response[来自服务器的问候]&quot;;\n&#125;\n\n② 实验二（请求体是  JSON）\n\n\n\n\n\n\n\n\n请求：发送普通的请求参数，请求参数整体正好对应实体类\nhandler 方法：使用普通实体类接收请求参数\n响应：返回普通文本数据\n导入Json依赖​ :star:\n&lt;!--我们自己导入时需要注意：SpringMVC 和 Jackson 配合使用有版本的要求。二者中任何一个版本太高或太低都不行。--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.12.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n前台代码 （axios中传参的部分使用 ：data，表示请求体的是 json数据）\n&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    new Vue(&#123;\n        el: &quot;#testSpan&quot;,\n        methods: &#123;\n            demo3() &#123;\n                axios(&#123;\n                    method: &quot;post&quot;,\n                    url: &quot;axios&#x2F;demo3&quot;,\n                    data: &#123;\n                        id: 1,\n                        name: &quot;黄任翔&quot;,\n                        pwd: &quot;2222222&quot;,\n                        bir: &quot;1999-10-14 12:13:14&quot;,\n                        subjectList: [\n                            &#123;\n                                subjectName: &quot;java&quot;,\n                                subjectScore: &quot;200.0&quot;\n                            &#125;,\n                            &#123;\n                                subjectName: &quot;c++&quot;,\n                                subjectScore: &quot;100.0&quot;\n                            &#125;,\n                            &#123;\n                                subjectName: &quot;python&quot;,\n                                subjectScore: &quot;50.0&quot;\n                            &#125;\n                        ]\n                    &#125;\n\n                &#125;).then(response &#x3D;&gt; &#123;\n                    console.log(response)\n                &#125;).catch(error &#x3D;&gt; &#123;\n                    console.log(error)\n                &#125;)\n            &#125;\n&lt;&#x2F;script&gt;\n\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Student &#123;\n    private Integer id;\n    private String name;\n    private String pwd;\n    @JsonFormat(pattern &#x3D; &quot;yyyy:MM:dd HH:mm:ss&quot;,timezone &#x3D; &quot;GMT+8&quot;)\n    @DateTimeFormat(pattern &#x3D; &quot;yyyy:MM:dd HH:mm:ss&quot;)\n    private Date bir;\n    private List&lt;Subject&gt; subjectList;\n\n&#125;\n\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Subject &#123;\n    private  String subjectName;\n    private String subjectScore;\n&#125;\n\n@RequestMapping(value &#x3D; &quot;&#x2F;axios&#x2F;demo3&quot;)\npublic String axiosDemo3(@RequestBody Student student) &#123;\n    log.debug(&quot;-----------&quot; + student.toString() + &quot;-----------&quot;);\n    return &quot;axiosDemo3   is   ok!!!&quot;;\n&#125;\n\n注意：如果前端程序使用 axios 的 params 属性发送请求参数，那么请求参数会附着在 URL 地址后面，此时当前请求没有请求体。同时服务器端 handler 方法使用了 @RequestBody 注解，会在日志中看到下面异常信息：\n\n\n\n\n\n\n\n\n\nHttpMessageNotReadableException: Required request body is missing:\n意思是需要请求体，但是没有找到。\n③ 实验三（返回数据是JSON）@RequestMapping(&quot;&#x2F;axios&#x2F;demo4&quot;)\npublic Student axiosDemo4() &#123;\n    log.debug(&quot;-----------&quot; + &quot;demo4&quot; + &quot;-----------&quot;);\n    List&lt;Subject&gt; subjectList &#x3D; new ArrayList&lt;&gt;();\n    subjectList.add(new Subject(&quot;java&quot;,&quot;99.0&quot;));\n    subjectList.add(new Subject(&quot;c++&quot;,&quot;89.0&quot;));\n    subjectList.add(new Subject(&quot;php&quot;,&quot;79.0&quot;));\n    return new Student(1, &quot;hh&quot;, &quot;gg&quot;,new Date(),subjectList);\n&#125;\n\n&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    new Vue(&#123;\n        el: &quot;#testSpan&quot;,\n        methods: &#123;\n            demo4() &#123;\n                axios(&#123;\n                    method: &quot;post&quot;,\n                    url: &quot;axios&#x2F;demo4&quot;,\n                &#125;).then(response &#x3D;&gt; &#123;\n                    console.log(response.data)\n                    console.log(response.data.uName)\n                    console.log(response.data.uPwd)\n                &#125;).catch(error &#x3D;&gt; &#123;\n                    console.log(error)\n                &#125;)\n            &#125;\n&lt;&#x2F;script&gt;\n\n④ 常见错误\n\n\n\n\n\n\n\n\n415错误\n表示 SpringMVC 为了将 实体类对象转换为 JSON 数据，需要转换器。但是现在找不到转换器。它想要成功完成转换需要两方面支持：\n\nmvc:annotation-driven\n引入 Jackson 依赖\n\n\n\n\n\n\n\n\n\n\n406错误\n问题出现的原因：\n\n请求地址扩展名：html\n服务器端打算返回的数据格式：JSON\n\n上面二者不一致。SpringMVC 要坚守一个商人的良心，不能干『挂羊头，卖狗肉』的事儿。解决办法有三种思路：\n\n第一种方法：不使用请求扩展名\n第二种方法：使用和实际返回的数据格式一致的扩展名\n\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;dispatcherServlet&lt;&#x2F;servlet-name&gt;\n    &lt;url-pattern&gt;*.html&lt;&#x2F;url-pattern&gt;\n    &lt;url-pattern&gt;*.json&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;servlet-mapping&gt;\n\n\n第三种方法：使用一个 HTTP 协议中没有被定义的扩展名，例如：*.atguigu\n\n⑤ @RestController:point_right:  提取@ResponseBody如果类中每个方法上都标记了 @ResponseBody 注解，那么这些注解就可以提取到类上。\n:point_right:  合并类上的 @ResponseBody 注解可以和 @Controller 注解合并为 @RestController 注解。所以使用了 @RestController 注解就相当于给类中的每个方法都加了 @ResponseBody 注解。\n:point_right: 源码@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Controller\n@ResponseBody\npublic @interface RestController &#123;\n \n    &#x2F;**\n     * The value may indicate a suggestion for a logical component name,\n     * to be turned into a Spring bean in case of an autodetected component.\n     * @return the suggested component name, if any (or empty String otherwise)\n     * @since 4.0.1\n     *&#x2F;\n    @AliasFor(annotation &#x3D; Controller.class)\n    String value() default &quot;&quot;;\n \n&#125;\n\n:point_right: SpringMVC 4 版本响应体字符集设置&#x2F;&#x2F; 当返回响应体数据包含乱码时，在@RequestMapping注解中设置\n&#x2F;&#x2F; produces属性给响应体设置内容类型\n@ResponseBody\n@RequestMapping(value &#x3D; &quot;&#x2F;ajax&#x2F;get&#x2F;message&quot;, produces &#x3D; &quot;text&#x2F;html;charset&#x3D;UTF-8&quot;)\npublic String getMessage() &#123;\n    return &quot;message from server:你好&quot;;\n&#125;\n\n&#x2F;&#x2F; 如果返回 JSON 数据时遇到乱码问题，那么内容类型应设置为：application&#x2F;json;charset&#x3D;UTF-8\n&#x2F;&#x2F; 这里需要注意：JSON 属于 application 这个大类，不属于 text\n@ResponseBody\n@RequestMapping(value &#x3D; &quot;&#x2F;ajax&#x2F;get&#x2F;entity&quot;, produces &#x3D; &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;)\npublic Emp getEntity() &#123;\n    Emp emp &#x3D; new Emp();\n\n    emp.setEmpName(&quot;舔狗&quot;);\n\n    return emp;\n&#125;\n\n\n\n07、入参出参数格式化\n准备，定义一个pojo，它有一个 java.util.Date 类型的属性 date。\n\nimport java.util.Date;\npublic class DateVo &#123;\n  private Date date;\n  public void setDate(Date date)&#123;\n    this.date &#x3D; date;\n  &#125;\n  public Date getDate()&#123;\n    return date;\n  &#125;\n&#125;\n\n定义一个Controller\n@RestController\n@RequestMapping(&quot;&#x2F;date&#x2F;&quot;)\npublic class DateController &#123;\n  @RequestMapping(&quot;test&quot;)\n  public DateVo getDate(DateVo vo)&#123;\n    System.out.println(&quot;date1:&quot;+vo.getDate());\n\n    SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n    String date &#x3D; sdf.format(vo.getDate());\n    System.out.println(&quot;date2:&quot;+date);\n\n    DateVo vo2 &#x3D; new DateVo();\n    vo2.setDate(new Date());\n    return vo2;\n  &#125;\n&#125;\n\n访问 /date/test ，并传入参数：2018-08-02 22:05:55\n发现并不能访问成功，会抛出异常：因为传入的参数是 String 类型的，而用来接收参数的 DateVo 的 date 属性是 java.util.Date 类型的，类型无法转换。\n2、入参格式化\n这时，就可以使用 Spring 的 @DateTimeFormat 注解格式化参数，来解决上述问题。\n\n改造 DateVo：\npublic class DateVo &#123;\n  @DateTimeFormat(pattern&#x3D;&quot;yyyy-MM-dd HH:mm:ss&quot;)\n  private Date date;\n  public void setDate(Date date)&#123;\n    this.date &#x3D; date;\n  &#125;\n  public Date getDate()&#123;\n    return date;\n  &#125;&#125;\n再像上面一样访问 /date/test ，并传入参数：2018-08-02 22:05:55，将在控制台上打印：\ndate1:Thu Aug 02 22:05:55 CST 2018\ndate2:2018-08-02 22:05:55\n可以看到，加入 @DateTimeFormat 注解后参数可以被接收到了，但日期时间的格式还是需要自己再手动转换一下。\n因为 @DateTimeFormat 注解的 pattern 属性值指定的日期时间格式并不是将要转换成的日期格式，这个指定的格式是和传入的参数对应的，假如注解为：\n@DateTimeFormat(pattern=”yyyy/MM/dd HH:mm:ss”)\n则传入的参数应该是这样的：2018/08/02 22:05:55，否则会抛出异常\n3、出参格式化，在上述示例中，调用接口的返回结果为：”date”: “2018-08-01T14:25:31.296+0000”\n这个格式并不是我们想要的，那么如何将其进行格式化？这时就需要用到 jackson 的 @JsonFormat 注解。\n改造 DateVo：\npublic class DateVo &#123;\n  @DateTimeFormat(pattern&#x3D;&quot;yyyy-MM-dd HH:mm:ss&quot;)\n  @JsonFormat(\n    pattern &#x3D; &quot;yyyy-MM-dd HH:mm:ss&quot;\n  )\n  private Date date;\n  public void setDate(Date date)&#123;\n    this.date &#x3D; date;\n  &#125;\n  public Date getDate()&#123;\n    return date;\n  &#125;&#125;\n继续访问 /date/test ，并传入参数：2018-08-02 22:05:55，可以看到接口返回的结果为：”date”: “2018-08-01 14:32:57”\n虽然时间格式正确了，但实际上当前时间是 “2018-08-01 22:32:57” ，早了8个小时。因为，jackson在序列化时间时是按照国际标准时间GMT进行格式化的，而在国内默认时区使用的是CST时区，两者相差8小时。\n所以，@JsonFormat 注解还要再加一个属性：\n@JsonFormat(\n    pattern &#x3D; &quot;yyyy-MM-dd HH:mm:ss&quot;，\n    timezone &#x3D; &quot;GMT+8&quot;\n)\nprivate Date date;\n\n这样，结果就正确了。\n因为 @JsonFormat 注解不是 Spring 自带的注解，所以使用该注解前需要添加 jackson 相关的依赖包。当然，如果是 SpringBoot 项目就不需要自己手动添加依赖了，因为在 spring-boot-start-web 下已经包含了 jackson 相关依赖\n","slug":"52-SpringMVC-基础功能","date":"2021-09-13T15:29:32.000Z","categories_index":"SpringMVC","tags_index":"SpringMVC","author_index":"大黄"},{"id":"a69a9b95a293fad60680e3e8965ab8da","title":"Spring 声明式事务","content":"1、JdbcTemplate\nSpring提供了整合JDBC的JDBCTemplate，先有Spring，再出现MyBatis，所以整合包不是Spring提供的，而是第三方提供的。\nJDBCTemplate和MyBatis共同点：都是对JDBC进行了封装\n不同点：肯定是MyBatis封装的更彻底，提供了更多的功能\n1.1、常用方法\n\n\n方法\n作用\n注意\n\n\n\nupdate()\n返回的是一个int值，影响的行数。\n用于执行INSERT、UPDATE、DELETE等DML语句\n\n\nqueryForMap()\n将查询结果封装为map集合，列名作为key，值作为value\n查询单个对象，这个方法查询的结果集长度为  1\n\n\nqueryForList()\n查询多个对象，返回一个List对象，List对象存储是Map对象\n将每一条记录封装为一个map集合，再讲map集合封装到List集合中\n\n\nqueryForObject( sql , 聚合函数类型的Class对象)\n查询单个对象,将结果封装为对象，返回单个实体类对象\n一般用于聚合函数的查询\n\n\nquery( sql , RowMapper)\n查询多个对象，返回的是一个List对象，List对象存储是实体类（javaBean对象）\n一般我们使用的是BeanPropertyRowMapper实现类，可以完成数据到javabean的自动封装\n\n\nString sql &#x3D; &quot;select count(学号) from xs_kc&quot;;\nLong aLong &#x3D; template.queryForObject(sql, Long.class);\n\nList&lt;xskc&gt; list &#x3D; template.query(sql,new BeanPropertyRowMapper&lt;xskc&gt;(xskc.class));\n\n\n\n1.2、配置环境\n\n\n\n\n\n\n\n\n添加依赖\n&lt;!-- Spring 持久化层支持jar包 --&gt;\n&lt;!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个jar包 --&gt;\n&lt;!-- 导入 orm 包就可以通过 Maven 的依赖传递性把其他两个也导入 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-orm&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.3.3&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;!-- MySQL驱动 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.1.3&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;!-- 数据库连接池 alibaba 的 druid  --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.0.31&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\n\n\n\n\n\n\n\nSpring配置\n&lt;!-- 导入外部属性文件 jdbc配置文件中，各项值必须有前缀--&gt;\n&lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot;&#x2F;&gt;\n&lt;bean id&#x3D;&quot;druidDataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;\n    &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.driverClassName&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n&lt;bean id&#x3D;&quot;jdbcTemplate&quot; class&#x3D;&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;\n    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;druidDataSource&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n\n\n1.3、使用方法\n\n\n\n\n\n\n\n\nexecute\npublic void testExecute() &#123;\n    jdbcTemplate.execute(&quot;create table user1(id int, name varchar(20))&quot;);\n&#125;\n\n\n\n\n\n\n\n\n\n\nupdate\n&#x2F;&#x2F; update 方法\npublic void testUpdate() &#123;\n    String sql &#x3D; &quot;insert into student(name, sex) values(?,?)&quot;;\n    jdbcTemplate.update(sql, new Object[]&#123;&quot;张飞&quot;, &quot;男&quot;&#125;);  &#x2F;&#x2F; 将值放到数组中\n&#125;\n\n&#x2F;&#x2F; update 方法（常用）\npublic void testUpdate2() &#123;\n    String sql &#x3D; &quot;update student set sex&#x3D;? where id&#x3D;?&quot;;\n    jdbcTemplate.update(sql, &quot;女&quot;, 1);   &#x2F;&#x2F; 直接写参数，不用放在数组中\n&#125;\n\n\n\n\n\n\n\n\n\n\n查询简单数据项 —-&gt;   非对象类型，比如 聚合查询，查询单行数据的某列字段\n获取一个\nT queryForObject(String sql, Class&lt;T&gt; type)\nT queryForObject(String sql, Object[] args, Class&lt;T&gt; type)\nT queryForObject(String sql, Class&lt;T&gt; type, Object... args)\n\n获取多个\nList&lt;T&gt; queryForList(String sql, Class&lt;T&gt; type)\nList&lt;T&gt; queryForList(String sql, Object[] args, Class&lt;T&gt; type)\nList&lt;T&gt; queryForList(String sql, Class&lt;T&gt; type, Object... args)\n\n举例说明\n&#x2F;&#x2F; 查询简单数据项（获取一个）\npublic void testQuerySimple() &#123;\n    String sql &#x3D; &quot;select count(*) from student&quot;;\n    int count &#x3D; jdbcTemplate.queryForObject(sql, Integer.class);\n    System.out.println(count);\n&#125;\n\n&#x2F;&#x2F; 查询简单数据项（获取多个）\npublic void testQuerySimple2() &#123;\n    String sql &#x3D; &quot;select name from student where sex&#x3D;?&quot;;\n    List&lt;String&gt; names &#x3D; jdbcTemplate.queryForList(sql, String.class, &quot;男&quot;);\n    System.out.println(names);\n\n&#125;\n\n\n\n\n\n\n\n\n\n\n查询复杂对象（封装为Map）——&gt;  查询一条数据，或多条数据\n获取一个\nMap queryForMap(String sql)\nMap queryForMap(String sql, Object[] args)\nMap queryForMap(String sql, Object... args)\n\n获取多个\nList&lt;Map&lt;String, Object&gt;&gt; queryForList(String sql)\nList&lt;Map&lt;String, Object&gt;&gt; queryForList(String sql, Object[] args)\nList&lt;Map&lt;String, Object&gt;&gt; queryForList(String sql, Object... args)\n\n举例说明\n&#x2F;&#x2F; 查询复杂对象（封装为Map，查询一个）\n public void testQueryMap1() &#123;\n     String sql &#x3D; &quot;select * from student where id &#x3D; ?&quot;;\n     Map&lt;String, Object&gt; stu &#x3D; jdbcTemplate.queryForMap(sql, 1);\n     System.out.println(stu);\n &#125;\n\n &#x2F;&#x2F; 查询复杂对象（封装为Map， 查询多个）\n public void testQueryMap2() &#123;\n     String sql &#x3D; &quot;select * from student&quot;;\n     List&lt;Map&lt;String, Object&gt;&gt; stus &#x3D; jdbcTemplate.queryForList(sql);\n     System.out.println(stus);\n &#125;\n\n\n\n\n\n\n\n\n\n\n查询复杂对象（封装为实体对象）——-&gt; 使用RowMapper接口\n获取一个\nT queryForObject(String sql, RowMapper&lt;T&gt; mapper)\nT queryForObject(String sql, Object[] args, RowMapper&lt;T&gt; mapper)\nT queryForObject(String sql, RowMapper&lt;T&gt; mapper, Object... arg)\n\n获取多个\nList&lt;T&gt; query(String sql, RowMapper&lt;T&gt; mapper)\nList&lt;T&gt; query(String sql, Object[] args, RowMapper&lt;T&gt; mapper)\nList&lt;T&gt; query(String sql, RowMapper&lt;T&gt; mapper, Object... arg)\n\n举例说明\n&#x2F;&#x2F;查询复杂对象（封装为实体对象，获取一个）\n&#x2F;&#x2F;映射写法\npublic void testQueryEntity1() &#123;\n    final String sql &#x3D; &quot;select * from student where id&#x3D;?&quot;;\n    &#x2F;&#x2F; 匿名内部类\n    Student stu &#x3D; jdbcTemplate.queryForObject(sql, new RowMapper&lt;Student&gt;() &#123;\n        public Student mapRow(ResultSet resultSet, int i) throws SQLException &#123;\n            Student stu &#x3D; new Student();\n            stu.setId(resultSet.getInt(&quot;id&quot;));\n            stu.setName(resultSet.getString(&quot;name&quot;));\n            stu.setSex(resultSet.getString(&quot;sex&quot;));\n            stu.setBorn(resultSet.getDate(&quot;born&quot;));\n            return stu;\n        &#125;\n    &#125;, 3);\n    System.out.println(stu);\n&#125;\n\n&#x2F;&#x2F; 查询复杂对象（封装为实体对象，查询多个）\npublic void testQueryEntity2() &#123;\n    String sql &#x3D; &quot;select * from student&quot;;\n    List&lt;Student&gt; stus &#x3D; jdbcTemplate.query(sql, new StudentRowMapper());\n    System.out.println(stus);\n&#125;\n\n&#x2F;&#x2F; 构造封装对象类\nprivate class StudentRowMapper implements RowMapper&lt;Student&gt; &#123;\n    public Student mapRow(ResultSet resultSet, int i) throws SQLException &#123;\n        Student stu &#x3D; new Student();\n        stu.setId(resultSet.getInt(&quot;id&quot;));\n        stu.setName(resultSet.getString(&quot;name&quot;));\n        stu.setSex(resultSet.getString(&quot;sex&quot;));\n        stu.setBorn(resultSet.getDate(&quot;born&quot;));\n        return stu;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n一般我们使用的是BeanPropertyRowMapper实现类，可以完成数据到javabean的自动封装\n创建  实体类，直接进行封装\nList&lt;xskc&gt; list &#x3D; template.query(sql,new BeanPropertyRowMapper&lt;xskc&gt;(xskc.class));\n\n\n\n1.4、优缺总结JDBC Template 优点：简单 灵活\nJDBC Template 缺点：SQL 与 Java 代码参杂  功能不丰富\n总结：JDBC Template是 Spring 框架对 JDBC 操作的封装。简单、灵活但不够强大。实际应用中还需要和其他 ORM 框架混合使用。\n2、声明式事务\n2.1、声明式，编程式事务编程式事务：事务功能的相关操作全部通过自己编写代码来实现，自己写代码实现功能\n编程式的实现方式存在缺陷：\n\n细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。\n代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。\n\n声明式事务：既然事务控制的代码有规律可循，代码的结构基本是确定的，所以框架就可以将固定模式的代码抽取出来，进行相关的封装。进而，我们可以通过配置让框架实现功能\n封装起来后，我们只需要在配置文件中进行简单的配置即可完成操作。\n\n好处1：提高开发效率\n好处2：消除了冗余的代码\n好处3：框架会综合考虑相关领域中在实际开发环境下有可能遇到的各种问题，进行了健壮性、性能等各个方面的优化\n\n2.2 事务管理器我们现在（使用JDBCTemplate访问数据库）要使用的事务管理器是 DataSourceTransactionManager，整合 Mybatis 用的也是。\norg.springframework.jdbc.datasource.DataSourceTransactionManager，\nDataSourceTransactionManager类中的主要方法：\n\n\n\n方法\n功能\n\n\n\ndoBegin()\n开启事务\n\n\ndoSuspend()\n挂起事务\n\n\ndoResume()\n恢复挂起的事务\n\n\ndoCommit()\n提交事务\n\n\ndoRollback()\n回滚事务\n\n\n\nspring5.2 以后PlatformTransactionManager继承自TransactionManager，TransactionManager接口中什么都没有，但是它还是有存在的意义——定义一个技术体系。\n\n3、使用事务\n3.1、准备工作\n\n\n\n\n\n\n\n\n在JdbcTemplate项目的基础上，添加依赖，orm为必须包\n&lt;!-- Spring 持久化层支持jar包 --&gt;\n&lt;!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个jar包 --&gt;\n&lt;!-- 导入 orm 包就可以通过 Maven 的依赖传递性把其他两个也导入 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-orm&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.3.3&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\n\n\n\n\n\n\n\nspring配置\n&lt;!-- 配置事务管理器 --&gt;\n&lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;\n   \n    &lt;!-- 事务管理器的bean只需要装配数据源，其他属性保持默认值即可 --&gt;\n    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;druidDataSource&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n&lt;!-- 开启基于注解的声明式事务功能 --&gt;\n&lt;!-- 使用transaction-manager属性指定当前使用是事务管理器的bean --&gt;\n&lt;!-- transaction-manager属性的默认值是transactionManager，如果事务管理器bean的id正好就是这个默认值，则可以省略这个属性 --&gt;\n&lt;tx:annotation-driven transaction-manager&#x3D;&quot;transactionManager&quot;&#x2F;&gt;\n\n\n\n\n\n\n\n\n\n\nDao层\npublic interface UserDao &#123;\n\n    &#x2F;**\n     * 通过id 更新员工名称\n     * @param empId\n     * @param empName\n     *&#x2F;\n    public void updateEmpNameById(Integer empId, String empName);\n\n    &#x2F;**\n     * 通过id修改员工薪水\n     * @param empId\n     * @param salary\n     *&#x2F;\n    public void updateEmpSalaryById(Integer empId, Double salary);\n\n    &#x2F;**\n     * 通过id查找员工姓名\n     * @param empId\n     * @return\n     *&#x2F;\n    public String selectEmpNameById(Integer empId);\n&#125;\n\n@Repository\npublic class UserDaoImpl implements UserDao &#123;\n\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    &#x2F;**\n     * 通过id修改姓名\n     * @param empId\n     * @param empName\n     *&#x2F;\n    @Override\n    public void updateEmpNameById(Integer empId, String empName) &#123;\n        String  sql &#x3D; &quot;update emp set ename&#x3D;? where empno&#x3D;?&quot;;\n        jdbcTemplate.update(sql,empName,empId);\n    &#125;\n\n    @Override\n    public void updateEmpSalaryById(Integer empId, Double salary)&#123;\n\n        try &#123;\n            TimeUnit.SECONDS.sleep(8);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        String  sql &#x3D; &quot;update emp set sal&#x3D;? where empno&#x3D;?&quot;;\n        jdbcTemplate.update(sql,salary,empId);\n    &#125;\n\n    @Override\n    public String selectEmpNameById(Integer empId) &#123;\n        String sql &#x3D; &quot;select ename from emp where empno&#x3D;?&quot;;\n        String s &#x3D; jdbcTemplate.queryForObject(sql, String.class, empId);\n        return s;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\nservice层\npublic interface UserService &#123;\n\n    &#x2F;**\n     * 通过id 更新员工名称\n     *\n     * @param empId\n     * @param empName\n     *&#x2F;\n    public void updateEmpNameById(Integer empId, String empName);\n\n    &#x2F;**\n     * 通过id修改员工薪水\n     *\n     * @param empId\n     * @param salary\n     *&#x2F;\n    public void updateEmpSalaryById(Integer empId, Double salary);\n\n    &#x2F;**\n     * 通过id查找员工姓名\n     *\n     * @param empId\n     * @return\n     *&#x2F;\n    public String selectEmpNameById(Integer empId);\n\n    &#x2F;**\n     * 为了测试事务是否生效，执行两个数据库操作，看它们是否会在某一个失败时一起回滚\n     * @param empId\n     * @param newName\n     * @param empIdSalary\n     * @param newSalary\n     *&#x2F;\n    public void updateTwice(&#x2F;&#x2F; 修改员工姓名的一组参数\n                            Integer empId, String newName,\n                            &#x2F;&#x2F; 修改员工工资的一组参数\n                            Integer empIdSalary, Double newSalary);\n&#125;\n\n@Service\npublic class UserServiceImpl implements UserService &#123;\n\n    &#x2F;**\n     * 数据库访问层接口\n     *&#x2F;\n    @Autowired\n    private UserDao userDao;\n\n    &#x2F;**\n     * 通过id改姓名\n     *\n     * @param empId\n     * @param empName\n     *&#x2F;\n    @Override\n    public void updateEmpNameById(Integer empId, String empName) &#123;\n        userDao.updateEmpNameById(empId, empName);\n    &#125;\n\n    &#x2F;**\n     * 通过id改薪水\n     *\n     * @param empId\n     * @param salary\n     *&#x2F;\n    @Override\n    @Transactional\n    public void updateEmpSalaryById(Integer empId, Double salary) &#123;\n        userDao.updateEmpSalaryById(empId, salary);\n    &#125;\n\n    &#x2F;**\n     * 通过id找姓名\n     *\n     * @param empId\n     * @return\n     *&#x2F;\n    @Override\n    @Transactional\n    public String selectEmpNameById(Integer empId) &#123;\n        return userDao.selectEmpNameById(empId);\n    &#125;\n\n    &#x2F;&#x2F; 为了便于核对数据库操作结果，不要修改同一条记录\n    @Override\n    @Transactional\n    public void updateTwice(\n            &#x2F;&#x2F; 修改员工姓名的一组参数\n            Integer empId, String newName,\n            &#x2F;&#x2F; 修改员工工资的一组参数\n            Integer empIdSalary, Double newSalary\n    ) &#123;\n        &#x2F;&#x2F; 为了测试事务是否生效，执行两个数据库操作，看它们是否会在某一个失败时一起回滚\n        userDao.updateEmpNameById(empId, newName);\n\n        userDao.updateEmpSalaryById(empIdSalary, newSalary);\n\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n测试功能\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(value &#x3D; &#123;&quot;classpath:applicationContext.xml&quot;&#125;)\npublic class test &#123;\n\n    @Autowired\n    @Qualifier(value &#x3D; &quot;userServiceImpl&quot;)\n    private UserService userService;\n\n    &#x2F;**\n     * 测试sql操作\n     *&#x2F;\n    @Test\n    public void testDemo1() &#123;\n        String s &#x3D; userService.selectEmpNameById(7369);\n        System.out.println(s);\n\n        userService.updateEmpNameById(7369, &quot;SMITH&quot;);\n\n        userService.updateEmpSalaryById(7369, 900.0);\n    &#125;\n\n    &#x2F;**\n     * 不修改同一条数据，并破坏第二条修改薪资的sql语句，查看是否同时失败\n     * 结果，第一条成功，第二条失败\n     *&#x2F;\n    @Test\n    public void testDemo2() &#123;\n        userService.updateTwice(7369, &quot;HH&quot;, 7499, 1700.0);\n    &#125;\n\n    &#x2F;&#x2F; 添加事务功能,并开启，且在updateTwice方法上添加使用事务的注解\n\n    &#x2F;**\n     * 再次调用updateTwice方法,看是否同时成功同时失败\n     *\n     * 效果：控制台报错，主要是因为第二项失败，而第一项名字修改也没有成功\n     *&#x2F;\n    @Test\n    public void testDemo3() &#123;\n        userService.updateTwice(7369, &quot;SMITH&quot;, 7499, 1700.0);\n    &#125;\n\n    &#x2F;**\n     * 将sql修改正确\n     *\n     * 效果： 同时成功\n     *&#x2F;\n    @Test\n    public void testDemo4() &#123;\n        userService.updateTwice(7369, &quot;SMITH&quot;, 7499, 1700.0);\n    &#125;\n\n    &#x2F;**\n     * 添加日子功能，在日志中查看事务\n     *&#x2F;\n    @Test\n    public void testDemo5()&#123;\n        String s &#x3D; userService.selectEmpNameById(7369);\n        System.out.println(s);\n    &#125;\n\n\n&#125;\n\n\n\n3.2、业务添加在哪一层\n3.3、基本的事务控制\n\n\n\n\n\n\n\n\n在需要的业务上添加 事务注解\n\n\n\n\n\n\n\n\n\n\n启用日志，方便 查看运行过程 ，清晰了解事务的开启 提交 回滚 关闭\n使用 logback日志框架，添加logback.xml文件\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;configuration debug&#x3D;&quot;true&quot;&gt;\n    &lt;!-- 指定日志输出的位置 --&gt;\n    &lt;appender name&#x3D;&quot;STDOUT&quot;\n              class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;\n        &lt;encoder&gt;\n            &lt;!-- 日志输出的格式 --&gt;\n            &lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt;\n            &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n&lt;&#x2F;pattern&gt;\n        &lt;&#x2F;encoder&gt;\n    &lt;&#x2F;appender&gt;\n\n    &lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt;\n    &lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;\n    &lt;root level&#x3D;&quot;INFO&quot;&gt;\n        &lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;\n        &lt;appender-ref ref&#x3D;&quot;STDOUT&quot; &#x2F;&gt;\n    &lt;&#x2F;root&gt;\n\n    &lt;!-- 根据特殊需求指定局部日志级别 --&gt;\n    &lt;logger name&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot; level&#x3D;&quot;DEBUG&quot;&#x2F;&gt;\n    &lt;logger name&#x3D;&quot;org.springframework.jdbc.core.JdbcTemplate&quot; level&#x3D;&quot;DEBUG&quot; &#x2F;&gt;\n\n&lt;&#x2F;configuration&gt;\n\n\n\n\n\n\n\n\n\n\n测试 —–&gt;   成功提交事务，失败回滚事务\n\n\n4、事务注解位置\n位置\n​     类上：该类的所有方法都启用事务\n​     方法上：只有该方法启用事务，和其他方法无关\n​     如果类上和某些方法上都有事务，以方法上的事务配置为准。（就近优先）\n测试代码\n&#x2F;**\n * 如果类中的每一个方法都需要添加事务，那么可以提取到类上\n *[com.atguigu.service.impl.UserServiceImpl3.selectEmpNameById]:\n * PROPAGATION_REQUIRED,ISOLATION_DEFAULT,readOnly]\n *&#x2F;\n@Test\npublic void testDemo1() &#123;\n    String s &#x3D; userService.selectEmpNameById(7369);\n    System.out.println(s);\n&#125;\n\n&#x2F;**\n * 对一个方法来说，离它最近的@Transactional注解中的事务属性设置生效。\n *\n *在selectEmpName上添加就近的事务管理注解，并设置readOnly&#x3D;false\n * [com.atguigu.service.impl.UserServiceImpl3.selectEmpNameById]:\n * PROPAGATION_REQUIRED,ISOLATION_DEFAULT]\n *\n * PS：Spring 环境下很多场合都有类似设定，一个注解如果标记了类的每一个方法那么通常就可以提取到类级别。\n *&#x2F;\n@Test\npublic void testDemo2() &#123;\n    String s &#x3D; userService.selectEmpNameById(7369);\n    System.out.println(s);\n&#125;\n\n\n5、事务中的五大属性\nPropagation 传播特性      Isolation 隔离级别        timeout 超时时间         readonly 只读事务         （异常回滚类型）\n5.1、只读对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化。\n针对增删改操作设置只读，就会抛出异常：\nCaused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed\n\n\n\n\n\n\n\n\n\n\n问题：查询不使用事务， 还是使用只读事务？？应用场合：\n如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持SQL执行期间的读一致性；\n如果你一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询SQL必须保证整体的读一致性，否则，在前条SQL查询之后，后条SQL查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持。\n\n\n\n\n\n\n\n\n\n使用事务注解 @Transaction中的属性 readOnly 开启或关闭只读属性\n@Override\n@Transactional(readOnly &#x3D; true)\npublic void updateEmpNameById(Integer empId, String empName) &#123;\n    userDao.updateEmpNameById(empId, empName);\n&#125;\n\n\n\n\n\n\n\n\n\n\n测试只读\n&#x2F;**\n * 测试只读\n * [Creating new transaction with name [com.atguigu.service.impl.UserServiceImpl2.selectEmpNameById]:\n * PROPAGATION_REQUIRED,ISOLATION_DEFAULT,readOnly]，我们发现会多一个readOnly\n *&#x2F;\n@Test\npublic void testDemo1() &#123;\n    String s &#x3D; userService.selectEmpNameById(7369);\n    System.out.println(s);\n&#125;\n\n&#x2F;**    \n * 设置 修改操作为只读\n *\n * 【结果，控制台】\n * org.springframework.dao.TransientDataAccessResourceException: PreparedStatementCallback;\n * SQL [update emp set ename&#x3D;? where empno&#x3D;?];\n * Connection is read-only. Queries leading to data modification are not allowed;\n * nested exception is java.sql.SQLException: Connection is read-only.\n * Queries leading to data modification are not allowed\n *&#x2F;\n@Test\npublic void testDemo2()&#123;\n    userService.updateEmpNameById(7369,&quot;HH&quot;);\n&#125;\n\n\n\n5.2、超时事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。\n此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。\n概括来说就是一句话：超时回滚，释放资源。\n\n\n\n\n\n\n\n\n\n\n测试代码\n&#x2F;**\n * 事务属性：超时\n *\n * 超时的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。\n *\n *  | @Transactional(readOnly &#x3D; true,timeout &#x3D; 5)\n *  在UserDaoImpl中执行sql语言前设置 睡眠时间 8秒\n *  TimeUnit.SECONDS.sleep(8);\n *\n *  效果：修改没成功\n *  org.springframework.transaction.TransactionTimedOutException:\n *  Transaction timed out: deadline was Wed Jul 14 16:36:30 CST 2021\n *&#x2F;\n@Test\npublic void testDemo1() &#123;\n    userService.updateTwice(7369,&quot;SMITH&quot;,7499,1600.0);\n&#125;\n\n注意\n如果一个事务中，启用了两个操作，后一个超时，第一个操作也会回滚\n如果超时，出现如下错误：\norg.springframework.transaction.TransactionTimedOutException: Transaction timed out: deadline was Fri Jun 04 16:25:39 CST 2021\n\n\n\n\n\n\n\n\n\n\n超时的操作只能加在这个位置，加在执行sql语句后将不起作用\n\n5.3、回滚和不回滚异常\n\n\n\n\n\n\n\n\n默认只针对运行时异常回滚，编译时异常不回滚。情景模拟代码如下：\npublic void updateEmpSalaryById(Integer empId, Double salary) throws FileNotFoundException &#123;\n    String sql &#x3D; &quot;update t_emp set emp_salary&#x3D;? where emp_id&#x3D;?&quot;;\n    jdbcTemplate.update(sql, salary, empId);\n\n    &#x2F;&#x2F;  抛出编译时异常测试是否回滚（编译期间，查找文件所处位置）\n        new FileInputStream(&quot;aaaa.aaa&quot;);\n\n    &#x2F;&#x2F;  抛出运行时异常测试是否回滚\n    &#x2F;&#x2F;  System.out.println(10 &#x2F; 0);\n&#125;\n\nrollbackFor属性：需要设置一个Class类型的对象  （ @Transactional(rollbackFor = Exception.class)  ）\nrollbackForClassName属性：需要设置一个字符串类型的全类名\nnoRollbackFor属性：在默认设置和已有设置的基础上，再指定一个异常类型，碰到它不回滚。\n@Transactional(noRollbackFor = FileNotFoundException.class)\n\n\n\n\n\n\n\n\n\n测试代码\n&#x2F;**\n * 事务属性：编译时异常不回滚\n *\n * 添加编译时异常，在serviceImpl实现类中的第一条语句和第二条语句中间加入new FileInputStream(&quot;aaaa.aaa&quot;);\n * 编译时，会找不到文件\n *\n * 效果：第一条成功，第二条失败，所以，虽然添加了事务，但是，编译时并不会回滚\n *&#x2F;\n@Test\npublic void testDemo2() throws FileNotFoundException &#123;\n    userService.updateTwice(7369,&quot;SMITH&quot;,7499,1800.0);\n&#125;\n\n&#x2F;**\n * 设置回滚异常\n *\n * Transactional设置回滚异常的属性\n * rollbackFor属性：需要设置一个Class类型的对象\n * rollbackForClassName属性：需要设置一个字符串类型的全类名\n * 设置异常不回滚的属性\n * noRollbackFor &#x3D; FileNotFoundException.class\n *\n * |设置 @Transactional(rollbackFor &#x3D; FileNotFoundException.class)\n *\n * 效果：进行行了回滚，都没成功\n * [17:08:47.897] [DEBUG] [main] [org.springframework.jdbc.datasource.DataSourceTransactionManager] [Initiating transaction rollback]\n * [17:08:47.897] [DEBUG] [main] [org.springframework.jdbc.datasource.DataSourceTransactionManager] [Rolling back JDBC transaction on Connection\n *&#x2F;\n@Test\npublic void testDemo3() throws FileNotFoundException &#123;\n    userService.updateTwice(7369,&quot;HH&quot;,7499,1700.0);\n&#125;\n\n\n\n\n\n\n\n\n\n\n所有的异常都回滚\n方法1：设置rollbackFor=Exception.class\n方法2：异常链。底层出现了检查异常，进行处理，并向上层抛出一个新的异常（一般是运行异常）。既可以传递异常到上层，还可以避免方法签名中使用throws。在Spring事务中还可以实现所有异常都回滚的效果\n@Transactional(timeout &#x3D; 5,rollbackFor &#x3D; Exception.class)\n\npublic void updateEmpSalaryById(Integer empId, Double salary) &#123;   \n\tString sql &#x3D; &quot;update t_emp set emp_salary&#x3D;? where emp_id&#x3D;?&quot;;   \n\tjdbcTemplate.update(sql, salary, empId);   \n    \n    &#x2F;&#x2F;int n &#x3D; 10&#x2F;0;   \n    &#x2F;&#x2F;new FileInputStream(&quot;asdfadf&quot;);   \n    try&#123;\n        FileInputStream(&quot;asdfadf&quot;);    \n    &#125; catch (FileNotFoundException e) &#123;     \n        e.printStackTrace();     \n        throw new RuntimeException(e.getMessage()); \n    &#125;\n&#125;\n\n\n\n5.4、隔离级别脏读 :一个事务读到了另一个事务的未提交的数据\n不可重复读 :一个事务读到了另一个事务已经提交的 update 的数据导致多次查询结果不一致.\n幻读 :一个事务读到了另一个事务已经提交的 insert或者delete 的数据导致多次查询结果不一致.\n\n\n\n隔离级别\n描述\n\n\n\nread-uncommitted\n允许A事务读取其他事务未提交和已提交的数据。会出现脏读、不可重复读、幻读问题\n\n\nread-committed\n只允许A事务读取其他事务已提交的数据。可以避免脏读，但仍然会出现不可重复读、幻读问题\n\n\nrepeatable-read\n确保事务可以多次从一个字段中读取相同的值。在这个事务持续期间，禁止其他事务对这个字段进行更新。可以避免脏读和不可重复读。但是幻读问题仍然存在。注意：mysql中使用了MVCC多版本控制技术，在这个级别也可以避免幻读。\n\n\nserializable\n确保事务可以从一个表中读取相同的行，相同的记录。在这个事务持续期间，禁止其他事务对该表执行插入、更新、删除操作。所有并发问题都可以避免，但性能十分低下。\n\n\n\n\n\n\n\n\n\n\n\nSpring的隔离级别\npublic enum Isolation &#123;\n    DEFAULT(-1),\n    READ_UNCOMMITTED(1),\n    READ_COMMITTED(2),\n    REPEATABLE_READ(4),\n    SERIALIZABLE(8);\n\n    private final int value;\n    private Isolation(int value) &#123;\n        this.value &#x3D; value;\n    &#125;\n    public int value() &#123;\n        return this.value;\n    &#125;\n&#125;\n\n如果选择DEFAULT，默认值，由底层数据库自动判断应该使用什么隔离级别。\n对于互联网高并发项目来说，如果采用隔离级别SERIALIZABLE，固然安全，担心性能会受到严重影响。此时一般将隔离级别降低，保证效率，再配合悲观锁、乐观锁等技术来保证安全性。\n事务的隔离级别要得到底层数据库引擎的支持, 而不是应用程序或者框架的支持。Oracle 支持的 2 种事务隔离级别：READ_COMMITED（默认） , SERIALIZABLE。MySQL 支持 4种事务隔离级别，默认REPEATABLE READ。\n\n\n\n\n\n\n\n\n\n使用注解 @Transaction 中的属性 isolation 设置隔离级别\n@Override\n@Transactional(readOnly &#x3D; false,isolation &#x3D; Isolation.REPEATABLE_READ)\npublic void updateEmpNameById(Integer empId, String empName) &#123;\n    userDao.updateEmpNameById(empId, empName);\n&#125;\n\n测试代码\n&#x2F;**\n * 设置两个方法的隔离级别是：isolation &#x3D; Isolation.READ_UNCOMMITTED\n * 在 UserDaoImpl 的jdbcTemplate执行完sql语句后，自定义一个错误，打断点，我们运行此测试方法，跳到断点\n * 我们在开启查询方法，直接运行完成，发现得到的输出结果是  HH，此时的数据还未提交，继续运行，报错后会进行rollback\n *\n * 设置隔离级别是：isolation &#x3D; Isolation.READ_COMMITTED\n * 同时开启1,2两个事务\n * 1.查询名字 2.修改 （数据没有提交，就查不到，只能读到数据库中的） 1.再次查询（与第一次是同一次事务）\n * 我们发现我们只能读到已经提交的\n * 但是同时我们会发现，第一次查和第二次查的不一样\n *\n * 设置隔离级别是：isolation &#x3D; Isolation.REPEATABLE_READ\n * 在这个事务持续期间，禁止其他事务对这个字段进行更新。可以避免脏读和不可重复读\n * 开启了两个事务，1进行添加id为7的员工后，在第2事务也进行添加id为7的操作，却发现无用，这就是幻读\n *&#x2F;\n@Test\npublic void updateNameTest()&#123;\n    userService.updateEmpNameById(7369,&quot;GG&quot;);\n&#125;\n\n@Test\npublic void getNameTest()&#123;\n    String s &#x3D; userService.selectEmpNameById(7369);\n    System.out.println(s);\n&#125;\n\n\n\n5.5、传播特性在大多数情况下，我们会认为事务操作要么都成功，要么回到初始状态。比如下订单，如果主订单添加成功，三个订单明细添加成功两个，总额就对不上了，顾客最终收货会有减少的。这种情况肯定要保证全部成功。类似还有银行转账例子。但也存在不同的需求，\n一般是业务层直接调用DAO层，不存在业务层平行调用的问题。哪怎么会有被调用的方法还是否开启事务的问题呢？比如：\n①Service方法应用了通知\n②过滤器或拦截器等类似组件\n@Transactional 注解通过 propagation 属性设置事务的传播行为。它的默认值是：\nPropagation propagation() default Propagation.REQUIRED;\n\npropagation 属性的可选值由 org.springframework.transaction.annotation.Propagation 枚举类提供\n\n\n\n名称\n含义\n\n\n\nREQUIRED\n如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是默认值。\n\n\nREQUIRES_NEW\n新建事务，如果当前存在事务，把当前事务挂起。\n\n\nSUPPORTS\n支持当前事务，如果当前没有事务，就以非事务方式执行。\n\n\nMANDATORY\n使用当前的事务，如果当前没有事务，就抛出异常。\n\n\nNOT_SUPPORTED\n以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\n\n\nNEVER\n以非事务方式执行，如果当前存在事务，则抛出异常。\n\n\nNESTED\n如当前存在事务，则在嵌套事务内执行。如当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作\n\n\n测试 REQUIRED  REQUIRES_NEW模式\n\n    \n    \n    \n\n\n测试代码\n@Override\n@Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)\npublic void updateEmpNameById(Integer empId, String empName) &#123;\n    userDao.updateEmpNameById(empId, empName);\n&#125;\n\n&#x2F;**\n * 通过id改薪水\n *\n * @param empId\n * @param salary\n *&#x2F;\n@Override\n@Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)\npublic void updateEmpSalaryById(Integer empId, Double salary) &#123;\n    System.out.println(10 &#x2F; 0);\n    userDao.updateEmpSalaryById(empId, salary);\n&#125;\n\n&#x2F;&#x2F; 为了便于核对数据库操作结果，不要修改同一条记录\n@Override\n@Transactional\npublic void updateTwice(\n    &#x2F;&#x2F; 修改员工姓名的一组参数\n    Integer empId, String newName,\n    &#x2F;&#x2F; 修改员工工资的一组参数\n    Integer empIdSalary, Double newSalary\n) &#123;\n    &#x2F;&#x2F; 为了测试事务是否生效，执行两个数据库操作，看它们是否会在某一个失败时一起回滚\n    userDao.updateEmpNameById(empId, newName);\n\n    userDao.updateEmpSalaryById(empIdSalary, newSalary);\n\n&#125;\n\n&#x2F;**\n * 测试事务的传播性\n *\n * 一个方法调用了两个方法，使第二个方法内部抛出异常，想让第一条执行成功，第二条失败\n *\n * propagation 属性的可选值为 REQUIRED\n * 发现两条语句都没执行成功 \n *\n * propagation 属性的可选值为 REQUIRES_NEW\n * 第一条成功，第二条失败\n *&#x2F;\n@Test\npublic void updateNameTest()&#123;\n    topicService.runTwice();\n&#125;\n\n我们在事务传播行为这里，使用 REQUIRES_NEW 属性，也可以说是让不同事务方法从事务的使用上解耦合，不要互相影响。\n过滤器或拦截器等类似组件\n\n6、Spring5 新特性\n6.1、JSP305标准相关注解CP：JCP（Java Community Process) 是一个由SUN公司发起的，开放的国际组织。主要由Java开发者以及被授权者组成，负责Java技术规范维护，Java技术发展和更新。\nJSR ：Java Specification Request，意思是 Java 规范提案。谁向谁提案呢？任何人都可以向 JCP (Java Community Process) 提出新增一个标准化技术规范的正式请求。\nJSR 305: 使用注解（例如@NonNull等等）协助开发者侦测软件缺陷\nSpring5中对JSR305提案给出了实现\n\n\n\n注解名称\n含义\n可标记位置\n\n\n\n@Nullable\n可以为空\n@Target({ElementType.METHOD,  ElementType.PARAMETER,  ElementType.FIELD})\n\n\n@NonNull\n不应为空\n@Target({ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD})\n\n\n@NonNullFields\n在特定包下的字段不应为空\n@Target(ElementType.PACKAGE)   @TypeQualifierDefault(ElementType.FIELD)\n\n\n@NonNullApi\n参数和方法返回值不应为空\n@Target(ElementType.PACKAGE)   @TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER})\n\n\n 以上注解是Spring5提供的，不是JDK提供的。\n6.2、整合Junit5注意：Junit5的@Test和Junit4的@Test不是一个包下，要使用Junit5的@Test\nJunit4：org.junit.Test\nJunit5：org.junit.jupiter.api.Test;\n@RunWith(SpringJUnit4ClassRunner.class)\n&#x2F;*@ExtendWith(SpringExtension.class)\n@ContextConfiguration(value &#x3D; &quot;classpath:applicationContext.xml&quot;)*&#x2F;\n\n@SpringJUnitConfig(locations&#x3D;&quot;classpath:applicationContext.xml&quot;)\npublic class testJunit5 &#123;\n\n    @Autowired\n    private DataSource dataSource;\n\n    @Test\n    public void test1() throws SQLException &#123;\n\n        Connection connection &#x3D; dataSource.getConnection();\n        System.out.println(connection);\n\n    &#125;\n\n&#125;\n\n\n\n7、事务使用xml配置\n相比于基于注解的声明式事务，基于 XML 的声明式事务需要一个额外的依赖：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-aspects&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.3.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n将上一个基于注解的 module 中的代码转移到新module。去掉 @Transactional 注解。\n去掉 tx:annotation-driven 标签，然后加入下面的配置：\n\n&lt;aop:config&gt;\n    &lt;!-- 配置切入点表达式，将事务功能定位到具体方法上 --&gt;\n    &lt;aop:pointcut id&#x3D;&quot;txPoincut&quot; expression&#x3D;&quot;execution(* *..*Service.*(..))&quot;&#x2F;&gt;\n    \n    &lt;!-- 将事务通知和切入点表达式关联起来 --&gt;\n    &lt;aop:advisor advice-ref&#x3D;&quot;txAdvice&quot; pointcut-ref&#x3D;&quot;txPoincut&quot;&#x2F;&gt;\n    \n&lt;&#x2F;aop:config&gt;\n    \n&lt;!-- tx:advice标签：配置事务通知 --&gt;\n&lt;!-- id属性：给事务通知标签设置唯一标识，便于引用 --&gt;\n&lt;!-- transaction-manager属性：关联事务管理器 --&gt;\n&lt;tx:advice id&#x3D;&quot;txAdvice&quot; transaction-manager&#x3D;&quot;transactionManager&quot;&gt;\n    &lt;tx:attributes&gt;\n    \n        &lt;!-- tx:method标签：配置具体的事务方法 --&gt;\n        &lt;!-- name属性：指定方法名，可以使用星号代表多个字符 --&gt;\n        &lt;tx:method name&#x3D;&quot;get*&quot; read-only&#x3D;&quot;true&quot;&#x2F;&gt;\n        &lt;tx:method name&#x3D;&quot;query*&quot; read-only&#x3D;&quot;true&quot;&#x2F;&gt;\n        &lt;tx:method name&#x3D;&quot;find*&quot; read-only&#x3D;&quot;true&quot;&#x2F;&gt;\n    \n        &lt;!-- read-only属性：设置只读属性 --&gt;\n        &lt;!-- rollback-for属性：设置回滚的异常 --&gt;\n        &lt;!-- no-rollback-for属性：设置不回滚的异常 --&gt;\n        &lt;!-- isolation属性：设置事务的隔离级别 --&gt;\n        &lt;!-- timeout属性：设置事务的超时属性 --&gt;\n        &lt;!-- propagation属性：设置事务的传播行为 --&gt;\n        &lt;tx:method name&#x3D;&quot;save*&quot; read-only&#x3D;&quot;false&quot; rollback-for&#x3D;&quot;java.lang.Exception&quot; propagation&#x3D;&quot;REQUIRES_NEW&quot;&#x2F;&gt;\n        &lt;tx:method name&#x3D;&quot;update*&quot; read-only&#x3D;&quot;false&quot; rollback-for&#x3D;&quot;java.lang.Exception&quot; propagation&#x3D;&quot;REQUIRES_NEW&quot;&#x2F;&gt;\n        &lt;tx:method name&#x3D;&quot;delete*&quot; read-only&#x3D;&quot;false&quot; rollback-for&#x3D;&quot;java.lang.Exception&quot; propagation&#x3D;&quot;REQUIRES_NEW&quot;&#x2F;&gt;\n    &lt;&#x2F;tx:attributes&gt;\n&lt;&#x2F;tx:advice&gt;\n\n其余自行百度\n","slug":"51-Spirng-声明式事务","date":"2021-09-13T15:28:32.000Z","categories_index":"Spring","tags_index":"Spring","author_index":"大黄"},{"id":"e2df2a86487823e0935863049b9742d3","title":"Spring 面向切面编程","content":"1. AOP是什么\n\n\n\n\n\n\n\n\nAOP是Aspect Oriented Programming的缩写，意思是：面向切面编程，它是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。\n可以认为AOP是对OOP(Object Oriented Programming 面向对象编程)的补充，主要使用在日志记录，性能统计，安全控制等场景，使用AOP可以使得业务逻辑各部分之间的耦合度降低，只专注于各自的业务逻辑实现，从而提高程序的可读性及维护性。\n比如，我们需要记录项目中所有对外接口的入参和出参，以便出现问题时定位原因，在每一个对外接口的代码中添加代码记录入参和出参当然也可以达到目的，但是这种硬编码的方式非常不友好，也不够灵活，而且记录日志本身和接口要实现的核心功能没有任何关系。\n此时，我们可以将记录日志的功能定义到1个切面中，然后通过声明的方式定义要在何时何地使用这个切面，而不用修改任何1个外部接口。\n在讲解具体的实现方式之前，我们先了解几个AOP中的术语。\n\n2. AOP核心概念2.1 通知 (Advice)\n\n\n\n\n\n\n\n\n在AOP术语中，切面要完成的工作被称为通知，通知定义了切面是什么以及何时使用。\nSpring切面有5种类型的通知，分别是：\n\n前置通知(Before)：在目标方法被调用之前调用通知功能\n后置通知(After)：在目标方法完成调用的最后（finally）通知，此时不关心方法的输出结果是什么\n返回通知(After-returning)：在目标方法成功执行之后调用通知\n异常通知(After-throwing)：在目标方法抛出异常后调用通知\n环绕通知(Around)：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为\n\n\n2.2 连接 (Join point)连接点是在应用执行过程中能够插入切面的一个点，这个点可以是调用方法时、抛出异常时、修改某个字段时。\n\n\n\n\n\n\n\n\n\n插入通知的位置，Spring中的连接点肯定是一个方法。比如给Calculator的add()方法添加日志功能。add()就是一个连接点\n2.3 切点 (Pointcut)切点是为了缩小切面所通知的连接点的范围，即切面在何处执行。我们通常使用明确的类和方法名称，或者利用正则表达式定义所匹配的类和方法名称来指定切点。\n\n\n\n\n\n\n\n\n\n其实是一个表达式，指出了所有满足条件的连接点的完整路径。类似过滤器的过滤路径。execution(* com.spring.service.impl..(..))\n2.4 切面 (Aspect)切面是通知和切点的结合。通知和切点共同定义了切面的全部内容：它是什么，在何时和何处完成其功能。\n\n2.5 引入 (Introduction)引入允许我们在不修改现有类的基础上，向现有类添加新方法或属性。\n2.6 织入 (Weaving)织入是把切面应用到目标对象并创建新的代理对象的过程。\n切面在指定的连接点被织入到目标对象中，在目标对象的生命周期里，有以下几个点可以进行织入：\n\n编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。\n类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器(ClassLoader)，它可以在目标类被引入应用之前增强该目标类的字节码。\n运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。\n\n2.7 目标 代理target: 被代理的对象\nproxy: 添加了通知以后的目标\n\n3. 代理选择\n\n\n\n\n\n\n\n\nSpring 实现AOP 思想使用的是动态代理技术\n\n默认情况下\n如果 被代理类 实现接口 ⇒ 选择 JDK 动态代理\n否则 ⇒ 选择 CGLIB 动态代理\n\n可通过配置方式设置强制使用 CGLIB 动态代理\n\n\n3.1 What 代理\n\n\n\n\n\n\n\n\n二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。\n\n3.1 静态代理\n\n\n\n\n\n\n\n\n要想采用静态代理方式，需要具备以下条件：1.目标类具有接口，并实现了其接口。2.代理类也得实现目标类的接口，并有一个属性是目标类接口。3.代理类的得有一个无参构造方法和一个构造方法，参数为目标类接口类型，用于接收目标对象赋值给代理类的目标类接口属性。4.代理类必须实现接口的所有方法，并在在方法中访问目标类对象的方法，在访问之前和之后都可以进行一些代理操作。\n代码实现（接口，实现类，代理类，测试）\npublic interface Calculator &#123;\n    void abc();\n    int add(int i, int j);\n    int sub(int i, int j);\n    int mul(int i, int j);\n    int div(int i, int j);\n&#125;\n\npublic class CalculatorPureImpl implements Calculator &#123;\n    @Override\n    public void abc() &#123;\n        System.out.println(&quot;abc&quot;);\n    &#125;\n\n    @Override\n    public int add(int i, int j) &#123;\n        int result &#x3D; i + j;\n        System.out.println(&quot;方法内部 result &#x3D; &quot; + result);\n        return result;\n    &#125;\n\t... ...\n&#125;\n\npublic class StaticProxy implements Calculator&#123;\n    private CalculatorPureImpl target;\n    \n    public StaticProxy(CalculatorPureImpl target) &#123;\n        this.target &#x3D; target;\n    &#125;\n\n    public void before(int i,int j)&#123;\n        System.out.println(&quot;静态代理 -- 计算数字前：&quot;+i+&quot;、&quot;+j);\n    &#125;\n\n    public void after()&#123;\n        System.out.println(&quot;静态代理 -- 计算数字后：successful&quot;);\n    &#125;\n\n    @Override\n    public void abc() &#123;\n        before(1,1);\n        after();\n    &#125;\n\n    @Override\n    public int add(int i, int j) &#123;\n        before(i,j);\n        int result &#x3D; this.target.add(i, j);\n        after();\n        return result;\n    &#125;\n    ... ...\n&#125;\n\n@Test\npublic void test()&#123;\n    StaticProxy staticProxy &#x3D; new StaticProxy(new CalculatorPureImpl());\n    staticProxy.abc();\n    staticProxy.add(10,20);\n    staticProxy.div(10,2);\n&#125;\n\n&#x2F;* 结果\n静态代理 -- 计算数字前：1、1\n静态代理 -- 计算数字后：successful\n\n静态代理 -- 计算数字前：10、20\n方法内部 result &#x3D; 30\n静态代理 -- 计算数字后：successful\n\n静态代理 -- 计算数字前：10、2\n方法内部 result &#x3D; 5\n静态代理 -- 计算数字后：successful*&#x2F;\n\n静态代理的优缺点\n\n优点\n静态代理对客户（测试类）隐藏了被代理类接口（目标类接口）的具体实现类，在一定程度上实现了解耦合，同时提高了安全性！\n\n缺点\n静态代理类需要实现目标类（被代理类）的接口，并实现其方法，造成了代码的大量冗余。\n静态代理只能对某个固定接口的实现类进行代理服务，其灵活性不强。故一般大项目不会选择静态代理\n\n\n3.2 动态代理3.2.1 JDK 动态代理\n\n\n\n\n\n\n\n\n动态代理能够实现代理类无需和被代理类直接关联，但是动态代理类必须实现Invocation接口，并且实现invoke() 方法，在invoke()方法中需要完成两件事情：一是添加服务，二是调用业务逻辑方法。代理服务就是在代理类中的invoke中执行的。我们可以通过反射机制获取目标对象的加载类、接口，还有实现了Invocation接口的代理类传到**Proxy.newProxyInstance(被代理类，被代理类接口，代理类)**方法中获取到代理类的对象实例。\n代码实现（接口，实现类，代理类，测试）\npublic interface Calculator &#123;\n    void abc();\n    int add(int i, int j);\n    int sub(int i, int j);\n    int mul(int i, int j);\n    int div(int i, int j);\n&#125;\n\npublic class CalculatorPureImpl implements Calculator &#123;\n    @Override\n    public void abc() &#123;\n        System.out.println(&quot;abc&quot;);\n    &#125;\n\n    @Override\n    public int add(int i, int j) &#123;\n        int result &#x3D; i + j;\n        System.out.println(&quot;方法内部 result &#x3D; &quot; + result);\n        return result;\n    &#125;\n\t... ...\n&#125;\n\npublic class DynamicProxy&lt;T&gt; &#123;\n\n    private T target;\n\n    public DynamicProxy(T target) &#123;\n        this.target &#x3D; target;\n    &#125;\n\n    public T getProxy() &#123;\n\n        ClassLoader classLoader &#x3D; this.target.getClass().getClassLoader();\n\n        Class&lt;?&gt;[] interfaces &#x3D; this.target.getClass().getInterfaces();\n\n        InvocationHandler handler &#x3D; new InvocationHandler() &#123;\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n\n                String methodName &#x3D; method.getName();\n                Object result &#x3D; null;\n                try &#123;\n                    System.out.println(&quot;前置：&quot; + methodName);\n                    result &#x3D; method.invoke(target, args);\n                    System.out.println(&quot;完成：&quot; + methodName);\n                &#125; catch (Exception e) &#123;\n                    e.printStackTrace();\n                    System.out.println(&quot;异常：&quot; + methodName);\n                &#125; finally &#123;\n                    System.out.println(&quot;后置：&quot; + methodName);\n                &#125;\n\n                return result;\n            &#125;\n        &#125;;\n\n        T proxy &#x3D; (T) Proxy.newProxyInstance(classLoader, interfaces, handler);\n        return proxy;\n    &#125;\n&#125;\n\n@Test\npublic void testDemo2()&#123;\n        DynamicProxy&lt;CalculatorPureImpl&gt; proxy &#x3D; new DynamicProxy&lt;&gt;(new CalculatorPureImpl());\n        Calculator proxy1 &#x3D; proxy.getProxy();\n\n        proxy1.add(10,20);\n&#125;\n\n&#x2F;* 结果\n前置：add\n方法内部 result &#x3D; 30\n完成：add\n后置：add*&#x2F;\n\nJDK动态代理的优缺点\n1.优点\n\n动态代理实现了只需要将被代理对象作为参数传入代理类就可以获取代理类对象，从而实现类代理，具有较强的灵活性。\n动态代理的服务内容不需要像静态代理一样写在每个代码块中，只需要写在invoke()方法中即可，降低了代码的冗余度。\n\n2.缺点\n\n动态代理类仍然需要实现接口。\n\n3.2.2 CGLIB 动态代理\n\n\n\n\n\n\n\n\n“代理”的目的是构造一个和被代理的对象有同样行为的对象，一个对象的行为是在类中定义的，对象只是类的实例。所以构造代理，不一定非得通过持有、包装对象这一种方式。\n通过“继承”可以继承父类所有的公开方法，然后可以重写这些方法，在重写时对这些方法增强，这就是cglib的思想。根据里氏代换原则（LSP），父类需要出现的地方，子类可以出现，所以cglib实现的代理也是可以被正常使用的\n3.3 AOP 中Bean的代理第一种：具有接口，且实现了接口需要注入的Bean\npublic interface Calculator &#123;\n    void abc();\n    int add(int i, int j);\n    int sub(int i, int j);\n    int mul(int i, int j);\n    int div(int i, int j);\n&#125;\n\n@Component\npublic class CalculatorImpl implements Calculator &#123;\n    @Override\n    public void abc() &#123;\n        System.out.println(&quot;abc&quot;);\n    &#125;\n    \n    @Override\n    public int add(int i, int j) &#123;\n        int result &#x3D; i + j;\n        System.out.println(&quot;方法内部 result &#x3D; &quot; + result);\n        return result;\n    &#125;\n\t... ...\n&#125;\n\n第二种：没有接口，需要注入的Bean\n@Component\npublic class Happy &#123;\n    public void doWork() &#123;\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;HappyComponentDaoImpl&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n    &#125;\n&#125;\n\n测试代码\n@ContextConfiguration(value &#x3D; &#123;&quot;classpath:applicationContext.xml&quot;&#125;)\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class EnableAspect &#123;\n    @Autowired\n    private Calculator calculator;\n    \n    @Autowired\n    private Happy happy;\n    \n    @Test\n    public void testDemo1()&#123;\n        calculator.add(10,20);\n        System.out.println();\n        happy.doWork();\n    &#125;\n&#125;\n\n\n3.4 代理知识总结Spring 在运行期， 生成动态代理对象， 不需要特殊的编译器Spring AOP 的底层就是通过 JDK 动态代理或 CGLib 动态代理技术 为目标Bean 执行横向织入\n\n1.若目标对象实现了若干接口， spring 使用 JDK 的 java.lang.reflect.Proxy 类代理。\n\n2.若目标对象没有实现任何接口， spring 使用 CGLIB 库生成目标对象的子类。\n\n程序中应优先对接口创建代理， 便于程序解耦维护\n\n标记为 final 的方法， 不能被代理， 因为无法进行覆盖\n\nJDK 动态代理， 是针对接口生成子类， 接口中方法不能使用 final 修饰\n\nCGLib 是针对目标类生产子类， 因此类或方法 不能使 final 的\n\nSpring 只支持方法连接点， 不提供属性连接\n\n\n\n4. AOP基于注解的实现4.1 初步实现添加依赖\n&lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-aspects&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.3.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n准备被代理的资源\npublic interface Calculator &#123;\n    void abc();\n    int add(int i, int j);\n    int sub(int i, int j);\n    int mul(int i, int j);\n    int div(int i, int j);\n&#125;\n\n@component(value&#x3D;&quot;calculator1&quot;)\npublic class CalculatorPureImpl implements Calculator &#123;\n    @Override\n    public void abc() &#123;\n        System.out.println(&quot;abc&quot;);\n    &#125;\n\n    @Override\n    public int add(int i, int j) &#123;\n        int result &#x3D; i + j;\n        System.out.println(&quot;方法内部 result &#x3D; &quot; + result);\n        return result;\n    &#125;\n\t... ...\n&#125;\n\n创建切面类\n@org.aspectj.lang.annotation.Aspect\n@Component\npublic class Aspect &#123;\n    @Before(value &#x3D; &quot;execution(public int com.hrenxiang.calculator.CalculatorPureImpl.*(..))&quot;)\n    public void beforeLog()&#123;\n        System.out.println(&quot;[AOP前置通知] 方法开始了&quot;);\n    &#125;\n\n    @After(value &#x3D; &quot;execution(public int com.hrenxiang.calculator.CalculatorPureImpl.*(..))&quot;)\n    public void afterLog()&#123;\n        System.out.println(&quot;[AOP后置通知] 方法最终结束了&quot;);\n    &#125;\n\n    @AfterReturning(value &#x3D; &quot;execution(public int com.hrenxiang.calculator.CalculatorPureImpl.*(..))&quot;)\n    public void afterReturningLog()&#123;\n        System.out.println(&quot;[AOP正常运行结束] 方法结束了&quot;);\n    &#125;\n\n    @AfterThrowing(value &#x3D; &quot;execution(public int com.hrenxiang.calculator.CalculatorPureImpl.*(..))&quot;)\n    public void afterThrowingLog()&#123;\n        System.out.println(&quot;[AOP运行异常结束了] 方法结束了了&quot;);\n    &#125;\n&#125;\n\n测试\n@ContextConfiguration(value &#x3D; &#123;&quot;classpath:applicationContext.xml&quot;&#125;)\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class TestCalculator &#123;\n\n    @Autowired\n    @Qualifier(value &#x3D; &quot;calculator1&quot;)\n    private Calculator calculator;\n\n    @Test\n    public void testDemo()&#123;\n        calculator.add(10,20);\n\n        System.out.println(&quot;\\n&quot;);\n\n        &#x2F;*calculator.div(10,0);*&#x2F;\n        calculator.sub(100,500);\n\n        System.out.println(&quot;\\n&quot;);\n\n        calculator.abc();\n    &#125;\n    \n&#x2F;*结果\n[AOP前置通知] 方法开始了\n方法内部 result &#x3D; 30\n[AOP正常运行结束] 方法结束了\n[AOP后置通知] 方法最终结束了\n\n\n[AOP前置通知] 方法开始了\n方法内部 result &#x3D; -400\n[AOP正常运行结束] 方法结束了\n[AOP后置通知] 方法最终结束了\n\n\nabc*&#x2F;\n\n4.2 通知执行顺序通知执行顺序\nSpring版本5.3.x以前：\n\n前置通知\n目标操作\n后置通知\n返回通知或异常通知\nSpring版本5.3.x以后：\n\n前置通知\n目标操作\n返回通知或异常通知\n后置通知\n\n\n5. AOP获取细节信息&#x2F;&#x2F; 在前置通知方法形参位置声明一个JoinPoint类型的参数，Spring就会将这个对象传入\n@Before(value &#x3D; &quot;execution(public int com.hrenxiang.calculator.CalculatorPureImpl.*(..))&quot;)\npublic void beforeLog(JoinPoint joinPoint)&#123;\n\n        &#x2F;&#x2F; 0.通过JoinPoint对象获取外界调用目标方法时传入的实参列表\n        Object[] args &#x3D; joinPoint.getArgs();\n        System.out.println(Arrays.toString(args));\n\n        String kind &#x3D; joinPoint.getKind();\n        System.out.println(kind);\n\n        String s &#x3D; joinPoint.toString();\n        System.out.println(s);\n\n        &#x2F;&#x2F; 1.通过JoinPoint对象获取目标方法签名对象\n        &#x2F;&#x2F; 方法的签名：一个方法的全部声明信息\n        Signature signature &#x3D; joinPoint.getSignature();\n        System.out.println(signature);\n        &#x2F;&#x2F; 2.获取声明的类型\n        Class declaringType &#x3D; signature.getDeclaringType();\n\n        String declaringTypeName &#x3D; signature.getDeclaringTypeName();\n        int modifiers &#x3D; signature.getModifiers();\n        System.out.println(declaringType+&quot;,&quot;+declaringTypeName+&quot;,&quot;+modifiers);\n        &#x2F;&#x2F; 3.通过方法的签名对象获取目标方法的详细信息\n        String methodName &#x3D; signature.getName();\n        System.out.println(&quot;methodName &#x3D; &quot; + methodName);\n\n        SourceLocation sourceLocation &#x3D; joinPoint.getSourceLocation();\n        System.out.println(sourceLocation);\n\n        Object target &#x3D; joinPoint.getTarget();\n        System.out.println(target);\n\n        System.out.println(&quot;[AOP前置通知] 方法开始了&quot;);\n&#125;\n\n[10, 20]\nmethod-execution\nexecution(int com.hrenxiang.calculator.Calculator.add(int,int))\nint com.hrenxiang.calculator.Calculator.add(int,int)\ninterface com.hrenxiang.calculator.Calculator,com.hrenxiang.calculator.Calculator,1025\norg.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint$SourceLocationImpl@290222c1\ncom.hrenxiang.calculator.CalculatorPureImpl@67f639d3\n[AOP前置通知] 方法开始了\n\n&#x2F;*方法内部 result &#x3D; 30\n[AOP正常运行结束] 方法结束了\n[AOP后置通知] 方法最终结束了*&#x2F;\n\n5.1 方法返回值@AfterReturning(\n    value &#x3D; &quot;execution(public int com.hrenxiang.calculator.CalculatorPureImpl.*(..))&quot;,\n    returning &#x3D; &quot;returnValue&quot;)\n\n    public void afterReturningLog(JoinPoint joinPoint , Object returnValue)&#123;\n\n        System.out.println(&quot;[AOP正常运行结束] 方法结束了&quot;+&quot;返回值：&quot;+returnValue);\n    &#125;\n\n[AOP正常运行结束] 方法结束了返回值：30\n\n5.2 目标方法抛出异常@AfterThrowing(\n\tvalue &#x3D; &quot;execution(public int com.hrenxiang.calculator.CalculatorPureImpl.*(..))&quot;,\n\tthrowing &#x3D; &quot;throwInfo&quot;)\n\t\n    public void afterThrowingLog(Throwable throwInfo)&#123;\n        System.out.println(&quot;[AOP运行异常结束了] 方法结束了了&quot;+&quot;,异常原因：&quot;+throwInfo);\n    &#125;\n\n@ContextConfiguration(value &#x3D; &#123;&quot;classpath:applicationContext.xml&quot;&#125;)\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class TestCalculator &#123;\n\n    @Autowired\n    @Qualifier(value &#x3D; &quot;calculator1&quot;)\n    private Calculator calculator;\n\n    @Test\n    public void testDemo()&#123;\n        calculator.div(10,0);\n    &#125;\n&#125;\n\n[AOP前置通知] 方法开始了\n[AOP运行异常结束了] 方法结束了了,异常原因：java.lang.ArithmeticException: &#x2F; by zero\n[AOP后置通知] 方法最终结束了\n\n5.3 重用切入表达式\n\n\n\n\n\n\n\n\n在一处声明切入点表达式之后，其他有需要的地方引用这个切入点表达式。易于维护，一处修改，处处生效\n而作为存放切入点表达式的类，可以把整个项目中所有切入点表达式全部集中过来，便于统一管理\npublic class pointcuts &#123;\n    @Pointcut(value &#x3D; &quot;execution(* *.*.*.*.*(..))&quot;)\n    public void declarePointCut() &#123;&#125;\n&#125;\n\n@Before(value &#x3D; &quot;com.hrenxiang.config.pointcuts.declarePointCut()&quot;)\n    public void beforeLog()&#123;\n        System.out.println(&quot;[AOP前置通知] 方法开始了&quot;);\n    &#125;\n\n6. 表达式语法细节\n用*号代替“权限修饰符”和“返回值”部分表示“权限修饰符”和“返回值”不限\n在包名的部分，一个“*”号只能代表包的层次结构中的一层，表示这一层是任意的。\n例如：***.Hello匹配com.Hello，不匹配com.atguigu.Hello**\n\n\n在包名的部分，使用“***..”表示包名任意、包的层次深度任意**\n在类名的部分，类名部分整体用*号代替，表示类名任意\n在类名的部分，可以使用*号代替类名的一部分\n\n*Service\n\n上面例子表示匹配所有名称以Service结尾的类或接口\n\n在方法名部分，可以使用*号表示方法名任意\n在方法名部分，可以使用*号代替方法名的一部分\n\n*Operation\n\n上面例子表示匹配所有方法名以Operation结尾的方法\n\n在方法参数列表部分，使用**(..)表示参数列表任意**\n在方法参数列表部分，使用**(int,..)表示参数列表以一个int类型的参数开头**\n在方法参数列表部分，基本数据类型和对应的包装类型是不一样的\n切入点表达式中使用 int 和实际方法中 Integer 是不匹配的\n\n\n在方法返回值部分，如果想要明确指定一个返回值类型，那么必须同时写明权限修饰符\n\nexecution(public int *..*Service.*(.., int))\n\n上面例子是对的，下面例子是错的：\nexecution(* int *..*Service.*(.., int))\n\n但是public *表示权限修饰符明确，返回值任意是可以的。\n\n对于execution()表达式整体可以使用三个逻辑运算符号\nexecution() || execution()表示满足两个execution()中的任何一个即可\nexecution() &amp;&amp; execution()表示两个execution()表达式必须都满足\n!execution()表示不满足表达式的其他方法\n\n\n\n\n\n7. 环绕通知\n\n\n\n\n\n\n\n\n环绕通知对应整个try…catch…finally结构，包括前面四种通知的所有功能。\n\n&#x2F;&#x2F; 使用@Around注解标明环绕通知方法\n@Around(value &#x3D; &quot;com.atguigu.aop.aspect.AtguiguPointCut.transactionPointCut()&quot;)\npublic Object manageTransaction(\n    \n        &#x2F;&#x2F; 通过在通知方法形参位置声明ProceedingJoinPoint类型的形参，\n        &#x2F;&#x2F; Spring会将这个类型的对象传给我们\n        ProceedingJoinPoint joinPoint) &#123;\n    \n    &#x2F;&#x2F; 通过ProceedingJoinPoint对象获取外界调用目标方法时传入的实参数组\n    Object[] args &#x3D; joinPoint.getArgs();\n    \n    &#x2F;&#x2F; 通过ProceedingJoinPoint对象获取目标方法的签名对象\n    Signature signature &#x3D; joinPoint.getSignature();\n    \n    &#x2F;&#x2F; 通过签名对象获取目标方法的方法名\n    String methodName &#x3D; signature.getName();\n    \n    &#x2F;&#x2F; 声明变量用来存储目标方法的返回值\n    Object targetMethodReturnValue &#x3D; null;\n    \n    try &#123;\n    \n        &#x2F;&#x2F; 在目标方法执行前：开启事务（模拟）\n        System.out.println(&quot;[AOP 环绕通知] 开启事务，方法名：&quot; + methodName + &quot;，参数列表：&quot; + Arrays.asList(args));\n    \n        &#x2F;&#x2F; 过ProceedingJoinPoint对象调用目标方法\n        &#x2F;&#x2F; 目标方法的返回值一定要返回给外界调用者\n        targetMethodReturnValue &#x3D; joinPoint.proceed(args);\n    \n        &#x2F;&#x2F; 在目标方法成功返回后：提交事务（模拟）\n        System.out.println(&quot;[AOP 环绕通知] 提交事务，方法名：&quot; + methodName + &quot;，方法返回值：&quot; + targetMethodReturnValue);\n    \n    &#125;catch (Throwable e)&#123;\n    \n        &#x2F;&#x2F; 在目标方法抛异常后：回滚事务（模拟）\n        System.out.println(&quot;[AOP 环绕通知] 回滚事务，方法名：&quot; + methodName + &quot;，异常：&quot; + e.getClass().getName());\n    \n    &#125;finally &#123;\n    \n        &#x2F;&#x2F; 在目标方法最终结束后：释放数据库连接\n        System.out.println(&quot;[AOP 环绕通知] 释放数据库连接，方法名：&quot; + methodName);\n    \n    &#125;\n    \n    return targetMethodReturnValue;\n&#125;\n\n\n8. 切面的优先级相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。\n\n优先级高的切面：外面\n优先级低的切面：里面\n\n使用@Order注解可以控制切面的优先级：\n\n@Order(较小的数)：优先级高\n@Order(较大的数)：优先级低\n\n\n    \n    \n\n\n实际开发时，如果有多个切面嵌套的情况，要慎重考虑。例如：如果事务切面优先级高，那么在缓存中命中数据的情况下，事务切面的操作都浪费了。\n\n\n\n9. AOP对IOC DI影响\n\n\n\n\n\n\n\n\nIOC 是控制反转 DI是依赖注入\n没有使用AOP之前\n​        有接口的实现类：如果实现类唯一，按照接口和实现类都可以拿到\n​        没有接口的类：按照类名可以拿到\n使用了AOP之后\n​        有接口的实现类：如果实现类唯一，按照接口可以拿到，按照实现类拿不到\n​        没有接口的类：按照类名依旧可以拿到\n原因\n有接口的，aop底层使用 jdk动态代理，采用实现接口的形式代理，因为jdk动态代理直接继承了Proxy，java中是单继承，所以和被代理类接实现类没有直接关系\n没有接口的，aop底层使用CGLIB动态代理，CGLIB直接继承了被代理类\n\n\n10. AOP基于XML的实现&lt;!-- 配置目标类的bean --&gt;\n&lt;bean id&#x3D;&quot;calculatorPure&quot; class&#x3D;&quot;com.atguigu.aop.imp.CalculatorPureImpl&quot;&#x2F;&gt;\n    \n&lt;!-- 配置切面类的bean --&gt;\n&lt;bean id&#x3D;&quot;logAspect&quot; class&#x3D;&quot;com.atguigu.aop.aspect.LogAspect&quot;&#x2F;&gt;\n    \n&lt;!-- 配置AOP --&gt;\n&lt;aop:config&gt;\n    \n    &lt;!-- 配置切入点表达式 --&gt;\n    &lt;aop:pointcut id&#x3D;&quot;logPointCut&quot; expression&#x3D;&quot;execution(* *..*.*(..))&quot;&#x2F;&gt;\n    \n    &lt;!-- aop:aspect标签：配置切面 --&gt;\n    &lt;!-- ref属性：关联切面类的bean --&gt;\n    &lt;aop:aspect ref&#x3D;&quot;logAspect&quot;&gt;\n        &lt;!-- aop:before标签：配置前置通知 --&gt;\n        &lt;!-- method属性：指定前置通知的方法名 --&gt;\n        &lt;!-- pointcut-ref属性：引用切入点表达式 --&gt;\n        &lt;aop:before method&#x3D;&quot;printLogBeforeCore&quot; pointcut-ref&#x3D;&quot;logPointCut&quot;&#x2F;&gt;\n    \n        &lt;!-- aop:after-returning标签：配置返回通知 --&gt;\n        &lt;!-- returning属性：指定通知方法中用来接收目标方法返回值的参数名 --&gt;\n        &lt;aop:after-returning\n                method&#x3D;&quot;printLogAfterCoreSuccess&quot;\n                pointcut-ref&#x3D;&quot;logPointCut&quot;\n                returning&#x3D;&quot;targetMethodReturnValue&quot;&#x2F;&gt;\n    \n        &lt;!-- aop:after-throwing标签：配置异常通知 --&gt;\n        &lt;!-- throwing属性：指定通知方法中用来接收目标方法抛出异常的异常对象的参数名 --&gt;\n        &lt;aop:after-throwing\n                method&#x3D;&quot;printLogAfterCoreException&quot;\n                pointcut-ref&#x3D;&quot;logPointCut&quot;\n                throwing&#x3D;&quot;targetMethodException&quot;&#x2F;&gt;\n    \n        &lt;!-- aop:after标签：配置后置通知 --&gt;\n        &lt;aop:after method&#x3D;&quot;printLogCoreFinallyEnd&quot; pointcut-ref&#x3D;&quot;logPointCut&quot;&#x2F;&gt;\n    \n        &lt;!-- aop:around标签：配置环绕通知 --&gt;\n        &lt;!--&lt;aop:around method&#x3D;&quot;……&quot; pointcut-ref&#x3D;&quot;logPointCut&quot;&#x2F;&gt;--&gt;\n    &lt;&#x2F;aop:aspect&gt;\n    \n&lt;&#x2F;aop:config&gt;\n\n","slug":"50-Spring-面向切面编程","date":"2021-09-13T15:27:32.000Z","categories_index":"Spring","tags_index":"Spring","author_index":"大黄"},{"id":"8ec558949bfff1ff48dc8dd0d9de915c","title":"Spring 基础和IOC","content":"01. Spring框架简介\n\n\n\n\n\n\n\n\nSpring 框架是一个 Java 平台，为开发 Java 应用程序提供全面的基础架构支持。 Spring 处理基础结构，因此您可以专注于应用程序。\nSpring 使您能够从“普通的 Java 对象”(POJO)构建应用程序，并将企业服务非侵入性地应用于 POJO。此功能适用于 Java SE 编程模型以及全部和部分 Java EE。\n1.1 介绍Spring是一个分层的（**一站式**） 轻量级开源框架\nSpring的核心是**控制反转（IoC）和 面向切面（AOP）**\n1.2 一站式 轻量javaEE分三层开发 WEB层，业务层，持久层。在spring中有SpringMvc可以替代Struts2，springJDBC可以替代Hibernate。等于一个spring框架可以快速开发JavaEE应用。\n关于轻量级就不太多说了，spring整个框架打包出来也才1M多的内存大小。spring运行中的消耗也不大。那肯定是轻量级的框架。\n\n02. SpringFramework\n\n\n\n\n\n\n\n\nSpring 基础框架，可以视为 Spring 基础设施，基本上任何其他 Spring 项目都是以 Spring Framework 为基础的。\n2.1 五大功能模块\n\n\n\n功能模块\n功能介绍\n\n\n\nTesting\n提供了对 junit 或 TestNG 测试框架的整合。\n\n\nCore Container\n核心容器，在 Spring 环境下使用任何功能都必须基于 IOC 容器。\n\n\nAOP&amp;Aspects\n面向切面编程\n\n\nData Access/Integration\n提供了对数据访问/集成的功能。\n\n\nSpring MVC\n提供了面向Web应用程序的集成功能。\n\n\n2.2 SpringFramework优点\n非侵入式：使用 Spring Framework 开发应用程序时，Spring 对应用程序本身的结构影响非常小。对领域模型可以做到零污染；对功能性组件也只需要使用几个简单的注解进行标记，完全不会破坏原有结构，反而能将组件结构进一步简化。这就使得基于 Spring Framework 开发应用程序时结构清晰、简洁优雅。\n控制反转：IOC——Inversion of Control，翻转资源获取方向。把自己创建资源、向环境索取资源变成环境将资源准备好，我们享受资源注入。\n面向切面编程：AOP——Aspect Oriented Programming，在不修改源代码的基础上增强代码功能。\n容器：Spring IOC 是一个容器，因为它包含并且管理组件对象的生命周期。组件享受到了容器化的管理，替程序员屏蔽了组件创建过程中的大量细节，极大的降低了使用门槛，大幅度提高了开发效率。\n组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML 和 Java 注解组合这些对象。这使得我们可以基于一个个功能明确、边界清晰的组件有条不紊的搭建超大型复杂应用系统。\n声明式：很多以前需要编写代码才能实现的功能，现在只需要声明需求即可由框架代为实现。\n一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库。而且 Spring 旗下的项目已经覆盖了广泛领域，很多方面的功能性需求可以在 Spring Framework 的基础上全部使用 Spring 来实现。\n\n\n03. IOC 的简介3.1 容器Servlet 容器能够管理 Servlet、Filter、Listener 这样的组件的一生，所以它是一个复杂容器。我们即将要学习的 IOC 容器也是一个复杂容器。它们不仅要负责创建组件的对象、存储组件的对象，还要负责调用组件的方法让它们工作，最终在特定情况下销毁组件。\n3.2 IOC DI\n\n\n\n\n\n\n\n\nIOC – Inverse of Control，控制反转，将对象的创建权反转给Spring！！\nIOC作用：对象之间解耦。利于后期维护和修改。（修改xml文件不同于修改.java源代码，不涉及重新编译、打包、部署等操作）\nDI：Dependency Injection，翻译过来是依赖注入。在Spring框架负责创建Bean对象时，动态的将依赖对象注入到Bean组件中！！\nDI 是 IOC 的另一种表述方式：即组件以一些预先定义好的方式（例如：setter 方法）接受来自于容器的资源注入。相对于IOC而言，这种表述更直接。\n所以结论是：IOC 就是一种反转控制的思想， 而 DI 是对 IOC 的一种具体实现。\n3.3 IOC 内容\n\n04. IOC 的实现\n\n\n\n\n\n\n\n\nSpring 的 IOC 容器就是 IOC 思想的一个落地的产品实现。IOC 容器中管理的组件也叫做 bean。\nSpring认为一切类都是Bean，比如实体类、DAO类、业务层、控制类、通知类等，容纳这些Bean的是Spring提供的IoC容器，所以Spring是一种基于Bean的编程\n在创建 bean 之前，首先需要创建 IOC 容器。Spring 提供了 IOC 容器的两种实现方式\n4.1 BeanFactory\n\n\n\n\n\n\n\n\n这是 IOC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，不提供给开发人员使用。\n4.2 ApplicationContext接口\n\n\n\n\n\n\n\n\nBeanFactory 的子接口，提供了更多高级特性。\n面向 Spring 的使用者，几乎所有场合都使用 ApplicationContext 而不是底层的 BeanFactory。\n* 使用ApplicationContext工厂的接口，使用该接口可以获取到具体的Bean对象\n\n* ApplicationContext提供的功能\n    * 事件传递\n    * Bean自动装配\n    * 各种不同应用层的Context实现\n    \n* 该接口下有两个具体的实现类\n    * ClassPathXmlApplicationContext            -- 加载类路径下的Spring配置文件\n    * FileSystemXmlApplicationContext           -- 加载本地磁盘下的Spring配置文件\n\n\n\n\n\n类型名\n简介\n\n\n\nClassPathXmlApplicationContext\n通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象\n\n\nFileSystemXmlApplicationContext\n通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象\n\n\nConfigurableApplicationContext\nApplicationContext 的子接口，包含一些扩展方法 refresh() 和 close() ，让 ApplicationContext 具有启动、关闭和刷新上下文的能力。\n\n\nWebApplicationContext\n专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。\n\n\n4.3 实现代码添加依赖\n&lt;dependencies&gt;\n    &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;5.3.1&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;!-- junit测试 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;4.12&lt;&#x2F;version&gt;\n        &lt;scope&gt;test&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n创建相关类\n@Data\n@Builder(toBuilder &#x3D; true)\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User &#123;\n    private Integer id;\n    private Integer age;\n    private String name;\n\n    private Teacher teacher;\n\n    private List&lt;String&gt; hobby;\n\n    private Map&lt;String,String&gt; friend;\n\n    private Integer[] arr;\n&#125;\n\n创建配置文件\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;\n       xmlns:util&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util&#x2F;spring-util.xsd&quot;&gt;\n    \n&lt;&#x2F;beans&gt;\n\n添加组件\n&lt;!--1.ioc创建bean--&gt;\n&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.hrenxiang.pojo.User&quot;&#x2F;&gt;\n\nbean标签：通过配置bean标签告诉IOC容器需要创建对象的组件是什么\nid属性：bean的唯一标识\nclass属性：组件类的全类名\n\n创建测试\n@Test\n    public void testDemo1()&#123;\n        ClassPathXmlApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);\n        User user &#x3D; applicationContext.getBean(&quot;user&quot;, User.class);\n        user.setId(1);\n        user.setAge(21);\n        user.setName(&quot;王茜&quot;);\n        User user1 &#x3D; user.toBuilder().name(&quot;黄任翔&quot;).age(21).id(2).build();\n\n        System.out.println(user);\n        System.out.println(user1);\n    &#125;\n\n4.4 注意==Spring 底层默认通过反射技术调用组件类的无参构造器来创建组件对象==，这一点需要注意。如果在需要无参构造器时，没有无参构造器，则会抛出异常\n所以对一个JavaBean来说，无参构造器和属性的getXxx()、setXxx()方法是必须存在的，特别是在框架中。\n\n05. Bean 概述\n\n\n\n\n\n\n\n\nSpring IoC 容器 Management 一个或多个 bean。这些 bean 是使用您提供给容器的配置元数据创建的，例如，以 XML &lt;bean/&gt;定义的形式。\n在容器本身内，这些 bean 定义表示为BeanDefinition对象，其中包含(除其他信息外)以下元数据：\n\n包限定的类名称：通常是所定义的 Bean 的实际实现类。\nBean 行为配置元素，用于声明 Bean 在容器中的行为(作用域，生命周期回调等)。\n引用该 bean 完成其工作所需的其他 bean；这些引用也称为* collaborators 或 dependencies *。\n要在新创建的对象中设置的其他配置设置，例如，在 Management 连接池的 bean 中使用的连接数，或该池的大小限制。\n\n该元数据转换为构成每个 bean 定义的一组属性。\n\n\n\n属性\n定义\n\n\n\nclass\n“实例化 bean”\n\n\nname\n“命名 bean”\n\n\nscope\n“ Bean 范围”\n\n\nconstructor arguments\n“依赖注入”\n\n\nproperties\n“依赖注入”\n\n\nautowiring mode\n“自动装配合作者”\n\n\nlazy-initialization mode\n“延迟初始化的 bean”\n\n\ninitialization method\n称为“初始化回调”的部分\n\n\ndestruction method\n称为“销毁回调”的部分\n\n\n5.1 命名 Bean\n\n\n\n\n\n\n\n\n每个 bean 具有一个或多个标识符。这些标识符在承载 Bean 的容器内必须唯一。 Bean 通常只有一个标识符，但是如果需要多个标识符，则多余的标识符可以被视为别名。\n使用id和/或name属性来指定 Bean 标识符。\nid与name 属性在作用上基本没有区别。推荐使用id。\n\nid取值要求严格些，必须满足XML的命名规范。id是唯一的，配置文件中不允许出现两个id相同的&lt;bean&gt;。\n \nname取值比较随意，甚至可以用数字开头。配置文件中允许两个name相同的&lt;bean&gt;，在用getBean()返回实例时，后面一个Bean被返回。\n\n如果没有id，name，则用类的全名作为name，如&lt;bean class&#x3D;&quot;test.Test&quot;&gt;,可以使用getBean(&quot;test.Test&quot;)返回该实例。\n\n\n\n\n\n\n\n\n\n\n约定是在命名 bean 时将标准 Java 约定用于实例字段名称。也就是说，bean 名称以小写字母开头，并且此后以驼峰大小写。此类名称的示例将是(不带引号)&#39;accountManager&#39;，&#39;accountService&#39;，&#39;userDao&#39;，&#39;loginController&#39;等。\n但是，在(不寻常的)特殊情况下，如果有多个字符并且第一个和第二个字符均为大写字母，则会保留原始大小写。\n5.2 别名 Bean在 bean 定义本身中，可以使用id属性指定的最多一个名称和name属性中任意数量的其他名称的组合来为 bean 提供多个名称。\n&lt;alias name&#x3D;&quot;fromName&quot; alias&#x3D;&quot;toName&quot;&#x2F;&gt;\n\n在这种情况下，使用该别名定义后，名为fromName的 bean(在同一容器中)也可以称为 toName\n5.3 实例化 BeanBean 定义本质上是创建一个或多个对象的方法。询问时，容器将查看命名 bean 的配方，并使用该 bean 定义封装的配置元数据来创建(或获取)实际对象。\n如果使用基于 XML 的配置元数据，则可以在&lt;bean/&gt;元素的class属性中指定要实例化的对象的类型(或类)\n\n\n\n\n\n\n\n\n\nNote\n内部类名. 如果要为static嵌套类配置 bean 定义，则必须使用嵌套类的* binary *名称。\n例如，如果您在com.example包中有一个名为Foo的类，并且此Foo类具有一个名为Bar的static嵌套类，则 Bean 定义上&#39;class&#39;属性的值将为…\ncom.example.Foo$Bar\n请注意，名称中使用了$字符以将嵌套的类名与外部类名分开。\n使用构造方法实例化  根据您用于该特定 bean 的 IoC 的类型，您可能需要一个**默认(空)构造函数**。\n\n使用静态工厂方法实例化\n\n使用动态工厂方法实例化\n\n5.4 获取Bena\n\n\n\n\n\n\n\n\n方法1：按照Id获取Bean。id必须正确，否则：NoSuchBeanDefinitionException: No bean named ‘happyComponent1’ available\nid必须唯一：Configuration problem: Bean name ‘happyComponent’ is already used in this  element\nid可以使用name替代，建议使用id。\n&lt;bean name&#x3D;&quot;happyComponent&quot; class&#x3D;&quot;com.atguigu.ioc.impl.HappyComponentImpl&quot;&gt;&lt;&#x2F;bean&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n方法2：可以通过类名（或者上级接口名）获取。条件：该类的实例只能有一个。如果有多个，只能通过id获取。\n&lt;!--IoC容器创建对象时遵守的指令 --&gt;  \n&lt;bean name&#x3D;&quot;happyComponent&quot; class&#x3D;&quot;com.atguigu.ioc.impl.HappyComponentImpl&quot;&gt;&lt;&#x2F;bean&gt;    \n&lt;bean name&#x3D;&quot;happyComponent2&quot; class&#x3D;&quot;com.atguigu.ioc.impl.HappyComponentImpl&quot;&gt;&lt;&#x2F;bean&gt;\n\n\n06. 依赖注入6.1 基于构造函数注入@Data\n@Builder(toBuilder &#x3D; true)\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User &#123;\n    private Integer id;\n    private Integer age;\n    private String name;\n&#125;\n\n配置\n&lt;bean id&#x3D;&quot;constructor&quot; class&#x3D;&quot;com.hrenxiang.pojo.User&quot;&gt;\n\t\t&lt;constructor-arg value&#x3D;&quot;1&quot;&#x2F;&gt;\n        &lt;constructor-arg value&#x3D;&quot;21&quot;&#x2F;&gt;\n        &lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;kk&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n@Test\npublic void testDemo6()&#123;\n        ClassPathXmlApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);\n    \n        User user &#x3D; applicationContext.getBean(&quot;constructor&quot;, User.class);\n    \n        System.out.println(user);\n&#125;\n\nconstructor-arg标签还有两个属性可以进一步描述构造器参数：\n\nindex属性：指定参数所在位置的索引（从0开始）\nname属性：指定参数名\n\n6.2 基于Setter注入通过property标签配置的属性值会通过setXxx()方法注入\n@Data\n@Builder(toBuilder &#x3D; true)\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User &#123;\n    private Integer id;\n    private Integer age;\n    private String name;\n&#125;\n\n&lt;!--2.ioc setter注入--&gt;\n&lt;bean id&#x3D;&quot;user1&quot; class&#x3D;&quot;com.hrenxiang.pojo.User&quot;&gt;\n    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;铁锤妹妹&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;22&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;id&quot; value&#x3D;&quot;3&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n&lt;!-- property标签：通过组件类的setXxx()方法给组件对象设置属性 --&gt;\n&lt;!-- name属性：指定属性名（这个属性名是getXxx()、setXxx()方法定义的，和成员变量无关） --&gt;\n&lt;!-- value属性：指定属性值 --&gt;\n\n\n\n\n\n\n\n\n\n\nConstructor-based or setter-based DI?\n由于您可以混合使用基于构造函数的 DI 和基于 setter 的 DI，因此，将构造函数用于强制依赖项和将 setter 方法或配置方法用于可选依赖项是一个很好的经验法则。请注意，在 setter 方法上使用@Required注解可用于使属性成为必需的依赖项。\n\n07. 详细的依赖和配置7.1 引入外部声明的Bean引入新组件 Teacher\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Teacher &#123;\n    private String name;\n    private Integer age;\n&#125;\n\n&lt;bean id&#x3D;&quot;user2&quot; class&#x3D;&quot;com.hrenxiang.pojo.User&quot;&gt;\n    &lt;property name&#x3D;&quot;teacher&quot; ref&#x3D;&quot;teacher&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n&lt;bean id&#x3D;&quot;teacher&quot; class&#x3D;&quot;com.hrenxiang.pojo.Teacher&quot;&gt;\n    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;刘德华&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;56&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n易错点\n\n\n\n\n\n\n\n\n\n如果错把ref属性写成了value属性，会抛出异常： Caused by: java.lang.IllegalStateException: Cannot convert value of type ‘java.lang.String’ to required type ‘com.atguigu.ioc.component.HappyMachine’ for property ‘happyMachine’: no matching editors or conversion strategy found 意思是不能把String类型转换成我们要的HappyMachine类型 说明我们使用value属性时，Spring只把这个属性看做一个普通的字符串，不会认为这是一个bean的id，更不会根据它去找到bean来赋值\n7.2 内部bean在bean里面配置的bean就是内部bean，内部bean只能在当前bean内部使用，在其他地方不能使用。\n&lt;bean id&#x3D;&quot;user3&quot; class&#x3D;&quot;com.hrenxiang.pojo.User&quot;&gt;\n    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;hh&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;21&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;id&quot; value&#x3D;&quot;4&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;teacher&quot;&gt;\n        &lt;bean class&#x3D;&quot;com.hrenxiang.pojo.Teacher&quot;&gt;\n        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;刘德华&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;56&quot;&#x2F;&gt;\n        &lt;&#x2F;bean&gt;\n    &lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n\n7.3 引入外部属性文件&lt;!-- MySQL驱动 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.1.3&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!-- 数据源 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.0.31&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;!-- 引入外部属性文件 --&gt;\n&lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot;&#x2F;&gt;\n\n&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;\n    &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.driverClassName&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\njdbc属性文件中，driverClassName、url、username等前面都要有前缀，比如jdbc.  否则运行都会报错\n7.4 级联属性赋值关联对象：teacher\n级联属性：teacher.name\n&lt;bean id&#x3D;&quot;user4&quot; class&#x3D;&quot;com.hrenxiang.pojo.User&quot;&gt;\n    &lt;property name&#x3D;&quot;teacher&quot; ref&#x3D;&quot;teacher1&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;teacher.name&quot; value&#x3D;&quot;gg&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n&lt;bean id&#x3D;&quot;teacher1&quot; class&#x3D;&quot;com.hrenxiang.pojo.Teacher&quot;&#x2F;&gt;\n\n7.5 特殊值处理\n\n\n\n\n\n\n\n\n字面量\n字面量是相对于变量来说的。看下面的代码：int a = 10;\n声明一个变量a，初始化为10，此时a就不代表字母a了，而是作为一个变量的名字。当我们引用a的时候，我们实际上拿到的值是10。\n而如果a是带引号的：’a’，那么它现在不是一个变量，它就是代表a这个字母本身，这就是字面量。所以字面量没有引申含义，就是我们看到的这个数据本身。\n[1]字面量举例\n&lt;!-- 使用value属性给bean的属性赋值时，Spring会把value属性的值看做字面量 --&gt;\n&lt;property name&#x3D;&quot;commonValue&quot; value&#x3D;&quot;hello&quot;&#x2F;&gt;\n\n[2]类似变量举例\n&lt;!-- 使用ref属性给bean的属性复制是，Spring会把ref属性的值作为一个bean的id来处理 --&gt;\n&lt;!-- 此时ref属性的值就不是一个普通的字符串了，它应该是一个bean的id --&gt;\n&lt;property name&#x3D;&quot;happyMachine&quot; ref&#x3D;&quot;happyMachine&quot;&#x2F;&gt;\n\n空字符串值和空字符串\nSpring 将属性等的空参数视为空Strings。以下基于 XML 的配置元数据片段将 email 属性设置为空的String值(“”)。\n&lt;bean class&#x3D;&quot;ExampleBean&quot;&gt;\n    &lt;property name&#x3D;&quot;email&quot; value&#x3D;&quot;&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n前面的示例等效于以下 Java 代码：\nexampleBean.setEmail(&quot;&quot;);\n\n&lt;null&#x2F;&gt;元素处理null个值。例如：\n&lt;bean class&#x3D;&quot;ExampleBean&quot;&gt;\n    &lt;property name&#x3D;&quot;email&quot;&gt;\n        &lt;null&#x2F;&gt;\n    &lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n\n上面的配置等效于以下 Java 代码：\nexampleBean.setEmail(null);\n\n小于号\n&lt;!-- 实验九 给bean的属性赋值：特殊值处理 --&gt;\n&lt;bean id&#x3D;&quot;propValue&quot; class&#x3D;&quot;com.atguigu.ioc.component.PropValue&quot;&gt;\n    &lt;!-- 小于号在XML文档中用来定义标签的开始，不能随便使用 --&gt;\n    &lt;!-- 解决方案一：使用XML实体来代替 --&gt;\n    &lt;property name&#x3D;&quot;expression&quot; value&#x3D;&quot;a &lt; b&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n\n上述等同于下\n&lt;!-- 实验九 给bean的属性赋值：特殊值处理 --&gt;\n&lt;bean id&#x3D;&quot;propValue&quot; class&#x3D;&quot;com.atguigu.ioc.component.PropValue&quot;&gt;\n    &lt;property name&#x3D;&quot;expression&quot;&gt;\n        &lt;!-- 解决方案二：使用CDATA节 --&gt;\n        &lt;!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 --&gt;\n        &lt;!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 --&gt;\n        &lt;!-- 所以CDATA节中写什么符号都随意 --&gt;\n        &lt;value&gt;&lt;![CDATA[a &lt; b]]&gt;&lt;&#x2F;value&gt;\n    &lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n\n7.6 p-命名空间p 名称空间使您可以使用bean元素的属性而不是嵌套的&lt;property/&gt;元素来描述属性值，\n&lt;bean name&#x3D;&quot;classic&quot; class&#x3D;&quot;com.example.ExampleBean&quot;&gt;\n    &lt;property name&#x3D;&quot;email&quot; value&#x3D;&quot;[emailprotected]&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n&lt;bean name&#x3D;&quot;p-namespace&quot; class&#x3D;&quot;com.example.ExampleBean&quot;\n    p:email&#x3D;&quot;[emailprotected]&quot;&#x2F;&gt;\n\n第二个 bean 定义使用p:spouse-ref=&quot;jane&quot;作为属性来执行完全相同的操作。在这种情况下，spouse是属性名称，而-ref部分表示这不是一个直接值，而是对另一个 bean 的引用。\n&lt;bean name&#x3D;&quot;john-classic&quot; class&#x3D;&quot;com.example.Person&quot;&gt;\n    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;John Doe&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;spouse&quot; ref&#x3D;&quot;jane&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n&lt;bean name&#x3D;&quot;john-modern&quot;\n      class&#x3D;&quot;com.example.Person&quot;\n      p:name&#x3D;&quot;John Doe&quot;\n      p:spouse-ref&#x3D;&quot;jane&quot;&#x2F;&gt;\n\n&lt;bean name&#x3D;&quot;jane&quot; class&#x3D;&quot;com.example.Person&quot;&gt;\n    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;Jane Doe&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n\n\n\n\n\n\n\n\n\np 命名空间不如标准 XML 格式灵活。例如，用于声明属性引用的格式与以Ref结尾的属性发生冲突，而标准 XML 格式则没有。\n7.7 集合属性@Data\n@Builder(toBuilder &#x3D; true)\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User &#123;\n    private Integer id;\n    private Integer age;\n    private String name;\n\n    private Teacher teacher;\n\n    private List&lt;String&gt; hobby;\n    \n    private Map&lt;String,String&gt; friend;\n\n    private Integer[] arr;\n&#125;\n\n&lt;bean id&#x3D;&quot;user6&quot; class&#x3D;&quot;com.hrenxiang.pojo.User&quot;&gt;\n        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;jj&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;21&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;hobby&quot;&gt;\n            &lt;list&gt;\n                &lt;value&gt;123&lt;&#x2F;value&gt;\n                &lt;value&gt;456&lt;&#x2F;value&gt;\n                &lt;value&gt;789&lt;&#x2F;value&gt;\n            &lt;&#x2F;list&gt;\n        &lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n\n其他变换形式\n&lt;!-- 使用set标签也能实现相同效果，只是附带了去重功能 --&gt;\n&lt;bean id&#x3D;&quot;user6&quot; class&#x3D;&quot;com.hrenxiang.pojo.User&quot;&gt;\n        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;jj&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;21&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;hobby&quot;&gt;\n            &lt;set&gt;\n                &lt;value&gt;456&lt;&#x2F;value&gt;\n                &lt;value&gt;456&lt;&#x2F;value&gt;\n                &lt;value&gt;123&lt;&#x2F;value&gt;\n                &lt;value&gt;789&lt;&#x2F;value&gt;\n            &lt;&#x2F;set&gt;\n        &lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n\n&lt;!-- array也同样兼容 --&gt;\n&lt;bean id&#x3D;&quot;user6&quot; class&#x3D;&quot;com.hrenxiang.pojo.User&quot;&gt;\n        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;jj&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;21&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;arr&quot;&gt;\n            &lt;array&gt;\n                &lt;value&gt;456&lt;&#x2F;value&gt;\n                &lt;value&gt;456&lt;&#x2F;value&gt;\n                &lt;value&gt;123&lt;&#x2F;value&gt;\n                &lt;value&gt;789&lt;&#x2F;value&gt;\n            &lt;&#x2F;array&gt;\n        &lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n\n&lt;!-- 给Map类型的属性赋值 --&gt;\n&lt;bean id&#x3D;&quot;user6&quot; class&#x3D;&quot;com.hrenxiang.pojo.User&quot;&gt;\n        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;jj&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;21&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;friend&quot;&gt;\n            &lt;map&gt;\n                &lt;entry key&#x3D;&quot;3&quot; value&#x3D;&quot;gg&quot;&#x2F;&gt;\n                &lt;entry key&#x3D;&quot;1&quot; value&#x3D;&quot;ll&quot;&#x2F;&gt;\n                &lt;entry key&#x3D;&quot;2&quot; value&#x3D;&quot;pp&quot;&#x2F;&gt;\n            &lt;&#x2F;map&gt;\n        &lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n\n7.8 集合类型的Beanutil:list id&#x3D;&quot;teacher3&quot;&gt;\n        &lt;bean class&#x3D;&quot;com.hrenxiang.pojo.Teacher&quot;&gt;\n            &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;qq&quot;&#x2F;&gt;\n            &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;56&quot;&#x2F;&gt;\n        &lt;&#x2F;bean&gt;\n        &lt;bean class&#x3D;&quot;com.hrenxiang.pojo.Teacher&quot;&gt;\n            &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;ww&quot;&#x2F;&gt;\n            &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;56&quot;&#x2F;&gt;\n        &lt;&#x2F;bean&gt;\n        &lt;bean class&#x3D;&quot;com.hrenxiang.pojo.Teacher&quot;&gt;\n            &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;ee&quot;&#x2F;&gt;\n            &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;56&quot;&#x2F;&gt;\n        &lt;&#x2F;bean&gt;\n&lt;&#x2F;util:list&gt;\n\n测试方法\n@Test\npublic void testDemo11()&#123;\n        ClassPathXmlApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);\n        \n        List&lt;Teacher&gt; teacherList &#x3D; (List&lt;Teacher&gt;) applicationContext.getBean(&quot;teacher3&quot;);\n        \n        System.out.println(teacherList);\n    &#125;\n\n\n\n\n08. 自动装配模式★★★\n\n\n\n\n\n\n\n\n顶级&lt;beans/&gt;元素在其default-autowire-candidates属性内接受一个或多个模式\n通过将 Bean 标签中的 autowire 属性定义为以下4中模式中的一个，来确定装配类型\n通过将 Bean 定义的autowire-candidate属性设置为false来避免自动装配。\nautowire-candidate属性旨在仅影响基于类型的自动装配。它不会影响名称的显式引用，即使指定的 bean 未标记为自动装配候选，名称也将得到解析。因此，如果名称匹配，按名称自动装配仍将注入 Bean。\n只用注解的方式时，注解默认是使用byType的！\n\n\n\nMode\nExplanation\n\n\n\nno\n(默认)无自动装配。 Bean 引用必须通过ref元素定义。对于大型部署，建议不要更改默认设置，因为明确指定协作者可以提供更好的控制和清晰度。在某种程度上，它记录了系统的结构。\n\n\nbyName\n按属性名称自动布线。 Spring 寻找与需要自动装配的属性同名的 bean。例如，如果将一个 bean 定义设置为按名称自动装配，并且包含一个* master 属性(即，它具有一个 setMaster(..)*方法)，那么 Spring 将查找一个名为master的 bean 定义，并使用它来设置属性。\n\n\nbyType\n如果容器中恰好存在一个该属性类型的 bean，则允许自动装配该属性。如果存在多个错误，则会引发致命异常，这表明您可能不对该 bean 使用* byType *自动装配。如果没有匹配的 bean，则什么也没有发生。该属性未设置。\n\n\nconstructor\n与* byType *类似，但适用于构造函数参数。如果容器中不存在构造函数参数类型的一个 bean，则将引发致命错误。\n\n\n代码实现\npublic interface MyWork &#123;\n    public void doWork();\n&#125;\n\npublic class MyWorkImpl implements MyWork &#123;\n    @Override\n    public void doWork() &#123;\n        System.out.println(&quot;zuo jia wu ！！！&quot;);\n    &#125;\n&#125;\n\npublic class MyWorkService &#123;\n    private MyWorkImpl myWorkImpl;\n\n    public MyWorkImpl returnMy() &#123;\n        return myWorkImpl;\n    &#125;\n\n    public void setMyWork(MyWorkImpl myWorkImpl) &#123;\n        this.myWorkImpl &#x3D; myWorkImpl;\n    &#125;\n\n    public MyWorkImpl getMyWork() &#123;\n        return myWorkImpl;\n    &#125;\n&#125;\n\n&lt;bean id&#x3D;&quot;myWorkImpl&quot; class&#x3D;&quot;com.hrenxiang.ioc.impl.MyWorkImpl&quot;&#x2F;&gt;\n\n\n&lt;!-- 使用bean标签的autowire属性设置自动装配效果 --&gt;\n&lt;!-- byType表示根据类型进行装配，此时如果类型匹配的bean不止一个，那么会抛NoUniqueBeanDefinitionException --&gt;\n&lt;!-- byName表示根据bean的id进行匹配。而bean的id是根据需要装配组件的属性的属性名来确定的 --&gt;\n&lt;bean id&#x3D;&quot;myWorkService&quot; class&#x3D;&quot;com.hrenxiang.service.MyWorkService&quot; autowire&#x3D;&quot;byName&quot;&gt;\n    &lt;!--&lt;property name&#x3D;&quot;myWorkImpl&quot; ref&#x3D;&quot;myWorkImpl&quot;&#x2F;&gt;--&gt;\n&lt;&#x2F;bean&gt;\n\n@Test\n    public void test2()&#123;\n        ClassPathXmlApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);\n        MyWorkService myWorkService &#x3D; applicationContext.getBean(&quot;myWorkService&quot;, MyWorkService.class);\n        myWorkService.getMyWork().doWork();\n    &#125;\n\n8.1 FactoryBean机制\n\n\n\n\n\n\n\n\nFactoryBean是Spring提供的一种整合第三方框架的常用机制。和普通的bean不同，配置一个FactoryBean类型的bean，在获取bean的时候得到的并不是class属性中配置的这个类的对象，而是getObject()方法的返回值。通过这种机制，Spring可以帮我们把复杂组件创建的详细过程和繁琐细节都屏蔽起来，只把最简洁的使用界面展示给我们。\n将来我们整合Mybatis时，Spring就是通过FactoryBean机制来帮我们创建SqlSessionFactory对象的。\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Work &#123;\n    private String workName;\n&#125;\n\npublic class WorkFactoryBean implements FactoryBean&lt;Work&gt; &#123;\n\n    private String workName;\n\n    public String getWorkName() &#123;\n        return workName;\n    &#125;\n\n    public void setWorkName(String workName) &#123;\n        this.workName &#x3D; workName;\n    &#125;\n\n    @Override\n    public Work getObject() throws Exception &#123;\n        Work work &#x3D; new Work();\n        work.setWorkName(&quot;JavaProgrammer&quot;);\n        return work;\n    &#125;\n\n    @Override\n    public Class&lt;?&gt; getObjectType() &#123;\n        return Work.class;\n    &#125;\n&#125;\n\n&lt;bean id&#x3D;&quot;workFactoryBean&quot; class&#x3D;&quot;com.hrenxiang.ioc.WorkFactoryBean&quot;&gt;\n        &lt;property name&#x3D;&quot;workName&quot; value&#x3D;&quot;teacher&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n@Test\n    public void test3()&#123;\n        ClassPathXmlApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);\n\n        &#x2F;*Bean named &#39;workFactoryBean&#39; is expected to be of type &#39;com.hrenxiang.ioc.WorkFactoryBean&#39; but was actually of type &#39;com.hrenxiang.ioc.Work&#39;*&#x2F;\n        &#x2F;*WorkFactoryBean workFactoryBean &#x3D; applicationContext.getBean(&quot;workFactoryBean&quot;, WorkFactoryBean.class);\n        System.out.println(workFactoryBean);*&#x2F;\n        \n        Work work &#x3D; applicationContext.getBean(&quot;workFactoryBean&quot;, Work.class);\n        System.out.println(work);\n    &#125;\n\n8.2 使用注解 @Autowired\n\n\n\n\n\n\n\n\n使用注解 @Autowired 其实还是手动装配，因为使用这个注解后，我们在代码中查询自动装配类型时，返回的是0,而0在自动装配类型中代表的是 no ，所以说，此注解，并不是通过自动装配模式装配的，它使用的是一种变种的setter注入的方式\n\n09. lazy-Init 延迟加载\n关闭延迟加载(默认状态) ：ApplicationContext 容器的默认⾏为是在启动服务器时将所有 singleton bean 提前进⾏实例化\n开启延迟加载：bean 将不会在 ApplicationContext 启动时提前被实例化，⽽是第⼀次向容器通过 getBean 索取 bean 时实例化的。\n在  设置 lazy-init=”true”，控制单个 bean\n在  设置 default-lazy-init=”true” ，控制该容器下所有 bean\n\n\n\n作用：\n\n开启延迟加载⼀定程度提⾼容器启动和运转性能\n对于不常使⽤的 Bean 设置延迟加载，这样偶尔使⽤的时候再加载，不必要从⼀开始该 Bean 就占⽤资源\n\n\n10. Bean的作用域在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围，各取值含义参加下表：\n\n\n\n取值\n含义\n创建对象的时机\n\n\n\nsingleton\n在IOC容器中，这个bean的对象始终为单实例\nIOC容器初始化时\n\n\nprototype\n这个bean在IOC容器中有多个实例\n获取bean时\n\n\n如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）：\n\n\n\n取值\n含义\n\n\n\nrequest\n在一个请求范围内有效\n\n\nsession\n在一个会话范围内有效\n\n\n&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&gt;\n&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt;\n&lt;bean id&#x3D;&quot;workFactoryBean2&quot; class&#x3D;&quot;com.hrenxiang.ioc.WorkFactoryBean&quot; scope&#x3D;&quot;singleton&quot;&gt;\n        &lt;property name&#x3D;&quot;workName&quot; value&#x3D;&quot;teacher&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n@Test\npublic void test4()&#123;\n        ClassPathXmlApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);\n\n        &#x2F;*scope&#x3D;&quot;prototype&quot;  false  true*&#x2F;\n        &#x2F;*scope&#x3D;&quot;singleton&quot;  true   true*&#x2F;\n        Work work1 &#x3D; applicationContext.getBean(&quot;workFactoryBean2&quot;, Work.class);\n        Work work2 &#x3D; applicationContext.getBean(&quot;workFactoryBean2&quot;, Work.class);\n        System.out.println(work1&#x3D;&#x3D;work2);\n    \t&#x2F;*记得重写equals方法，否则默认调用object的，比较的还是地址值*&#x2F;\n        System.out.println(work1.equals(work2));\n    &#125;\n\n单例bean的优势由于不会每次都新创建新对象所以有一下几个性能上的优势：\n1.减少了新生成实例的消耗\n新生成实例消耗包括两方面，第一，spring会通过反射或者cglib来生成bean实例这都是耗性能的操作，其次给对象分配内存也会涉及复杂算法。\n2.减少jvm垃圾回收\n由于不会给每个请求都新生成bean实例，所以自然回收的对象少了。\n3.可以快速获取到bean\n因为单例的获取bean操作除了第一次生成之外其余的都是从缓存里获取的所以很快。\n单例bean的劣势单例的bean一个很大的劣势就是他不能做到线程安全！！！，由于所有请求都共享一个bean实例，所以这个bean要是有状态的一个bean的话可能在并发场景下出现问题，而原型的bean则不会有这样问题（但也有例外，比如他被单例bean依赖），因为给每个请求都新创建实例。\n\n11. Bean的生命周期bean 为 singleton（单例模式）\n\n\n\n\n\n\n\n\n\n单例模式的 bean 对象生命周期与容器相同\nbean 为 prototype（多例模式）\n\n\n\n\n\n\n\n\n\n多例模式的 bean 对象，Spring 框架只负责创建，不负责销毁\n\n\n\n\n\n\n\n\n\n在传统Java应用中，bean生命周期很简单，使用Java关键字 new 进行Bean 的实例化，然后该Bean 就能够使用了。一旦bean不再被使用，则由Java自动进行垃圾回收。\n相比之下，Spring管理Bean的生命周期就复杂多了，正确理解Bean 的生命周期非常重要，因为Spring对Bean的管理可扩展性非常强，下面展示了一个Bean的构造过程。\n\n其中红框标记四个阶段的是基本阶段。\n蓝色标记的是针对所有Bean的扩展阶段，需定义BeanPostProcessor实现类并配置。\n未进行标记的是只针对当前Bean的阶段，需要当前Bean实现相应的接口。\n从上图可以看出，Bean生命周期的主要阶段包括：\n\nbean对象创建（调用无参构造器）\n给bean对象设置属性\nbean对象初始化之前操作（由bean的后置处理器负责）\nbean对象初始化（需在配置bean时指定初始化方法）\nbean对象初始化之后操作（由bean的后置处理器负责）\nbean对象就绪可以使用\nbean对象销毁（需在配置bean时指定销毁方法）\nIOC容器关闭\n\n\n12. 基于注解管理Bean\n\n\n\n\n\n\n\n\n情况一 在配置文件中开启注解 扫描（最基础，常用）\n&lt;context:component-scan base-package&#x3D;&quot;com.hrenxiang&quot;&#x2F;&gt;  &lt;!--烧苗hrenxiang包下的所有文件--&gt;\n\n\n\n\n\n\n\n\n\n\n指定要排除的组件或者也可以说指定不扫描的组件\n&lt;!-- 情况三：指定不扫描的组件 --&gt;\n&lt;context:component-scan base-package&#x3D;&quot;com.atguigu.ioc.component&quot;&gt;\n    &lt;!-- context:exclude-filter标签：指定排除规则 --&gt;\n    &lt;!-- type属性：指定根据什么来进行排除，annotation取值表示根据注解来排除 --&gt;\n    &lt;!-- expression属性：指定排除规则的表达式，对于注解来说指定全类名即可 --&gt;\n\t&lt;context:exclude-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Controller&quot;&#x2F;&gt;\n&lt;&#x2F;context:component-scan&gt;\n\n\n\n\n\n\n\n\n\n仅扫描指定组件\n&lt;!-- 情况四：仅扫描指定的组件 --&gt;\n&lt;!-- 仅扫描 &#x3D; 关闭默认规则 + 追加规则 --&gt;\n&lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;\n&lt;context:component-scan base-package&#x3D;&quot;com.atguigu.ioc.component&quot; use-default-filters&#x3D;&quot;false&quot;&gt;\n\t&lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt;\n\t&lt;context:include-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Controller&quot;&#x2F;&gt;\n&lt;&#x2F;context:component-scan&gt;\n12.1 @Component\n\n\n\n\n\n\n\n\n下面是@Component 的三衍生注解 (功能目前来讲是一致的) (作用在类上)\n把普通pojo实例化到spring容器中，相当于配置文件中的 \n①默认情况类名首字母小写就是bean的id。例如：SoldierController类对应的bean的id就是soldierController。\n②使用value属性指定 —– 当注解中只设置一个属性时，value属性的属性名可以省略\n@Controller(value &#x3D; &quot;tianDog&quot;)\npublic class SoldierController &#123;\n&#125;\n\n@Service(&quot;smallDog&quot;)\npublic class SoldierService &#123;\n&#125;\n\n\n\n注解\n作用\n\n\n\n@Controller\n标明WEB 层\n\n\n@Service\n标明业务层\n\n\n@Repository\n标明持久层\n\n\n@Repository(value &#x3D; &quot;happyComponentDao&quot;)\npublic class HappyComponentDaoImpl implements HappyComponentDao &#123;\n    @Override\n    public void doWork() &#123;\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;HappyComponentDaoImpl&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n    &#125;\n&#125;\n\n@Service(value &#x3D; &quot;happyComponentService1&quot;)\npublic class HappyComponentServiceImpl implements HappyComponentService &#123;\n    \n    @Autowired\n    private HappyComponentDao happyComponentDao;\n\n    @Override\n    public void doWork() &#123;\n        this.happyComponentDao.doWork();\n    &#125;\n&#125;\n\n@Service(value &#x3D; &quot;happyComponentService2&quot;)\npublic class HappyComponentServiceImpl2 implements HappyComponentService &#123;\n    @Autowired\n    private HappyComponentDao happyComponentDao;\n\n    @Override\n    public void doWork() &#123;\n        this.happyComponentDao.doWork();\n    &#125;\n&#125;\n\n@Controller(value &#x3D; &quot;controller&quot;)\npublic class HappyComponentController &#123;\n\n    @Autowired\n    &#x2F;*@Qualifier(value &#x3D; &quot;happyComponentService1&quot;)*&#x2F;\n    @Resource(name &#x3D; &quot;happyComponentService1&quot;)\n    private HappyComponentService happyComponentService;\n\n    public void doWork()&#123;\n        this.happyComponentService.doWork();\n    &#125;\n&#125;\n\n12.2 @Qualifier @Resource\n\n\n\n\n\n\n\n\n按名称注入\n@Qualifier：当一个接口有多个实现的时候，为了指名具体调用哪个类的实现。\n@Resource: 可以通过 byName 和 byType的方式注入， 默认先按 byName的方式 (通过id) 进行匹配，如果匹配不到，再按 byType的方式进行匹配。 \n12.3 @Value\n\n\n\n\n\n\n\n\n用于注入普通类型\n@Component\npublic class UserDao &#123;\n\n    @Value(&quot;hh&quot;)\n    private String name;\n\n    public void test()&#123;\n        System.out.println(name);\n    &#125;\n&#125;\n\n12.4 @Autowired\n\n\n\n\n\n\n\n\n自动装配：默认按类型进行装配.\n在成员变量上直接标记@Autowired注解即可，不需要提供setXxx()方法。\n\n首先根据所需要的组件类型到IOC容器中查找\n\n\t能够找到唯一的bean：直接执行装配\n\n\t如果完全找不到匹配这个类型的bean：装配失败\n\n\t和所需类型匹配的bean不止一个\n\n\t\t没有@Qualifier注解：根据@Autowired标记位置成员变量的变量名作为bean的id进行匹配\n\n            能够找到：执行装配\n            找不到：装配失败\n            \n        使用@Qualifier注解：根据@Qualifier注解中指定的名称作为bean的id进行匹配\n\n            能够找到：执行装配\n            找不到：装配失败\n\n\n\n\n\n\n\n\n\n\n佛系装配\n给@Autowired注解设置required = false属性表示：能装就装，装不上就不装。但是实际开发时，基本上所有需要装配组件的地方都是必须装配的，用不上这个属性。\n\n13. 整合Juint4\n\n\n\n\n\n\n\n\n导入依赖\n&lt;!-- Spring的测试包 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.3.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\n\n\n\n\n\n\n\n编写测试代码\n@ContextConfiguration(value &#x3D; &#123;&quot;classpath:applicationContext.xml&quot;&#125;)\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class TestCalculator &#123;\n\n    @Autowired\n    private Calculator calculator;\n\n    @Test\n    public void testDemo()&#123;\n        calculator.add(10,20);\n\n        System.out.println(&quot;\\n&quot;);\n\n        &#x2F;*calculator.div(10,0);*&#x2F;\n        calculator.sub(100,500);\n\n        System.out.println(&quot;\\n&quot;);\n\n        calculator.abc();\n    &#125;","slug":"49-Spring-基础与IOC","date":"2021-09-13T15:26:32.000Z","categories_index":"Spring","tags_index":"Spring","author_index":"大黄"},{"id":"cd7729b360a46c66a0dd34df45ad5b41","title":"Mybatis 逆向工程","content":"8. 补充（逆向工程）8.1 概念概念\n    正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的。\n\n    逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：\n            Java实体类\n            Mapper接口\n            Mapper配置文件\n\n8.2 基本原理\n8.3 配置POM文件&lt;!-- 依赖MyBatis核心包 --&gt;\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;3.5.7&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n    \n&lt;!-- 控制Maven在构建过程中相关配置 --&gt;\n&lt;build&gt;\n        \n    &lt;!-- 构建过程中用到的插件 --&gt;\n    &lt;plugins&gt;\n        \n        &lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;1.3.0&lt;&#x2F;version&gt;\n    \n            &lt;!-- 插件的依赖 --&gt;\n            &lt;dependencies&gt;\n                \n                &lt;!-- 逆向工程的核心依赖 --&gt;\n                &lt;dependency&gt;\n                    &lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt;\n                    &lt;artifactId&gt;mybatis-generator-core&lt;&#x2F;artifactId&gt;\n                    &lt;version&gt;1.3.2&lt;&#x2F;version&gt;\n                &lt;&#x2F;dependency&gt;\n                    \n                &lt;!-- 数据库连接池 --&gt;\n                &lt;dependency&gt;\n                    &lt;groupId&gt;com.mchange&lt;&#x2F;groupId&gt;\n                    &lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt;\n                    &lt;version&gt;0.9.2&lt;&#x2F;version&gt;\n                &lt;&#x2F;dependency&gt;\n                    \n                &lt;!-- MySQL驱动 --&gt;\n                &lt;dependency&gt;\n                    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n                    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n                    &lt;version&gt;5.1.8&lt;&#x2F;version&gt;\n                &lt;&#x2F;dependency&gt;\n            &lt;&#x2F;dependencies&gt;\n        &lt;&#x2F;plugin&gt;\n    &lt;&#x2F;plugins&gt;\n&lt;&#x2F;build&gt;\n\n8.4 MBG配置文件文件名必须是：generatorConfig.xml\n\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE generatorConfiguration\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD MyBatis Generator Configuration 1.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-generator-config_1_0.dtd&quot;&gt;\n&lt;generatorConfiguration&gt;\n    &lt;!--\n            targetRuntime: 执行生成的逆向工程的版本\n                    MyBatis3Simple: 生成基本的CRUD（清新简洁版）\n                    MyBatis3: 生成带条件的CRUD（奢华尊享版）\n     --&gt;\n    &lt;context id&#x3D;&quot;DB2Tables&quot; targetRuntime&#x3D;&quot;MyBatis3&quot;&gt;\n        &lt;!-- 数据库的连接信息 --&gt;\n        &lt;jdbcConnection driverClass&#x3D;&quot;com.mysql.jdbc.Driver&quot;\n                        connectionURL&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;192.168.198.100:3306&#x2F;mybatis-example&quot;\n                        userId&#x3D;&quot;root&quot;\n                        password&#x3D;&quot;atguigu&quot;&gt;\n        &lt;&#x2F;jdbcConnection&gt;\n        &lt;!-- javaBean的生成策略--&gt;\n        &lt;javaModelGenerator targetPackage&#x3D;&quot;com.atguigu.mybatis.entity&quot; targetProject&#x3D;&quot;.\\src\\main\\java&quot;&gt;\n            &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;\n            &lt;property name&#x3D;&quot;trimStrings&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;\n        &lt;&#x2F;javaModelGenerator&gt;\n        &lt;!-- SQL映射文件的生成策略 --&gt;\n        &lt;sqlMapGenerator targetPackage&#x3D;&quot;com.atguigu.mybatis.mapper&quot;  targetProject&#x3D;&quot;.\\src\\main\\java&quot;&gt;\n            &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;\n        &lt;&#x2F;sqlMapGenerator&gt;\n        &lt;!-- Mapper接口的生成策略 --&gt;\n        &lt;javaClientGenerator type&#x3D;&quot;XMLMAPPER&quot; targetPackage&#x3D;&quot;com.atguigu.mybatis.mapper&quot;  targetProject&#x3D;&quot;.\\src\\main\\java&quot;&gt;\n            &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;\n        &lt;&#x2F;javaClientGenerator&gt;\n        &lt;!-- 逆向分析的表 --&gt;\n        &lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;\n        &lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;\n        &lt;table tableName&#x3D;&quot;t_emp&quot; domainObjectName&#x3D;&quot;Employee&quot;&#x2F;&gt;\n        &lt;table tableName&#x3D;&quot;t_customer&quot; domainObjectName&#x3D;&quot;Customer&quot;&#x2F;&gt;\n        &lt;table tableName&#x3D;&quot;t_order&quot; domainObjectName&#x3D;&quot;Order&quot;&#x2F;&gt;\n    &lt;&#x2F;context&gt;\n&lt;&#x2F;generatorConfiguration&gt;\n\n8.5 执行MBG插件的generate目标\n8.6 效果（自动生成下述文件）\n8.7 QBC查询想了解去百度\n","slug":"48-Mybatis-逆向工程","date":"2021-09-13T15:25:32.000Z","categories_index":"Mybatis","tags_index":"Mybatis","author_index":"大黄"},{"id":"14472dd3b23cbe4f0d4e64f3f2df1f1f","title":"Mybatis 装饰底层","content":"1. 装饰器模式装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。\n这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。\n我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。\n1.1 介绍意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。\n主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。\n何时使用：在不想增加很多子类的情况下扩展类。\n优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。\n缺点：多层装饰比较复杂。\n使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。\n注意事项：可代替继承。\n1.2 案例演示准备环境\n    1. 编写一个Star接口, 提供sing 和 dance抽象方法\n    2. 编写一个LiuDeHua类,实现Star接口,重写抽象方法\n\npublic interface Star &#123;\n    public void sing();\n    public void dance();\n&#125;\n\npublic class LiuDeHua implements Star &#123;\n    @Override\n    public void sing() &#123;\n        System.out.println(&quot;刘德华在唱忘情水...&quot;);\n    &#125;\n    @Override\n    public void dance() &#123;\n        System.out.println(&quot;刘德华在跳街舞...&quot;);\n    &#125;\n&#125;\n\n需求\n\n\t在不改变原类的基础上对LiuDeHua类的sing方法进行扩展\n\n实现步骤\n\n    1. 编写一个LiuDeHuaWarpper类, 实现Star接口,重写抽象方法\n    2. 提供LiuDeHuaWarpper类的有参构造, 传入LiuDeHua类对象\n    3. 在LiuDeHuaWarpper类中对需要增强的sing方法进行增强\n    4. 在LiuDeHuaWarpper类对不需要增强的方法调用LiuDeHua类中的同名方法\n\n1.3 实现代码LiuDeHua类: 被装饰类。\nLiuDeHuaWarpper类: 我们称之为装饰类。\n&#x2F;*\n\t装饰模式遵循原则:\n\t\t装饰类和被装饰类必须实现相同的接口\n\t\t在装饰类中必须传入被装饰类的引用\n\t\t在装饰类中对需要扩展的方法进行扩展\n\t\t在装饰类中对不需要扩展的方法调用被装饰类中的同名方法\n*&#x2F;\npublic class LiuDeHuaWarpper implements Star &#123;\n    &#x2F;&#x2F; 存放被装饰类的引用\n    private LiuDeHua liuDeHua;\n    &#x2F;&#x2F; 通过构造器传入被装饰类对象\n    public LiuDeHuaWarpper(LiuDeHua liuDeHua)&#123;\n        this.liuDeHua &#x3D; liuDeHua;\n    &#125;\n    @Override\n    public void sing() &#123;\n        &#x2F;&#x2F; 对需要扩展的方法进行扩展增强\n        System.out.println(&quot;刘德华在鸟巢的舞台上演唱忘情水.&quot;);\n    &#125;\n    @Override\n    public void dance() &#123;\n        &#x2F;&#x2F; 不需要增强的方法调用被装饰类中的同名方法\n        liuDeHua.dance();\n    &#125;\n&#125;\n\n1.4 测试结果public static void main(String[] args) &#123;\n    &#x2F;&#x2F; 创建被装饰类对象\n    LiuDeHua liuDeHua &#x3D; new LiuDeHua();\n    &#x2F;&#x2F; 创建装饰类对象,被传入被装饰类\n    LiuDeHuaWarpper liuDeHuaWarpper &#x3D; new LiuDeHuaWarpper(liuDeHua);\n    &#x2F;&#x2F; 调用装饰类的相关方法,完成方法扩展\n    liuDeHuaWarpper.sing();\n    liuDeHuaWarpper.dance();\n&#125;\n\n2. 装饰模式小结装饰模式可以在不改变原类的基础上对类中的方法进行扩展增强,实现原则为:\n\n装饰类和被装饰类必须实现相同的接口\n在装饰类中必须传入被装饰类的引用\n在装饰类中对需要扩展的方法进行扩展\n在装饰类中对不需要扩展的方法调用被装饰类中的同名方法\n\n3. Mybatis四大对象3.1 概述\nStatementHandler：处理sql语句预编译，设置参数等相关工作\nParameterHandler：设置预编译参数用的\nResultSetHandler：处理结果集 \nExecutor：它是一个执行器，真正进行java与数据库交互的对象\n\n3.2 具体Executor对象在创建Configuration对象的时候创建，并且缓存在Configuration对象里，负责管理一级缓存和二级缓存，并提供是事务管理的相关操作。\nExecutor对象的主要功能是调用StatementHandler访问数据库，并将查询结果存入缓存中（如果配置了缓存的话)。\nStatementHandler首先通过ParammeterHandler完成SQL的实参绑定，然后通过java.sql.Statement对象执行sql语句并得到结果集ResultSet，最后通过ResultSetHandler完成结果集的映射，得到对象并返回\n\n3.3 Executor每一个 SqlSession 都会拥有一个Executor 对象，这个对象负责增删改查的具体操作，简单的将它理解为 JDBC 中 Statement 的封装版\n位于继承体系最顶层的是Executor执行器，它有两个实现类，分别是和BaseExecutor和CachingExecutor\nBaseExecutor\nBaseExecutor是一个抽象类，这种通过抽象的实现接口的方式是的体现，是Executor 的默认实现，实现了大部分 Executor 接口定义的功能，关于查询更新的具体实现由其子类实现。️BaseExecutor 的子类有四个，分别是 SimpleExecutor、ReuseExecutor 、CloseExecutor 和 BatchExecutor\n\n\nSimpleExecutor\n  简单执行器，是 MyBatis 中默认使用的执行器，每执行一次 update 或 select，就开启一个Statement 对象，用完就直接关闭 Statement 对象(可以是 Statement 或者是 PreparedStatment 对象)\n\n\nReuseExecutor\n  可重用执行器，这里的重用指的是重复使用Statement，它会在内部使用一个 Map 把创建的Statement 都缓存起来，每次执行 SQL 命令的时候，都会去判断是否存在基于该 SQL 的 Statement 对象，如果存在Statement 对象并且对应的 connection 还没有关闭的情况下就继续使用之前的 Statement 对象，并将其缓存起来。因为每一个 SqlSession都有一个新的 Executor对象，所以我们缓存在 ReuseExecutor 上的 Statement作用域是同一个 SqlSession。\n\nCachingExecutor\n缓存执行器，先从缓存中查询结果，如果存在就返回之前的结果；如果不存在，再委托给&#96;Executor delegate&#96; 去数据库中取，delegate 可以是上面任何一个执行器。\n\nExecutor执行流程\n\n3.4 StatementHandlerStatementHandler主要负责操作Statement对象与数据库进行交互\n顶层负接口分别有两个实现 BaseStatementHandler 和 RoutingStatementHandler，而BaseStatementHandler分别有三个实现类SimpleStatementHandler、PreparedStatementHandler、CallableStatementHandler\nBaseStatementHandler\n它本身是一个抽象类，用于简化StatementHandler 接口实现的难度，属于适配器设计模式体现，它主要有三个实现类：\n&#96;SimpleStatementHandler&#96;\n\n  java.sql.Statement对象创建处理器，管理 Statement 对象并向数据库中推送不需要预编译的SQL语句。\n\n\n&#96;PreparedStatementHandler&#96;\n\n  java.sql.PrepareStatement对象的创建处理器，管理Statement对象并向数据中推送需要预编译的SQL语句。\n  \n  \n&#96;CallableStatementHandler&#96;\n\n  java.sql.CallableStatement对象的创建处理器，管理 Statement 对象并调用数据库中的存储过程。\n\n  注意：SimpleStatementHandler 和 PreparedStatementHandler 的区别是 SQL 语句是否包含变量。是否通过外部进行参数传入。SimpleStatementHandler 用于执行没有任何参数传入的 SQL，PreparedStatementHandler 需要对外部传入的变量和参数进行提前参数绑定和赋值。\n3.5 ParameterHandler相比于其他的组件就简单很多了，ParameterHandler 译为参数处理器，负责为 PreparedStatement 的 sql 语句参数动态赋值，这个接口很简单只有两个方法：\n\ngetParameterObject：用于读取参数\n\nsetParameters: 用于对 PreparedStatement 的参数赋值\n\npublic ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) &#123;\n    ParameterHandler parameterHandler &#x3D; mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);\n    parameterHandler &#x3D; (ParameterHandler) interceptorChain.pluginAll(parameterHandler);\n    return parameterHandler;\n  &#125;\n\n3.6 ResultSetHandler&#96;ResultSetHandler&#96; 也很简单，它只有一个实现类&#96;DefaultResultSetHandler&#96;，主要负责处理两件事\n\n* 处理 Statement 执行后产生的结果集，生成结果列表。\n* 处理存储过程执行后的输出参数\n\npublic ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,\n      ResultHandler resultHandler, BoundSql boundSql) &#123;\n    ResultSetHandler resultSetHandler &#x3D; new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);\n    resultSetHandler &#x3D; (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);\n    return resultSetHandler;\n  &#125;\n\n\n\n4. Mybatis查询过程1.根据配置文件(全局，sql映射)初始化出Configuration对象\n\n2.创建一个DefaultSqlSession对象，它里面包含Configuration以及Executor(根据全局配置文件的defaultExecutorType创建出对应的Executor)\n\n3.DefaultSqlSession.getMapper()拿到Mapper接口对应的MapperProxy\n\n4.MapperProxy里面有DefaultSqlSession\n\n5.执行增删改查方法：\n    (代理对象)调用DefaultSqlSession的增删改查(Executor)\n    创建一个StatementHandler对象，同时也创建ParameterHandler和ResultSetHandler\n    调用StatementHandler的预编译参数（使用ParameterHandler设置参数值）\n    调用StatementHandler的增删改查方法\n    ResultSetHandler封装结果\n\n\n\n\n\n\n\n\n\n\n注意\n四大对象每个创建的时候都有一个interceptorChain.pluginAll(parameterHandler),每个对象不是直接返回的，而是调用\ninterceptorChain.pluginAll()，获取到所有的Interceptor，调用interceptor.plugin(target)，返回target包装后的对象\n插件机制：可以使用插件为目标对象创建一个代理对象，代理对象会拦截每一个对象的执行。\n5. Mybatis插件机制5.1 Mybatis插件原理1.Mybatis的插件借助于责任链的模式进行对拦截的处理\n\n2.使用动态代理对目标对象进行包装，达到拦截的目的\n\n3.作用于Mybatis的作用域对象之上\n\n以ParameterHandler 来说\npublic ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object object, BoundSql sql, InterceptorChain interceptorChain)&#123;\n       ParameterHandler parameterHandler &#x3D; mappedStatement.getLang().createParameterHandler(mappedStatement,object,sql);\n       parameterHandler &#x3D; (ParameterHandler) interceptorChain.pluginAll(parameterHandler);\n       return parameterHandler;\n   &#125;\n\npublic Object pluginAll(Object target) &#123;\n    for (Interceptor interceptor : interceptors) &#123;\n      target &#x3D; interceptor.plugin(target);\n    &#125;\n    return target;\n  &#125;\n\ninterceptorChain 保存了所有的拦截器(interceptors)，是mybatis初始化的时候创建的。调用拦截器链中的拦截器依次的对目标进行拦截或增强。interceptor.plugin(target)中的target就可以理解为mybatis中的四大对象。返回的target是被重重代理后的对象。\n5.2 Mybatis插件接口-Interceptor1.Intercept方法，插件的核心方法\n\n2.使plugin方法，生成target的代理对象\n\n3.setProperties方法，传递插件所需参数\n\n5.3 总结1.遵循插件尽量不使用的原则，因为会修改底层设计\n\n2.插件是生成的层层代理对象的责任链模式，使用反射机制实现\n\n3.插件的编写要考虑全面，特别是多个插件层层代理的时候\n\n\n\n6. Mybatis总结\n\nMybatis环境所需依赖 ★\n配置\nMybatis全局配置\nMapper配置 ★\n\n\nMapper接口 ★\nAPI\nSqlSessionFactory\nSqlSession\n\n\nMBG ★\n缓存\n一级缓存\n二级缓存\n自带\nEHCache ☆\n\n\n\n\n原理\n把配置文件信息封装到Java对象中\n缓存底层机制\n四大接口\nMybatis底层是JDBC\n\n\n\n7. Mybatis思维导图总结的xmind思维导图\n","slug":"47-Mybatis-装饰底层","date":"2021-09-13T15:24:32.000Z","categories_index":"Mybatis","tags_index":"Mybatis","author_index":"大黄"},{"id":"381bed42b31a39fe0a5eda0244c8a085","title":"Mybatis 延迟缓存","content":"1. 延迟加载延迟加载：先从单表查询、需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。也叫懒加载。\nresultMap可以实现高级映射（使用&#96;association&#96;、&#96;collection&#96;实现一对一及一对多映射），&#96;association&#96;、&#96;collection&#96;具备延迟加载功能。\n\n2. 延迟加载配置2.1 较低版本在Mybatis全局配置文件中配置settings\n&lt;!-- 使用settings对Mybatis全局进行设置 --&gt;\n&lt;settings&gt;\n    &lt;!-- 开启延迟加载功能：需要配置两个配置项 --&gt;\n    &lt;!-- 1、将lazyLoadingEnabled设置为true，开启懒加载功能 --&gt;\n    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;\n    &lt;!-- 2、将aggressiveLazyLoading设置为false，关闭“积极的懒加载” --&gt;\n    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;\n&lt;/settings&gt;\n\n2.2 较高版本&lt;!-- Mybatis全局配置 --&gt;\n&lt;settings&gt;\n    &lt;!-- 开启延迟加载功能 --&gt;\n    &lt;setting name&#x3D;&quot;lazyLoadingEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n&lt;&#x2F;settings&gt;\n\n3. 实例CustomerMapper.xml\n\n&lt;resultMap id&#x3D;&quot;customerMap2&quot; type&#x3D;&quot;customer&quot;&gt;\n   &lt;id column&#x3D;&quot;customer_id&quot; property&#x3D;&quot;customerId&quot;&#x2F;&gt;\n   &lt;result column&#x3D;&quot;customer_name&quot; property&#x3D;&quot;customerName&quot;&#x2F;&gt;\n   &lt;collection property&#x3D;&quot;orderList&quot; select&#x3D;&quot;com.hrenxiang.mapper.OrderMapper.selectOrderByCustomerId&quot;\n               column&#x3D;&quot;customer_id&quot;&gt;\n   &lt;&#x2F;collection&gt;\n&lt;&#x2F;resultMap&gt;\n\nOrderMapper.xml\n\n&lt;select id&#x3D;&quot;selectOrderByCustomerId&quot; resultType&#x3D;&quot;order&quot;&gt;\n        select order_id, order_name\n        from t_order\n        where customer_id2 &#x3D; #&#123;cusomerId&#125;\n&lt;&#x2F;select&gt;\n\njunit\n\n\tCustomerMapper mapper &#x3D; sqlSession.getMapper(CustomerMapper.class);\n    Customer customer &#x3D; mapper.selectCustomerWithOrderList2(1);\n\n    System.out.println(customer.getCustomerId());\n    System.out.println(customer.getCustomerName());\n    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n    System.out.println(customer.getOrderList());\n\n从控制台打印的日志来看，第一次执行，我们只调用了customer里的方法，而当调用customer中的订单列表时，我们又进行了一次查询\nconsle\n\nDEBUG 07-11 23:51:18,254 &#x3D;&#x3D;&gt;  Preparing: select customer_id, customer_name from t_customer where customer_id &#x3D; ?   (BaseJdbcLogger.java:159) \nDEBUG 07-11 23:51:18,317 &#x3D;&#x3D;&gt; Parameters: 1(Integer)  (BaseJdbcLogger.java:159) \nDEBUG 07-11 23:51:18,370 &lt;&#x3D;&#x3D;      Total: 1  (BaseJdbcLogger.java:159) \n1\nc01\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;   \nDEBUG 07-11 23:51:18,371 &#x3D;&#x3D;&gt;  Preparing: select order_id, order_name from t_order where customer_id2 &#x3D; ?   (BaseJdbcLogger.java:159) \nDEBUG 07-11 23:51:18,372 &#x3D;&#x3D;&gt; Parameters: 1(Integer)  (BaseJdbcLogger.java:159) \nDEBUG 07-11 23:51:18,375 &lt;&#x3D;&#x3D;      Total: 3  (BaseJdbcLogger.java:159) \n[Order(orderId&#x3D;1, orderName&#x3D;o1, customerId2&#x3D;null, customer&#x3D;null), Order(orderId&#x3D;2, orderName&#x3D;o2, customerId2&#x3D;null, customer&#x3D;null), Order(orderId&#x3D;3, orderName&#x3D;o3, customerId2&#x3D;null, customer&#x3D;null)]\n\n\n\n\n4. 查询缓存mybatis提供查询缓存，用于减轻数据压力，提高数据库性能。\nmybaits提供一级缓存，和二级缓存。\n\n一级缓存是SqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。\n二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。\n为什么要用缓存？\n如果缓存中有数据就不用从数据库中获取，大大提高系统性能。\n5. 缓存查询顺序\n先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。\n如果二级缓存没有命中，再查询一级缓存\n如果一级缓存也没有命中，则查询数据库\nSqlSession关闭之前，一级缓存中的数据会写入二级缓存\n\n6. 缓存范围* 一级缓存：SqlSession级别\n\n* 二级缓存：SqlSessionFactory级别\n\n\n\n7. 一级缓存7.1 测试一级缓存@Test\npublic void testFirstLevelCache() &#123;\n    \n    EmployeeMapper mapper &#x3D; session.getMapper(EmployeeMapper.class);\n    \n    &#x2F;&#x2F; 1.第一次查询\n    Employee employee1 &#x3D; mapper.selectEmployeeById(2);\n    \n    System.out.println(&quot;employee1 &#x3D; &quot; + employee1);\n    \n    &#x2F;&#x2F; 2.第二次查询\n    Employee employee2 &#x3D; mapper.selectEmployeeById(2);\n    \n    System.out.println(&quot;employee2 &#x3D; &quot; + employee2);\n    \n    &#x2F;&#x2F; 3.经过验证发现，两次查询返回的其实是同一个对象\n    System.out.println(&quot;(employee2 &#x3D;&#x3D; employee1) &#x3D; &quot; + (employee2 &#x3D;&#x3D; employee1));\n    System.out.println(&quot;employee1.equals(employee2) &#x3D; &quot; + employee1.equals(employee2));\n    System.out.println(&quot;employee1.hashCode() &#x3D; &quot; + employee1.hashCode());\n    System.out.println(&quot;employee2.hashCode() &#x3D; &quot; + employee2.hashCode());\n    \n&#125;\n\nDEBUG 12-01 09:14:48,760 &#x3D;&#x3D;&gt;  Preparing: select emp_id,emp_name,emp_salary,emp_gender,emp_age from t_emp where emp_id&#x3D;?   (BaseJdbcLogger.java:145) \nDEBUG 12-01 09:14:48,804 &#x3D;&#x3D;&gt; Parameters: 2(Integer)  (BaseJdbcLogger.java:145) \nDEBUG 12-01 09:14:48,830 &lt;&#x3D;&#x3D;      Total: 1  (BaseJdbcLogger.java:145) \nemployee1 &#x3D; Employee&#123;empId&#x3D;2, empName&#x3D;&#39;AAAAAA&#39;, empSalary&#x3D;6666.66, empAge&#x3D;20, empGender&#x3D;&#39;male&#39;&#125;\nemployee2 &#x3D; Employee&#123;empId&#x3D;2, empName&#x3D;&#39;AAAAAA&#39;, empSalary&#x3D;6666.66, empAge&#x3D;20, empGender&#x3D;&#39;male&#39;&#125;\n(employee2 &#x3D;&#x3D; employee1) &#x3D; true\nemployee1.equals(employee2) &#x3D; true\nemployee1.hashCode() &#x3D; 1131645570\nemployee2.hashCode() &#x3D; 1131645570\n\n\n\n\n\n\n\n\n\n\n两个变量指向同一个对象\n7.2 一级缓存失效\n不是同一个SqlSession\n同一个SqlSession但是查询条件发生了变化\n同一个SqlSession两次查询期间执行了任何一次增删改操作\n同一个SqlSession两次查询期间手动清空了缓存\n同一个SqlSession两次查询期间提交了事务\n\n8. 二级缓存8.1 开启二级缓存功能在想要使用二级缓存的Mapper配置文件中加入cache标签\n&lt;mapper namespace=&quot;com.atguigu.mybatis.EmployeeMapper&quot;&gt;\n&lt;!-- 加入cache标签启用二级缓存功能 --&gt;\n&lt;cache/&gt;\n\n8.2 实体类支持序列化public class Employee implements Serializable &#123;\n\n8.3 测试@Test\npublic void testSecondLevelCacheExists() &#123;\n    SqlSession session &#x3D; factory.openSession();\n    \n    EmployeeMapper mapper &#x3D; session.getMapper(EmployeeMapper.class);\n    \n    Employee employee &#x3D; mapper.selectEmployeeById(2);\n    \n    System.out.println(&quot;employee &#x3D; &quot; + employee);\n    \n    &#x2F;&#x2F; 在执行第二次查询前，关闭当前SqlSession\n    session.close();\n    \n    &#x2F;&#x2F; 开启一个新的SqlSession\n    session &#x3D; factory.openSession();\n    \n    mapper &#x3D; session.getMapper(EmployeeMapper.class);\n    \n    employee &#x3D; mapper.selectEmployeeById(2);\n    \n    System.out.println(&quot;employee &#x3D; &quot; + employee);\n    \n    session.close();\n    \n&#125;\n\nDEBUG 12-01 09:44:27,057 Cache Hit Ratio [com.atguigu.mybatis.EmployeeMapper]: 0.0  (LoggingCache.java:62) \nDEBUG 12-01 09:44:27,459 &#x3D;&#x3D;&gt;  Preparing: select emp_id,emp_name,emp_salary,emp_gender,emp_age from t_emp where emp_id&#x3D;?   (BaseJdbcLogger.java:145) \nDEBUG 12-01 09:44:27,510 &#x3D;&#x3D;&gt; Parameters: 2(Integer)  (BaseJdbcLogger.java:145) \nDEBUG 12-01 09:44:27,536 &lt;&#x3D;&#x3D;      Total: 1  (BaseJdbcLogger.java:145) \nemployee &#x3D; Employee&#123;empId&#x3D;2, empName&#x3D;&#39;AAAAAA&#39;, empSalary&#x3D;6666.66, empAge&#x3D;20, empGender&#x3D;&#39;male&#39;&#125;\nDEBUG 12-01 09:44:27,622 Cache Hit Ratio [com.atguigu.mybatis.EmployeeMapper]: 0.5  (LoggingCache.java:62) \nemployee &#x3D; Employee&#123;empId&#x3D;2, empName&#x3D;&#39;AAAAAA&#39;, empSalary&#x3D;6666.66, empAge&#x3D;20, empGender&#x3D;&#39;male&#39;&#125;\n\n8.4 缓存命中率日志中打印的Cache Hit Ratio叫做缓存命中率\nCache Hit Ratio [com.atguigu.mybatis.EmployeeMapper]: 0.0（0/1)\nCache Hit Ratio [com.atguigu.mybatis.EmployeeMapper]: 0.5（1/2）\nCache Hit Ratio [com.atguigu.mybatis.EmployeeMapper]: 0.6666666666666666（2/3）\nCache Hit Ratio [com.atguigu.mybatis.EmployeeMapper]: 0.75（3/4）\nCache Hit Ratio [com.atguigu.mybatis.EmployeeMapper]: 0.8（4/5）\n\n缓存命中率=命中缓存的次数/查询的总次数\n8.5 二级缓存相关配置在Mapper配置文件中添加的cache标签可以设置一些属性：\n\neviction属性：缓存回收策略\n\n\tLRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。\n\n\tFIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。\n\n\tSOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。\n\n\tWEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。\n\n\t默认的是 LRU。\n\nflushInterval属性：刷新间隔，单位毫秒\t\n\n\t默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新\n\nsize属性：引用数目，正整数  \n\t代表缓存最多可以存储多少个对象，太大容易导致内存溢出\n\nreadOnly属性：只读，true&#x2F;false\n\n\ttrue：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。\n\n\tfalse：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是 false。\n\n9. 整合EHcache9.1 添加依赖&lt;!-- Mybatis EHCache整合包 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis.caches&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mybatis-ehcache&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.2.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!-- slf4j日志门面的一个具体实现 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;ch.qos.logback&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;logback-classic&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.2.3&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n9.2 依赖传递\n\n\n\n\n\n\n\n\n\n我们发现，他们都有一个 slf4j 的依赖jar包\n\n\n\njar包名称\n作用\n\n\n\nmybatis-ehcache\nMybatis和EHCache的整合包\n\n\nehcache\nEHCache核心包\n\n\nslf4j-api\nSLF4J日志门面包\n\n\nlogback-classic\n支持SLF4J门面接口的一个具体实现\n\n\n9.3 开始整合ehcache.xml\n\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot; ?&gt;\n&lt;ehcache xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:noNamespaceSchemaLocation&#x3D;&quot;..&#x2F;config&#x2F;ehcache.xsd&quot;&gt;\n    &lt;!-- 磁盘保存路径 --&gt;\n    &lt;diskStore path&#x3D;&quot;D:\\atguigu\\ehcache&quot;&#x2F;&gt;\n    \n    &lt;defaultCache\n            maxElementsInMemory&#x3D;&quot;1000&quot;\n            maxElementsOnDisk&#x3D;&quot;10000000&quot;\n            eternal&#x3D;&quot;false&quot;\n            overflowToDisk&#x3D;&quot;true&quot;\n            timeToIdleSeconds&#x3D;&quot;120&quot;\n            timeToLiveSeconds&#x3D;&quot;120&quot;\n            diskExpiryThreadIntervalSeconds&#x3D;&quot;120&quot;\n            memoryStoreEvictionPolicy&#x3D;&quot;LRU&quot;&gt;\n    &lt;&#x2F;defaultCache&gt;\n&lt;&#x2F;ehcache&gt;\n\n在xxxmapper.xml 的 cache 标签中，指定缓存管理器的类型\n&lt;cache type&#x3D;&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&#x2F;&gt;\n\n9.4 EHCache配置文件说明当借助CacheManager.add(“缓存名称”)创建Cache时，EhCache便会采用指定的的管理策略。\ndefaultCache标签各属性说明：\n\n\n\n属性名\n是否必须\n作用\n\n\n\nmaxElementsInMemory\n是\n在内存中缓存的element的最大数目\n\n\nmaxElementsOnDisk\n是\n在磁盘上缓存的element的最大数目，若是0表示无穷大\n\n\neternal\n是\n设定缓存的elements是否永远不过期。 如果为true，则缓存的数据始终有效， 如果为false那么还要根据timeToIdleSeconds、timeToLiveSeconds判断\n\n\noverflowToDisk\n是\n设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上\n\n\ntimeToIdleSeconds\n否\n当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时， 这些数据便会删除，默认值是0,也就是可闲置时间无穷大\n\n\ntimeToLiveSeconds\n否\n缓存element的有效生命期，默认是0.,也就是element存活时间无穷大\n\n\ndiskSpoolBufferSizeMB\n否\nDiskStore(磁盘缓存)的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区\n\n\ndiskPersistent\n否\n在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。\n\n\ndiskExpiryThreadIntervalSeconds\n否\n磁盘缓存的清理线程运行间隔，默认是120秒。每个120s， 相应的线程会进行一次EhCache中数据的清理工作\n\n\nmemoryStoreEvictionPolicy\n否\n当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。 默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出\n\n\n10. logback存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。\n\n我们也可以添加，下面依赖进行解析，进而使用log4j\n&lt;dependency&gt;\n    &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.7.30&lt;&#x2F;version&gt;\n    &lt;scope&gt;test&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\nlogback.xml\n\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;configuration debug&#x3D;&quot;true&quot;&gt;\n    &lt;!-- 指定日志输出的位置 --&gt;\n    &lt;appender name&#x3D;&quot;STDOUT&quot;\n        class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;\n        &lt;encoder&gt;\n            &lt;!-- 日志输出的格式 --&gt;\n            &lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt;\n            &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n&lt;&#x2F;pattern&gt;\n        &lt;&#x2F;encoder&gt;\n    &lt;&#x2F;appender&gt;\n    \n    &lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt;\n    &lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;\n    &lt;root level&#x3D;&quot;DEBUG&quot;&gt;\n        &lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;\n        &lt;appender-ref ref&#x3D;&quot;STDOUT&quot; &#x2F;&gt;\n    &lt;&#x2F;root&gt;\n    \n    &lt;!-- 根据特殊需求指定局部日志级别 --&gt;\n    &lt;logger name&#x3D;&quot;com.atguigu.crowd.mapper&quot; level&#x3D;&quot;DEBUG&quot;&#x2F;&gt;\n    \n&lt;&#x2F;configuration&gt;\n\n11. 缓存的原理1. cache 接口org.apache.ibatis.cache.Cache接口：所有缓存都必须实现的顶级接口\n\n\n2. cache接口中的方法\n\n\n\n方法名\n作用\n\n\n\nputObject()\n将对象存入缓存\n\n\ngetObject()\n从缓存中取出对象\n\n\nremoveObject()\n从缓存中删除对象\n\n\n3. 缓存的本质根据Cache接口中方法的声明我们能够看到，缓存的本质是一个Map。\n\n4. PerpetualCache\norg.apache.ibatis.cache.impl.PerpetualCache是Mybatis的默认缓存，也是Cache接口的默认实现。Mybatis一级缓存和自带的二级缓存都是通过PerpetualCache来操作缓存数据的。但是这就奇怪了，同样是PerpetualCache这个类，怎么能区分出来两种不同级别的缓存呢？\n其实很简单，调用者不同。\n\n一级缓存：由BaseExecutor调用PerpetualCache\n二级缓存：由CachingExecutor调用PerpetualCache，而CachingExecutor可以看做是对BaseExecutor的装饰\n\n4.1 一级缓存机制\norg.apache.ibatis.executor.BaseExecutor类中的关键方法：\nquery方法\n\n\npublic &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;\n    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());\n    if (closed) &#123;\n        throw new ExecutorException(&quot;Executor was closed.&quot;);\n    &#125;\n    if (queryStack &#x3D;&#x3D; 0 &amp;&amp; ms.isFlushCacheRequired()) &#123;\n        clearLocalCache();\n    &#125;\n    List&lt;E&gt; list;\n    try &#123;\n        queryStack++;\n        \n        &#x2F;&#x2F; 尝试从本地缓存中获取数据\n        list &#x3D; resultHandler &#x3D;&#x3D; null ? (List&lt;E&gt;) localCache.getObject(key) : null;\n        \n        if (list !&#x3D; null) &#123;\n            handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);\n        &#125; else &#123;\n            \n            &#x2F;&#x2F; 如果本地缓存中没有查询到数据，则查询数据库\n            list &#x3D; queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);\n        &#125;\n    &#125; finally &#123;\n        queryStack--;\n    &#125;\n    if (queryStack &#x3D;&#x3D; 0) &#123;\n        for (org.apache.ibatis.executor.BaseExecutor.DeferredLoad deferredLoad : deferredLoads) &#123;\n            deferredLoad.load();\n        &#125;\n        &#x2F;&#x2F; issue #601\n        deferredLoads.clear();\n        if (configuration.getLocalCacheScope() &#x3D;&#x3D; LocalCacheScope.STATEMENT) &#123;\n            &#x2F;&#x2F; issue #482\n            clearLocalCache();\n        &#125;\n    &#125;\n    return list;\n&#125;\n\nqueryFromDatabase方法\n\nprivate &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;\n    List&lt;E&gt; list;\n    localCache.putObject(key, EXECUTION_PLACEHOLDER);\n    try &#123;\n        \n        &#x2F;&#x2F; 从数据库中查询数据\n        list &#x3D; doQuery(ms, parameter, rowBounds, resultHandler, boundSql);\n    &#125; finally &#123;\n        localCache.removeObject(key);\n    &#125;\n    \n    &#x2F;&#x2F; 将数据存入本地缓存\n    localCache.putObject(key, list);\n    if (ms.getStatementType() &#x3D;&#x3D; StatementType.CALLABLE) &#123;\n        localOutputParameterCache.putObject(key, parameter);\n    &#125;\n    return list;\n&#125;\n\n4.2 二级缓存机制\n未开启二级缓存\n\n开启后\n\n使用EHcache\n\n","slug":"46-Mybatis-延迟缓存","date":"2021-09-13T15:23:32.000Z","categories_index":"Mybatis","tags_index":"Mybatis","author_index":"大黄"},{"id":"b4fe850bfca7fffe4256d22b623aea94","title":"Mybatis 对一对多","content":"1. 一对一1.1. resultType实现\nsql语句\n\n确定查询的主表：订单表\n确定查询的关联表：用户表\n关联查询使用内连接？还是外连接？\n由于orders表中有一个外键（user_id），通过外键关联查询用户表只能查询出一条记录，可以使用内连接。\nSELECT \n  orders.*,\n  USER.username,\n  USER.sex,\n  USER.address \nFROM\n  orders,\n  USER \nWHERE orders.user_id &#x3D; user.id\n\n\n创建pojo\n\n将上边sql查询的结果映射到pojo中，pojo中必须包括所有查询列名。\n原始的Orders.java不能映射全部字段，需要新创建的pojo。\n创建一个pojo继承包括查询字段较多的po类。\n对应数据表的几个pojo类(Items,Orderdetail,Orders)就是把该类的属性名设为和数据表列字段名相同，并为这些属性添加getter和setter，在这里就不贴代码了，只贴出对应于关联查询的自定义pojo类OrdersCustom的代码\npackage cn.edu.wtu.po;\n\n&#x2F;**\n * @Package cn.edu.wtu.po\n * @ClassName OrdersCustom\n * @Description 通过此类映射订单和用户查询的结果，让此类继承包括 字段较多的pojo类\n * @Date 19&#x2F;11&#x2F;10 11:17\n * @Author LIM\n * @Version V1.0\n *&#x2F;\npublic class OrdersCustom extends Orders&#123;\n    private String username;\n    private String sex;\n    private String address;\n\n    public String getUsername() &#123;\n        return username;\n    &#125;\n\n    public void setUsername(String username) &#123;\n        this.username &#x3D; username;\n    &#125;\n\n    public String getSex() &#123;\n        return sex;\n    &#125;\n\n    public void setSex(String sex) &#123;\n        this.sex &#x3D; sex;\n    &#125;\n\n    public String getAddress() &#123;\n        return address;\n    &#125;\n\n    public void setAddress(String address) &#123;\n        this.address &#x3D; address;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;OrdersCustom&#123;&quot; +\n                &quot;username&#x3D;&#39;&quot; + username + &#39;\\&#39;&#39; +\n                &quot;, sex&#x3D;&#39;&quot; + sex + &#39;\\&#39;&#39; +\n                &quot;, address&#x3D;&#39;&quot; + address + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n\n\n\n\n\nOrderMapper.xml\n\n &lt;!-- 查询订单关联查询用户信息 --&gt;\n&lt;select id&#x3D;&quot;findOrdersUser&quot;  resultType&#x3D;&quot;com.iot.mybatis.po.OrdersCustom&quot;&gt;\n  SELECT\n      orders.*,\n      user.username,\n      user.sex,\n      user.address\n    FROM\n      orders,\n      user\n    WHERE orders.user_id &#x3D; user.id\n&lt;&#x2F;select&gt;\n\n\n\nOrdeMapper.java\n\n&#x2F;&#x2F;查询订单关联查询用户信息\npublic List&lt;OrdersCustom&gt; findOrdersUser()throws Exception;\n&#125;\n\n\n\n1.2 resultMap实现使用resultMap将查询结果中的订单信息映射到Orders对象中，在orders类中添加User属性，将关联查询出来的用户信息映射到orders对象中的user属性中。\n\n定义resultMap\n\n&lt;!-- 订单查询关联用户的resultMap\n 将整个查询的结果映射到cn.edu.wtu.po.Orders中\n --&gt;\n &lt;resultMap id&#x3D;&quot;OrdersUsersResultMap&quot; type&#x3D;&quot;cn.edu.wtu.po.Orders&quot;&gt;\n     &lt;!-- 配置映射的订单信息 --&gt;\n     &lt;!-- id：指定查询列中的唯一标识，订单信息的中的唯 一标识，如果有多个列组成唯一标识，配置多个id\n         column：订单信息的唯一标识列\n         property：订单信息的唯一标识列所映射到Orders中哪个属性\n       --&gt;\n     &lt;id column&#x3D;&quot;id&quot; property&#x3D;&quot;id&quot;&#x2F;&gt;\n     &lt;result column&#x3D;&quot;user_id&quot; property&#x3D;&quot;userId&quot;&#x2F;&gt;\n     &lt;result column&#x3D;&quot;createtime&quot; property&#x3D;&quot;createtime&quot;&#x2F;&gt;\n     &lt;result column&#x3D;&quot;number&quot; property&#x3D;&quot;number&quot;&#x2F;&gt;\n     &lt;result column&#x3D;&quot;note&quot; property&#x3D;&quot;note&quot;&#x2F;&gt;\n     &lt;!-- 配置映射的关联的用户信息 --&gt;\n     &lt;!-- association：用于映射关联查询单个对象的信息\n     property：要将关联查询的用户信息映射到Orders中哪个属性\n      --&gt;\n     &lt;association property&#x3D;&quot;user&quot; javaType&#x3D;&quot;cn.edu.wtu.po.User&quot;&gt;\n         &lt;!-- id：关联查询用户的唯一标识\n         column：指定唯 一标识用户信息的列\n         javaType：映射到user的哪个属性\n          --&gt;\n         &lt;id column&#x3D;&quot;user_id&quot; property&#x3D;&quot;id&quot;&#x2F;&gt;\n         &lt;result column&#x3D;&quot;username&quot; property&#x3D;&quot;username&quot;&#x2F;&gt;\n         &lt;result column&#x3D;&quot;sex&quot; property&#x3D;&quot;sex&quot;&#x2F;&gt;\n         &lt;result column&#x3D;&quot;address&quot; property&#x3D;&quot;address&quot;&#x2F;&gt;\n     &lt;&#x2F;association&gt;\n &lt;&#x2F;resultMap&gt;\n\n\n\nstatement定义\n\n&lt;!-- 查询订单关联查询用户信息 --&gt;\n&lt;select id&#x3D;&quot;findOrdersUserResultMap&quot; resultMap&#x3D;&quot;OrdersUserResultMap&quot;&gt;\n    SELECT\n    orders.*,\n    user.username,\n    user.sex,\n    user.address\n    FROM\n    orders,\n    user\n    WHERE orders.user_id &#x3D; user.id\n&lt;&#x2F;select&gt;\n\n\nOrderMapper.java\n\n&#x2F;&#x2F;查询订单关联查询用户使用resultMap\npublic List&lt;Orders&gt; findOrdersUserResultMap()throws Exception;\n\n\n测试代码\n\n@Test\npublic void testFindOrdersUserResultMap() throws Exception &#123;\n\n\tSqlSession sqlSession &#x3D; sqlSessionFactory.openSession();\n\t&#x2F;&#x2F; 创建代理对象\n\tOrdersMapperCustom ordersMapperCustom &#x3D; sqlSession\n\t\t\t.getMapper(OrdersMapperCustom.class);\n\n\t&#x2F;&#x2F; 调用maper的方法\n\tList&lt;Orders&gt; list &#x3D; ordersMapperCustom.findOrdersUserResultMap();\n\n\tSystem.out.println(list);\n\n\tsqlSession.close();\n&#125;\n\n1.3 resultType和resultMap实现一对一查询小结实现一对一查询：\n\nresultType：使用resultType实现较为简单，如果pojo中没有包括查询出来的列名，需要增加列名对应的属性，即可完成映射。如果没有查询结果的特殊要求建议使用resultType。\nresultMap：需要单独定义resultMap，实现有点麻烦，如果对查询结果有特殊的要求，使用resultMap可以完成将关联查询映射pojo的属性中。\nresultMap可以实现延迟加载，resultType无法实现延迟加载。\n\n2. 一对多2.1 需求查询订单及订单明细的信息。(根据数据库模型分析的结果来查询)使用resultMap\n2.2 要求对orders映射不能出现重复记录。\n2.3 解决思路\n在orders.java类中添加List&lt;&gt;, orderDetails属性。\n最终会将订单信息映射到orders中，订单所对应的订单明细映射到orders中的orderDetails属性中。\n映射成的orders记录数为两条（orders信息不重复）\n每个orders中的orderDetails属性存储了该订单所对应的订单明细\n\n2.4 resultMap&lt;!-- 订单及订单明细的resultMap\n    使用extends继承，不用在中配置订单信息和用户信息的映射\n--&gt;\n&lt;resultMap id&#x3D;&quot;OrdersAndOrderDetailResultMap&quot; type&#x3D;&quot;cn.edu.wtu.po.Orders&quot; extends&#x3D;&quot;OrdersUsersResultMap&quot;&gt;\n        &lt;!-- 订单信息 --&gt;\n        &lt;!-- 用户信息 --&gt;\n        &lt;!-- 使用extends继承，不用在中配置订单信息和用户信息的映射 --&gt;\n        &lt;!-- 订单明细信息\n        一个订单关联查询出了多条明细，要使用collection进行映射\n        collection：对关联查询到多条记录映射到集合对象中\n        property：将关联查询到多条记录映射到cn.edu.wtu.po.Orders哪个属性\n        ofType：指定映射到list集合属性中pojo的类型\n         --&gt;\n        &lt;collection property&#x3D;&quot;orderDetails&quot; ofType&#x3D;&quot;cn.edu.wtu.po.OrderDetail&quot;&gt;\n            &lt;!-- id：订单明细唯 一标识\n            property:要将订单明细的唯 一标识 映射到cn.edu.wtu.po.OrderDetail的哪个属性\n              --&gt;\n            &lt;id column&#x3D;&quot;orderDetail_id&quot; property&#x3D;&quot;id&quot;&#x2F;&gt;\n            &lt;result column&#x3D;&quot;items_id&quot; property&#x3D;&quot;itemsId&quot;&#x2F;&gt;\n            &lt;result column&#x3D;&quot;order_id&quot; property&#x3D;&quot;ordersId&quot;&#x2F;&gt;\n            &lt;result column&#x3D;&quot;items_num&quot; property&#x3D;&quot;itemsNum&quot;&#x2F;&gt;\n        &lt;&#x2F;collection&gt;\n&lt;&#x2F;resultMap&gt;\n\n2.5 OrderMapper.xml&lt;!-- 查询订单关联查询用户及订单明细，使用resultMap --&gt;\n    &lt;select id&#x3D;&quot;findOrdersAndOrderDetailResultMap&quot; resultMap&#x3D;&quot;OrdersAndOrderDetailResultMap&quot;&gt;\n        SELECT\n          orders.*,\n          user.username,\n          user.sex,\n          user.address,\n          orderdetail.id orderdetail_id,\n          orderdetail.items_id,\n          orderdetail.items_num,\n          orderdetail.orders_id\n        FROM\n          orders,\n          user,\n          orderdetail\n        WHERE orders.user_id &#x3D; user.id AND orderdetail.orders_id&#x3D;orders.id;\n    &lt;&#x2F;select&gt;\n\n2.6 OrderMapper.java&#x2F;**\n     * 查询订单关联查询用户及订单明细，使用resultMap\n     * @return Orders的列表\n     * @throws Exception\n     *&#x2F;\n    public List&lt;Orders&gt; findOrdersAndOrderDetailResultMap() throws Exception;\n\n2.7 测试@Test\n    public void testFindOrdersAndOrderDetailResultMap() throws Exception&#123;\n        &#x2F;&#x2F; 创建会话\n        SqlSession sqlSession &#x3D; sqlSessionFactory.openSession();\n        &#x2F;&#x2F; 创建代理对象\n        OrderMapper orderMapper &#x3D; sqlSession.getMapper(OrderMapper.class);\n\n        List&lt;Orders&gt; lists &#x3D; orderMapper.findOrdersAndOrderDetailResultMap();\n\n        for (Orders list:lists)&#123;\n            System.out.println(list.toString());\n        &#125;\n    &#125;\n\n2.8 小结mybatis使用resultMap的collection对关联查询的多条记录映射到一个list集合属性中。\n使用resultType实现：将订单明细映射到orders中的orderdetails中，需要自己处理，使用双重循环遍历，去掉重复记录，将订单明细放在orderdetails中。\n另外，下面这篇文章对一对多的resultMap机制解释的很清楚：\n\n\n\n\n\n\n\n\n\nMyBatis：一对多表关系详解(从案例中解析)\n3. 多对多3.1 需求查询用户及用户购买商品信息。\n查询主表是：用户表\n关联表：由于用户和商品没有直接关联，通过订单和订单明细进行关联，所以关联表：orders、orderdetail、items\n3.2 sqlSELECT \n  orders.*,\n  user.username,\n  user.sex,\n  user.address,\n  orderdetail.id orderdetail_id,\n  orderdetail.items_id,\n  orderdetail.items_num,\n  orderdetail.orders_id,\n  items.name items_name,\n  items.detail items_detail,\n  items.price items_price\nFROM\n  orders,\n  user,\n  orderdetail,\n  items\nWHERE orders.user_id &#x3D; user.id AND orderdetail.orders_id&#x3D;orders.id AND orderdetail.items_id &#x3D; items.id\n\n3.3 映射思路\n将用户信息映射到user中。\n\n在user类中添加订单列表属性List&lt;Orders&gt; orderslist，将用户创建的订单映射到orderslist\n\n在Orders中添加订单明细列表属性List&lt;OrderDetail&gt;orderdetials，将订单的明细映射到orderdetials\n\n在OrderDetail中添加Items属性，将订单明细所对应的商品映射到Items\n\n\n3.4 resultMap&lt;!-- 查询用户及购买的商品 --&gt;\n    &lt;resultMap id&#x3D;&quot;UserAndItemsResultMap&quot; type&#x3D;&quot;cn.edu.wtu.po.User&quot;&gt;\n        &lt;!-- 用户信息 --&gt;\n        &lt;id column&#x3D;&quot;user_id&quot; property&#x3D;&quot;id&quot;&#x2F;&gt;\n        &lt;result column&#x3D;&quot;username&quot; property&#x3D;&quot;username&quot;&#x2F;&gt;\n        &lt;result column&#x3D;&quot;sex&quot; property&#x3D;&quot;sex&quot;&#x2F;&gt;\n        &lt;result column&#x3D;&quot;address&quot; property&#x3D;&quot;address&quot;&#x2F;&gt;\n        &lt;!-- 订单信息\n        一个用户对应多个订单，使用collection映射\n         --&gt;\n        &lt;collection property&#x3D;&quot;ordersList&quot; ofType&#x3D;&quot;cn.edu.wtu.po.Orders&quot;&gt;\n            &lt;id column&#x3D;&quot;id&quot; property&#x3D;&quot;id&quot;&#x2F;&gt;\n            &lt;result column&#x3D;&quot;user_id&quot; property&#x3D;&quot;userId&quot;&#x2F;&gt;\n            &lt;result column&#x3D;&quot;number&quot; property&#x3D;&quot;number&quot;&#x2F;&gt;\n            &lt;result column&#x3D;&quot;createtime&quot; property&#x3D;&quot;createtime&quot;&#x2F;&gt;\n            &lt;result column&#x3D;&quot;note&quot; property&#x3D;&quot;note&quot;&#x2F;&gt;\n            &lt;!-- 订单明细\n             一个订单包括 多个明细\n             --&gt;\n            &lt;collection property&#x3D;&quot;orderDetails&quot; ofType&#x3D;&quot;cn.edu.wtu.po.OrderDetail&quot;&gt;\n                &lt;id column&#x3D;&quot;orderDetail_id&quot; property&#x3D;&quot;id&quot;&#x2F;&gt;\n                &lt;result column&#x3D;&quot;items_id&quot; property&#x3D;&quot;itemsId&quot;&#x2F;&gt;\n                &lt;result column&#x3D;&quot;items_num&quot; property&#x3D;&quot;itemsNum&quot;&#x2F;&gt;\n                &lt;result column&#x3D;&quot;orders_id&quot; property&#x3D;&quot;ordersId&quot;&#x2F;&gt;\n                &lt;!-- 商品信息\n                 一个订单明细对应一个商品\n                 --&gt;\n                &lt;association property&#x3D;&quot;items&quot; javaType&#x3D;&quot;cn.edu.wtu.po.Items&quot;&gt;\n                    &lt;id column&#x3D;&quot;items_id&quot; property&#x3D;&quot;id&quot;&#x2F;&gt;\n                    &lt;result column&#x3D;&quot;items_name&quot; property&#x3D;&quot;name&quot;&#x2F;&gt;\n                    &lt;result column&#x3D;&quot;items_detail&quot; property&#x3D;&quot;detail&quot;&#x2F;&gt;\n                    &lt;result column&#x3D;&quot;items_price&quot; property&#x3D;&quot;price&quot;&#x2F;&gt;\n                &lt;&#x2F;association&gt;\n            &lt;&#x2F;collection&gt;\n        &lt;&#x2F;collection&gt;\n    &lt;&#x2F;resultMap&gt;\n\n3.5 OrderMapper.xml&lt;!-- 查询用户及购买的商品信息，使用resultMap --&gt;\n    &lt;select id&#x3D;&quot;findUserAndItemsResultMap&quot; resultMap&#x3D;&quot;UserAndItemsResultMap&quot;&gt;\n        SELECT\n        orders.*,\n        USER.username,\n        USER.sex,\n        USER.address,\n        orderdetail.id orderdetail_id,\n        orderdetail.items_id,\n        orderdetail.items_num,\n        orderdetail.orders_id,\n        items.name items_name,\n        items.detail items_detail,\n        items.price items_price\n        FROM\n        orders,\n        USER,\n        orderdetail,\n        items\n        WHERE orders.user_id &#x3D; user.id AND orderdetail.orders_id&#x3D;orders.id AND orderdetail.items_id &#x3D; items.id\n    &lt;&#x2F;select&gt;\n\n3.6 OrderMapper.java&#x2F;**\n     * 查询用户购买商品信息\n     * @return User的列表\n     * @throws Exception\n     *&#x2F;\n    public List&lt;User&gt;  findUserAndItemsResultMap()throws Exception;\n\n3.7 测试@Test\n    public void testFindUserAndItemsResultMap() throws Exception&#123;\n        &#x2F;&#x2F; 创建会话\n        SqlSession sqlSession &#x3D; sqlSessionFactory.openSession();\n        &#x2F;&#x2F; 创建代理对象\n        OrderMapper orderMapper &#x3D; sqlSession.getMapper(OrderMapper.class);\n\n        List&lt;User&gt; lists &#x3D; orderMapper.findUserAndItemsResultMap();\n\n        for (User list:lists)&#123;\n            System.out.println(list.toString());\n        &#125;\n    &#125;\n\n3.8 多对多查询总结将查询用户购买的商品信息明细清单，（用户名、用户地址、购买商品名称、购买商品时间、购买商品数量）\n针对上边的需求就使用resultType将查询到的记录映射到一个扩展的pojo中，很简单实现明细清单的功能。\n一对多是多对多的特例，如下需求：\n查询用户购买的商品信息，用户和商品的关系是多对多关系。\n\n需求1：\n\n查询字段：用户账号、用户名称、用户性别、商品名称、商品价格(最常见)\n企业开发中常见明细列表，用户购买商品明细列表，\n使用resultType将上边查询列映射到pojo输出。\n\n需求2：\n\n查询字段：用户账号、用户名称、购买商品数量、商品明细（鼠标移上显示明细）\n使用resultMap将用户购买的商品明细列表映射到user对象中。\n总结：\n使用resultMap是针对那些对查询结果映射有特殊要求的功能，比如特殊要求映射成list中包括多个list。\n4. 总结14.1 resultType\n作用：将查询结果按照sql列名pojo属性名一致性映射到pojo中。\n场合：常见一些明细记录的展示，比如用户购买商品明细，将关联查询信息全部展示在页面时，此时可直接使用resultType将每一条记录映射到pojo中，在前端页面遍历list（list中是pojo）即可。\n\n4.2 resultMap使用association和collection完成一对一和一对多高级映射（对结果有特殊的映射要求）。\n4.2.1 association(一对一)\n作用：将关联查询信息映射到一个pojo对象中。\n场合：为了方便查询关联信息可以使用association将关联订单信息映射为用户对象的pojo属性中，比如：查询订单及关联用户信息。\n\n使用resultType无法将查询结果映射到pojo对象的pojo属性中，根据对结果集查询遍历的需要选择使用resultType还是resultMap。\n4.2.2 collection(一对多)\n作用：将关联查询信息映射到一个list集合中。\n场合：为了方便查询遍历关联信息可以使用collection将关联信息映射到list集合中，比如：查询用户权限范围模块及模块下的菜单，可使用collection将模块映射到模块list中，将菜单列表映射到模块对象的菜单list属性中，这样的作的目的也是方便对查询结果集进行遍历查询。如果使用resultType无法将查询结果映射到list集合中。\n\n4.2.3 关键标签\n\n\n关联关系\n配置项关键词\n所在配置文件\n\n\n\n对一\nassociation标签/javaType属性\nMapper配置文件中的resultMap\n\n\n对多\ncollection标签/ofType属性\nMapper配置文件中的resultMap\n\n\n对一分步\nassociation标签/select属性\nMapper配置文件中的resultMap\n\n\n对多分步\ncollection标签/select属性\nMapper配置文件中的resultMap\n\n\n5. 总结21. 多表连接查询和分步查询的优缺点\n多表连接查询\n好处：是一条SQL语句获取多个表的数据，效率高\n缺点：不存在延迟加载，有可能获取非常多不必要的数据\n\n\n分步查询\n优点：可以配置延迟加载，需要数据时再获取，不需要就不加载\n多条SQL语句获取多个表的数据，效率低\n\n\n建议\n如果确定是获取多表数据，就使用多表连接查询。\n如果不能确定是否加载多表数据，就使用分步查询（多个单表查询组合而成）\n\n\n\n2. 一对一、一对多、多对多的数据库实现、Java实体类实现、MyBatis映射文件实现\n一对一\n\n数据库：进行外键关联，并设置外键唯一；进行主键关联，一个表中作为另外一个的主键，也是外键\njava实体类：添加对应的实体类对象参数\nmybatis映射：通过association进行对一的相关配置，使用javaType指定对一的类的全路径名\n\n\n一对多\n\n数据库：一对多，在多的一方的表中添加一的主键为外键进行对应\n\njava实体类：在一的一方添加多的实体对象的集合\n\nmybatis映射：使用collection标签，属性property指向 实体类中多的实体对象集合，oftype指明集合中对象的实体类的全路径名\n若没有使用多表连接语句查询，也可以定义各自单独的查询方法，collection标签中，使用select属性，调用需要查询对象集合的相关方法，使其映射到property指向的属性中\n\n\n\n多对多\n\n数据库：使用一个中间表，保存两个表的主键做外键，并在设置一个自身的主键，使其变为两个一对多的关系\njava实体类：分别在两方添加对应的实体对象集合\nmybatis映射：一对多是一种特殊的多对多，所以根据需求，我们可以将多对多转化为一对多，将查询的结果映射到实体参数中对应的集合中\n\n\n\n","slug":"45-Mybatis-对一对多","date":"2021-09-13T15:22:32.000Z","categories_index":"Mybatis","tags_index":"Mybatis","author_index":"大黄"},{"id":"650dc14f73504516668e17ca7e793b09","title":"Mybatis 动态SQL","content":"1. 什么是动态SQL动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。\n使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。\n如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。\n\nif\nchoose (when, otherwise)\ntrim (where, set)\nforeach\n\n==动态sql中的判断：==\n① “!=” : 表示不等于 ② “=”：表示等于。注意是一个等号。 ③ “and” : 逻辑与(小写) ④ “or” ： 逻辑或(小写)\n==动态sql中进行传入的数据判断时：==\n\n单个参数没有使用别名，直接使用value进行替代，或者使用别名\n多个参数就直接使用别名\n\n2. if 标签使用动态 SQL 最常见情景是根据条件包含 where 子句的一部分。比如：\n1 = 1 是为了解决  没有条件满足时，也能正常查询，不然，where后什么都没有，sql语句就语法错误了\n&lt;select id&#x3D;&quot;selectEmployee2&quot; resultType&#x3D;&quot;employee&quot;&gt;\n        select * from t_emp2 where 1 &#x3D; 1\n        &lt;if test&#x3D;&quot;empName!&#x3D;null and empName!&#x3D;&#39;&#39;&quot;&gt;\n            and emp_name like concat(&#39;%&#39;,#&#123;empName&#125;,&#39;%&#39;)\n        &lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;empSalary!&#x3D;0&quot;&gt;\n            and emp_salary &gt;&#x3D; #&#123;empSalary&#125;;\n        &lt;&#x2F;if&gt;\n&lt;&#x2F;select&gt;\n\n这是最好的改进，加入标签\n&lt;select id&#x3D;&quot;selectEmployee3&quot; resultType&#x3D;&quot;employee&quot;&gt;\n        select * from t_emp2\n        &lt;where&gt;\n            &lt;if test&#x3D;&quot;empName!&#x3D;null and empName!&#x3D;&#39;&#39;&quot;&gt;\n                and emp_name like concat(&#39;%&#39;,#&#123;empName&#125;,&#39;%&#39;)\n            &lt;&#x2F;if&gt;\n            &lt;if test&#x3D;&quot;empSalary!&#x3D;0&quot;&gt;\n                and emp_salary &gt;&#x3D; #&#123;empSalary&#125;;\n            &lt;&#x2F;if&gt;\n        &lt;&#x2F;where&gt;\n&lt;&#x2F;select&gt;\n\n这条语句提供了可选的查找文本功能。\n3. choose、when、otherwise有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。\n注意：当第一个直接满足条件后，就不看后面的了，仅仅选择一个条件来使用\n&lt;select id&#x3D;&quot;selectEmployee5&quot; resultType&#x3D;&quot;employee&quot;&gt;\n        select * from t_emp2\n        &lt;where&gt;\n            &lt;!--\n            第一种情况：第一个when满足条件 where emp_name&#x3D;?\n            第二种情况：第二个when满足条件 where emp_salary &lt; 3000\n            第三种情况：两个when都不满足 where 1&#x3D;1 执行了otherwise\n            --&gt;\n            &lt;choose&gt;\n                &lt;when test&#x3D;&quot;empName!&#x3D;null and empName!&#x3D;&#39;&#39;&quot;&gt; emp_name like concat(&#39;%&#39;,#&#123;empName&#125;,&#39;%&#39;)&lt;&#x2F;when&gt;\n                &lt;when test&#x3D;&quot;empSalary!&#x3D;0&quot;&gt;emp_salary &gt;&#x3D; #&#123;empSalary&#125;&lt;&#x2F;when&gt;\n                &lt;otherwise&gt;1&#x3D;1&lt;&#x2F;otherwise&gt;\n            &lt;&#x2F;choose&gt;\n        &lt;&#x2F;where&gt;\n    &lt;&#x2F;select&gt;\n\n4. where、trim、set前面几个例子已经方便地解决了一个臭名昭著的动态 SQL 问题。现在回到之前的 “if” 示例，如果没有匹配的条件会怎么样？最终这条 SQL 会变成这样：\nSELECT * FROM BLOG\nWHERE\n\n这会导致查询失败。如果匹配的只是第二个条件又会怎样？这条 SQL 会是这样:\nSELECT * FROM BLOG\nWHERE\nAND title like ‘someTitle’\n\n这个查询也会失败。这个问题不能简单地用条件元素来解决。这个问题是如此的难以解决，以至于解决过的人不会再想碰到这种问题。\nMyBatis 有一个简单且适合大多数场景的解决办法。而在其他场景中，可以对其进行自定义以符合需求。而这，只需要一处简单的改动：\n&lt;select id&#x3D;&quot;selectEmployee3&quot; resultType&#x3D;&quot;employee&quot;&gt;\n        select * from t_emp2\n        &lt;where&gt;\n            &lt;if test&#x3D;&quot;empName!&#x3D;null and empName!&#x3D;&#39;&#39;&quot;&gt;\n                and emp_name like concat(&#39;%&#39;,#&#123;empName&#125;,&#39;%&#39;)\n            &lt;&#x2F;if&gt;\n            &lt;if test&#x3D;&quot;empSalary!&#x3D;0&quot;&gt;\n                and emp_salary &gt;&#x3D; #&#123;empSalary&#125;;\n            &lt;&#x2F;if&gt;\n        &lt;&#x2F;where&gt;\n&lt;&#x2F;select&gt;\n\n\n\n\n\n\n\n\n\n\n*where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，*where 元素也会将它们去除。**\n可以通过自定义 trim 元素来定制 where 元素的功能。比如，和 where 元素等价的自定义 trim 元素为：\n&lt;trim prefix&#x3D;&quot;WHERE&quot; prefixOverrides&#x3D;&quot;AND |OR &quot;&gt;\n  ...\n&lt;&#x2F;trim&gt;\n\nprefixOverrides 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有 prefixOverrides 属性中指定的内容，并且插入 prefix 属性中指定的内容。\n用于动态更新语句的类似解决方案叫做 set。set 元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如：\n&lt;select id&#x3D;&quot;updateEmployee2&quot; resultType&#x3D;&quot;employee&quot;&gt;\n        update t_emp2\n        &lt;set&gt;\n            &lt;if test&#x3D;&quot;empName!&#x3D;null and empName!&#x3D;&#39;&#39;&quot;&gt;\n                emp_name &#x3D; #&#123;empName&#125;,\n            &lt;&#x2F;if&gt;\n            &lt;if test&#x3D;&quot;empSalary!&#x3D;0&quot;&gt;\n                emp_salary &#x3D; #&#123;empSalary&#125;,\n            &lt;&#x2F;if&gt;\n        &lt;&#x2F;set&gt;\n        where emp_id &#x3D; #&#123;empId&#125;\n&lt;&#x2F;select&gt;\n\n这个例子中，set 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。\n来看看与 set 元素等价的自定义 trim 元素吧：\n&lt;trim prefix&#x3D;&quot;SET&quot; suffixOverrides&#x3D;&quot;,&quot;&gt;\n  ...\n&lt;&#x2F;trim&gt;\n\n注意，我们覆盖了后缀值设置，并且自定义了前缀值。\n5. foreach动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如：\n&lt;select id&#x3D;&quot;selectEmployee7&quot; resultType&#x3D;&quot;employee&quot;&gt;\n        select\n        &lt;include refid&#x3D;&quot;EmployeeSql&quot;&#x2F;&gt;&lt;!--这里包含的是，提取出的需要查询的字段及别名--&gt;\n        from t_emp2 where emp_id in\n        &lt;foreach collection&#x3D;&quot;empIdArr&quot; open&#x3D;&quot;(&quot; close&#x3D;&quot;)&quot; separator&#x3D;&quot;,&quot; item&#x3D;&quot;empId&quot;&gt;\n            #&#123;empId&#125;\n        &lt;&#x2F;foreach&gt;\n&lt;&#x2F;select&gt;\n\n&lt;sql id&#x3D;&quot;EmployeeSql&quot;&gt;\n        emp_id\n        empId,emp_name empName ,emp_salary empSalary\n&lt;&#x2F;sql&gt;\n\nforeach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！\n提示 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 foreach。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。\n至此，我们已经完成了与 XML 配置及映射文件相关的讨论。下一章将详细探讨 Java API，以便你能充分利用已经创建的映射配置。\n6. script要在带注解的映射器接口类中使用动态 SQL，可以使用 script 元素。比如:\n@Update(&#123;&quot;&lt;script&gt;&quot;,\n  &quot;update Author&quot;,\n  &quot;  &lt;set&gt;&quot;,\n  &quot;    &lt;if test&#x3D;&#39;username !&#x3D; null&#39;&gt;username&#x3D;#&#123;username&#125;,&lt;&#x2F;if&gt;&quot;,\n  &quot;    &lt;if test&#x3D;&#39;password !&#x3D; null&#39;&gt;password&#x3D;#&#123;password&#125;,&lt;&#x2F;if&gt;&quot;,\n  &quot;    &lt;if test&#x3D;&#39;email !&#x3D; null&#39;&gt;email&#x3D;#&#123;email&#125;,&lt;&#x2F;if&gt;&quot;,\n  &quot;    &lt;if test&#x3D;&#39;bio !&#x3D; null&#39;&gt;bio&#x3D;#&#123;bio&#125;&lt;&#x2F;if&gt;&quot;,\n  &quot;  &lt;&#x2F;set&gt;&quot;,\n  &quot;where id&#x3D;#&#123;id&#125;&quot;,\n  &quot;&lt;&#x2F;script&gt;&quot;&#125;)\nvoid updateAuthorValues(Author author);\n\n7. bindbind 元素允许你在 OGNL 表达式以外创建一个变量，并将其绑定到当前的上下文。比如：\n&lt;select id&#x3D;&quot;selectBlogsLike&quot; resultType&#x3D;&quot;Blog&quot;&gt;\n  &lt;bind name&#x3D;&quot;pattern&quot; value&#x3D;&quot;&#39;%&#39; + _parameter.getTitle() + &#39;%&#39;&quot; &#x2F;&gt;\n  SELECT * FROM BLOG\n  WHERE title LIKE #&#123;pattern&#125;\n&lt;&#x2F;select&gt;\n\n8. 多数据库支持如果配置了 databaseIdProvider，你就可以在动态代码中使用名为 “_databaseId” 的变量来为不同的数据库构建特定的语句。比如下面的例子：\n&lt;insert id&#x3D;&quot;insert&quot;&gt;\n  &lt;selectKey keyProperty&#x3D;&quot;id&quot; resultType&#x3D;&quot;int&quot; order&#x3D;&quot;BEFORE&quot;&gt;\n    &lt;if test&#x3D;&quot;_databaseId &#x3D;&#x3D; &#39;oracle&#39;&quot;&gt;\n      select seq_users.nextval from dual\n    &lt;&#x2F;if&gt;\n    &lt;if test&#x3D;&quot;_databaseId &#x3D;&#x3D; &#39;db2&#39;&quot;&gt;\n      select nextval for seq_users from sysibm.sysdummy1&quot;\n    &lt;&#x2F;if&gt;\n  &lt;&#x2F;selectKey&gt;\n  insert into users values (#&#123;id&#125;, #&#123;name&#125;)\n&lt;&#x2F;insert&gt;\n\n9. 动态 SQL 中的插入脚本语言MyBatis 从 3.2 版本开始支持插入脚本语言，这允许你插入一种语言驱动，并基于这种语言来编写动态 SQL 查询语句。\n可以通过实现以下接口来插入一种语言：\npublic interface LanguageDriver &#123;\n  ParameterHandler createParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql);\n  SqlSource createSqlSource(Configuration configuration, XNode script, Class&lt;?&gt; parameterType);\n  SqlSource createSqlSource(Configuration configuration, String script, Class&lt;?&gt; parameterType);\n&#125;\n\n实现自定义语言驱动\n后，你就可以在 mybatis-config.xml 文件中将它设置为默认语言：\n&lt;typeAliases&gt;\n  &lt;typeAlias type&#x3D;&quot;org.sample.MyLanguageDriver&quot; alias&#x3D;&quot;myLanguage&quot;&#x2F;&gt;\n&lt;&#x2F;typeAliases&gt;\n&lt;settings&gt;\n  &lt;setting name&#x3D;&quot;defaultScriptingLanguage&quot; value&#x3D;&quot;myLanguage&quot;&#x2F;&gt;\n&lt;&#x2F;settings&gt;\n\n或者，你也可以使用 lang 属性为特定的语句指定语言：\n&lt;select id&#x3D;&quot;selectBlog&quot; lang&#x3D;&quot;myLanguage&quot;&gt;\n  SELECT * FROM BLOG\n&lt;&#x2F;select&gt;\n\n或者，在你的 mapper 接口上添加 @Lang 注解：\npublic interface Mapper &#123;\n  @Lang(MyLanguageDriver.class)\n  @Select(&quot;SELECT * FROM BLOG&quot;)\n  List&lt;Blog&gt; selectBlog();\n&#125;\n\n提示 可以使用 Apache Velocity 作为动态语言，更多细节请参考 MyBatis-Velocity 项目。\n你前面看到的所有 xml 标签都由默认 MyBatis 语言提供，而它由语言驱动 org.apache.ibatis.scripting.xmltags.XmlLanguageDriver（别名为 xml）所提供。\n","slug":"44-Mybatis-动态SQL","date":"2021-09-13T15:21:32.000Z","categories_index":"Mybatis","tags_index":"Mybatis","author_index":"大黄"},{"id":"a439be0041fedf424a1ac2607c12651d","title":"Mybatis 基础要点","content":":hatching_chick: 回忆JDBC① JDBC 编程步骤1. 加载驱动\t2. 获取连接 3. 获取数据库操作对象 4. 编写sql，赋值 5. 执行sql 6. 处理查询结果集 7. 释放资源\n\n② 遗留问题1.数据库连接，使用时就创建，不使用立即释放，对数据库进行频繁连接开启和关闭，造成数据库资源浪费，影响数据库性能。\n设想：使用数据库连接池管理数据库连接。\n2.将sql语句硬编码到java代码中，如果sql语句修改，需要重新编译java代码，==不利于系统维护==。\n设想：将sql语句配置在xml配置文件中，即使sql变化，不需要对java代码进行重新编译。\n3.向preparedStatement中设置参数，对占位符号位置和设置参数值，硬编码在java代码中，不利于系统维护。\n设想：将sql语句及占位符号和参数全部配置在xml中。\n4.从resultSet中遍历结果集数据时，存在硬编码，将获取表的字段进行硬编码，不利于系统维护。\n设想：==将查询的结果集，自动映射成java对象==。\n:hatching_chick: 总体技术① 单一架构一个项目，一个工程，导出为一个war包，在一个Tomcat上运行。也叫all in one。\n\n② 分布式架构一个项目，拆分成很多个模块，每个模块是一个工程。每一个工程都是运行在自己的Tomcat上。模块之间可以互相调用。每一个模块内部可以看成是一个单一架构的应用。\n\n:hatching_chick: 框架、MyBatis、ORM介绍① 框架\n什么是框架\n框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;\n另一种定义认为，框架是可被应用开发者定制的应用骨架。\n前者是从应用方面而后者是从目的方面给出的定义。\n\n\n框架的优势\n框架技术是一个应用程序的半成品，提供可重用的公共结构，按一定规则组织的一组组件，不用再考虑公共问题，专心在业务实现上结构统一，易于学习、维护新手也可写出好程序\n\n\n\n② mybatis介绍\nmybatis是一个持久层的框架，是apache下的顶级项目。\nmybatis托管到goolecode下，再后来托管到github下(https://github.com/mybatis/mybatis-3/releases)。\n\nMyBatis 是一款优秀的持久层框架，它支持自定义 SQL（可以优化sql）、存储过程以及高级映射，自由灵活生成（半自动化ORM框架，大部分需要程序员编写sql）满足需要sql语句。。\n\nMyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。\n\nMyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。（向 preparedStatement中的输入参数自动进行输入映射，将查询结果集灵活映射成java对象。（输出映射））\n\nmybatis中文学习网址\n\n\n③ ORM介绍关于面向对象的Java语言、面向关系的数据库之间数据的转换必须要做，问题在于这个转换是否可以不由开发者来做。可以的。ORM框架就是专门来做这个问题的，相当于在面向对象语言和关系数据库之间搭建一个桥梁。\n即Object-Relationl Mapping，它的作用是在关系型数据库和对象之间作一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的SQL语句打交道，只要像平时操作对象一样操作它就可以了 \n\n:hatching_chick: 持久化层技术的对比* JDBC\n    * SQL 夹杂在Java代码中耦合度高，导致硬编码内伤\n    * 维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见\n    * 代码冗长，开发效率低\n\n* Hibernate 和 JPA\n    * 操作简便，开发效率高\n    * 程序中的长难复杂 SQL 需要绕过框架\n    * 内部自动生产的 SQL，不容易做特殊优化\n    * 基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。\n    * 反射操作太多，导致数据库性能下降\n\n* MyBatis\n    * 轻量级，性能出色\n    * SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据\n    * 开发效率稍逊于HIbernate，但是完全能够接收\n\n\n\n\n\n\n\n\n\n\n为什么半自动化的Mybatis比自动化的Hibernate受欢迎?\n MyBatis需要手写SQL语句，所以工作量要大于Hibernate。但是由于自定义SQL语句，所以灵活性、可优化性就超过了Hibernate。\nHibernate封装了SQL语句，由开发者对对象操作，Hibernate来生成SQL语句。虽然也可以通过映射配置来控制生成的SQL语句，但是对于要生成复杂的SQL语句，很难实现，或者实现后导致性能的丢失。\nMyBatis对存储过程可提供很好的支持。另外MyBatis的开发工作量大不意味着学习成本大。对于新手，学习Hibernate时间成本比Mybatis大很多，Mybatis很快就上手了。\n* 应用场景\n\t* MyBatis具有封装少、映射多样化、支持存储过程、可以进行SQL语句优化等特点，符合互联网高并发、大数据、高性能、高响应的要求\n\n\t* 而对于对性能要求不高的比如内部管理系统、ERP等可以使用Hibernate。\n\n\n\n:hatching_chick: mybatis的创建执行* 物理建模\t\t\t-----&gt; \t\t\t创建数据库\n* 逻辑建模\t\t\t-----&gt;\t\t\t创建maven项目，创建实体类\n* 搭建环境\t\t\t-----&gt; \t\t\t导入mybatis，mysql依赖，准备mybatis全局配置文件，mybatis映射配置文件\n* 测试代码\t\t\t-----&gt;\t\t\t导入junit依赖，进行相关测试\n\n① 创建实体类* 和数据库表t_emp对应的实体类\n* emp_id INT AUTO_INCREMENT\n* emp_name CHAR(100)\n* emp_salary DOUBLE(10,5)\n*\n* Java的实体类中，属性的类型不要使用基本数据类型，要使用包装类型。因为包装类型可以赋值为null，表示空，而基本数据类型不可以。\n\n\n\n\n\n\n\n\n\n\n最好遵循驼峰命名法，数据库中使用   emp(前缀) _(下划线) id(后缀)，而实体类中用  empId\n② 全局配置文件&lt;!--mybatis-config.xml--&gt;\n\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n\n    &lt;!--采用软编码，使用读取配置得方式引入数据库地址，用户名等，方便后期维护--&gt;\n    &lt;properties resource&#x3D;&quot;jdbc.properties&quot;&#x2F;&gt;\n\n    &lt;!-- 具体配置 --&gt;\n    &lt;!-- 从org.apache.ibatis.session.Configuration类中可以查看能使用的配置项 --&gt;\n    &lt;!-- 将mapUnderscoreToCamelCase属性配置为true，表示开启自动映射驼峰式命名规则 --&gt;\n    &lt;!-- 规则要求数据库表字段命名方式：单词_单词 --&gt;\n    &lt;!-- 规则要求Java实体类属性名命名方式：首字母小写的驼峰式命名 --&gt;\n    &lt;settings&gt;\n        &lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n    &lt;&#x2F;settings&gt;\n    \n    &lt;!--和spring整合后 environments配置将废除--&gt;\n    &lt;!--指定默认使用哪个环境，内部可以指定多个环境--&gt;\n    &lt;environments default&#x3D;&quot;development&quot;&gt;\n        &lt;!--environment 一个数据库的信息配置，环境--&gt;\n        &lt;environment id&#x3D;&quot;development&quot;&gt;\n            &lt;!--使用JDBC事务--&gt;\n            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;\n            &lt;!--数据库连接池--&gt;\n            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;\n                &lt;!--指定驱动，数据库地址，用户名，密码--&gt;\n                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;\n            &lt;&#x2F;dataSource&gt;\n        &lt;&#x2F;environment&gt;\n    &lt;&#x2F;environments&gt;\n    &lt;!--加载映射文件--&gt;\n    &lt;mappers&gt;\n        &lt;!--Mapper注册：指定Mybatis映射文件的具体位置--&gt;\n        &lt;!--mapper标签：配置一个具体的Mapper映射文件--&gt;\n        &lt;!--resource属性：指定Mapper映射文件的实际存储位置，这里需要使用一个以类路径根目录为基准的相对路径--&gt;\n        &lt;!--对Maven工程的目录结构来说，resources目录下的内容会直接放入类路径，所以这里我们可以以resources目录为基准--&gt;\n        &lt;mapper resource&#x3D;&quot;mappers&#x2F;EmployeeMapper.xml&quot;&#x2F;&gt;\n        &lt;mapper resource&#x3D;&quot;mappers&#x2F;EmployeeMapper2.xml&quot;&#x2F;&gt;\n    &lt;&#x2F;mappers&gt;\n&lt;&#x2F;configuration&gt;\n\n③ 映射配置文件&lt;!--EmployeeMapper.xml--&gt;\n\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;\n\n&lt;!-- mapper是根标签，namespace属性：在Mybatis全局范围内找到一个具体的Mapper配置 --&gt;\n&lt;!-- 引入接口后，为了方便通过接口全类名来找到Mapper配置文件，所以通常将namespace属性设置为接口全类名 --&gt;\n&lt;mapper namespace&#x3D;&quot;com.atguigu.mybatis.dao.EmployeeMapper&quot;&gt;\n\n    &lt;!-- 编写具体的SQL语句，使用id属性唯一的标记一条SQL语句 --&gt;\n    &lt;!-- resultType属性：指定封装查询结果的Java实体类的全类名 --&gt;\n    &lt;select id&#x3D;&quot;selectEmployee&quot; resultType&#x3D;&quot;com.atguigu.mybatis.entity.Employee&quot;&gt;\n        &lt;!-- Mybatis负责把SQL语句中的#&#123;&#125;部分替换成“?”占位符，在#&#123;&#125;内部还是要声明一个见名知意的名称 --&gt;\n        select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id&#x3D;#&#123;empId&#125;\n    &lt;&#x2F;select&gt;\n&lt;&#x2F;mapper&gt;\n\n\n\n\n\n\n\n\n\n\n注意：配置文件存放的位置是src/main/resources目录下。\n4.测试文件编写\n@Test\npublic void testSelectEmployee() throws IOException &#123;\n    \n    &#x2F;&#x2F; 1.创建SqlSessionFactory对象\n    &#x2F;&#x2F; ①声明Mybatis全局配置文件的路径\n    String mybatisConfigFilePath &#x3D; &quot;mybatis-config.xml&quot;;\n    \n    &#x2F;&#x2F; ②以输入流的形式加载Mybatis配置文件\n    InputStream inputStream &#x3D; Resources.getResourceAsStream(mybatisConfigFilePath);\n    \n    &#x2F;&#x2F; ③基于读取Mybatis配置文件的输入流创建SqlSessionFactory对象\n    SqlSessionFactory sessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);\n    \n    &#x2F;&#x2F; 2.使用SqlSessionFactory对象开启一个会话\n    SqlSession session &#x3D; sessionFactory.openSession();\n    \n    &#x2F;&#x2F; 3.根据Mapper配置文件的名称空间+SQL语句的id找到具体的SQL语句\n    &#x2F;&#x2F; 格式是：名称空间.SQL语句的id\n    String statement &#x3D; &quot;com.atguigu.mybatis.dao.EmployeeMapper.selectEmployee&quot;;\n    \n    &#x2F;&#x2F; 要传入SQL语句的参数\n    Integer empId &#x3D; 1;\n    \n    &#x2F;&#x2F; 执行SQL语句\n    Object result &#x3D; session.selectOne(statement, empId);\n    \n    System.out.println(&quot;o &#x3D; &quot; + result);\n    \n    &#x2F;&#x2F; 4.关闭SqlSession\n    session.close();\n&#125;\n\n\n\n\n\n\n\n\n\n\n说明：\n\nSqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话）\nSqlSessionFactory：是“生产”SqlSession的“工厂”。\n工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象。\n\n注意：\n\n==如果是修改删除操作，若没有调用 SqlSession 的 commit 的方法，数据是不会提交到数据库的==\n\n:hatching_chick: mybatis执行过程① 执行流程误区初始化xml配置文件时，就把数据封装到对象中了，都在Java代码中执行\n刚开始接触框架，我们会认为Java程序会转入XML配置文件中执行，但其实框架会在初始化时将XML文件读取进来，封装到对象中，再然后就都是Java代码的执行了，XML中的配置是没法执行的。\n\n② 执行流程\n:hatching_chick: 日志① 概述日志就是记录程序的运行轨迹，方便查找关键信息，也方便快速定位解决问题。\n\n常用的日志框架：Log4j 、Slf4j 、Logback 。\n\n② 日志框架介绍门面（相当于接口）：\n\n\n\n名称\n说明\n\n\n\nJCL（Jakarta Commons Logging）\n陈旧\n\n\nSLF4J（Simple Logging Facade for Java）★\n适合\n\n\njboss-logging\n特殊专业领域使用\n\n\n实现：\n\n\n\n名称\n说明\n\n\n\nlog4j★\n最初版\n\n\nJUL（java.util.logging）\nJDK自带\n\n\nlog4j2\nApache收购log4j后全面重构，内部实现和log4j完全不同\n\n\nlogback★\n优雅、强大\n\n\n\n\n\n\n\n\n\n\n\n注：标记★的技术是同一作者。\n③ log4j相关依赖&lt;!-- log4j日志 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.2.17&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n④ 配置文件\n\n\n\n\n\n\n\n\n支持XML和properties属性文件两种形式。无论使用哪种形式，文件名是固定的  log4j.xml  /  log4j.properties\n在 maven项目的 main/resource/log4j.xml\nSTDOUT是standard output的缩写，意思是标准输出。对于Java程序来说，打印到标准输出就是打印到控制台\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;\n    \n&lt;log4j:configuration xmlns:log4j&#x3D;&quot;http:&#x2F;&#x2F;jakarta.apache.org&#x2F;log4j&#x2F;&quot;&gt;\n    \n    &lt;appender name&#x3D;&quot;STDOUT&quot; class&#x3D;&quot;org.apache.log4j.ConsoleAppender&quot;&gt;\n        &lt;param name&#x3D;&quot;Encoding&quot; value&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n        &lt;layout class&#x3D;&quot;org.apache.log4j.PatternLayout&quot;&gt;\n            &lt;param name&#x3D;&quot;ConversionPattern&quot; value&#x3D;&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m  (%F:%L) \\n&quot; &#x2F;&gt;\n        &lt;&#x2F;layout&gt;\n    &lt;&#x2F;appender&gt;\n    &lt;logger name&#x3D;&quot;java.sql&quot;&gt;\n        &lt;level value&#x3D;&quot;debug&quot; &#x2F;&gt;\n    &lt;&#x2F;logger&gt;\n    &lt;logger name&#x3D;&quot;org.apache.ibatis&quot;&gt;\n        &lt;level value&#x3D;&quot;info&quot; &#x2F;&gt;\n    &lt;&#x2F;logger&gt;\n    &lt;root&gt;\n        &lt;level value&#x3D;&quot;debug&quot; &#x2F;&gt;\n        &lt;appender-ref ref&#x3D;&quot;STDOUT&quot; &#x2F;&gt;\n    &lt;&#x2F;root&gt;\n&lt;&#x2F;log4j:configuration&gt;\n\n⑤ 日志的级别\n\n\n日志级别\n描述\n\n\n\nOFF\n关闭：最高级别，不输出日志。\n\n\nFATAL\n致命：输出非常严重的可能会导致应用程序终止的错误。\n\n\nERROR\n错误：输出错误，但应用还能继续运行。\n\n\nWARN\n警告：输出可能潜在的危险状况。\n\n\nINFO\n信息：输出应用运行过程的详细信息。\n\n\nDEBUG\n调试：输出更细致的对调试应用有用的信息。\n\n\nTRACE\n跟踪：输出更细致的程序运行轨迹。\n\n\nALL\n所有：输出所有级别信息。\n\n\n日志优先级别标准顺序为：ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF\n⑥ 打印效果DEBUG 05-24 18:51:13,331 &#x3D;&#x3D;&gt;  Preparing: select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id&#x3D;?  (BaseJdbcLogger.java:137) \nDEBUG 05-24 18:51:13,371 &#x3D;&#x3D;&gt; Parameters: 1(Integer)  (BaseJdbcLogger.java:137) \nDEBUG 05-24 18:51:13,391 &lt;&#x3D;&#x3D;      Total: 1  (BaseJdbcLogger.java:137) \no &#x3D; Employee&#123;empId&#x3D;1, empName&#x3D;&#39;tom&#39;, empSalary&#x3D;200.33&#125;\n\n\n\n:hatching_chick: #{} 和 ${}* 使用  #&#123; &#125; \n\n  底层使用的是PreparedStatement，使用占位符（MyBatis 会将 sql 中的&#96;#&#123;&#125;&#96;替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值），安全性高，可以避免SQL注入。不需要进行SQL拼接\n\n* 使用  $&#123; &#125;\n\n  底层使用的Statement，使用的是字符串的拼接，容易出错，并且不安全，无法有效的避免SQL注入。一般不使用。\n  \n  是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如\\$&#123;driver&#125;会被静态替换为&#96;com.mysql.jdbc.Driver&#96;。\n\n&lt;insert id&#x3D;&quot;insertEmployee&quot;&gt;\n    &lt;!-- 现在在这条SQL语句中，#&#123;&#125;中的表达式需要被用来从Emp emp实体类中获取emp_name的值、emp_salary的值 --&gt;\n    &lt;!-- 而我们从实体类中获取值通常都是调用getXxx()方法 --&gt;\n    &lt;!-- 而getXxx()方法、setXxx()方法定义了实体类的属性 --&gt;\n    &lt;!-- 定义属性的规则是：把get、set去掉，剩下部分首字母小写 --&gt;\n    &lt;!-- 所以我们在#&#123;&#125;中使用getXxx()方法、setXxx()方法定义的属性名即可 --&gt;\n    insert into t_emp(emp_name,emp_salary) values(#&#123;empName&#125;,#&#123;empSalary&#125;)\n&lt;&#x2F;insert&gt;\n\n\n应用场景\n在SQL语句中，数据库表的表名不确定，需要外部动态传入，此时不能使用#&#123;&#125;，因为数据库不允许表名位置使用问号占位符，此时只能使用$&#123;&#125;。\n\n其他情况，只要能用#&#123;&#125;肯定不用$&#123;&#125;，避免SQL注入。\n\n\n\n:hatching_chick: 使用接口改进案例\npublic interface EmployeeMapper &#123;\n    \n    Employee selectEmployee(Integer empId);\n        \n&#125;\n\n\n\n\n\n\n\n\n\n\n注意：\n方法名和SQL的id一致方法返回值和resultType一致方法的参数和SQL的参数一致接口的全类名和映射配置文件的名称空间一致\n由于Mapper接口中方法名是作为SQL语句标签的id，不能重复，所以Mapper接口中不能出现重名的方法，不允许重载！\n:hatching_chick: 数据输入① mybatis机制sql语句 + 参数   -----&gt;    mybatis处理   -------&gt;    读写数据库或返回相关参数\n\n② 输入的概念这里数据输入具体是指上层方法（例如Service方法）调用Mapper接口时，数据传入的形式。\n* 简单类型： 只包含一个值的类型\n    * 基本数据类型\n    * 基本包装类型\n    * 字符串类型\n* 复杂类型： 包含多个值的数据类型\n    * 实体类型\n    * 集合类型\n    * 数组类型\n    * 复合类型 List&lt;User&gt; 集合中是实体\n\n③ 单个参数类型1.接口\nEmployee selectEmployee(Integer empId);  \n\n2.sql\n&lt;select id&#x3D;&quot;selectEmployee&quot; resultType&#x3D;&quot;com.atguigu.mybatis.entity.Employee&quot;&gt;\n    select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id&#x3D;#&#123;empId&#125;\n&lt;&#x2F;select&gt;\n\n④ 实体参数类型1.接口\nint insertEmployee(Employee employee);\n\n2.sql\n&lt;insert id&#x3D;&quot;insertEmployee&quot;&gt;\n    insert into t_emp(emp_name,emp_salary) values(#&#123;empName&#125;,#&#123;empSalary&#125;)\n&lt;&#x2F;insert&gt;\n\n3.结论\nMybatis会根据#&#123;&#125;中传入的数据，加工成getXxx()方法，通过反射在实体类对象中调用这个方法，从而获取到对应的数据。填充到#&#123;&#125;这个位置。\n\n\n⑤ 零散简单数据类型1.接口\nint updateEmployee(@Param(&quot;empId&quot;) Integer empId,@Param(&quot;empSalary&quot;) Double empSalary);\n\n2.sql\n&lt;update id&#x3D;&quot;updateEmployee&quot;&gt;\n    update t_emp set emp_salary&#x3D;#&#123;empSalary&#125; where emp_id&#x3D;#&#123;empId&#125;\n&lt;&#x2F;update&gt;\n\n\n⑥ Map参数类型1.接口\nint updateEmployeeByMap(Map&lt;String, Object&gt; paramMap);\n\n2.sql\n&lt;update id&#x3D;&quot;updateEmployeeByMap&quot;&gt;\n     update t_emp set emp_salary&#x3D;#&#123;empSalaryKey&#125; where emp_id&#x3D;#&#123;empIdKey&#125;\n&lt;&#x2F;update&gt;\n\n3.测试代码\n@Test\npublic void testUpdateEmpNameByMap() &#123;\n    \n    EmployeeMapper mapper &#x3D; session.getMapper(EmployeeMapper.class);\n    \n    Map&lt;String, Object&gt; paramMap &#x3D; new HashMap&lt;&gt;();\n    \n    paramMap.put(&quot;empSalaryKey&quot;, 999.99);\n    paramMap.put(&quot;empIdKey&quot;, 5);\n    \n    int result &#x3D; mapper.updateEmployeeByMap(paramMap);\n    \n    System.out.println(&quot;result &#x3D; &quot; + result);\n&#125;\n\n\n\n\n\n\n\n\n\n\n#{}中写Map中的key\n有很多零散的参数需要传递，但是没有对应的实体类类型可以使用。使用@Param注解一个一个传入又太麻烦了。所以都封装到Map中。\n:hatching_chick: 数据输出返回单个简单类型数据\n\n返回实体类对象\n通过给数据库表字段加别名，让查询结果的每一列都和Java实体类中属性对应起来。\n\n返回Map类型\n适用于SQL查询返回的各个字段综合起来并不和任何一个现有的实体类对应，没法封装到实体类对象中。能够封装成实体类类型的，就不使用Map类型。\n\n返回List类型\n查询结果返回多个实体类对象，希望把多个实体类对象放在List集合中返回。此时不需要任何特殊处理，在resultType属性中还是设置实体类类型即可。\n\n\n\n:hatching_chick: 返回自增主键1.接口\nint insertEmployee(Employee employee);\n\n2.sql\n&lt;!-- int insertEmployee(Employee employee); --&gt;\n&lt;!-- useGeneratedKeys属性字面意思就是“使用生成的主键” --&gt;\n&lt;!-- keyProperty属性可以指定主键在实体类对象中对应的属性名，Mybatis会将拿到的主键值存入这个属性 --&gt;\n&lt;insert id&#x3D;&quot;insertEmployee&quot; useGeneratedKeys&#x3D;&quot;true&quot; keyProperty&#x3D;&quot;empId&quot;&gt;\n    insert into t_emp(emp_name,emp_salary)\n    values(#&#123;empName&#125;,#&#123;empSalary&#125;)\n&lt;&#x2F;insert&gt;\n\n在 mapper 接口中入参时使用了 @Param 注解\n\n当使用了 @Param 注解后，想把 insert 插入操作成功后的自增 id 返回出来，需要在\n\nkeyProperty 设置值时，添加 @Param(&quot;xxx&quot;) 括号中定义的别名  比如别名是emp，这keyProperty&#x3D;&quot;emp.empId&quot;;\n\n3.注意\nMybatis是将自增主键的值设置到实体类对象中，而不是以Mapper接口方法返回值的形式返回。\n而对于不支持自增型主键的数据库（例如 Oracle），则可以使用 selectKey 子元素：selectKey  元素将会首先运行，id  会被设置，然后插入语句会被调用\n:hatching_chick: 表字段和实体属性1.别名\n将字段的别名设置成和实体类属性一致。\n&lt;!-- 编写具体的SQL语句，使用id属性唯一的标记一条SQL语句 --&gt;\n&lt;!-- resultType属性：指定封装查询结果的Java实体类的全类名 --&gt;\n&lt;select id&#x3D;&quot;selectEmployee&quot; resultType&#x3D;&quot;com.atguigu.mybatis.entity.Employee&quot;&gt;\n    &lt;!-- Mybatis负责把SQL语句中的#&#123;&#125;部分替换成“?”占位符 --&gt;\n    &lt;!-- 给每一个字段设置一个别名，让别名和Java实体类中属性名一致 --&gt;\n    select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id&#x3D;#&#123;maomi&#125;\n&lt;&#x2F;select&gt;\n\n\n\n\n\n\n\n\n\n\n关于实体类属性的约定：\ngetXxx()方法、setXxx()方法把方法名中的get或set去掉，首字母小写。\n2.全局配置自动识别驼峰式命名规则\n在Mybatis全局配置文件加入如下配置\n&lt;!-- 使用settings对Mybatis全局进行设置 --&gt;\n&lt;settings&gt;\n    &lt;!-- 将xxx_xxx这样的列名自动映射到xxXxx这样驼峰式命名的属性名 --&gt;\n    &lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n&lt;&#x2F;settings&gt;\n\nSQL语句中可以不使用别名\n&lt;!-- Employee selectEmployee(Integer empId); --&gt;\n&lt;select id&#x3D;&quot;selectEmployee&quot; resultType&#x3D;&quot;com.atguigu.mybatis.entity.Employee&quot;&gt;\n    select emp_id,emp_name,emp_salary from t_emp where emp_id&#x3D;#&#123;empId&#125;\n&lt;&#x2F;select&gt;\n\n3.使用resultMap\n使用resultMap标签定义对应关系，再在后面的SQL语句中引用这个对应关系\n&lt;!-- 专门声明一个resultMap设定column到property之间的对应关系 --&gt;\n&lt;resultMap id&#x3D;&quot;selectEmployeeByRMResultMap&quot; type&#x3D;&quot;com.atguigu.mybatis.entity.Employee&quot;&gt;\n    \n    &lt;!-- 使用id标签设置主键列和主键属性之间的对应关系 --&gt;\n    &lt;!-- column属性用于指定字段名；property属性用于指定Java实体类属性名 --&gt;\n    &lt;id column&#x3D;&quot;emp_id&quot; property&#x3D;&quot;empId&quot;&#x2F;&gt;\n    \n    &lt;!-- 使用result标签设置普通字段和Java实体类属性之间的关系 --&gt;\n    &lt;result column&#x3D;&quot;emp_name&quot; property&#x3D;&quot;empName&quot;&#x2F;&gt;\n    &lt;result column&#x3D;&quot;emp_salary&quot; property&#x3D;&quot;empSalary&quot;&#x2F;&gt;\n&lt;&#x2F;resultMap&gt;\n    \n&lt;!-- Employee selectEmployeeByRM(Integer empId); --&gt;\n&lt;select id&#x3D;&quot;selectEmployeeByRM&quot; resultMap&#x3D;&quot;selectEmployeeByRMResultMap&quot;&gt;\n    select emp_id,emp_name,emp_salary from t_emp where emp_id&#x3D;#&#123;empId&#125;\n&lt;&#x2F;select&gt;\n\n\n\n:hatching_chick: 相关标签① properties在Mybatis全局配置文件中指定外部jdbc.properties文件的位置\n&lt;properties resource&#x3D;&quot;jdbc.properties&quot;&#x2F;&gt;\n\n而mybatis中用 $&#123;driver&#125;,$&#123;username&#125;等进行引用\n\n② MapperMybatis真正的核心在映射文件中，比直接使用jdbc节省了许多代码，而且将sql代码独立在java代码之外，可以惊醒更加细致的sql优化\n\nMapper映射文件中的顶级元素\n1. select 映射查询语句\n2. insert 插入\n3. update 更新\n4. delete 删除\n5. sql 可以重用的书签栏代码块\n6. resultMap （不是select标签内的那个）最复杂，最有力量的元素，用来面熟如何从数据库结果集中加载你的对象\n7. cache 配置给定命名空间的缓存\n8. cache-ref 从其他命名空间引用缓存配置 \n\nMapper文件中的 &lt;mapper&gt;标签属性信息\n\nnamespace：namespace是一个命名空间，一个命名空间对应着一个dao接口（唯一值）\n\n\t\t  要求使用 dao接口的 全限定名称，也就是全类名\n\nMapper文件中的 select标签内的属性信息\n\n必须配置：\n\n\tid: id是命名空间的唯一标识符，可以用来代替这条sql语句\n\t\t\n\t\t这个id也应该对应着所属命名空间间对应的道接口中的某个方法\n\t\t\n\t\tsql语句相当于方法的实现，因此，id应该与方法名一致\n\n可选配置：\n\n\tresultType：用来指定返回类型，指定类型可以是基本类型，也可以是java容器，也可以是javaBean\n\t\n\t            resultType 与 resultMap 二选一配置\n\t            \n\tresultMap：用于引用我们通过 resultMap标签定义的映射类型，这也是 mybatis组件的高级复杂映射关键\n\t\n\tparameterType：主要指定将要传入语句的参数的类型，可以是int，sort，long等，也可以是java对象\n\t\n\tstatementType：STATEMENT, PREPARED或CALLABLE的一种，默认值：PREPARED\n\t\n\t\t\t\t  这会让MyBatis使用选择Statement, PrearedStatement或CallableStatement，\n\nMapper文件中的 resultMap标签属性信息\n\n1. type 对应的返回类型，可以是javabean, 也可以是其它\n\n2. id 必须唯一， 用于标示这个resultMap的唯一性，在使用resultMap的时候，就是通过id引用\n\n3. extends 继承其他resultMap标签\n\n③ sqlMapper文件中的 sql标签（重用sql代码块）\n\n例：&lt;sql id&#x3D;&quot;userColumns&quot;&gt;id,username,password&lt;&#x2F;sql&gt;\n\n   &lt;select id&#x3D;&quot;selectList&quot; paramertType&#x3D;&quot;int&quot; resultType&#x3D;&quot;hashmap&quot;&gt;\n　\t　SELECT \n    \t　　&lt;include refid&#x3D;&quot;userColumns&quot;&#x2F;&gt;\n　　\t FROM \n    \t　　user\n   &lt;&#x2F;select&gt;\n\n④ typeAliases完全限定名使用别名替代\n\n在 mybatis 配置文件中，如下配置\n\n&lt;typeAliases&gt;\n\t&lt;!--这里是导入一个实体类，而package是导入包下所有的--&gt;\n    &lt;typeAlias type&#x3D;&quot;com.charon.dao.StudentDao&quot; alias&#x3D;&quot;StudentDao&quot;&#x2F;&gt;\n    \n    &lt;!-- 声明了实体类所在的包之后，在Mapper配置文件中，只需要指定这个包下的实体类名首字母小写即可 --&gt;\n    &lt;package name&#x3D;&quot;com.atguigu.mybatis.entity&quot;&#x2F;&gt;\n&lt;&#x2F;typeAliases&gt;\n\n⑤ mappersmybatis 的 mappers标签中 mapper映射器引入映射文件\n\nmybatis的主配置文件中需要引入映射文件，有四种方法（后两种很少用）\n\n1、 &lt;mapper resource&#x3D;&quot; &quot; &#x2F;&gt;\n    使用相对于类路径的资源\n    \n2、&lt;mapper class&#x3D;&quot; &quot; &#x2F;&gt;\n   使用mapper接口类路径\n   如：&lt;mapper class&#x3D;&quot;com.iss.mybatis.mapper.UserMapper&quot;&#x2F;&gt;\n   注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。\n\nMybatis允许在指定Mapper映射文件时，只指定其所在的包：\n&lt;mappers&gt;\n        &lt;package name&#x3D;&quot;com.atguigu.mybatis.dao&quot;&#x2F;&gt;\n&lt;&#x2F;mappers&gt;\n\n\n此时这个包下的所有Mapper配置文件将被自动加载、注册，比较方便。\n但是，要求是：\nMapper接口和Mapper配置文件名称一致==Mapper配置文件放在Mapper接口所在的包内==\n\n","slug":"43-Mybatis-基础要点","date":"2021-09-13T15:20:32.000Z","categories_index":"Mybatis","tags_index":"Mybatis","author_index":"大黄"},{"id":"a978a5e93d8e6628e9f4ee713be55be8","title":"Redis","content":"1. NoSQL数据库1.1  技术发展技术的分类\n1、解决功能性的问题：Java、JSP、RDBMS、Tomcat、HTML、Linux、JDBC、SVN\n2、解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis\n3、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch\n1.2 NoSQL特点 适用场合\n特点\n易扩展：不依赖业务逻辑方式存储，以简单的key-value模式存储，扩展能力高\n大数据量，高性能：NoSQL泛指非关系型数据库，关系简单，数据库结构简单\n灵活的数据模型（视频/音频/位置地图等）：不遵循sql标准，无需事先为要存储的数据建立字段，随时自定义数据存储格式\n高可用：nosql数据库不是强一致的，而是最终一致的，也没有严格遵守ACID约束\n\n\n适用场景\n对数据高并发读写\n海量数据的读写\n对数据高可扩展性\n\n\n\n### 计数器\n\n可以对 String 进行自增自减运算，从而实现计数器功能。\n\nRedis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。\n\n### 缓存\n\n将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。\n\n### 查找表\n\n例如 DNS 记录就很适合使用 Redis 进行存储。\n\n查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。\n\n### 消息队列\n\nList 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息\n\n不过最好使用 Kafka、RabbitMQ 等消息中间件。\n\n### 会话缓存\n\n可以使用 Redis 来统一存储多台应用服务器的会话信息。\n\n当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。\n\n### 分布式锁实现\n\n在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。\n\n可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。\n\n### 其它\n\nSet 可以实现交集、并集等操作，从而实现共同好友等功能。\n\nZSet 可以实现有序性操作，从而实现排行榜等功能。\n\n\n不适用场景\n需要事务支持\n基于sql的结构化查询存储，处理复杂的关系，需要即席查询\n\n\n\n1.3 主要的NoSQL数据库\nMemcache nosql数据库\n\n临时性键值存储，一般不支持持久化，支持类型单一，一般作为缓存数据库辅助持久化数据库\n\n\nRedis 缓存数据库\n\nredis支持两种持久化策略（RDB 快照和 AOF 日志），主要用作备份恢复\n\n支持多种数据结构存储，如key-value，list，set，hash，zset，一般也是作为缓存数据库辅助持久化数据库\n\nMemcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。\nRedis Cluster 实现了分布式的支持。\n\n在 ==Redis 中，并不是所有数据都一直存储在内存中==，可以将一些很久没用的 value 交换到磁盘，而 ==Memcached== 的数据则==会一直在内存中==。\n\n\n\nMongoDB  文档型数据库\n\n数据都在内存中，若内存不足，则吧不常用的保存到硬盘中\n虽然是key-value模式，但对value提供了丰富的查询功能\n支持二进制数据及大型对象\n可根据特点替代 RDBMS，或配合RDBMS 存储特定的数据\n\n\n面向列的数据库\n\nHbase hadoop生态系统中原生的一种nosql数据库，重量级的分布式nosql数据库，用于海量数据的场景，实时的读写\nCassandra hadoop生态系统中原生的一种分布式nosql数据库，管理庞大集群上的海量数据集，对读写操作进行了规模调整\n\n\n图关系型数据库\n\nNeo4j 主要应用于社会关系，交通网路，它以节点，关系和属性的形式存储应用程序的数据\n\n\n\n2. Redis2.1 概述Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和多种不同类型的值之间的映射。\n\n键的类型只能为字符串，支持多种数据结构，如 string（字符串）、 list(双向链表)、dict(hash表)、set(集合）、zset(排序set)、hyperloglog（基数估算）\n\nRedis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。\n\n2.2 特点和应用场景\n特点\n支持多种数据结构\n支持持久化操作，可以进行aof及rdb数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失的手段。\n支持数据复制，通过master-slave机制，可以实时进行数据的同步复制，支持多级复制和增量复制，master-slave机制是Redis进行HA的重要手段。\n单线程请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。性能受限于CPU性能\n数据都是缓存在内存中。区别是Redis会周期性把更新的数据写入磁盘或把修改操作写入追加的记录文件。\n支持简单的事务需求\n\n\n应用场景\n配合关系型数据库做高速缓存\n多样的数据结构存储持久化数据\n\n\n\n2.3 安装目录介绍redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何\nredis-check-aof：修复有问题的AOF文件，rdb和aof后面讲\nredis-check-dump：修复有问题的dump.rdb文件\nredis-sentinel：Redis集群使用\nredis-server：Redis服务器启动命令\nredis-cli：客户端，操作入口\nbind 127.0.0.1 #注释掉这部分，这是限制redis只能本地访问\n\nprotected-mode no #默认yes，开启保护模式，限制为本地访问\n\ndaemonize no#默认no，改为yes意为以守护进程方式启动，可后台运行，除非kill进程，改为yes会使配置文件方式启动redis失败\n\ndatabases 16 #数据库个数（可选），我修改了这个只是查看是否生效。。\n\ndir  .&#x2F; #输入本地redis数据库存放文件夹（可选）\n\nappendonly yes #redis持久化（可选）\n\n2.4 设置后台启动前台启动（不推荐）：前台启动，命令行窗口不能关闭，否则服务器停止\n\n后台启动（推荐）\n1.\t备份redis.conf ，拷贝一份redis.conf到其他目录\n\t[root@localhost opt]# mkdir &#x2F;myredis\n\t[root@localhost opt]# cp redis-6.2.1&#x2F;redis.conf &#x2F;myredis&#x2F;redis.conf\n\t\n2.  cd reids-6.2.1\n\t  make\n\t  make install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis\n\t\n2.\t后台启动设置daemonize no改成yes\n\t修改redis.conf(128行)文件将里面的daemonize no 改成 yes，让服务在后台启动\n\t\n3.\tRedis启动\n\t&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server  &#x2F;myredis&#x2F;redis.conf\n \n4.\t用客户端访问：redis-cli\n \n5.\t多个端口可以：redis-cli -p 6379\n\n6.\t测试验证： ping\nRedis Ping 命令使用客户端向 Redis 服务器发送一个 PING ，如果服务器运作正常的话，会返回一个 PONG 。通常用于测试与服务器的连接是否仍然生效，或者用于测量延迟值。\n\n7.\tRedis关闭\n单实例关闭：redis-cli shutdown\n \n也可以进入终端后再关闭\n \n多实例关闭，指定端口关闭：redis-cli -p 6379 shutdown\n\n\n2.5 命令手册网址https:&#x2F;&#x2F;www.redis.net.cn&#x2F;order&#x2F;\n\nhttp:&#x2F;&#x2F;doc.redisfans.com&#x2F;\n\nhttp:&#x2F;&#x2F;www.redis.cn&#x2F;commands.html\n\n\n\n3. 数据类型\n\n\n数据类型\n可以存储的值\n操作\n\n\n\nSTRING\n字符串、整数或者浮点数\n对整个字符串或者字符串的其中一部分执行操作 对整数和浮点数执行自增或者自减操作\n\n\nLIST\n列表\n从两端压入或者弹出元素  对单个或者多个元素进行修剪， 只保留一个范围内的元素\n\n\nSET\n无序集合\n添加、获取、移除单个元素 检查一个元素是否存在于集合中 计算交集、并集、差集 从集合里面随机获取元素\n\n\nHASH\n包含键值对的无序散列表\n添加、获取、移除单个键值对 获取所有键值对 检查某个键是否存在\n\n\nZSET\n有序集合\n添加、获取、删除元素 根据分值范围或者成员来获取元素 计算一个键的排名\n\n\n3.1 几个基本的命令KEYS * 获得当前数据库的所有键\n\nEXISTS key [key ...]  判断键是否存在，返回个数，如果key有一样的也是叠加数\n\nDEL key [key ...]       删除键，返回删除的个数\n\nTYPE key                  获取减值的数据类型（string，hash，list，set，zset）\n\nFLUSHALL                清空所有数据库\n\nCONFIG [get、set]    redis配置\n\n-inf 负无穷\n\n+inf正无穷\n\n3.2 字符串String字符串类型是Redis的最基本类型，它可以存储任何形式的字符串。其它的四种类型都是字符串类型的不同形式。\n\n最基本的命令：GET、SET         语法：GET key，SET key value   value如果有空格需要双引号以示区分\n\n整数递增：INCR                语法：INCR key    默认值为0，所以首先执行命令得到 1 ，不是整型提示错误\n\n增加指定的整数：INCRBY         语法：INCRBY key increment\n\n整数递减：DECR                语法：DECR key   默认值为0，所以首先执行命令得到 -1，不是整型提示错误\n\n减少指定的整数：DECRBY         语法：DECRBY key increment\n\n增加指定浮点数：INCRBYFLOAT    语法：INCRBYFLOAT key increment  与INCR命令类似，只不过可以递增一个双精度浮点数\n\n向尾部追加值：APPEND           语法：APPEND key value   redis客户端并不是输出追加后的字符串，而是输出字符串总长度\n\n获取字符串长度：STRLEN         语法：STRLEN key  如果键不存在返回0，注意如果有中文时，一个中文长度是3，redis是使用UTF-8编码中文的\n\n获取多个键值：MGET             语法：MGET key [key ...]  例如：MGET key1 key2 \n\n设置多个键值：MSET             语法：MSET key value [key value ...]  例如：MSET key1 1 key2 &quot;hello redis&quot;\n\n二进制指定位置值：GETBIT        语法：GETBIT key offset   例如：GETBIT key1 2 ，key1为hello 返回 1，返回的值只有0或1，当key不存在或超出实际长度时为0\n\n设置二进制位置值：SETBIT        语法：SETBIT key offset value ，返回该位置的旧值\n\n二进制是1的个数：BITCOUNT       语法：BITCOUNT key [start end] ，start 、end为开始和结束字节\n\n位运算：BITOP                 语法：BITOP operation destkey key [key ...]  ，operation支持AND、OR、XOR、NOT\n\n偏移：BITPOS                        语法：BITPOS key bit [start] [end]\n\n在set时，set后跟不同的后缀有不一样的效果：\n\t*NX：当数据库中key不存在时，可以将key-value添加数据库\n\t*XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥\n\t*EX：key的超时秒数\n\t*PX：key的超时毫秒数，与EX互斥\n\t\nmsetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;  ..... \n同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。\n\ngetrange  &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;\n获得值的范围，类似java中的substring，前包，后包\n\nsetrange  &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;\n用 &lt;value&gt;  覆写&lt;key&gt;所储存的字符串值，从&lt;起始位置&gt;开始(索引从0开始)。\n\nsetex  &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;\n设置键值的同时，设置过期时间，单位秒。\n\ngetset &lt;key&gt;&lt;value&gt;\n以新换旧，设置了新值同时获得旧值。\n\n\n3.3 列表类型（list）单键多值\n\nRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。\n\n它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。\n\n添加左边元素：LPUSH             语法：LPUSH key value [value ...]  ，返回添加后的列表元素的总个数\n\n添加右边元素：RPUSH             语法：RPUSH key value [value ...]  ，返回添加后的列表元素的总个数\n\n移除左边第一个元素：LPOP         语法：LPOP key  ，返回被移除的元素值\n\n移除右边第一个元素：RPOP         语法：RPOP key ，返回被移除的元素值 \n\n列表元素个数：LLEN              语法：LLEN key， 不存在时返回0，redis是直接读取现成的值，并不是统计个数\n\n获取列表片段：LRANGE            语法：LRANGE key start stop，如果start比stop靠后时返回空列表，0 -1 返回整个列表\n\t\t\t\t\t\t\t  正数时：start 开始索引值，stop结束索引值（索引从0开始）\n    \t\t\t\t\t\t  负数时：例如 lrange num -2 -1，-2表示最右边第二个，-1表示最右边第一个，\n\n删除指定值：LREM                语法：LREM key count value，返回被删除的个数\n\t\t\t\t\t\t\t\t\tcount&gt;0，从左边开始删除前count个值为value的元素\n    \t\t\t\t\t\t\t\tcount&lt;0，从右边开始删除前|count|个值为value的元素\n    \t\t\t\t\t\t\t\tcount&#x3D;0，删除所有值为value的元素\n\n索引元素值：LINDEX              语法：LINDEX key index ，返回索引的元素值，-1表示从最右边的第一位\n\n设置元素值：LSET                语法：LSET key index value\n\n保留列表片段：LTRIM              语法：LTRIM key start stop，start、top 参考lrange命令\n\n一个列表转移另一个列表：RPOPLPUSH  \n语法：RPOPLPUSH source desctination ，从source列表转移到desctination列表，命令分两步看，首先source列表RPOP右移除，再desctination列表LPUSH\n\n3.4 集合类型（set）集合类型  值具有 唯一性 ，常用操作是向集合添加、删除、判断某个值是否存在，集合内部是使用值为空的散列表实现的\n\nRedis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是O(1)。\n\n添加元素：SADD                  语法：SADD key member [member ...] ，向一个集合添加一个或多个元素，因为集合的唯一性，所以添加相同值时会被忽略。返回成功添加元素的数量。\n\n删除元素：SREM                  语法：SREM key member [member ...] 删除集合中一个或多个元素，返回成功删除的个数。\n\n获取全部元素：SMEMBERS           语法：SMEMBERS key ，返回集合全部元素\n\n值是否存在：SISMEMBER            语法：SISMEMBER key member ，如果存在返回1，不存在返回0\n\n差运算：SDIFF                   语法：SDIFF key [key ...] ，例如：集合A和集合B，差集表示A-B，在A里有的元素B里没有，返回差集合；多个集合(A-B)-C\n\n交运算：SINTER             　　  语法：SINTER key [key ...]，返回交集集合，每个集合都有的元素\n\n并运算：SUNION　　　　　　        语法：SUNION key [key ...]，返回并集集合，所有集合的元素\n\n集合元素个数：SCARD              语法：SCARD key ，返回集合元素个数\n\n集合运算后存储结果                语法：SDIFFSTROE destination key [key ...] ，差运算并存储到destination新集合中\n\t\t\t\t\t\t\t\t\tSINTERSTROE destination key [key ...]，交运算并存储到destination新集合中\t\t\t\t\t\t\t\t\tSUNIONSTROE destination key [key ...]，并运算并存储到destination新集合中\n\n随机获取元素：SRANDMEMGER 语法：SRANDMEMBER key [count]，根据count不同有不同结果，count大于元素总数时返回全部元素\n\t\t\t\t\t\t\tcount&gt;0 ，返回集合中count不重复的元素\n\t\t\t\t\t\t\tcount&lt;0，返回集合中count的绝对值个元素，但元素可能会重复\n\n弹出元素：SPOP                 语法：SPOP key [count] ，因为集合是无序的，所以spop会随机弹出一个元素\n\n把集合中一个值从一个集合移动到另一个集合  语法：smove &lt;source&gt;&lt;destination&gt;value\n\n3.5 散列类型（hash）Redis hash 是一个键值对集合，value是一个string类型的field和value的映射表，hash特别适合用于存储对象，类似Java里面的Map&lt;String,Object&gt;\n\n\n\n\n\n设置单个：HSET                    语法：HSET key field value，不存在时返回1，存在时返回0，没有更新和插入之分\n\n设置多个：HMSET                   语法：HMSET key field value [field value ...]\n\n读取单个：HGET                    语法：HGET key field，不存在是返回nil\n\n读取多个：HMGET                   语法：HMGET key field [field ...]\n\n读取全部：HGETALL                 语法：HGETALL key，返回时字段和字段值的列表\n\n判断字段是否存在：HEXISTS          语法：HEXISTS key field，存在返回1 ，不存在返回0\n\n字段不存在时赋值：HSETNX           语法：HSETNX key field value，与hset命令不同，hsetnx是键不存在时设置值\n\n增加数字：HINCRBY                 语法：HINCRBY key field increment ，返回增加后的数，不是整数时会提示错误\n\n删除字段：HDEL                    语法：HDEL key field [field ...] ，返回被删除字段的个数\n\n只获取字段名：HKEYS               语法：HKEYS key ，返回键的所有字段名\n\n只获取字段值：HVALS               语法：HVALS key  ，返回键的所有字段值\n\n字段数量：HLEN                    语法：HLEN key ，返回字段总数\n\n3.6 有序集合类型（zset）Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。\n\n不同之处是有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。\n\n因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。\n\n访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。\n\n添加集合元素：ZADD            语法：ZADD key [NX|XX] [CH] [INCR] score member [score member ...]，不存在添加，存在更新。\n\n返回该有序集合的元素个数\t\t语法：zcard&lt;key&gt;\n\n统计该集合，分数区间内的元素个数 语法：zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;\n\n获取元素分数：ZSCORE          语法：ZSCORE key member ，返回元素成员的score 分数\n\n元素小到大：ZRANGE            语法：ZRANGE key start top [WITHSCORES] ，参考LRANGE ，加上withscores 返回带元素，即元素，分数当分数一样时，按元素排序\n\n元素大到小：ZREVRANGE         语法：ZREVRANGE key start [WITHSCORES] ，与zrange区别在于zrevrange是从大到小排序\n\n指定分数范围元素：ZRANGEBYSCORE   语法：ZRANGEBYSCORE key min max [WITHSCORE] [LIMIT offest count]返回从小到大的在min和max之间的元素，( 符号表示不包含，例如：80-100，(80 100，withscore返回带分数,limit offest count 向左偏移offest个元素，并获取前count个元素指定分数范围元素：ZREVRANGESCORE   语法：ZREVRANGEBYSCORE key max  min [WITHSCORE] [LIMIT offest count]与zrangebyscore类似，只不过该命令是从大到小排序的。\n\n增加分数：ZINCRBY             语法：ZINCRBY key increment member ，注意是增加分数，返回增加后的分数；如果成员不存在，则添加一个为0的成员。\n\nzrem  &lt;key&gt;&lt;member &gt;删除该集合下，指定值的元素 \n\nzrank &lt;key&gt;&lt;member &gt; 返回有序集 key 中成员member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。排名以 0 为底，也就是说， score 值最小的成员排名为 0 。\n\nzrevrank &lt;key&gt;&lt;member &gt; 获得成员按 score 值递减(从大到小)排列的排名。\n\n\n\n\n4. 键过期时间 数据淘汰策略4.1 键过期时间Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。\n\n对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。\n\n4.2 数据淘汰策略可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。\n\n\n\n\n策略\n描述\n\n\n\nvolatile-lru\n从已设置过期时间的数据集中挑选最近最少使用的数据淘汰\n\n\nvolatile-ttl\n从已设置过期时间的数据集中挑选将要过期的数据淘汰\n\n\nvolatile-random\n从已设置过期时间的数据集中任意选择数据淘汰\n\n\nallkeys-lru\n从所有数据集中挑选最近最少使用的数据淘汰\n\n\nallkeys-random\n从所有数据集中任意选择数据进行淘汰\n\n\nnoeviction\n禁止驱逐数据\n\n\n作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。\n\n使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。\n\nRedis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。\n\n\n\n5. Redis配置文件介绍5.1 开头说明\n\n这里没什么好说的，需要注意的是后面需要使用内存大小时，可以指定单位，通常是以 k,gb,m的形式出现，并且单位不区分大小写。\n5.2 INCLUDES\n我们知道Redis只有一个配置文件，如果多个人进行开发维护，那么就需要多个这样的配置文件，这时候多个配置文件就可以在此通过 include &#x2F;path&#x2F;to&#x2F;local.conf 配置进来，而原本的 redis.conf 配置文件就作为一个总闸。\n\n另外需要注意的时，如果将此配置写在redis.conf 文件的开头，那么后面的配置会覆盖引入文件的配置，如果想以引入文件的配置为主，那么需要将 include 配置写在 redis.conf 文件的末尾。\n\n5.3 MODULES\nredis3.0的爆炸功能是新增了集群，而redis4.0就是在3.0的基础上新增了许多功能，其中这里的 自定义模块配置就是其中之一。通过这里的 loadmodule 配置将引入自定义模块来新增一些功能。\n\n5.4 NETWORK\n只截取了一部分，下同。\n\n　　①、bind:绑定redis服务器网卡IP，默认为127.0.0.1,即本地回环地址。这样的话，访问redis服务只能通过本机的客户端连接，而无法通过远程连接。如果bind选项为空的话，那会接受所有来自于可用网络接口的连接。\n\n　　②、port：指定redis运行的端口，默认是6379。由于Redis是单线程模型，因此单机开多个Redis进程的时候会修改端口。\n\n　　③、timeout：设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么关闭该连接。默认值为0，表示不关闭。\n\n　　④、tcp-keepalive ：单位是秒，表示将周期性的使用SO_KEEPALIVE检测客户端是否还处于健康状态，避免服务器一直阻塞，官方给出的建议值是300s，如果设置为0，则不会周期性的检测。\n\n5.5 GENERAL\n具体配置详解：\n\n　　①、daemonize:设置为yes表示指定Redis以守护进程的方式启动（后台启动）。默认值为 no\n\n　　②、pidfile:配置PID文件路径，当redis作为守护进程运行的时候，它会把 pid 默认写到 &#x2F;var&#x2F;redis&#x2F;run&#x2F;redis_6379.pid 文件里面\n\n　　③、loglevel ：定义日志级别。默认值为notice，有如下4种取值：\n\n　　　　　　　　　　debug（记录大量日志信息，适用于开发、测试阶段）\n\n　　　　　　　　　　verbose（较多日志信息）\n\n　　　　　　　　　　notice（适量日志信息，使用于生产环境）\n\n　　　　　　　　　　warning（仅有部分重要、关键信息才会被记录）\n\n　　④、logfile ：配置log文件地址,默认打印在命令行终端的窗口上\n\n　　⑤、databases：设置数据库的数目。默认的数据库是DB 0 ，可以在每个连接上使用select  &lt;dbid&gt; 命令选择一个不同的数据库，dbid是一个介于0到databases - 1 之间的数值。默认值是 16，也就是说默认Redis有16个数据库。\n\n5.6 SNAPSHOTTING\n①、save：这里是用来配置触发 Redis的持久化条件，也就是什么时候将内存中的数据保存到硬盘。默认如下配置：\n\nsave 900 1：表示900 秒内如果至少有 1 个 key 的值变化，则保存\nsave 300 10：表示300 秒内如果至少有 10 个 key 的值变化，则保存\nsave 60 10000：表示60 秒内如果至少有 10000 个 key 的值变化，则保存\n　　　　当然如果你只是用Redis的缓存功能，不需要持久化，那么你可以注释掉所有的 save 行来停用保存功能。可以直接一个空字符串来实现停用：save &quot;&quot;\n\n　　②、stop-writes-on-bgsave-error ：默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了\n\n　　③、rdbcompression ；默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。\n\n　　④、rdbchecksum ：默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。\n\n　　⑤、dbfilename ：设置快照的文件名，默认是 dump.rdb\n\n　　⑥、dir：设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。使用上面的 dbfilename 作为保存的文件名。\n\n5.7 REPLICATION①、slave-serve-stale-data：默认值为yes。当一个 slave 与 master 失去联系，或者复制正在进行的时候，slave 可能会有两种表现：\n\n  　　　　1) 如果为 yes ，slave 仍然会应答客户端请求，但返回的数据可能是过时，或者数据可能是空的在第一次同步的时候 \n\n  　　　　2) 如果为 no ，在你执行除了 info he salveof 之外的其他命令时，slave 都将返回一个 &quot;SYNC with master in progress&quot; 的错误\n\n　　②、slave-read-only：配置Redis的Slave实例是否接受写操作，即Slave是否为只读Redis。默认值为yes。\n\n　　③、repl-diskless-sync：主从数据复制是否使用无硬盘复制功能。默认值为no。\n\n　　④、repl-diskless-sync-delay：当启用无硬盘备份，服务器等待一段时间后才会通过套接字向从站传送RDB文件，这个等待时间是可配置的。  这一点很重要，因为一旦传送开始，就不可能再为一个新到达的从站服务。从站则要排队等待下一次RDB传送。因此服务器等待一段  时间以期更多的从站到达。延迟时间以秒为单位，默认为5秒。要关掉这一功能，只需将它设置为0秒，传送会立即启动。默认值为5。\n\n　　⑤、repl-disable-tcp-nodelay：同步之后是否禁用从站上的TCP_NODELAY 如果你选择yes，redis会使用较少量的TCP包和带宽向从站发送数据。但这会导致在从站增加一点数据的延时。  Linux内核默认配置情况下最多40毫秒的延时。如果选择no，从站的数据延时不会那么多，但备份需要的带宽相对较多。默认情况下我们将潜在因素优化，但在高负载情况下或者在主从站都跳的情况下，把它切换为yes是个好主意。默认值为no。\n\n5.8 SECURITY①、rename-command：命令重命名，对于一些危险命令例如：\n\n　　　　flushdb（清空数据库）\n\n　　　　flushall（清空所有记录）\n\n　　　　config（客户端连接后可配置服务器）\n\n　　　　keys（客户端连接后可查看所有存在的键）                   \n\n　　作为服务端redis-server，常常需要禁用以上命令来使得服务器更加安全，禁用的具体做法是是：\n\nrename-command FLUSHALL &quot;&quot;\n也可以保留命令但是不能轻易使用，重命名这个命令即可：\n\nrename-command FLUSHALL abcdefg\n　　这样，重启服务器后则需要使用新命令来执行操作，否则服务器会报错unknown command。\n\n　　②、requirepass:设置redis连接密码\n\n　　比如: requirepass 123  表示redis的连接密码为123\n\n5.9 CLIENTS①、maxclients ：设置客户端最大并发连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件。  描述符数-32（redis server自身会使用一些），如果设置 maxclients为0 。表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息\n\n5.10 MEMORY MANAGEMENT①、maxmemory：设置Redis的最大内存，如果设置为0 。表示不作限制。通常是配合下面介绍的maxmemory-policy参数一起使用。\n\n　　②、maxmemory-policy ：当内存使用达到maxmemory设置的最大值时，redis使用的内存清除策略。有以下几种可以选择：\n\n　　　　1）volatile-lru   利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used ) \n\n　　　　2）allkeys-lru   利用LRU算法移除任何key \n\n　　　　3）volatile-random 移除设置过过期时间的随机key \n\n　　　　4）allkeys-random  移除随机ke\n\n　　　　5）volatile-ttl   移除即将过期的key(minor TTL) \n\n　　　　6）noeviction  noeviction   不移除任何key，只是返回一个写错误 ，默认选项\n\n 　　③、maxmemory-samples ：LRU 和 minimal TTL 算法都不是精准的算法，但是相对精确的算法(为了节省内存)。随意你可以选择样本大小进行检，redis默认选择3个样本进行检测，你可以通过maxmemory-samples进行设置样本数。\n\n5.11 APPEND ONLY MODE①、appendonly：默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append Only File是另一种持久化方式，  可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入appendonly.aof文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。默认值为no。\n\n　　②、appendfilename ：aof文件名，默认是&quot;appendonly.aof&quot;\n\n　　③、appendfsync：aof持久化策略的配置；no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快；always表示每次写入都执行fsync，以保证数据同步到磁盘；everysec表示每秒执行一次fsync，可能会导致丢失这1s数据\n\n　　④、no-appendfsync-on-rewrite：在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。   设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。Linux的默认fsync策略是30秒。可能丢失30秒数据。默认值为no。\n\n　　⑤、auto-aof-rewrite-percentage：默认值为100。aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。\n\n　　⑥、auto-aof-rewrite-min-size：64mb。设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写。\n\n　　⑦、aof-load-truncated：aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data&#x3D;ordered选项，出现这种现象  redis宕机或者异常终止不会造成尾部不完整现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。默认值为 yes。\n\n\n\n5.12 LUA SCRIPTING①、lua-time-limit：一个lua脚本执行的最大时间，单位为ms。默认值为5000.\n\n5.13 REDIS CLUSTER①、cluster-enabled：集群开关，默认是不开启集群模式。\n\n　　②、cluster-config-file：集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。 这个文件并不需要手动配置，这个配置文件有Redis生成并更新，每个Redis集群节点需要一个单独的配置文件。请确保与实例运行的系统中配置文件名称不冲突。默认配置为nodes-6379.conf。\n\n　　③、cluster-node-timeout ：可以配置值为15000。节点互连超时的阀值，集群节点超时毫秒数\n\n　　④、cluster-slave-validity-factor ：可以配置值为10。在进行故障转移的时候，全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了，  导致数据过于陈旧，这样的slave不应该被提升为master。该参数就是用来判断slave节点与master断线的时间是否过长。判断方法是：比较slave断开连接的时间和(node-timeout * slave-validity-factor) + repl-ping-slave-period     如果节点超时时间为三十秒, 并且slave-validity-factor为10,假设默认的repl-ping-slave-period是10秒，即如果超过310秒slave将不会尝试进行故障转移\n\n　　⑤、cluster-migration-barrier ：可以配置值为1。master的slave数量大于该值，slave才能迁移到其他孤立master上，如这个参数若被设为2，那么只有当一个主节点拥有2 个可工作的从节点时，它的一个从节点会尝试迁移。\n\n　　⑥、cluster-require-full-coverage：默认情况下，集群全部的slot有节点负责，集群状态才为ok，才能提供服务。  设置为no，可以在slot没有全部分配的时候提供服务。不建议打开该配置，这样会造成分区的时候，小分区的master一直在接受写请求，而造成很长时间数据不一致。\n\n\n\n6. Jedis测试6.1 概述Jedis是Redis官方推荐的Java连接开发工具。好比Java提供了JDBC来访问关系型数据库一样，Java中也可以使用Jedis来操作Redis。Jedis操作非常简单，因为Jedis的API 和redis的命令基本是相同的。\n\n6.2 添加依赖&lt;dependency&gt;\n&lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;\n&lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;\n&lt;version&gt;3.2.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n6.3 连接前注意事项禁用Linux的防火墙：Linux(CentOS7)里执行命令\nsystemctl stop&#x2F;disable firewalld.service   \nredis.conf中注释掉bind 127.0.0.1 ,然后 protected-mode no\n\n6.4 创建测试Maven工程package com.atguigu.jedis;\nimport redis.clients.jedis.Jedis;\n\npublic class Demo01 &#123;\n    public static void main(String[] args) &#123;\n    Jedis jedis &#x3D; new Jedis(&quot;192.168.137.3&quot;,6379);\n    String pong &#x3D; jedis.ping();\n    System.out.println(&quot;连接成功：&quot;+pong);\n    jedis.close();\n\t&#125;\n&#125;\n\n\npublic class TestJedis3 &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;指定Jedis连接池的配置信息\n        JedisPoolConfig poolConfig &#x3D; new JedisPoolConfig();\n        poolConfig.setMaxTotal(200);\n        poolConfig.setMaxIdle(32);\n        poolConfig.setMaxWaitMillis(100*1000);\n        poolConfig.setBlockWhenExhausted(true);\n        poolConfig.setTestOnBorrow(true);  &#x2F;&#x2F; ping  PONG\n\n        &#x2F;&#x2F;根据配置创建Jedis连接池\n        JedisPool jedisPool &#x3D; new JedisPool(poolConfig, &quot;192.168.80.128&quot;, 6379, 60000 );\n        Jedis jedis &#x3D; jedisPool.getResource();\n        String result &#x3D; jedis.ping();\n        System.out.println(result);\n    &#125;\n&#125;\n\n接下来就是测试各种数据类型的方法\n\n\n\n7. Redis事务7.1 概述一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。\n\n事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。\n\nRedis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。\nRedis事务的主要作用就是串联多个命令防止别的命令插队。\n\nRedis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。\n\n从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。组队的过程中可以通过discard来放弃组队。\n\n*** 组队中某个命令出现了报告错误，执行时整个队列中所有命令都会被取消。\n*** 执行阶段某个命令报错，则只有报错命令不会被执行，而其他命令都会执行，不会回滚。（Redis事务没有原子性）\n\n7.1.1 原子性1、事务队列中出错，直接失败\n\n2、事务队列中不出错，但是，有一个语句错误，发现并没有同时失败（错误的话，应该回滚，但是redis并没有回滚）\n\n所以从严格意义上来讲，redis并不具备原子性\n7.1.2 一致性如果加上业务去谈一致性，例如，A 转账给 B，A 减少 10 块钱，B 增加 10 块钱，因为 Redis 并不具备回滚，也就不具备传统意义上的原子性，所以 Redis 也应该不具备传统的一致性。\n\n7.1.3 隔离性Redis 事务总是以串行的方式运行，事务也具备隔离性。\n\n7.1.4 持久性取决于redis的策略模式\n纯内存模式，不支持\nrdb aof 支持\n\n7.1.5 小结Redis 具备了一定的原子性，但不支持回滚；\n\nRedis 不具备 ACID 中一致性的概念。(或者说 Redis 在设计时就无视这点)；\n\nRedis 具备隔离性；\n\nRedis 通过一定策略可以保证持久性。\n\n7.2 悲观锁\n悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。\n传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。\n\n7.3 乐观锁\n乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。\n乐观锁适用于多读的应用类型，这样可以提高吞吐量。Redis就是利用这种check-and-set机制实现事务的。\n\n7.4 watch key 【key…】在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key\n\nhttps:&#x2F;&#x2F;gitee.com&#x2F;hrenxiang&#x2F;picture&#x2F;raw&#x2F;master&#x2F;img&#x2F;optimisticLock.png\n\n\n如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置更新为新值。否则，处理器不做任何操作。\n\n开始监视后，就会将监视的key的值保存下来，作为原值\n\n如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。\n\n7.5 Redis事务三特性单独的隔离操作 \n\t事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 \n没有隔离级别的概念 \n\t队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行\n不保证原子性 \n\t事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚\n\nRedis 事务和 **MySQL ** 事务的区别\nMySQL事务遵守严格的ACID特征，而Redis 设计更多的是追求简单与高性能，所以事务不会也没有必要受制于传统 ACID 的束缚。\n\n Redis 具备了一定的原子性，但不支持回滚，严格意义上无法保证原子性。\n\n Redis 不支持回滚，也就无法保证业务上的数据一致性。\n\n Redis 具备隔离性，但是没有隔离级别。\n\nRedis 通过一定策略可以保证持久性。Redis 是否具备持久化，取决于 Redis 的持久化模式比如AOF、RDB及其策略设置\n\n7.6 秒杀案例1. 超卖问题  (库存会出现负数)\n2. 乐观锁解决超卖问题，(有库存剩余问题和连接超时)\n3. lua脚本解决问题\n\n7.7 Lua脚本7.7.1 概述Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。\n\n7.7.2 特性轻量级: 它用标准C语言编写并以源代码形式开放，编译后仅仅一百余K，可以很方便的嵌入别的程序里。\n可扩展: Lua提供了非常易于使用的扩展接口和机制：由宿主语言(通常是C或C++)提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。\n\n其它特性:\n支持面向过程(procedure-oriented)编程和函数式编程(functional programming)；\n自动内存管理；只提供了一种通用类型的表（table），用它可以实现数组，哈希表，集合，对象；\n语言内置模式匹配；闭包(closure)；函数也可以看做一个值；提供多线程（协同进程，并非操作系统所支持的线程）支持；\n通过闭包和table可以很方便地支持面向对象编程所需要的一些关键机制，比如数据抽象，虚函数，继承和重载等。\n\n7.7.3 应用场景游戏开发\n独立应用脚本\nWeb 应用脚本\n扩展和数据库插件如：MySQL Proxy 和 MySQL WorkBench\n安全系统，如入侵检测系统\n\n7.7.4 LUA脚本在Redis中的优势将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数。提升性能。\n\nLUA脚本是类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作。\n\n但是注意redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用。\n\n利用lua脚本淘汰用户，解决超卖问题。\n\nredis 2.6版本以后，通过lua脚本解决**争抢问题**，实际上是**redis** **利用其单线程的特性，用任务队列的方式解决多任务并发问题**。\n\n\n\n8. Redis持久化8.1 概述很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后回复数据），或者是为了防止系统故障而将数据备份到一个远程位置。\n\n\n\n\n两种持久化方式\n\n\n\nRedis不同于Memcached的很重一点就是，Redis支持持久化，而且支持两种不同的持久化操作。Redis的一种持久化方式叫快照（snapshotting，RDB）,另一种方式是只追加文件（append-only file,AOF）\n\n\n8.2 快照（snapshotting，RDB）8.2.1 快照概述Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。\n如果在新的快照文件创建完毕之前，Redis、系统或者硬件这三者中的任意一个崩溃了，那么Redis将丢失最近一次创建快照写入的所有数据。\n如果数据量很大，保存快照的时间会很长。\n举个例子：假设Redis的上一个快照是2：35开始创建的，并且已经创建成功。下午3：06时，Redis又开始创建新的快照，并且在下午3：08快照创建完毕之前，有35个键进行了更新。如果在下午3：06到3：08期间，系统发生了崩溃，导致Redis无法完成新快照的创建工作，那么Redis将丢失下午2：35之后写入的所有数据。另一方面，如果系统恰好在新的快照文件创建完毕之后崩溃，那么Redis将丢失35个键的更新数据。\n\n\n\n快照持久化是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置：\n\nsave 900 1              #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。\n\nsave 300 10            #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。\n\nsave 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。\n\n\n根据配置，快照将被写入dbfilename选项指定的文件里面，并存储在dir选项指定的路径上面。\n\n8.2.2 备份是如何执行的Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。\n\n\n\n==fork==\nFork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程\n\nLinux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux引入“写时复制技术（CopyOnWrite）”\n\n一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。\n\n目前有两大类存储快照，一种叫做即写即拷（copy-on-write）快照【别名：写时复制】，另一种叫做分割镜像快照；\n\n8.2.3 创建快照的办法\nBGSAVE命令： 客户端向Redis发送 BGSAVE命令 来创建一个快照。对于支持BGSAVE命令的平台来说（基本上所有平台支持，除了Windows平台），Redis会调用fork来创建一个子进程，然后子进程负责将快照写入硬盘，而父进程则继续处理命令请求。\nSAVE命令： 客户端还可以向Redis发送 SAVE命令 来创建一个快照，接到SAVE命令的Redis服务器在快照创建完毕之前不会再响应任何其他命令。SAVE命令不常用，我们通常只会在没有足够内存去执行BGSAVE命令的情况下，又或者即使等待持久化操作执行完毕也无所谓的情况下，才会使用这个命令。\nsave选项： 如果用户设置了save选项（一般会默认设置），比如 save 60 10000，那么从Redis最近一次创建快照之后开始算起，当“60秒之内有10000次写入”这个条件被满足时，Redis就会自动触发BGSAVE命令。\nSHUTDOWN命令：  当Redis通过SHUTDOWN命令接收到关闭服务器的请求时，或者接收到标准TERM信号时，会执行一个SAVE命令，阻塞所有客户端，不再执行客户端发送的任何命令，并在SAVE命令执行完毕之后关闭服务器。\n一个Redis服务器连接到另一个Redis服务器： 当一个Redis服务器连接到另一个Redis服务器，并向对方发送SYNC命令来开始一次复制操作的时候，如果主服务器目前没有执行BGSAVE操作，或者主服务器并非刚刚执行完BGSAVE操作，那么主服务器就会执行BGSAVE命令\n\nRDB的持久化策略（触发持久化，其实就是上面的）\n\n\t配置文件中默认的快照配置（自动持久化）\n\tsave VS bgsave\n\tflushall：rdb文件将没有数据（貌似没有flushdb）\n\tshutdown：正常关闭\n\n如果系统真的发生崩溃，用户将丢失最近一次生成快照之后更改的所有数据。因此，快照持久化只适用于即使丢失一部分数据也不会造成一些大问题的应用程序。不能接受这个缺点的话，可以考虑AOF持久化。\n8.2.4 RDB文件结构\n\n\n\n数据部分\n数据类型\n长度\n数据含义\n\n\n\nREDIS\n常量\n5字节\nRDB文件标识，用来快速检查载入的文件是否是RDB文件\n\n\ndb_version\n变量\n4字节\nRDB文件版本号\n\n\ndatabase\n数据\n不定\nRedis各个非空数据库状态\n\n\nEOF\n常量\n1字节\n标志着RDB文件正文内容结束\n\n\ncheck_sum\n变量\n8字节\n校验和，根据前面4部分计算而来，用来检查RDB文件完整性\n\n\ndatabase部分\n\n\n\n\n数据部分\n数据类型\n长度\n数据含义\n\n\n\nSELECT_DB\n常量\n1字节\n数据库开头标识\n\n\ndb_number\n变量\n1-5个字节\n数据库开头号码\n\n\nkey_value_pairs\n数据\n不定\n数据库所有键值对数据\n\n\nkey_value_pairs部分\nkey_value_pairs部分保存了一个数据所有的键值对数据，其中不带过期时间的键值对有TYPE、key、value三部分组成，带过期时间的话，会在前面多出EXPIRETIME_MS和ms两部分。\n\n\n\n\n数据部分\n数据类型\n长度\n数据含义\n\n\n\nEXPIRETIME_MS\n常量\n1字节\n键值对过期时间标识\n\n\nms\n变量\n8字节\n键值对的过期时间（毫秒）\n\n\nTYPE\n常量\n1字节\n数据库值的类型\n\n\nkey\n变量\n不定\n数据库键，永远是字符串对象\n\n\nvalue\n变量\n不定\n数据库值，根据TYPE不用，value保存结构也不同\n\n\n\n\n\n\n\n\n\n\n\n每个value都保存着一个值对象，每个值对象的类型由TYPE字段记录。根据TYPE类型不同，value部分的结构、长度也会有所不同。这块思想上跟内存中底层数据结构类似，这里就不展开细讲了。\n至此，一个RDB文件完整的部分就出来了，如下所示：\n8.2.5 RDB的优缺点优点：\n    适合大规模的数据恢复\n    对数据完整性和一致性要求不高更适合使用\n    节省磁盘空间\n    恢复速度快\n\n缺点：\n\tFork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑\n\t虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。\n\t在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。\n\n8.2.6 小总结\n8.3 只追加文件（append-only file,AOF）8.3.1 AOF 概述以日志的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(读操作不记录)， 只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作\n==注意：文件越来越大；可以进行rewrite来减少大小。==\n8.3.2 AOF RDB共同使用与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。\nAOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）\n8.3.3 AOF 参数配置默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：\nappendonly yes\n\n开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。\n在Redis的配置文件中存在三种同步方式，它们分别是：\nappendfsync always     #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度\nappendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘\nappendfsync no      #让操作系统决定何时进行同步\n\n**appendfsync always** 可以实现将数据丢失减到最少，不过这种方式需要对硬盘进行大量的写入而且每次只写入一个命令，十分影响Redis的速度。另外使用固态硬盘的用户谨慎使用appendfsync always选项，因为这会明显降低固态硬盘的使用寿命。\n\n为了兼顾数据和写入性能，用户可以考虑 **appendfsync everysec选项** ，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。\n\n\n**appendfsync no**  选项一般不推荐，这种方案会使Redis丢失不定量的数据而且如果用户的硬盘处理写入操作的速度不够的话，那么当缓冲区被等待写入的数据填满时，Redis的写入操作将被阻塞，这会导致Redis的请求速度变慢。\n\n虽然AOF持久化非常灵活地提供了多种不同的选项来满足不同应用程序对数据安全的不同要求，但AOF持久化也有缺陷——==AOF文件的体积太大==\n8.3.4 AOF 持久化实现流程AOF 持久化实现可以分为以下三个步骤：\n1. 命令追加\n2. 文件写入\n3. 文件同步（刷盘）\n\n命令追加 ---&gt; 客户端的请求写命令会被append追加到AOF缓冲区内；\n文件写入 ---&gt; AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；\n文件同步 ---&gt; AOF 文件大小超过重写策略 或 手动重写 时，会对AOF文件rewrite重写，压缩AOF文件容量；\n\nRedis服务重启时，会重新load加载AOF文件中的 写操作 达到数据恢复的目的；\n8.3.5 重写 压缩AOFAOF虽然在某个角度可以将数据丢失降低到最小而且对性能影响也很小，但是极端的情况下，体积不断增大的AOF文件很可能会用完硬盘空间。另外，如果AOF体积过大，那么还原操作执行时间就可能会非常长。\n为了解决AOF体积过大的问题，用户可以向Redis发送 BGREWRITEAOF命令 ，这个命令会通过移除AOF文件中的冗余命令来重写（rewrite）AOF文件来减小AOF文件的体积。BGREWRITEAOF命令和BGSAVE创建快照原理十分相似，所以AOF文件重写也需要用到子进程，这样会导致性能问题和内存占用问题，和快照持久化一样。更糟糕的是，如果不加以控制的话，AOF文件的体积可能会比快照文件大好几倍。\n文件重写流程图如下：\n\n和快照持久化可以通过设置save选项来自动执行BGSAVE一样，AOF持久化也可以通过设置\nauto-aof-rewrite-percentage\n\n选项和\nauto-aof-rewrite-min-size\n\n选项自动执行BGREWRITEAOF命令。举例：假设用户对Redis设置了如下配置选项并且启用了AOF持久化。那么当AOF文件体积大于64mb，并且AOF的体积比上一次重写之后的体积大了至少一倍（100%）的时候，Redis将执行BGREWRITEAOF命令。\nauto-aof-rewrite-percentage 100  \nauto-aof-rewrite-min-size 64mb\n\n20M（重写后）——-&gt;40M(100%)————&gt;80M(100%)——–rewrite—-&gt; 30M\n无论是AOF持久化还是快照持久化，将数据持久化到硬盘上都是非常有必要的，但除了进行持久化外，用户还必须对持久化得到的文件进行备份（最好是备份到不同的地方），这样才能尽量避免数据丢失事故发生，备份前尽量先关闭redis服务。如果条件允许的话，最好能将快照文件和重新重写的AOF文件备份到不同的服务器上面。\n随着负载量的上升，或者数据的完整性变得 越来越重要时，用户可能需要使用到复制特性\n8.4 Redis 4.0对持久化的优化Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。\n如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分就是压缩格式不再是 AOF 格式，可读性较差。\n8.5 AOF 文件损坏如遇到**AOF文件损坏，通过/usr/local/bin/redis-check-aof–fix appendonly.aof进行恢复\n8.6 RDB AOF优缺点\nRDB的优缺点\n\n适合大规模的数据恢复\n对数据完整性和一致性要求不高更适合使用\n节省磁盘空间\n恢复速度快\n\n\nAOF优点\n\n备份机制更稳健，丢失数据概率更低。\n\n可读的日志文本，通过操作AOF稳健，可以处理误操作。\nrdb的文件是一个二进制文件，但是aof的文件是一个可读文件\n\n\n\nAOF缺点\n\n比起RDB占用更多的磁盘空间。\n恢复备份速度要慢。\n每次读写都同步的话，有一定的性能压力。\n存在个别Bug，造成恢复不能。\n\n\n\n8.7 使用哪个如果对数据不敏感，可以选单独用RDB。\n如果对数据敏感，两个都使用。\n如果只是做纯内存缓存，可以都不用。\n9. Redis主从复制9.1 是什么持久化后的数据仍然只在一台机器上，因此当硬件发生故障时，比如主板或CPU坏了，这时候无法重启服务器，有什么办法可以保证服务器发生故障时数据的安全性？或者可以快速恢复数据呢？想做到这一点，我们需要再了解Redis另外一种机制：主从复制。\n\n主从复制：主机数据更新后根据配置和策略，自动同步到备机的master&#x2F;slave机制，Master以写为主，Slave以读为主\n\n9.2 干什么Redis的主从复制机制是指可以让从服务器(slave)能精确复制主服务器(master)的数据\n\n一台master服务器也可以对应多台slave服务器\n\nslave服务器也可以有自己的slave服务器，这样的服务器称为sub-slave,而这些sub-slave通过主从复制最终数据也能与master保持一致\n\n读写分离，性能扩展\n容灾快速恢复，提高可用性\n\n\n9.3 怎么用实现方案\n    方案1：三台物理机\n    方案2：三台虚拟机\n    方案3：一台虚拟机，3个端口\n    \n方案三实现步骤\n准备三个配置文件（dump6379.conf  dump6380.conf dump6381.conf）\n    include &#x2F;myredis&#x2F;redis.conf\n    pidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid\n    port 6379\n    dbfilename dump6379.rdb\n\n启动三个redis服务器\n[root@localhost myredis]# redis-server  &#x2F;myredis&#x2F;redis-6379.conf \n[root@localhost myredis]# redis-server  &#x2F;myredis&#x2F;redis-6380.conf \n[root@localhost myredis]# redis-server  &#x2F;myredis&#x2F;redis-6381.conf\n\n\n\n使用 slaveof ip port  指定主机  例如指定IP为12.168.96.66 port为6379的机子为主机   slaveof  192.168.96.66  6379\n\n\n9.4 主从复制 — 一主二仆\n主机的内容会同步到从机\n\n==主机可以写可以读，从机只能读==\n\n主机宕机，从机不会上位；主机重新启动，依旧是大哥\n\n从机宕机，不是从机了；重新启动需要重新拜大哥\n\n可以将配置增加到文件redis.conf中。永久生效。\n\n主机又回来了后，主机新增记录，从机能顺利复制\n\n\n9.5 主从复制 — 薪火相传从机（同时又是主机）的状态\n\n上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。通过分封制，由之前的天子--百姓结构变成了天子--诸侯--卿大夫---百姓结构，减轻了天子的负担。\n\n\n\n从机（同时又是主机）是否可以写：不可以写\n主机挂了，从机还是从机，无法写数据了\n从机（同时又是主机）宕机，其下级从机和其上级主机断线；\n中途变更转向:会清除之前的数据，重新建立拷贝最新的\n风险是一旦某个slave宕机，后面的slave都没法备份\n\n9.6 主从复制 — 反客为主当一个master宕机后，后面的slave可以变为master主机，从而可以进行写操作。\n\n手动用 slaveof no one  将从机变为主机。\n\n其他没有变为master的slave需要手动指定新master(重新拜大哥)\n\n\n美好的愿望：如果上面的这三个手动都能变成自动，那该多好呀！！！！好的，不是问题；哨兵模式来解决！！！\n9.7 主从复制 — 哨兵模式哨兵模式就是反客为主的主从复制的==自动版==。能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。\n9.7.1 怎么用\n开启一主二仆模式\n\n自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错\n\n文件中的内容\nsentinel monitor mymaster 127.0.0.1 6379 1\n其中mymaster为监控对象起的服务器名称\n1为至少有多少个哨兵同意迁移的数量。\n开启哨兵\nredis-sentinel  &#x2F;myredis&#x2F;sentinel.conf\n主机挂，自动的反客为主\n\n\n\n9.7.2 选新master规则（故障恢复）\n优先级在redis.conf中默认：replica-priority 100，值越小优先级越高\n偏移量是指获得原主机数据最全的\n每个redis实例启动后都会随机生成一个40位的runid（通过info server获取查看）\n\n9.8 复制延时由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。\n9.9 复制原理slave启动成功连接到master后会发送一个sync命令\n\nMaster接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步\n\n全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。\n\n增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步\n\n但是只要是重新连接master,一次完全同步（全量复制)将被自动执行\n\n10. Redis集群10.1 遗留问题一个Redis主机缓存容量不够，如何进行扩容？\n\n更多的客户端对一个Redis主机进行并发写操作，忙不过来了， Redis如何分摊？\n\n另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。\n\n之前通过代理主机来解决，Redis3.0开始提供了解决方案，就是无中心化集群配置。\n\n10.2 什么是集群Redis Cluster 是 Redis 的 分布式解决方案，在 3.0 版本正式推出，有效地解决了 Redis 在 分布式 方面的需求。当遇到 单机内存、并发、流量 等瓶颈时，可以采用 Cluster 架构方案达到 负载均衡 的目的。\n\nRedis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1&#x2F;N。\n\nRedis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。\n\n10.3 cluster集群特点* 多个redis节点网络互联，数据共享\n\n* 所有的节点都是一主一从（也可以是一主多从），其中从不提供服务，仅作为备用\n\n* 不支持同时处理多个key（如MSET&#x2F;MGET），因为redis需要把key均匀分布在各个节点上，\n  并发量很高的情况下同时创建key-value会降低性能并导致不可预测的行为\n  \n* 支持在线增加、删除节点\n\n* 客户端可以连接任何一个主节点进行读写\n\n10.4 redis cluster配置修改cluster-enabled yes    打开集群模式\ncluster-config-file nodes-6379.conf  设定节点配置文件名\ncluster-node-timeout 15000   设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。\n\n10.5 开始测试\n制作六个实例（先删除其他的rdb，aof文件）（创建几个已.conf结束的文件）\n\ninclude &#x2F;etc&#x2F;redis.conf\npidfile &quot;&#x2F;var&#x2F;run&#x2F;redis_6379.pid&quot;\nport 6379\ndbfilename &quot;dump6379.rdb&quot;\ncluster-enabled yes\ncluster-config-file nodes-6379.conf\ncluster-node-timeout 15000\n\n\n\n启动六个redis服务\n\n将六个节点合成一个集群\n组合之前，请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。\ncd /opt/redis-6.2.1/src\nredis-cli --cluster create --cluster-replicas 1 192.168.11.101:6379 192.168.11.101:6380 192.168.11.101:6381 192.168.11.101:6389 192.168.11.101:6390 192.168.11.101:6391\n\n此处不要用127.0.0.1， 请用真实IP地址\n--replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组\n登录\n\n普通方式登录：可能直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，应该以集群方式登录。\nredis-cli -p 6379\n\nc 采用集群策略连接，设置数据会自动切换到相应的写主机\nredis-cli -c -p 6379\n\n\n\n\n10.6 查看集群状态cluster nodes\n\n10.7 cluster 如何分配六个节点一个集群至少要有三个主节点。\n选项 --cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。\n分配原则尽量保证每个主数据库运行在不同IP地址，每个从库主库不在一个IP地址。\n\n\n10.8 什么是slots一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个\n集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。\n集群中每个节点负责处理一部分插槽。 例如， 如果一个集群可以有主节点， 其中：\n​        节点 A 负责处理 0 号至 5460 号插槽。\n​        节点 B 负责处理 5461 号至 10922 号插槽。\n​        节点 C 负责处理 10923 号至 16383 号插槽。\n10.9 在集群中录入值在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。\nredis-cli客户端提供了 –c 参数实现自动重定向。\n如 redis-cli -c –p 6379 登入后，再录入、查询键值对可以自动重定向。\n不在一个slot下的键值，是不能使用mget,mset等多键操作。\n可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去。\n10.10 查询集群中的值CLUSTER GETKEYSINSLOT &lt;slot&gt;&lt;count&gt; 返回 count 个 slot 槽中的键。\n\n10.11 故障恢复\n如果主节点下线？从节点能否自动升为主节点？注意：15秒超时，主机挂，从机变主机；\n主节点恢复后，主从关系会如何？主节点回来变成从机。\n如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。redis.conf中的参数  cluster-require-full-coverage\n\n10.12 Redis集群优缺点\n优点\n实现扩容\n分摊压力\n无中心配置相对简单\n\n缺点\n多键操作是不被支持的 \n多键的Redis事务是不被支持的。lua脚本不被支持\n由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。\n\n\n11. 总结\n","slug":"42-Redis","date":"2021-09-13T15:19:32.000Z","categories_index":"Redis","tags_index":"Redis","author_index":"大黄"},{"id":"0f4e1baf76f1d61cc7b69fa9f200505f","title":"Linux（软件）","content":"1、安装 jdk目前使用的一台 m1 的 macbook pro ，但是安装上也大同小异\n下载 jdk：https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html\n\n下载后使用工具将文件放到 linux 中的 /opt 目录下，windows一般使用 xftp，Mac （目前使用的是paralles desktop，但是装不上 pd tools）我使用的是 forklift\n在 /opt 目录下将 压缩包解压\u0003\ntar -zxvf jdk-8u301-linux-aarch64.tar.gz\n\n得到 \n[root@localhost opt]# ls\njdk1.8.0_301  jdk-8u301-linux-aarch64.tar.gz\n\n配置环境变量，打开配置文件\nvim &#x2F;etc&#x2F;profile\n\n在最后追加配置\nexport JAVA_HOME&#x3D;&#x2F;opt&#x2F;jdk1.8.0_301\nexport PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH\n\n更新配置文件\nsource &#x2F;etc&#x2F;profile\n\n进行测试\njava -version\n\n成功如下\n[root@localhost bin]# java -version\njava version &quot;1.8.0_301&quot;\nJava(TM) SE Runtime Environment (build 1.8.0_301-b09)\nJava HotSpot(TM) 64-Bit Server VM (build 25.301-b09, mixed mode)\n\n\n\n2、安装 tomcat下载：apache-tomcat-7.0.70.tar.gz，也可以试试其他版本，这个没有特别要求\n解压到 /opt 目录中，进行解压，解压完成后进入 /opt/apache-tomcat-7.0.70/bin 可以使用命令启动\n.&#x2F;startup.sh\n\n关闭\n.&#x2F;shutdown.sh\n\n但是我们在其他目录没办法直接使用命令启动关闭，所以配置环境变量\nvim &#x2F;etc&#x2F;profile\n\nexport CATALINA_HOME&#x3D;&#x2F;opt&#x2F;apache-tomcat-7.0.70\nexport PATH&#x3D;$CATALINA_HOME&#x2F;bin:$PATH\n\nsource &#x2F;etc&#x2F;profile\n\n在任意目录下，都可以使用命令\n[root@localhost opt]# startup.sh \nUsing CATALINA_BASE:   &#x2F;opt&#x2F;apache-tomcat-7.0.70\nUsing CATALINA_HOME:   &#x2F;opt&#x2F;apache-tomcat-7.0.70\nUsing CATALINA_TMPDIR: &#x2F;opt&#x2F;apache-tomcat-7.0.70&#x2F;temp\nUsing JRE_HOME:        &#x2F;opt&#x2F;jdk1.8.0_301\nUsing CLASSPATH:       &#x2F;opt&#x2F;apache-tomcat-7.0.70&#x2F;bin&#x2F;bootstrap.jar:&#x2F;opt&#x2F;apache-tomcat-7.0.70&#x2F;bin&#x2F;tomcat-juli.jar\nTomcat started.\n\n\n[root@localhost opt]# ps -ef |grep tomcat\nroot        3311       1 16 17:50 pts&#x2F;0    00:00:01 &#x2F;opt&#x2F;jdk1.8.0_301&#x2F;bin&#x2F;java -Djava.util.logging.config.file&#x3D;&#x2F;opt&#x2F;apache-tomcat-7.0.70&#x2F;conf&#x2F;logging.properties -Djava.util.logging.manager&#x3D;org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize&#x3D;2048 -Djava.endorsed.dirs&#x3D;&#x2F;opt&#x2F;apache-tomcat-7.0.70&#x2F;endorsed -classpath &#x2F;opt&#x2F;apache-tomcat-7.0.70&#x2F;bin&#x2F;bootstrap.jar:&#x2F;opt&#x2F;apache-tomcat-7.0.70&#x2F;bin&#x2F;tomcat-juli.jar -Dcatalina.base&#x3D;&#x2F;opt&#x2F;apache-tomcat-7.0.70 -Dcatalina.home&#x3D;&#x2F;opt&#x2F;apache-tomcat-7.0.70 -Djava.io.tmpdir&#x3D;&#x2F;opt&#x2F;apache-tomcat-7.0.70&#x2F;temp org.apache.catalina.startup.Bootstrap start\nroot        3335    2619  0 17:51 pts&#x2F;0    00:00:00 grep --color&#x3D;auto tomcat\n\n\n[root@localhost opt]# shutdown.sh \nUsing CATALINA_BASE:   &#x2F;opt&#x2F;apache-tomcat-7.0.70\nUsing CATALINA_HOME:   &#x2F;opt&#x2F;apache-tomcat-7.0.70\nUsing CATALINA_TMPDIR: &#x2F;opt&#x2F;apache-tomcat-7.0.70&#x2F;temp\nUsing JRE_HOME:        &#x2F;opt&#x2F;jdk1.8.0_301\nUsing CLASSPATH:       &#x2F;opt&#x2F;apache-tomcat-7.0.70&#x2F;bin&#x2F;bootstrap.jar:&#x2F;opt&#x2F;apache-tomcat-7.0.70&#x2F;bin&#x2F;tomcat-juli.jar\n\n\n\n3、安装 msyql8之前还有安装 5 的方法，但是现在 5 的官方下载中已经取消了 aarch的相关文件，所以只能被迫安装8了\n使用最新的包管理器安装MySQL\nsudo dnf install @mysql\n\n开启启动，安装完成后，运行以下命令来启动MySQL服务并使它在启动时自动启动：\nsudo systemctl enable --now mysqld\n\n要检查MySQL服务器是否正在运行，请输入：\nsudo systemctl status mysqld\n\n添加密码及安全设置，运行mysql_secure_installation脚本，该脚本执行一些与安全性相关的操作并设置MySQL根密码：\nsudo mysql_secure_installation\n\n步骤如下：\n\n\u001d配置VALIDATE PASSWORD component（验证密码组件）： 输入y ，回车进入该配置\n选择密码验证策略等级， 建议选择 low，回车\n输入新密码两次\n确认是否继续使用提供的密码？输入y ，回车\n移除匿名用户？ 输入y ，回车\n不允许root远程登陆？ 我这里需要远程登陆，所以输入n ，回车\n移除test数据库？ 输入y ，回车\n重新载入权限表？ 输入y ，回车\n\n配置远程登陆，也就是配置 root 的 host 字段，将 localhost 修改为 %，将root用户的host字段设为 ‘%’ ，意为接受root 所有IP地址的登录请求，在 Linux 中登录 MySQL:\nmysql -uroot -p 密码\n\n接着继续执行 mysql 语句，将将 root 用户的 host 字段设为 ‘%’ ：\n如果是mysql 5\nGRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;root&#39; WITH GRANT OPTION;\n\n从 mysql 8开始,您不再可以(隐式)使用 GRANT 命令创建用户.请改用 CREATE USER,，然后使用 GRANT 声明：\nCREATE USER &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;root&#39;;\nGRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; WITH GRANT OPTION;\n\n刷新权限\nflush privileges;\n\n设置完成后输入exit退出mysql，回到终端shell界面，接着开启系统防火墙的3306端口：( 其实建议直接关闭防火墙 )\nsudo firewall-cmd --add-port&#x3D;3306&#x2F;tcp --permanent\nsudo firewall-cmd --reload\n\n# 关闭防火墙\nsystemctl stop firewalld.service\n# 永久关闭\nsystemctl disable firewalld.service\n\n在宿主机上使用相关数据库可视化界面工具连接 linux 上的数据库\n4、安装 Nginx在线安装：\n\n第 1.0 步 安装openssl、zlib、gcc 依赖 yum -y install make zlib zlib-devel gcc-c++ libtool  openssl openssl-devel\n第 2.1 步 联网下载pcrewget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz\n第 2.2 步 解压压缩文件 tar -zxvf pcre-8.37.tar.gz\n第 2.3 步 ./configure 完成后，回到pcre目录下执行 make，最后执行 make install\n第 2.4 步 pcre-config --version  检查版本\n第 3.0 步，安装nginx，先去官网下载安装包，最好是高点的版本，因为低版本 centos8 不能使用，我下载的是1.20.1 ，使用命令解压 然后进入解压缩目录，执行 ./configure 然后 make &amp;&amp; make install\n进入目录 /usr/local/nginx/sbin  执行 ./nginx 启动服务\n第 4.0 步，关闭防火墙，访问nginx\n\nNginx 相关命令，我们需要去相关目录下执行命令，下面我们一个命令直接到了相应目录并执行 nginx 相关操作\n# nginx版本检查\nnginx -v\n\n# nginx编译参数\nnginx -V\n\n# 启停方式\n- 启动\n\t[root@zls ~]# &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx\n\t[root@zls ~]# systemctl start nginx\n- 停止\n\t[root@zls ~]# &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s stop\n\t[root@zls ~]# systemctl stop nginx\n- 重启\n\t[root@zls ~]# systemctl restart nginx\n- 重载\n\t[root@zls ~]# &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload\n\t[root@zls ~]# systemctl reload nginx\n\n==上述 — 使用 systemctl start nginx 来启动 nginx 是需要配置的，下面我们来创建并配置 nginx.service 文件==\nSystemd服务文件以.service结尾，比如现在要建立nginx为开机启动，如果用yum install命令安装的，yum命令会自动创建nginx.service文件，可以直接使用systemctl相关命令。而用源码编译安装的，则需要手动创建nginx.service服务文件。\n配置nginx.service文件\nvim /usr/lib/systemd/system/nginx.service\n#配置文件内容\n[Unit]                                          \nDescription&#x3D;nginx \nAfter&#x3D;network.target \n\n[Service] \nType&#x3D;forking \nExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx \nExecReload&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload \nExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s quit\nPrivateTmp&#x3D;true \n\n[Install] \nWantedBy&#x3D;multi-user.target\n\n#[Unit]:服务的说明\n#Description:描述服务\n#After:描述服务类别\n#[Service]服务运行参数的设置\n#Type&#x3D;forking是后台运行的形式\n#ExecStart为服务的具体运行命令\n#ExecReload为重启命令\n#ExecStop为停止命令\n#PrivateTmp&#x3D;True表示给服务分配独立的临时空间\n#注意：[Service]的启动、重启、停止命令全部要求使用绝对路径\n#[Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3\n\n#查看nginx服务状态\nsystemctl status nginx.service\n#启动nginx服务\nsystemctl start nginx.service\n#停止nginx服务\nsystemctl stop nginx.service\n#重启nginx服务\nsystemctl restart nginx.service\n#重新读取nginx配置(这个最常用, 不用停止nginx服务就能使修改的配置生效)\nsystemctl reload nginx.service\n\n\n\n5、安装 redis前台启动（不推荐）：前台启动，命令行窗口不能关闭，否则服务器停止\n后台启动（推荐）\n备份redis.conf ，拷贝一份redis.conf到其他目录\n[root@localhost opt]# mkdir &#x2F;myredis\n[root@localhost opt]# cp redis-6.2.1&#x2F;redis.conf &#x2F;myredis&#x2F;redis.conf\n\ncd reids-6.2.1\nmake\nmake install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis\n\n后台启动设置daemonize no改成yes，修改redis.conf(128行)文件将里面的daemonize no 改成 yes，让服务在后台启动\nRedis启动\n&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server  &#x2F;myredis&#x2F;redis.conf\n\n用客户端访问：/usr/local/redis/bin/redis-cli\n多个端口可以：\nredis-cli -p 6379\n\n测试验证： ping，Redis Ping 命令使用客户端向 Redis 服务器发送一个 PING ，如果服务器运作正常的话，会返回一个 PONG 。通常用于测试与服务器的连接是否仍然生效，或者用于测量延迟值。\nRedis关闭，单实例关闭：\nredis-cli shutdown\n\n也可以进入终端后再关闭，多实例关闭，指定端口关闭\nredis-cli -p 6379 shutdown\n\n\n\n6、安装 HAProxy步骤1.首先，让我们首先确保您的系统是最新的。\nsudo clean all\nsudo dnf update\n\n步骤2.在CentOS 8上安装HAProxy。\nHAProxy在默认的CentOS 8上可用，现在使用以下dnf命令安装HAProxy：\nsudo dnf install haproxy\n\n步骤3.配置HAProxy。进入配置文件：/etc/haproxy/haproxy.cfg，开启客户端，defaults 模块下添加 stats uri\ndefaults\n    stats uri \t\t    &#x2F;admin&#x2F;stats\n\n启动停止服务\nsudo systemctl start haproxy\nsudo systemctl enable haproxy\nsudo systemctl stop haproxy\n\n","slug":"41-Linux（安装软件）","date":"2021-09-13T15:18:32.000Z","categories_index":"Linux","tags_index":"Linux","author_index":"大黄"},{"id":"3fe1ee3f3830128bf539e5f4ed9fbbe9","title":"Linux","content":"1. 为什么学习Linux开源、稳定、漏洞少、主要定位在服务器端操作系统（个人操作系统Windows还是具有很大优势的，操作方便，应用软件多，生态完善）。\n\n比如：可在Windows下使用idea进行软件开发，开发完毕后发布到Linux服务器上。\n\n\n2. Linux目录及结构2.1 Linux一切皆文件\n注意：Windows中C盘、D盘概念，每个盘有一个根目录。\n​            而Linux中没有盘符的概念，使用==一个 / 代表整个所有目录和文件的根目录==。\n2.2 目录结构\n\n\n目录\n释义\n\n\n\n/bin(/usr/bin、/usr/local/bin)\n是Binary的缩写, 这个目录存放着最经常使用的命令\n\n\n/sbin(/usr/sbin、/usr/local/sbin)\ns就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。\n\n\n/home\n存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。\n\n\n/root\n该目录为系统管理员，也称作超级权限者的用户主目录。\n\n\n/lib\n系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。\n\n\n/lost+found\n这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件\n\n\n/etc（等等，感觉应该是conf）\n所有的系统管理所需要的配置文件和子目录\n\n\n/usr(unix software  resource)\n这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。\n\n\n/boot\n这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件，自己的安装别放这里\n\n\n/proc\n这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。\n\n\n/srv\nservice缩写，该目录存放一些服务启动之后需要提取的数据\n\n\n/sys\n这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs\n\n\n/tmp\n这个目录是用来存放一些临时文件的。\n\n\n/dev (device)\n类似windows的设备管理器，把所有硬件用文件形式存储\n\n\n/media（centos6）\nlinux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。\n\n\n/run\n进程产生的临时文件，虚拟机加载光盘映像在：/run/media/root/ 目录下\n\n\n/mnt （mount）\n系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了。\n\n\n/opt\n这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。\n\n\n/usr/local\n这是另一个给主机额外安装软件所摆放的目录。一般是通过编译源码方式安装的程序。\n\n\n/var\n这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。\n\n\n2.3 Linux中的路径在Linux中，存在着绝对路径和相对路径 \n\n绝对路径：路径的写法一定是由根目录 / 写起的，例如 /usr/local/mysql\n相对路径：路径的写法不由根目录 / 写起的，例如当前目录是”/usr”，然后再进入到下级目录local，执行的命令为 “#cd local”，这个local是相对于/usr目录来讲的，所以称为相对路径。\n\n在Linux中，有几个特殊的符号也可以表示目录\n\n“/”：表示根目录\n“.”：表示当前目录，用在相对路径中，一般情况下会省略。\n“..”：表示当前目录的上一级目录，用在相对路径中，比如 cd ..\n“~”：表示/root目录\n\n3. Vi / Vim3.1 概述vi和vim一共有三种工作模式：一般模式、编辑模式和命令模式。\n\n1. 一般模式：通过vi或者是vim打开文档后默认进入到一般模式，默认模式。该模式下主要负责查看和一些基础的修剪工作\n\n2. 编辑模式：在一般模式下通过字母i、a、o 进入到编辑模式，进入后左下角会有【插入】的字样.如想退出编辑模式，需要按下【ESC】按键\n\n3. 命令模式：在一般模式下输入 &#x2F;或者: 进入命令模式，命令模式一般用于存盘、退出VIM 、显示行号、搜索、批量替换等操作.\n\n\n3.2 模式切换图\n3.3 三种常用命令3.3.1 一般模式\n\n\n命令\n操作\n\n\n\ndnd\n删除n行\n\n\nu\n撤销上一步\n\n\nX\n删除一个字母，类似于键盘Backspace功能\n\n\nyy\n复制光标当前行\n\n\np\n粘贴\n\n\nShift+g\n移动到页尾\n\n\n1+Shift+g\n移动到目标行\n\n\nN+shift+g\n移动到第N行\n\n\n3.3.2 输入模式\n\n\n命令\n操作\n\n\n\ni\n当前光标前录入\n\n\na\n当前光标后录入\n\n\no\n当前光标行的下一行录入\n\n\n3.3.3 底线命令模式\n\n\n命令\n操作\n\n\n\n:wq\n保存\n\n\n:q!\n强制执行\n\n\n:%s/old字符/new字符\n批量替换\n\n\n/要查找的词\n搜索,n查找下一个，N查找上一个\n\n\n:set nu\n显示行号\n\n\n:setnonu\n关闭行号\n\n\n:noh\n取消高亮显示\n\n\n非正常退出可能会出现存在交换文件swp提示，此时按照提示进行相应操作即可，也可以使用rm命令==直接删除swp文件==。\n4. 常用操作4.1 快捷键- Tab：命令和文件名补全；\n- Ctrl+C：中断正在运行的程序；\n- Ctrl+D：结束键盘输入（End Of File，EOF）\n\n4.2 求助命令\n\n\n命令\n操作\n\n\n\nman\n帮助手册(mannual)\n\n\n–help\n帮助手册\n\n\ndate\n日期\n\n\ncal\n日历\n\n\ndoc\n/usr/share/doc 存放着软件的一整套说明文件。\n\n\n4.3 系统关机\n\n\n命令\n操作\n\n\n\nwho\n使用 who 命令查看有没有其它用户在线\n\n\nsync\n为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘，因此关机之前需要先进行 sync 同步操作。\n\n\nshutdown\nshutdown [-krhc] 时间 [信息]-k ： 不会关机，只是发送警告信息，通知所有在线的用户-r ： 将系统的服务停掉后就重新启动-h ： 将系统的服务停掉后就立即关机-c ： 取消已经在进行的 shutdown\n\n\n4.4 环境变量\n\n\n命令\n操作\n\n\n\nPATH\n可以在环境变量 PATH 中声明可执行文件的路径，路径之间用 : 分隔。\n\n\n&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;sbin:&#x2F;home&#x2F;dmtsai&#x2F;.local&#x2F;bin:&#x2F;home&#x2F;dmtsai&#x2F;bin\n\n\n\n5. 文件目录\n\n\n命令\n操作\n\n\n\npwd\n显示当前所在目录(print working directory)\n\n\ngrep\n通过|管道符，配置grep进行过滤筛选。 比如：  ls –l |grep xxx               ls –l |grep xxx | grep yyy\n\n\nhistory\n查看历史命令\n\n\necho\n回显，输出  一般在shell脚本中使用较多\n\n\n5.1 ls列出文件或者目录的信息，目录的信息就是其中包含的文件。\n## ls [-aAdfFhilnrRSt] file|dir\n-a ：列出全部的文件\n-d ：仅列出目录本身\n-l ：以长数据串行列出，包含文件的属性与权限等等数据\n\n5.2 cd更换当前目录。\ncd [相对路径或绝对路径]\n\n5.3 mkdir创建目录。\n## mkdir [-mp] 目录名称\n-m ：配置目录权限\n-p ：递归创建目录\n\n5.4 rmdir删除目录，目录必须为空。\nrmdir [-p] 目录名称\n-p ：递归删除目录\n\n5.5 touch更新文件时间或者建立新文件。\n## touch [-acdmt] filename\n-a ： 更新 atime\n-c ： 更新 ctime，若该文件不存在则不建立新文件\n-m ： 更新 mtime\n-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date&#x3D;&quot;日期或时间&quot;\n-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]\n\n5.6 cp复制文件。如果源文件有两个以上，则目的文件一定要是目录才行。\ncp [-adfilprsu] source destination\n-a ：相当于 -dr --preserve&#x3D;all\n-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身\n-i ：若目标文件已经存在时，在覆盖前会先询问\n-p ：连同文件的属性一起复制过去\n-r ：递归复制\n-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制\n--preserve&#x3D;all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了\n\n5.7 rm删除文件。\n## rm [-fir] 文件或目录\n-r ：递归删除\n\n删除文件或者目录(remove)  -rvf:递归删除所有目录内容,有提示(recursive verbose  )  -rf:递归删除所有目录内容,无提示[慎用] \n\n5.8 mv移动文件。\n## mv [-fiu] source destination\n## mv [options] source1 source2 source3 .... directory\n-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖\n\n重命名或者移动文件(move)  \nmv oldFileName newFileName 是重命名  \nmv&#x2F;原目录&#x2F;原文件&#x2F;新目录 是移动文件  \n\n5.9 修改权限可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。\n## chmod [-R] xyz dirname&#x2F;filename\n\n示例：将 .bashrc 文件的权限修改为 -rwxr-xr–。\n## chmod 754 .bashrc\n\n也可以使用符号来设定权限。\n## chmod [ugoa]  [+-&#x3D;] [rwx] dirname&#x2F;filename\n- u：拥有者\n- g：所属群组\n- o：其他人\n- a：所有人\n- +：添加权限\n- -：移除权限\n- &#x3D;：设定权限\n\n示例：为 .bashrc 文件的所有用户添加写权限。\n## chmod a+w .bashrc\n\n默认权限\n文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。\n目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。\n\n可以通过 umask 设置或者查看默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r–。\n目录的权限文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。\n目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。\n5.10 链接## ln [-sf] source_filename dist_filename\n-s ：默认是实体链接，加 -s 为符号链接\n-f ：如果目标文件存在时，先删除目标文件\n\n5.10.1 实体链接在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。\n删除任意一个条目，文件还是存在，只要引用数量不为 0。\n有以下限制：不能跨越文件系统、不能对目录进行链接。\n## ln &#x2F;etc&#x2F;crontab .\n## ll -i &#x2F;etc&#x2F;crontab crontab\n34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab\n34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 &#x2F;etc&#x2F;crontab\n\n5.10.2 符号链接符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。\n当源文件被删除了，链接文件就打不开了。\n因为记录的是路径，所以可以为目录建立符号链接。\n## ll -i &#x2F;etc&#x2F;crontab &#x2F;root&#x2F;crontab2\n34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 &#x2F;etc&#x2F;crontab\n53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 &#x2F;root&#x2F;crontab2 -&gt; &#x2F;etc&#x2F;crontab\n\n\n\n6. 文件内容6.1 cat取得文件内容。\n## cat [-AbEnTv] filename\n-n ：打印出行号，连同空白行也会有行号，-b 不会\n\n6.2 tac是 cat 的反向操作，从最后一行开始打印。\n6.3 more和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。\n\n空格键:向下翻一页  回车键:向下翻一行  q:代表立刻离开more  ctrl+F向下滚动一屏  ctrl+B向上滚动一屏  \n\n6.4 less和 more 类似，但是多了一个向前翻页的功能。\n\npageDown：向下滚动一页  pageUp:向上滚动一页  &#x2F;字符串:向下搜索指定字符串  ?字符串:向上搜索执行字符串  n:重复前一个搜索  N：反向重复前一个搜索  \n\n6.5 head取得文件前几行。\n## head [-n number] filename\n-n ：后面接数字，代表显示几行的意思\n\n6.6 tail从尾部查看文件，是 head 的反向操作，只是取得是后几行。\n\n-n200 显示的行数  -f：跟随查看 (其他进程可通过echo“内容“&gt;&gt;文件名追加内容到文件，tail命令可以观察到数据的变化)  \n\n6.7 od以字符或者十六进制的形式显示二进制文件。\n7. 文件搜索7.1 which指令搜索。\n## which [-a] command\n-a ：将所有指令列出，而不是只列第一个\n\n7.2 whereis文件搜索。速度比较快，因为它只搜索几个特定的目录。\n## whereis [-bmsu] dirname&#x2F;filename\n\n7.3 locate文件搜索。可以用关键字或者正则表达式进行搜索。\nlocate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。\n## locate [-ir] keyword\n-r：正则表达式\n\n查找文件,基于索引，查询速度更快\nlocate -i &#39;*.log&#39; 不区分大小写  通过updatedb来更新索引  \n\n7.4 find文件搜索。可以使用文件的属性和权限进行搜索。\n## find [basedir] [option]\nexample: find . -name &quot;shadow*&quot;\n\nFind+搜索路径+参数+搜索关键字（下方③里）\n\n① 与时间有关的选项  \n-mtime  n ：列出在 n 天前的那一天修改过内容的文件\n-mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件\n-mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件\n-newer file ： 列出比 file 更新的文件\n\n+4、4 和 -4 的指示的时间范围如下：\n  \n\n② 与文件拥有者和所属群组有关的选项  \n-uid n\n-gid n\n-user name\n-group name\n-nouser ：搜索拥有者不存在 &#x2F;etc&#x2F;passwd 的文件\n-nogroup：搜索所属群组不存在于 &#x2F;etc&#x2F;group 的文件\n\n③ 与文件权限和名称有关的选项  \n-name filename\n-size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k\n-type TYPE\n-perm mode  ：搜索权限等于 mode 的文件\n-perm -mode ：搜索权限包含 mode 的文件\n-perm &#x2F;mode ：搜索权限包含任一 mode 的文件\n\n\n\n8. 压缩与打包8.1 压缩文件名\n\n\n扩展名\n压缩程序\n\n\n\n*.Z\ncompress\n\n\n*.zip\nzip\n\n\n*.gz\ngzip\n\n\n*.bz2\nbzip2\n\n\n*.xz\nxz\n\n\n*.tar\ntar 程序打包的数据，没有经过压缩\n\n\n*.tar.gz\ntar 程序打包的文件，经过 gzip 的压缩\n\n\n*.tar.bz2\ntar 程序打包的文件，经过 bzip2 的压缩\n\n\n*.tar.xz\ntar 程序打包的文件，经过 xz 的压缩\n\n\n8.2 压缩8.2.1 gzipgzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。\n经过 gzip 压缩过，源文件就不存在了。\n有 9 个不同的压缩等级可以使用。\n可以使用 zcat、zmore、zless 来读取压缩文件的内容。\n$ gzip [-cdtv#] filename\n-c ：将压缩的数据输出到屏幕上\n-d ：解压缩\n-t ：检验压缩文件是否出错\n-v ：显示压缩比等信息\n-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6\n\n8.2.2 bzip2提供比 gzip 更高的压缩比。\n查看命令：bzcat、bzmore、bzless、bzgrep。\n$ bzip2 [-cdkzv#] filename\n-k ：保留源文件\n\n8.2.3 xz提供比 bzip2 更佳的压缩比。\n可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。\n查看命令：xzcat、xzmore、xzless、xzgrep。\n$ xz [-dtlkc#] filename\n\n8.3 打包压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。==tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩==。\n$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename...  &#x3D;&#x3D;打包压缩\n$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件]              &#x3D;&#x3D;查看\n$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录]    &#x3D;&#x3D;解压缩\n-z ：使用 zip；\n-j ：使用 bzip2；\n-J ：使用 xz；\n-c ：新建打包文件；\n-t ：查看打包文件里面有哪些文件；\n-x ：解打包或解压缩的功能；\n-v ：在压缩&#x2F;解压缩的过程中，显示正在处理的文件名；\n-f : filename：要处理的文件；\n-C 目录 ： 在特定目录解压缩。\n\n\n\n\n使用方式\n命令\n\n\n\n打包压缩\ntar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称\n\n\n查 看\ntar -jtv -f filename.tar.bz2\n\n\n解压缩\ntar -jxv -f filename.tar.bz2 -C 要解压缩的目录\n\n\n\n\n\n\n解压缩\ntar -zxvf xxx.tar.gz\n\n\n压缩文件\ntar -zcvf xxx.tar.gz\n\n\n9. 网络进程服务9.1 网络配置\n\n\n使用方式\n命令\n\n\n\n查看⽹络接⼝属性\nifconfig  /    ip addr\n\n\n查看某网卡配置\nifconfig eth0\n\n\n查看占用8080端口的进程\nnetstat –anp|grep 8080\n\n\n查看已建立的TCP连接\nnetstat -antp\n\n\n查看所有监听端口\nnetstat -lntp\n\n\n查看主机名\nhostname\n\n\n如使用Linux作为服务器使用，应采用固定IP地址，而不是自动分配IP，避免变化\n命令行方式修改：vim /etc/sysconfig/network-scripts/ifcfg-ens33\n#静态分配IP，而不再使用DHCP动态分配\nBOOTPROTO&#x3D;&quot;static&quot;\n#IP和子网掩码\nIPADDR&#x3D;192.168.74.128\nNETMASK&#x3D;255.255.255.0\n#网关和DNS服务器\nGATEWAY&#x3D;192.168.74.2\nDNS1&#x3D;8.8.8.8\n#IP地址的前24为代表网络地址，后面是主机地址\nPREFIX&#x3D;24\n\n\n9.2 进程状态\n\n\n状态\n说明\n\n\n\nR\nrunning or runnable (on run queue)正在执行或者可执行，此时进程位于执行队列中。\n\n\nD\nuninterruptible sleep (usually I/O)不可中断阻塞，通常为 IO 阻塞。\n\n\nS\ninterruptible sleep (waiting for an event to complete)  可中断阻塞，此时进程正在等待某个事件完成。\n\n\nZ\nzombie (terminated but not reaped by its parent)僵死，进程已经终止但是尚未被其父进程获取信息。\n\n\nT\nstopped (either by a job control signal or because it is being traced)  结束，进程既可以被作业控制信号结束，也可能是正在被追踪。\n\n\n9.3 查看进程\n\n\n使用方式\n命令\n\n\n\n查看系统所有进程\nps -aux-a : 显示当前总段的所有进行信息-u : 以用户的格式显示进程信息-x : 显示后台进程运行的参数\n\n\n以全格式显示当前所有的进程\nps -ef (可以加 |grep xxx，进行过滤)\n\n\n查看所有进程树\npstree -A\n\n\n实时显示进程信息\ntop -d  时间（时间=2，说明两秒钟刷新一次进程信息）\n\n\n9.4 杀死进程\n\n\n使用方式\n命令\n\n\n\n杀死指定pid对应的进程.\nkill  pid\n\n\n杀死指定name对应的进程.\nkill  -s  name\n\n\n强制杀死指定pid对应的进程\nkill  -9  pid\n\n\n9.5 服务\n\n\n作⽤\n常⽤命令\n\n\n\n列出系统服务\nchkconfig –list\n\n\n查看某个服务\nservice &lt;服务名&gt; status\n\n\n启动某个服务\nservice &lt;服务名&gt; start\n\n\n终⽌某个服务\nservice &lt;服务名&gt; stop\n\n\n重启某个服务\nservice &lt;服务名&gt; restart\n\n\n查看某个服务\nsystemctl status &lt;服务名&gt;\n\n\n启动某个服务\nsystemctl start &lt;服务名&gt;\n\n\n终⽌某个服务\nsystemctl stop &lt;服务名&gt;\n\n\n重启某个服务\nsystemctl restart &lt;服务名&gt;\n\n\n开启⾃启动\nsystemctl enable &lt;服务名&gt;\n\n\n关闭⾃启动\nsystemctl disable &lt;服务名&gt;\n\n\n查看服务的命令\nsystemctl list-unit-filessystemctl –type service\n\n\n9.6 防火墙1、命令行界面输入命令“systemctl status firewalld.service”并按下回车键。\n2、然后在下方可度以查看得到“active（running）”，此时说明防火墙已经被打开了。\n3、在命令行中输入systemctl stop firewalld.service命令，进行关闭防火墙。\n4、然后再使用命令systemctl status firewalld.service，在下方出现disavtive（dead），这权样就说明防火墙已经关闭。\n5、再在命令行中输入命令“systemctl disable firewalld.service”命令，即可永久关闭防火墙。\n10. 包管理命令10.1 rpm概述RPM（RedHat Package Manager），Rethat软件包管理工具，类似windows里面的setup.exe。是Linux这系列操作系统里面的打包安装工具，它虽然是RedHat的标志，但理念是通用的。\n\nrpm 一般安装位置\n\n10.2 rpm 命令\n\n\n使用方式\n命令\n\n\n\n查看已安装的rpm包\nrpm -qa\n\n\n查询某个rpm包\nrpm -q 包名\n\n\nxxx 显示xxx功能是由哪个包提供的\nrpm -q –whatprovides\n\n\nxxx 显示xxx功能被哪个程序包依赖的\nrpm -q –whatrequires\n\n\nxxx 显示xxx包的更改记录\nrpm -q –changelog\n\n\n查看⼀个包的详细信息\nrpm -qi 包名\n\n\n查询⼀个包所提供的⽂档\nrpm -qd 包名\n\n\n查看已安装rpm包提供的配置⽂件\nrpm -qc 包名\n\n\n查看⼀个包安装了哪些⽂件\nrpm -ql  包名\n\n\n查看某个⽂件属于哪个包\nrpm -qf filename\n\n\n查询包的依赖关系\nrpm -qR 包名\n\n\n安装rpm包\nrpm -ivh xxx.rpm\n\n\n测试安装rpm包\nrpm -ivh –test xxx.rpm\n\n\n安装rpm包时忽略依赖关系\nrpm -ivh –nodeps xxx.rpm\n\n\n卸载程序包\nrpm -e xxx\n\n\nrpm -Fvh pkg_name\n升级确定已安装的rpm包\n\n\nrpm -Uvh pkg_name\n升级rpm包(若未安装则会安装)\n\n\nRPM包详细信息校验\nrpm -V pkg_name\n\n\n10.3 yum概述1)\t使用RPM安装软件依赖关系严重，不管是安装还是卸载，都需要先处理依赖软件，考验耐心。为了解决该方式，推出了yum安装方式。\n\n2)\tYum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。 \n\n3)\t类似于Java开发中的Maven工具，可以从镜像网站上下载应用程序并直接安装\n\n\n10.4 yum 命令* yum repolist enabled \t   显示可⽤的源仓库\n* yum search pkg_name \t搜索软件包\n* yum install pkg_name      下载并安装软件包\n* yum install --downloadonly pkg_name 只下载不安装\n* yum list     显示所有程序包\n* yum list installed        查看当前系统已安装包\n* yum list updates        查看可以更新的包列表\n* yum check-update    查看可升级的软件包\n* yum update        更新所有软件包\n* yum update pkg_name         升级指定软件包\n* yum deplist pkg_name          列出软件包依赖关系\n* yum remove pkg_name        删除软件包\n* yum clean all         清除缓存\n* yum clean packages         清除缓存的软件包\n* yum clean headers          清除缓存的header\n\n\n\n11. 磁盘分区11.1 磁盘分类1. IDE\nIDE（ATA）全称 Advanced Technology Attachment，接口速度最大为 133MB&#x2F;s，因为并口线的抗干扰性太差，且排线占用空间较大，不利电脑内部散热，已逐渐被 SATA 所取代。\n\n2. SATA\nSATA 全称 Serial ATA，也就是使用串口的 ATA 接口，抗干扰性强，且对数据线的长度要求比 ATA 低很多，支持热插拔等功能。SATA-II 的接口速度为 300MB&#x2F;s，而 SATA-III 标准可达到 600MB&#x2F;s 的传输速度。SATA 的数据线也比 ATA 的细得多，有利于机箱内的空气流通，整理线材也比较方便。\n\n3. SCSI\nSCSI 全称是 Small Computer System Interface（小型机系统接口），SCSI 硬盘广为工作站以及个人电脑以及服务器所使用，因此会使用较为先进的技术，如碟片转速 15000rpm 的高转速，且传输时 CPU 占用率较低，但是单价也比相同容量的 ATA 及 SATA 硬盘更加昂贵。\n\n4. SAS\nSAS（Serial Attached SCSI）是新一代的 SCSI 技术，和 SATA 硬盘相同，都是采取序列式技术以获得更高的传输速度，可达到 6Gb&#x2F;s。此外也通过缩小连接线改善系统内部空间等。\n\n11.2 磁盘的文件名Linux 中每个硬件都被当做一个文件，包括磁盘。磁盘以磁盘接口类型进行命名，常见磁盘的文件名如下：\n\n- IDE 磁盘：&#x2F;dev&#x2F;hd[a-d]\n- SATA&#x2F;SCSI&#x2F;SAS 磁盘：&#x2F;dev&#x2F;sd[a-p]\n\n其中文件名后面的序号的确定与系统检测到磁盘的顺序有关，而与磁盘所插入的插槽位置无关。\n\n11.3 磁盘分区磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的 GPT 分区表。\n因为对Linux来说无论有几个分区，却只有一个根目录，一个独立且唯一的文件结构。Linux中每个分区都是用来组成整个文件系统的一部分，因此它采用了一种叫“挂载点”的处理方法，将一个分区和一个目录联系起来，称为将该分区挂载到该目录，通过访问该目录来实现对该分区的访问。\n\n\n\n使用方式\n命令\n\n\n\n查看设备所有挂载情况\nlsblk或者lsblk -f\n\n\n查看所有磁盘分区\nfdisk -l\n\n\n进行分区m 显示命令列表p显示磁盘n新增分区d删除分区w写入并退出分区q 退出不保存\n通过fdisk /dev/sdb开始对/sdb进行分区\n\n\n格式化磁盘\nmkfs -t ext4 /dev/sdb1\n\n\n挂载（讲一个分区与一个目录联系起来）\nmount    /dev/分区     /new目录\n\n\n指定文件类型挂载\nmount   -t    ntfs    /dev/sdc1    /mnt/usbhd1\n\n\n挂载iso文件\nmount -o loop xxx.iso /mnt/cdrom\n\n\n通过设备名卸载\numount  -v  /dev/sda1\n\n\n通过挂载点卸载\numount -v /mnt/mymnt\n\n\n解除端口占用，并查看，k是杀死端口，m是查看，最后在umonut就可以了\nfuser -km /mnt/hda1\n\n\n永久挂载：\n通过修改&#x2F;etc&#x2F;fstab实现挂载\n添加完成后执行mount   –a 即刻生效\n\n\n&#x2F;etc&#x2F;fstab文件参数介绍\n第一列:   磁盘设备文件或者该设备的Label或者UUID\n第二列:   设备的挂载点，就是你要挂载到哪个目录下\n第三列:   磁盘文件系统的格式，包括ext2、ext3、reiserfs、nfs、vfat等\n第四列:   文件系统的参数，defaults代表同时具有rw,suid,dev,exec,auto,nouser,async等默认参数的设置\n第五列:   能否被dump备份命令作用\n\t0 代表不要做dump备份\n\t1 代表要每天进行dump的操作\n\t2 代表不定日期的进行dump操作\n第六列:   是否检验扇区\n\t0 不要检验\n\t1 最早检验（一般根目录会选择）\n\t2 1级别检验完成之后进行检验\n\n\n11.4 磁盘情况\n\n\n使用方式\n命令\n\n\n\n查看磁盘使用情况及挂载点\ndf  -h\n\n\n同上\ndf  -hl\n\n\n查询指定目录的磁盘占用情况，默认为当前目录\ndu -h /目录\n\n\n查看指定目录的大小\ndu -sh /dir\n\n\n从⾼到低依次显示⽂件和⽬录⼤⼩\ndu -sk * |sort -rn\n\n\n12. 用户与用户组12.1 用户管理1)\tLinux系统是一个多用户多任务的操作系统，任何一个要使用系统资的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。\n\n2)\t对用户的操作\n\t新增用户: useradd新用户名  观察home目录下新增了用户主目录\n\t设置密码: passwd  用户名\n\t用户是否存在：id  用户名\n\t切换用户：su 切换用户名\n\t查看当前用户&#x2F;登录用户：whoami&#x2F; who am I\n\t删除用户：userdel 用户名\n\t删除用户：userdel -r 用户名 同时删除主目录\n\t\n3)\t删除用户的错误：当我们想删除某个用户的时候，出现 user xxx is currently used by process yyy，可能的原因是你创建用户xxx之后，使用su命令切换到xxx用户下，之后又想删除xxx用户，使用su root切换到root用户下，使用userdel xxx。出现上述情况的根本原因在于切换回root用户之后，xxx还被某个进程占用。\n解决方案：两次ctrl+d（退出当前用户）\n第一次使用ctrl+d退出root用户，回到xxx用户；第二次使用ctrl+d退出xxx用户，此时会返回到root用户，此时使用userdel xxx正常删除\n\n\n12.2 用户组管理1)\t类似于角色，系统可以对有共性的多个用户进行统一的管理。\n2)\t对用户组的操作\n\t新增组:groupadd组名\n\t修改用户的组：usermod–g 用户组 用户名\n\t增加用户时直接加上组：useradd –g 用户组用户名\n\t删除组:groupdel组名\n\n12.3 用户和组的相关文件1)   用户（user）的配置文件： &#x2F;etc&#x2F;passwd \n\n​    每行的含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell\n\n2)   口令的配置文件: &#x2F;etc&#x2F;shadow\n\n  每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志\n\n3)   组(group)的配置文件： &#x2F;etc&#x2F;group\n\n​    每行含义：组名:口令:组标识号:组内用户列表\n\n\n\n13. 文件的权限管理13.1 文件权限讲解在 Linux 中我们可以使用 **ll** 或者 **ls –l** 命令来显示一个文件的属性以及文件所属的用户和组，如：\n\n[root@www &#x2F;]# ls -l\ntotal 64\ndr-xr-xr-x   2 root root 4096 Dec 14  2012 bin\ndr-xr-xr-x   4 root root 4096 Apr 19  2012 boot\n……\n\n实例中，**bin** 文件的第一个属性用 **d** 表示。**d** 在 Linux 中代表该文件是一个目录文件。\n\n在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。\n\n* 当为 **d** 则是目录\n* 当为 **-** 则是文件；\n* 若是 **l** 则表示为链接文档(link file)；\n* 若是 **b** 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；\n* 若是 **c** 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。\n\n接下来的字符中，以三个为一组，且均为 rwx 的三个参数的组合。其中， r 代表可读(read)、 w 代表可写(write)、 x 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 - 而已。\n\n每个文件的属性由左边第一部分的 10 个字符来确定（如下图）。\n\n从左至右用 0-9 这些数字来表示。\n第 0 位确定文件类型，第 1-3 位确定属主（该文件的所有者）拥有该文件的权限。\n第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。\n其中，第 1、4、7 位表示读权限，如果用 r 字符表示，则有读权限，如果用 - 字符表示，则没有读权限；\n第 2、5、8 位表示写权限，如果用 w 字符表示，则有写权限，如果用 - 字符表示没有写权限；第 3、6、9 位表示可执行权限，如果用 x 字符表示，则有执行权限，如果用 - 字符表示，则没有执行权限。\n权限对应的数字\n\nr ==&gt; 4\nw ==&gt; 2\nx ==&gt; 1\n\n13.2 文件权限授予chmod 修改权限\n\nl 第一种方式：+ 、-、&#x3D; 变更权限\n\n​    u:所有者 g:所有组 o:其他人\n\n  a:所有人(u、g、o的总和)\n\n​    chmod  u&#x3D;rwx,g&#x3D;rx,o&#x3D;x  文件目录名\n\n​    chmod o+w文件目录名\n\n​    chmod  a-x  文件目录名\n\nl 第二种方式：通过数字变更权限\n​    r&#x3D;4 w&#x3D;2 x&#x3D;1    rwx&#x3D;4+2+1&#x3D;7\n\nchmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x  文件目录名\n\n​    相当于chmod  751 文件目录名\n\n\n\n\n命令\n操作\n\n\n\nchmod ugo+rwx dir1\n设置⽬录所有者(u)、群组(g)及其他⼈(o)的读（r）写(w) 执⾏(x)权限\n\n\nchmod go-rwx dir1\n移除群组(g)与其他⼈(o)对⽬录的读写执⾏权限\n\n\nchown user1 file1\n改变⽂件的所有者属性\n\n\nchgrp group1 file1\n改变⽂件群组\n\n\nchown user1:group1 file1\n改变⽂件的所有⼈和群组\n\n\nchown -R user1 dir1\n改变⽬录的所有者属性\n\n\n","slug":"41-Linux","date":"2021-09-13T15:17:32.000Z","categories_index":"Linux","tags_index":"Linux","author_index":"大黄"},{"id":"6f4f974e39a23a6637b9ccfa82544a76","title":"Maven","content":"1. Maven简介1.1 完成一个java项目1. 分析项目要做什么，知道项目有哪些组成部分\n\n2. 设计项目（步骤，技术，多少人，多长时间）\n\n3. 组建团队，招人，购置设备，服务器，软件，笔记本\n\n4. 开发人员写代码，测试代码，重复多次工作\n\n5. 测试人员，测试项目功能  ------  测试如有问题，开发人员修改  ------  再提交给测试人员  ------  再次测试，直到没有问题\n\n1.2 传统开发问题项目的构建过程复杂繁琐\n    1. 将项目分为多个模块\n\n    2. 实现分布式部署\n\njar包的依赖管理复杂繁琐\n    3. 需要很多第三方功能,需手工获取（很多的jar文件，需要手工从网络中获取各个jar文件）\n\n    4. 需要管理jar的版本，因为版本之间要进行适配\n\n    5. 管理jar文件间的依赖（a.jar 需要 b.jar 中的类（这个关系叫做依赖），那么需要先获取b.jar然后才能使用a.jar）\n\n    6. 处理jar包间的冲突，当有多个jar时，到底使用哪一个\n\n1.3 Maven进行管理改进\n\n\n重要\n\n\n\nmaven能够完成的任务\n\n\n1. maven可以 【管理 jar文件】\n\n2. 自动 【下载 jar和他的文档，源代码】\n\n3. 管理 【jar文件间的依赖】（如果a.jar 需要 b.jar，会直接 自动下载 b.jar）\n\n4. 管理 【jar文件间的版本】\n\n5. 【编译程序】，把java文件编译为class文件\n\n6. 帮助我们 【测试代码是否正确】\n\n7. 帮我们 【打包文件】，形成 jar文件 或者 war文件\n\n8. 帮我们 【部署项目】\n\n1.4 Maven 中项目的构建\n\n\n重要\n\n\n\nmaven的七个构建过程\n\n\n构建是面向过程的（就是一些步骤），完成项目的编译，测试，运行，打包，部署等等\n\nmaven的【构建过程】有：\n\n1. 清理，把之前项目编译的东西删除，为新的编译代码做准备\n\n2. 编译：把程序源代码编译为执行代码，java --- class文件\n\n   批量的：maven 可以同时把成千上百的文件编译为class，而 javac一次只编译一个文件\n\n3. 测试：maven可以执行测试程序代码，验证功能是否正确\n\n   测试也是批量的，可以同时执行多个测试代码，同时测试很多功能\n\n4. 报告：生成测试结果文件\n\n5. 打包：把项目文件中的所有class文件，配置文件等所有资源放到一个压缩文件中\n\n   这个压缩文件就是 项目的结果文件，通常Java程序，压缩文件是jar扩展名结尾的Web应用，是以 war文件名结尾的\n\n6. 安装：把 5中生成的文件 jar，war安装到本机仓库\n\n7. 部署：把程序安装好可以执行。\n\n1.5 Maven的核心概念\n\n\n重要\n\n\n\nMaven的 九个核心概念：pom，约定的目录结构，坐标，依赖管理，仓库管理，生命周期，插件和命令，继承，聚合\n\n\n1. POM\n   指的是 pom.xml 文件，pom翻译过来叫做 项目对象模型\t\n\t    \n   Maven把一个项目当做一个模型使用，控制maven构建项目的过程，管理jar依赖\n\n2. 约定的目录结构\n\n   maven 项目的目录和文件位置都是规定的\n\n3. 坐标\n\n   是一个唯一字符串，用来表示资源\n   \n4. 依赖管理\n\n   管理项目可以使用的jar文件\n\n5. 仓库管理（了解）\n\n   资源存放的位置\n\n6. 生命周期（了解）\n\n   maven工具构建项目的过程，就叫生命周期 \n\n7. 插件和命令（了解）\n\n   执行maven构建的时候使用的工具是插件\n\n8. 继承\n\n9. 聚合\n\n\n\n2. Maven的核心概念2.1 约定的目录结构\n\n\n重要\n\n\n\n约定就是大家需要共同遵守的规则\n\n\n1. 约定指的是大家需要遵循的一个规则\n\n2. 每一个Maven项目在磁盘中都是一个文件夹（例如：我的项目Hellow）\n   Hello&#x2F;\n     ---&#x2F;src\n     \n     ------&#x2F;main           #放你主程序java代码和配置文件\n     ----------&#x2F;java       #你的程序包和包中的java文件\n     ----------&#x2F;resources  #你的java程序中要使用的配置文件\t\n     \n     ------&#x2F;test  #放测试程序代码和文件的（可以没有）\n     ----------&#x2F;java       #测试程序包和包中的java文件\n     ---------&#x2F;resources  #测试java程序中要使用的配置文件\n     \n     ---&#x2F;pom.xml  #maven的核心文件（maven项目必须有）\n\n2.2 compile 第一次编译\n\n\n重要\n\n\n\n默认本机仓库、中央仓库的地址，执行编译命令后项目编译后的文件存储在  target  目录中\n\n\n1. 第一次执行为什么要下载？\n\n   maven工具执行的时候，需要很多插件，jar文件完成\n\n2. 下载了什么东西？\n\n   当然是jar文件。\n\n3. 下载的东西存放在哪了？\n\n   默认的本机仓库：C:\\Users\\（登录操作系统的用户名）Administrator\\.m2\\repository\n\n4. 从哪下载插件 - jar文件\n\n   中央仓库的地址： https:&#x2F;&#x2F;repo.maven.apache.org \n\n5. 执行完mvn compile后\n\n   结果是在项目的根目录下生成 target目录（结果目录）\n\n   编译好的java程序，最后的class文件都在target目录中\n\n2.3 仓库\n\n\n重要\n\n\n\n仓库的概念，分类，使用  |  修改本地仓库的位置\n\n\n1. 仓库是什么：存放东西的地方，存放maven使用的 jar文件和我们项目中使用的 jar文件\n\n   ​\t\t\t\t\t  maven使用的插件（各种jar）\n\n   ​\t\t\t\t\t  我们项目使用的jar（第三方工具）\n\n2. 仓库的分类\n\n   本地仓库：个人计算机上的文件夹\n\n   远程仓库：在互联网上，使用网络才能使用的仓库\n\n   ​\t    1.中央仓库：最权威的， 所有的开发人员共享使用的仓库， https:&#x2F;&#x2F;repo.maven.apache.org\n\n   ​\t\t2.中央仓库的镜像：http:&#x2F;&#x2F;maven.aliyun.com\n\n   ​\t\t3.私服：在公司内部，在局域网中使用的， 不是对外使用的。\n\n3. 仓库的使用：maven仓库的使用不需要人为参与\n\n   开发人员使用某个驱动 ---&gt; maven首先检查本地仓库 ---&gt; 私服 ---&gt; 镜像 ---&gt; 中央仓库\n   \n4. 修改本地仓库位置\n\n   1. 修改maven的配置文件， maven安装目录&#x2F;conf&#x2F;settings.xml，先备份 settings.xml\n   \n   2. 修改 &lt;localRepository&gt;  指定你的目录（不要使用中文目录）\n\n2.4  POM\n\n\n重要\n\n\n\n坐标（gav），依赖（dependency），属性（properties）\n\n\n1. pom释义为 Project Object Model 项目对象模型，是一个pom.xml文件\n\n2. 坐标（gav）\n\n   唯一值，在互联网中唯一标识一个项目的\n   \n   &lt;groupId&gt;公司域名的倒写&lt;&#x2F;groupId&gt;\n   &lt;artifactId&gt;自定义项目名称&lt;&#x2F;artifactId&gt;\n   &lt;version&gt;自定版本号&lt;&#x2F;version&gt;\n\n   groupId、artifactId、version生成了一个Maven项目的基本坐标，在众多的maven项目中可以唯一定位到某一个项目。坐标也决定着将来项目在仓库中的路径及名称。\n\n3. 依赖（dependency）\n\n   dependencies 和dependency ，相当于是 java代码中import\n\n   你的项目中要使用的各种资源说明， 比我的项目要使用mysql驱动\n   \n   &lt;dependencies&gt;\n   \t&lt;!--依赖  java代码中 import --&gt;\n   \t&lt;dependency&gt;\n           &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n           &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n           &lt;version&gt;5.1.9&lt;&#x2F;version&gt;\n       &lt;&#x2F;dependency&gt;\n   &lt;&#x2F;dependencies&gt;\n\n4. packaging：打包后压缩文件扩展名，默认是jar，web是war（默认是jar 可以不写）\n\n5. properties：设置属性\n   &lt;properties&gt;\n     &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt; 源码编译 jdk 版本\n     &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt; 运行代码的 jdk 版本\n     &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;项目构建用的编码，避免中文乱码\n     &lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt; 生成报告的编码\n   &lt;&#x2F;properties&gt; \n\n6. build：maven在进行项目构建时，配置信息，例如指定编译 java代码使用的 jdk版本等\n\n2.5 生命周期，命令及插件\n\n\n重要\n\n\n\n生命周期，命令及插件的概念  |  常用的 maven命令\n\n\n1. maven的 生命周期：就是maven构建项目的过程，清理，编译，测试，报告，打包，安装，部署\n\n2. maven的 命令：maven独立使用，通过命令，完成maven的生命周期的执行。\n\n           \t    maven可以使用命令，完成项目的清理，编译，测试等等 \n\n3. maven的 插件： maven命令执行时，真正完成功能的是插件，插件就是一些jar文件， 一些类\n\n1. 常用命令：\n\n    mvn -version         查看maven的版本及配置信息\n\n    mvn archetype:generate  \t创建你的maven项目\n\n    mvn archetype:create  -DgroupId&#x3D;   DartifactId&#x3D;   构建java项目\n\n    mvn archetype:create  -DgroupId&#x3D;   DartifactId&#x3D;   -DarchetypeArtifactId&#x3D;maven-archetype-webapp 创建web项目\n\n    mvn clean           清除编译产生的target文件夹内容，可以配合相应命令一起使用，如mvn clean package， mvn clean test\n\n    mvn compile         编译项目代码\n\n    mvn test            运行单元测试\n\n    mvn package        打包项目\n\n    mvn package -Dmaven.test.skip&#x3D;true  打包项目时跳过单元测试\n\n    mvn install          打包后将其安装在本地仓库\n\n    mvn deploy          打包后将其安装到pom文件中配置的远程仓库\n\n2. 补充命令：\n\n    mvn jar:jar  \t只打jar包\n\n    mvn -e       显示详细错误 信息.\n    mvn validate    验证工程是否正确，所有需要的资源是否可用\n\n    mvn idea:idea \t生成idea项目\n\n    mvn eclipse:eclipse    将maven生成eclipse项目结构\n\n    mvn eclipse:clean     清除maven项目中eclipse的项目结构\n\n    mvn site            生成站点目录\n\n    mvn dependency:list    显示所有已经解析的所有依赖\n\n    mvn dependency:tree   以树的结构展示项目中的依赖\n\n    mvn dependency:analyze  对项目中的依赖进行分析，依赖未使用，使用单未引入\n\n    mvn tomcat:run        启动tomcat\n\n3. Maven 中的依赖范围\n\n\n重要\n\n\n\n依赖范围的含义，compile、test、provide表示的范围\n\n\n1. 依赖范围：表示依赖的作用范围，也就是maven在构建项目时，这些依赖在哪些阶段起作用。\n\n2. 范围标签使用scope表示，scope的值有 compile，test，provide，默认采用的是compile\n\n3. compile表示依赖中使用的jar包也会随着编译打包等操作，保存到文件中。test表示依赖只会在测试阶段参与，其他过程均不参与。\n\n4. provide表示依赖参与编译和测试，但是不会参与打包和部署，打包后放到tomcat中运行时，会使用tomcat中体积功的jar文件。\n\n5. maven构建项目的阶段：清除，编译，测试，报告，打包，安装，部署\n\n4. Maven 中的资源配置4.1 指定资源位置\n\n\n重要\n\n\n\n编译时，会把编译好的class文件以及resources目录下的资源拷贝到 target目录中，但是Java目录下的非java文件，并不会拷贝到target目录中，所以我们需要在pom文件中指定这些文件的位置，类型，然后使系统识别到并且拷贝这些文件\n\n\n1. maven执行编译代码时，会把src&#x2F;main&#x2F;resources目录中的文件拷贝到target&#x2F;classes中\n\n   但是src&#x2F;main&#x2F;java目录下的非java文件，并不会拷贝到target&#x2F;classes中，此时就需要资源插件\n\n2. 在&lt;build&gt;标签内的&lt;includes&gt;下的&lt;include&gt;标签内，写下需要拷贝的文件类型，那么目录中的此类文件就会被扫描到，并拷贝到结果目录中&lt;build&gt;\n    \n3. 指定资源位置的模板\n    &lt;resources&gt;\n          &lt;resource&gt;\n            &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;&lt;!--所在的目录--&gt;\n            &lt;includes&gt;&lt;!--包括目录下的.properties,.xml 文件都会扫描到--&gt;\n            &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;\n            &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;\n            &lt;&#x2F;includes&gt;\n            &lt;!-- filtering 选项 false 不启用过滤器， *.property 已经起到过滤的作用了 --&gt;\n            &lt;filtering&gt;false&lt;&#x2F;filtering&gt;\n          &lt;&#x2F;resource&gt;\n        \n          &lt;resource&gt;\n            &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;\n            &lt;includes&gt;\n            &lt;include&gt;**&#x2F;*.*&lt;&#x2F;include&gt;&lt;!--此目录下的全部内容--&gt;\n            &lt;&#x2F;includes&gt;\n            &lt;filtering&gt;false&lt;&#x2F;filtering&gt;\n          &lt;&#x2F;resource&gt;\n        &lt;&#x2F;resources&gt;\n  &lt;&#x2F;build&gt;\n\n4.2 全局变量\n\n\n重要\n\n\n\n在pom文件中通过属性定义全局变量，通过 ${property_name} 来调用，以提高扩展性以及维护性\n\n\n1. 在 Maven 的 pom.xml 文件中，&lt;properties&gt;用于定义全局变量（可以 &#123;自定义全局变量&#125; ）\n\n2. POM 中通过  $&#123;property_name&#125;  的形式引用变量的值。\n\n3. 定义全局变量：\n\n   &lt;properties&gt;\n    \t&lt;spring.version&gt;4.3.10.RELEASE&lt;&#x2F;spring.version&gt;\n   &lt;&#x2F;properties&gt;\n\n   引用全局变量：\n\n   &lt;dependency&gt;\n       &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n       &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;\n       &lt;version&gt;     $&#123;spring.version&#125;          &lt;&#x2F;version&gt;\n   &lt;&#x2F;dependency&gt;\n\n4. maven 系统采用的变量\n\n   &lt;properties&gt;\n        &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt; 源码编译 jdk 版本\n        &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt; 运行代码的 jdk 版本\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;项目构建用的编码，避免中文乱码\n        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt; 生成报告的编码\n   &lt;&#x2F;properties&gt;\n   \n\n\n\n打包方式pom：用在聚合工程或父工程中，并无实际意义\njar：默认打为jar包\nwar：打包后发布到服务器上\n","slug":"40_Maven","date":"2021-09-13T15:16:32.000Z","categories_index":"Project Manager","tags_index":"Project Manager","author_index":"大黄"},{"id":"cfe3c6b5bac26dbfd06dd74550839a48","title":"工具类，上传下载，验证码","content":"1. BeanUtils使用及方法分析1.1 概论1. BeanUtils被广泛的使用与三大框架。\n在整个J2EE的编程过程中，我们经常会从各种配置文件中读取相应的数据，需要明白的一点是从配置文件中读取到的数据都是String，但是很显然我们的应用程序中不仅仅有String一种数据类型，比如：基本数据类型（int、double、char、float等），还有自定义数据类型（引用数据类型），那么我们必须面临的一个问题就是讲字符串类型转换为各种具体的数据类型\n\n2. 主要解决的问题是：\n把对象的属性数据封装到对象中。该工具提供字符式操作为对象属性提供封装。BeanUtils&lt;kbd&gt;底层使用反射机制&lt;&#x2F;kbd&gt;实现数据访问及封装\n\n3. 使用前导入jar包：\n   commons-beanutils-1.9.3中的commons-beanutils-1.9.3.jar\n   commons-logging-1.2中的commons-logging-1.2.jar\n\n1.2 主要方法\n\n\n方法参数\n使用\n\n\n\nstatic void copyProperty (Object bean, String name, Object value)\n将指定的属性值复制到指定的目标bean，执行所需的任何类型转换。\n\n\nstatic void setProperty (Object bean, String name, Object value)\n和上一个方法使用\n\n\nstatic void populate (Object bean, Map  properties)\n将指定的map集合内的元素赋值到目标bean\n\n\nstatic void copyProperties (Object dest, Object orig)\n在属性名相同的所有情况下，将属性值从原始bean复制到目标bean。（底层进行深克隆）\n\n\n&#x2F;**\n * BeanUtils工具的使用\n * 功能：BeanUtils主要是用于将对象的属性封装到对象中\n * BeanUtils的好处：\n * BeanUtils设置属性值的时候，如果属性是基本数据类型，那么BeanUtils会自动帮我们进行数据类型的转换，并且\n * BeanUtils设置属性的时候也是依赖于底层的getter和setter方法\n * \n *方法内部参数使用 Map类型 和 泛型T 可以降低耦合度，提高扩展性，简化代码书写\n * dao层\n * service层\n * web层（servlet）\n * 使用HttpServletRequest request，只能应用在web层，并且最后传入的参数类型是 Map集合\n * 而直接使用 Map类型作为参数的话，在三层中都能使用，降低了代码的耦合性，提高了扩张性\n *\n * 如果设置的属性值是其他的引用数据类型，此时必须要注册一个类型转换器才能实现自动的转换\n * *&#x2F;\n\npublic class beanUtil &#123;\n\n    public static &lt;T&gt; T copyParaToBean(Map map, T been)&#123;\n\n        try &#123;\n            System.out.println(&quot;注入前：&quot;+been);\n            BeanUtils.populate(been,map);\n            System.out.println(&quot;注入后：&quot;+been);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        return been;\n\n    &#125;\n&#125;\n\n1.3 BeanUtils结论1. 方法进行数据封装\n   \n2. 一般其实不需要自定义转换器，只有在特殊情况下才会**自定义转换器**\n   1、如果form参数是String类型，javabean属性String类型 — 调用BeanUtils.populate 将form数据封装 javabean\n   2、如果JavaBean属性类型不是String — 将form数据封装javabean 需要转换器 —– 在BeanUtils API 提供很多默认转换器（完成常见转换）\n   3、如果需要转换类型非常特殊，可以通过自定义转换器完成 定义类实现Converter接口，实现convert方法 ，在populate调用之前通过ConvertUtils.register注册转换器   \n\n3. 最通俗的说法，JavaBean就是一个存数据的地方，要么\n   （1）通过JSP页面中的标签去存储form表单中的数据（action跳转到JSP页面，之后“useBean”，“setProperty”进行数据存储），再在JSP界面中通过“getProperty”显示数据。\n   （2）在JSP页面中通过action跳转到Servlet程序的url，在Servlet程序中通过BeanUtils工具类的相关方法对JSP页面中的表单信息进行存储。\n\n2. Threadlocal2.1 为什么会导致业务逻辑出错==ThreadLocal不调用remove方法会导致业务逻辑错误==\n当ThreadLocal用于线程池、web应用或者线程被多次重复使用的时候，特别要注意，以web应用为例：\n\n我们都知道web应用很多类都是单例模式，如spring默认注入方式所创建的类就是一个单例，当不同的http请求到达服务器的时候，实际上都是使用了同一个实例，假如该实例使用了全局变量，当请求A修改了这个变量，后面到来的其它请求（此时不管A请求是否结束），如请求B再使用该变量的时候，实际上是被请求A修改过的，这会导致业务逻辑出错，而且很难被发现，这种情况，通常是使用ThreadLocal来解决，因为不同的请求虽然使用了同一个实例，但所使用的线程却不同，但有一点需要特别注意，那就是web容器的线程是重复使用的，web容器使用了线程池，当一个请求使用完某个线程，该线程会放回线程池被其它请求使用，这就导致一个问题，不同的请求还是有可能会使用到同一个线程（只要请求数量大于线程数量），而ThreadLocal是属于线程的，如果我们使用完ThreadLocal对象而没有手动删掉，那么后面的请求就有机会使用到被使用过的ThreadLocal对象，如果一个请求在使用ThreadLocal的时候，是先get()来判断然后再set()，那就会有问题，因为get到的是别的请求set的内容，如果一个请求每次使用ThreadLocal，都是先set再get，那就不会有问题，因为一个线程同一时刻只被一个请求使用，只要我们每次使用之前，都设置成自己想要的内容，那就不会在使用的过程中被覆盖。使用ThreadLocal最好是每次使用完就调用remove方法，将其删掉，避免先get后set的情况导致业务的错误。\n\n2.2 ThreadLocal 的使用1. ThreadLocal 的作用，它可以解决多线程的数据安全问题。 \n\n   ThreadLocal 它可以给当前线程关联一个数据（可以是普通变量，可以是对象，也可以是数组，集合） \n\n2. ThreadLocal 的特点： \n\n   * 1、ThreadLocal 可以为当前线程  &#x3D;&#x3D; 关联一个数据 &#x3D;&#x3D;。（它可以像 Map 一样存取数据，key 为当前线程） \n   * 每一个 ThreadLocal 对象，只能为当前线程关联一个数据，如果要为当前线程关联多个数据，就需要使用多个 ThreadLocal 对象实例。 \n   * 每个 ThreadLocal 对象实例定义的时候，&#x3D;&#x3D; 一般都是 static 类型 &#x3D;&#x3D;\n   * ThreadLocal 中保存数据，在线程销毁后。会由 JVM 虚拟自动释放。\n\n2.3 Filter 和 ThreadLocal 组合管理事务使用 ThreadLocal 来确保所有 dao 操作都在同一个 Connection 连接对象中完 成\n先修改工具类的获取，提交，回滚方法\npublic static Connection getConnection() &#123;\n     Connection conn &#x3D; conns.get();\n\n     try &#123;\n         if (conn &#x3D;&#x3D; null) &#123;\n             conn &#x3D; ds.getConnection();\n             conns.set(conn);\n             conn.setAutoCommit(false);\n         &#125;\n     &#125; catch (Exception e) &#123;\n         e.printStackTrace();\n     &#125;\n     return conn;\n &#125;\n\n public static void commitAndClose() &#123;\n\n     Connection connection &#x3D; conns.get();\n     if (connection !&#x3D; null) &#123;\n         try &#123;\n             connection.commit();\n         &#125; catch (SQLException e) &#123;\n             e.printStackTrace();\n         &#125; finally &#123;\n             try &#123;\n                 connection.close();\n             &#125; catch (SQLException e) &#123;\n                 e.printStackTrace();\n             &#125;\n         &#125;\n     &#125;\n     &#x2F;&#x2F; 一定要执行remove操作，否则就会出错。（因为Tomcat服务器底层使用了线程池技术）\n     conns.remove();\n\n &#125;\n\n public static void rollbackAndClose() &#123;\n\n     Connection connection &#x3D; conns.get();\n\n     if (connection !&#x3D; null) &#123;\n         try &#123;\n             connection.rollback();\n         &#125; catch (SQLException e) &#123;\n             e.printStackTrace();\n         &#125; finally &#123;\n             try &#123;\n                 connection.close();\n             &#125; catch (SQLException e) &#123;\n                 e.printStackTrace();\n             &#125;\n         &#125;\n     &#125;\n     &#x2F;&#x2F; 一定要执行remove操作，否则就会出错。（因为Tomcat服务器底层使用了线程池技术）\n     conns.remove();\n &#125;\n\n再修改baseDao中的方法，因为要使用 ThreadLocal 来确保所有 dao 操作都在同一个 Connection 连接对象中完 成，所以不能使用完其中一个个方法就将其关闭，我们应该在提交或者回滚的时候关闭，并且无论哪个方法出现错误，都应该抛出来，让transactionFilter来接收处理\n&#x2F;&#x2F;使用DBUtils操作数据库对象\nprivate final QueryRunner queryRunner &#x3D; new QueryRunner();\n\n&#x2F;**\n * 进行增删改的操作\n * @param sql   数据库操作语句\n * @param args  sql语句的参数\n * @return  返回-1表示操作失败，其他值表示成功，值为影响的数据条数\n *&#x2F;\npublic int update(String sql,Object...args)&#123;\n    Connection conn &#x3D; jdbcUtil.getConnection();\n    try &#123;\n        return queryRunner.update(conn,sql,args);\n    &#125; catch (SQLException e) &#123;\n        e.printStackTrace();\n        throw new RuntimeException(e);\n    &#125;\n&#125;\n\n&#x2F;**\n * 查询返回一个javaBean的sql语句\n * @param sql 查询单个的查询语句\n * @param type  返回的对象类型\n * @param args  sql语句的参数\n * @param &lt;T&gt;   返回的数据类型的泛型\n * @return  返回null，说明数据库中，无此查询数据\n *&#x2F;\npublic &lt;T&gt; T queryOne(String sql,Class&lt;T&gt; type,Object...args)&#123;\n    Connection conn &#x3D; jdbcUtil.getConnection();\n    try &#123;\n        return queryRunner.query(conn,sql,new BeanHandler&lt;T&gt;(type),args);\n    &#125; catch (SQLException e) &#123;\n        e.printStackTrace();\n        throw new RuntimeException(e);\n    &#125;\n&#125;\n\n使用 Filter 过滤器统一给所有的 Service 方法都加上 try-catch。来进行实现的 管理。\n@WebFilter(filterName &#x3D; &quot;TransactonFilter&quot;,urlPatterns &#x3D; &quot;&#x2F;*&quot;)\npublic class TransactonFilter implements Filter &#123;\n    public void destroy() &#123;\n    &#125;\n\n    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;\n\n        try &#123;\n            chain.doFilter(req, resp);\n            jdbcUtil.commitAndClose();\n        &#125; catch (Exception e) &#123;\n            jdbcUtil.rollbackAndClose();\n            e.printStackTrace();\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n\n    public void init(FilterConfig config) throws ServletException &#123;\n\n    &#125;\n\n&#125;\n\n需要修改baseServlet中的异常捕获，使他抛出，利于transactionFilter 接收并做出相应处理\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n\n    request.setCharacterEncoding(&quot;utf8&quot;);\n    response.setContentType(&quot;text&#x2F;html;charset&#x3D;utf8&quot;);\n\n    String action &#x3D; request.getParameter(&quot;action&quot;);\n\n    try &#123;\n        &#x2F;&#x2F; 获取 action 业务鉴别字符串，获取相应的业务 方法反射对象\n        &#x2F;&#x2F;System.out.println(this);&#x2F;&#x2F;servlet.UserServlet@20e68ff8\n        &#x2F;&#x2F;System.out.println(this.getClass());&#x2F;&#x2F;class servlet.UserServlet\n        Method method &#x3D; this.getClass().getDeclaredMethod(action, HttpServletRequest.class, HttpServletResponse.class);\n        &#x2F;&#x2F;System.out.println(method);&#x2F;&#x2F;protected void servlet.UserServlet.login(javax.servlet.http.HttpServletRequest,\n        &#x2F;&#x2F; +javax.servlet.http.HttpServletResponse)throws javax.servlet.ServletException,java.io.IOException\n\n        &#x2F;&#x2F; 调用目标业务 方法\n        method.invoke(this,request,response);\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n        throw new RuntimeException(e);\n    &#125;\n\n&#125;\n\n将所有异常都统一交给 Tomcat，让 Tomcat 展示友好的错误信息页面\n&lt;error-page&gt;\n    &lt;error-code&gt;500&lt;&#x2F;error-code&gt;\n    &lt;location&gt;&#x2F;pages&#x2F;error&#x2F;error500.jsp&lt;&#x2F;location&gt;\n&lt;&#x2F;error-page&gt;\n\n3. 谷歌验证码 - kaptch谷歌验证码 kaptcha 使用步骤如下：\n1、导入谷歌验证码的 jar 包\n   kaptcha-2.3.2.jar\n\t\n2、在 web.xml 中去配置用于生成验证码的 Servlet 程序\n   &lt;servlet&gt;\n\t\t&lt;servlet-name&gt;KaptchaServlet&lt;&#x2F;servlet-name&gt;\n\t\t&lt;servlet-class&gt;com.google.code.kaptcha.servlet.KaptchaServlet&lt;&#x2F;servlet-class&gt;\n   &lt;&#x2F;servlet&gt;\n   &lt;servlet-mapping&gt;\n\t\t&lt;servlet-name&gt;KaptchaServlet&lt;&#x2F;servlet-name&gt;\n\t\t&lt;url-pattern&gt;&#x2F;kaptcha.jpg&lt;&#x2F;url-pattern&gt;\n   &lt;&#x2F;servlet-mapping&gt;\n   \n3、在表单中使用 img 标签去显示验证码图片并使用它\n   &lt;form action&#x3D;&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;tmp&#x2F;registServlet&quot; method&#x3D;&quot;get&quot;&gt;\n   \t\t用户名：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; &gt; &lt;br&gt;\n   \t\t验证码：&lt;input type&#x3D;&quot;text&quot; style&#x3D;&quot;width: 80px;&quot; name&#x3D;&quot;code&quot;&gt;\n   \t\t&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;tmp&#x2F;kaptcha.jpg&quot; alt&#x3D;&quot;&quot; style&#x3D;&quot;width: 100px; height: 28px;&quot;&gt; &lt;br&gt;\n   \t\t&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;登录&quot;&gt;\n   &lt;&#x2F;form&gt;\n   \n4、在服务器获取谷歌生成的验证码和客户端发送过来的验证码比较使用。\n   protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException,\n   IOException &#123;\n\t\t&#x2F;&#x2F; 获取 Session 中的验证码\n\t\tString token &#x3D; (String) req.getSession().getAttribute(KAPTCHA_SESSION_KEY);\n\t\t&#x2F;&#x2F; 删除 Session 中的验证码\n\t\treq.getSession().removeAttribute(KAPTCHA_SESSION_KEY);\n\t\tString code &#x3D; req.getParameter(&quot;code&quot;);\n\t\t\t\t\n\t\t&#x2F;&#x2F; 获取用户名\n\t\tString username &#x3D; req.getParameter(&quot;username&quot;);\n\t\tif (token !&#x3D; null &amp;&amp; token.equalsIgnoreCase(code)) &#123;\n\t\t\tSystem.out.println(&quot;保存到数据库：&quot; + username);\n\t\t\tresp.sendRedirect(req.getContextPath() + &quot;&#x2F;ok.jsp&quot;);\n\t\t&#125; else &#123;\n\t\t\tSystem.out.println(&quot;请不要重复提交表单&quot;);\n\t\t\t&#125;\n\t\t&#125;\n\t\t\n5、点击切换验证码：\n\t&#x2F;&#x2F; 给验证码的图片，绑定单击事件\n\t$(&quot;#code_img&quot;).click(function () &#123;\n\t&#x2F;&#x2F; 在事件响应的 function 函数中有一个 this 对象。这个 this 对象，是当前正在响应事件的 dom 对象\n\t&#x2F;&#x2F; src 属性表示验证码 img 标签的 图片路径。它可读，可写\n\t&#x2F;&#x2F; alert(this.src);\n\tthis.src &#x3D; &quot;$&#123;basePath&#125;kaptcha.jpg?d&#x3D;&quot; + new Date();\n\t&#125;);\n\n\n\n4. 文件上传4.1 概述1. 要有一个 form 标签，method&#x3D;post 请求 \n2. form 标签的 encType 属性值必须为 multipart&#x2F;form-data 值 \n3. 在 form 标签中使用 input type&#x3D;file 添加上传的文件 \n4. 编写服务器代码（Servlet 程序）接收，处理上传的数据。 \n5. encType&#x3D;multipart&#x2F;form-data 表示提交的数据，以多段（每一个表单项一个数据段）的形式进行拼 接，然后以二进制流的形式发送给服务器\n\n4.2 文件上传，HTTP 协议的说明\n4.3 commons-fileupload常用 API1. 第一步，就是需要导入两个 jar 包： commons-fileupload-1.2.1.jar \tcommons-io-1.4.jar\n\n2. commons-fileupload.jar 和 commons-io.jar 包中常用的类\n\n   * ServletFileUpload 类，用于解析上传的数据。 \n\n   * FileItem 类，表示每一个表单项。\n\n3. 常用API\n\n   * boolean  ServletFileUpload  isMultipartContent(HttpServletRequest request) 判断当前上传的数据格式是否是多段的格式。 \n\n   * public \tList \tparseRequest(HttpServletRequest request) \t解析上传的数据 \n\n   * boolean \tFileItem\tisFormField() \t判断当前这个表单项，是否是普通的表单项。还是上传的文件类型。 \n\n     true 表示普通类型的表单项\t false 表示上传的文件类型 \n\n   * String     FileItem    getFieldName()     获取表单项的 name 属性值 \n\n   * String     FileItem    getString() \t获取当前表单项的值。 \n\n   * String     FileItem    getName()\t 获取上传的文件名 \n\n   * void       FileItem    write( file )\t将上传的文件写到 参数 file 所指向抽硬盘位置 。\n\n4.4 示例HTML中代码：\n    &lt;form action&#x3D;&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;EL&#x2F;upload&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;\n        用户名:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&#x2F;&gt;\n        密码:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;password&quot;&#x2F;&gt;\n        文件上传:&lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;photo&quot;&#x2F;&gt;\n        &lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot;&#x2F;&gt;\n    &lt;&#x2F;form&gt;\n\n\n\n\t\trequest.setCharacterEncoding(&quot;utf8&quot;);\n        &#x2F;&#x2F;System.out.println(request.getCharacterEncoding());\n        &#x2F;&#x2F;1.判断是否是多段数据\n        if (ServletFileUpload.isMultipartContent(request)) &#123;\n            &#x2F;&#x2F;2.创建用于解析上传数据的工具类 ServletFileUpload 类\n            &#x2F;&#x2F; 创建 FileItemFactory 工厂实现类\n            FileItemFactory fileItemFactory &#x3D; new DiskFileItemFactory();\n            ServletFileUpload servletFileUpload &#x3D; new ServletFileUpload(fileItemFactory);\n\n            &#x2F;&#x2F;4.解析上传的数据，得到每一个表单项 FileItem\n            try &#123;\n                List&lt;FileItem&gt; list &#x3D; servletFileUpload.parseRequest(request);\n                for (FileItem fileItem : list) &#123;\n                    &#x2F;&#x2F;5.判断是否为普通表单项\n                    if (fileItem.isFormField()) &#123;\n                        &#x2F;&#x2F;是普通表单项\n                        System.out.println(&quot;name属性值：&quot; + fileItem.getFieldName());\n                        System.out.println(&quot;传入的数据：&quot; + fileItem.getString(&quot;utf-8&quot;));\n                    &#125; else &#123;\n                        &#x2F;&#x2F;是文件fileName &#x3D; URLDecoder.decode(fileDetail.getFileName(), &quot;UTF-8&quot;);\n                        System.out.println(&quot;文件上传项name属性值：&quot; + fileItem.getFieldName());\n                        System.out.println(&quot;上传的文件名：&quot; + fileItem.getName());\n\n                        &#x2F;&#x2F;6.把文件保存到要保存的位置StandardCharsets.UTF_8 can be used instead\n                        fileItem.write(new File(&quot;e:&#x2F;&#x2F;&quot; + fileItem.getName()));\n                    &#125;\n                &#125;\n            &#125; catch (Exception e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n\n5. 文件下载5.1 示例&#x2F;&#x2F;1.获取要下载的文件名\nString downloadfilename&#x3D;&quot;按钮.jpg&quot;;\n\n&#x2F;&#x2F;2.读取要下载的文件内容(通过servletContext对象获取)\n&#x2F;&#x2F;ServletContext servletContext &#x3D; getServletContext();\nServletContext servletContext &#x3D; getServletConfig().getServletContext();\n&#x2F;&#x2F;以流的方式获取文件内容\nInputStream resourceAsStream &#x3D; servletContext.getResourceAsStream(&quot;&#x2F;img&#x2F;&quot; + downloadfilename);\n\n&#x2F;&#x2F;3.再回传前，通过响应头告诉客户端返回的数据类型\nString mimeType &#x3D; servletContext.getMimeType(&quot;&#x2F;img&#x2F;&quot; + downloadfilename);\n&#x2F;&#x2F;System.out.println(mimeType);\nresponse.setContentType(mimeType);\n\n&#x2F;&#x2F;4.还要告诉客户端收到的数据是用于下载使用（通过响应头设置）\nresponse.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; fileName&#x3D;&quot;+ URLEncoder.encode(&quot;按钮.jpg&quot;,&quot;utf8&quot;));\n\n&#x2F;&#x2F;5.把要下载的文件回传给客户端(通过输出流进行输出)\nServletOutputStream outputStream &#x3D; response.getOutputStream();\n&#x2F;&#x2F;用commons-io-1.4.jar包中封装好的工具类进行复制输出\nIOUtils.copy(resourceAsStream, outputStream);\n\n5.2 常用API1. response.getOutputStream(); \n\n2. servletContext.getResourceAsStream(); \n\n   以流的方式获取文件内容\n\n3. servletContext.getMimeType(); \n\n   获得文件的数据类型\n\n4. response.setContentType();\n\n   再回传前，通过响应头告诉客户端返回的数据类型\n\n5. response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; fileName&#x3D;1.jpg&quot;);\n\n   这个响应头告诉浏览器。这是需要下载的。而 attachment 表示附件，也就是下载的一个文件。fileName&#x3D;后面， 表示下载的文件名。\n\n6. URLEncoder.encode(&quot;按钮.jpg&quot;,&quot;utf8&quot;)\n\n   以中文方式进行编码\n\n","slug":"39-utils kaptcher up down","date":"2021-09-13T15:15:32.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"大黄"},{"id":"cf8cafd4cf1868b0ac65896e606a4625","title":"Json Ajax","content":":beginner: ​Json① json 的定义1. json 是由键值对组成，并且由 花括号（大括号）包围。\n\n2. 每个键由引号引起来，键和值之间使用 冒号进行分隔， 多组键值对之间进行 逗号进行分隔。\n\n例子♥: \n&#123;  &quot;name&quot;:&quot;json学习笔记&quot;，\n\n   &quot;author&quot;:&quot;Fred&quot;,\n\n   &quot;content&quot;:[&quot;json基础入门&quot;，&quot;json解析&quot;]\n\n   &quot;time&quot;:&#123;\n          &quot;value&quot;:30,\n          &quot;unit&quot;:&quot;分钟&quot;\n          &#125;\n&#125;\n\n==注意：使用vue时，如果想让文本框中不自动渲染数字，那就用null表示==\ndata: &#123;\n            fname: &quot;&quot;,\n            price: null,\n            fcount: null,\n            remark: &quot;&quot;\n        &#125;\n\n② json 的访问1. json 本身是一个对象。 json 中的 key 我们可以理解为是对象中的一个属性。 \n\n2. json 中的 key 访问就跟访问对象的属性一样： json 对象.key\n\n③ json 的两个常用方法1. json 的存在有两种形式。\n\n   * 一种是：对象的形式存在，我们叫它 json 对象。 \n\n   * 一种是：字符串的形式存在，我们叫它 json 字符串。 \n\n2. 一般我们要操作 json 中的数据的时候，需要 json 对象的格式。 一般我们要在客户端和服务器之间进行数据交换的时候，使用 json 字符串。 \n\n   * JSON.stringify() \t把 json 对象转换成为 json 字符串 \n   * JSON.parse()       把 json 字符串转换成为 json 对象\n   \n3. 可以使用eval来转换JSON字符到Object\n   * function myEval() &#123; \n\t var str &#x3D; &#39;&#123; &quot;name&quot;: &quot;Violet&quot;, &quot;occupation&quot;: &quot;character&quot; &#125;&#39;; \n \t var obj &#x3D; eval(&#39;(&#39; + str + &#39;)&#39;); \n\t alert(obj.toJSONString()); \n\t &#125; \n\n④ json 在java中的使用1.javaBean 和 json 的互转\n@Test\npublic void javaBeanToJson() &#123;\n\n    student student &#x3D; new student(&quot;hh&quot;, 31);\n\n    Gson gson &#x3D; new Gson();\n\n    &#x2F;&#x2F;由javaBean对象转换为 json对象\n    String s &#x3D; gson.toJson(student);\n\n    System.out.println(s);\n\n    &#x2F;&#x2F;由json对象转换为 javaBean对象\n    com.bean.student student1 &#x3D; gson.fromJson(s, student.getClass());\n    System.out.println(student1);\n    System.out.println(student.getClass());\n\n&#125;\n\n2.List 和 json 的互转\n@Test\n    public void test2() &#123;\n\n        List&lt;student&gt; list &#x3D; new ArrayList&lt;student&gt;();\n\n        list.add(new student(&quot;hh&quot;, 21));\n        list.add(new student(&quot;ff&quot;, 22));\n\n        Gson gson &#x3D; new Gson();\n\n        String s &#x3D; gson.toJson(list);\n\n        System.out.println(s);\n\n        List&lt;student&gt; ss &#x3D; gson.fromJson(s, new TypeToken&lt;ArrayList&lt;student&gt;&gt;() &#123;\n        &#125;.getType());\n\n        student s1 &#x3D; ss.get(0);\n\n        System.out.println(s1);\n    &#125;\n\n3.Map 和 json 的互转\n@Test\n    public void test3() &#123;\n\n        Map&lt;Integer, student&gt; map &#x3D; new HashMap&lt;&gt;();\n\n        map.put(1, new student(&quot;hh&quot;, 21));\n        map.put(2, new student(&quot;gg&quot;, 22));\n\n        System.out.println(map);\n\n        Gson gson &#x3D; new Gson();\n\n        String s &#x3D; gson.toJson(map);\n\n        System.out.println(s);\n\n        Map&lt;Integer, student&gt; map1 &#x3D; gson.fromJson(s, new TypeToken&lt;HashMap&lt;Integer, student&gt;&gt;() &#123;\n        &#125;.getType());\n\n        System.out.println(map1.get(1));\n\n        Type type &#x3D; new TypeToken&lt;HashMap&lt;Integer, student&gt;&gt;() &#123;\n        &#125;.getType();\n\n        System.out.println(type);&#x2F;&#x2F;结果为:java.util.HashMap&lt;java.lang.Integer, com.bean.student&gt;\n    &#125;\n\n\n\n:beginner: Ajax① 什么是ajaxAJAX 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的 网页开发技术。 \n\najax 是一种浏览器异步发起请求。局部更新页面的技术。\n\n② 不同浏览器的支持现代浏览器中, 虽然几乎全部支持ajax, 但它们的技术方案却分为两种:\n① 标准浏览器通过 XMLHttpRequest 对象实现了ajax的功能. 只需要通过一行语句便可创建一个用于发送ajax请求的对象.\nvar xhr &#x3D; new XMLHttpRequest();复制代码\n\n② IE浏览器通过 XMLHttpRequest 或者 ActiveXObject 对象同样实现了ajax的功能.\n③ 全兼容的XMLHttpRequestvar xmlHttpRequest &#x3D; null;\n\nfunction createXmlHttpRequest() &#123;\n    if (window.XMLHttpRequest) &#123;&#x2F;&#x2F; 兼容 IE7+, Firefox, Chrome, Opera, Safari\n        xmlHttpRequest &#x3D; new XMLHttpRequest();\n    &#125; else if (window.ActiveXObject) &#123;&#x2F;&#x2F;\n        try &#123;\n            xmlHttpRequest &#x3D; new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);\n        &#125; catch (e) &#123;\n            xmlHttpRequest &#x3D; new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);\n        &#125;\n    &#125;\n&#125;\n\nfunction checkUname(uname) &#123;\n\n    createXmlHttpRequest();\n\n    xmlHttpRequest.open(&quot;post&quot;, &quot;user.do&quot;, true);\n    xmlHttpRequest.setRequestHeader(&quot;Content-type&quot;, &quot;application&#x2F;x-www-form-urlencoded&quot;);\n\n    xmlHttpRequest.onreadystatechange &#x3D; function checkUnameCB&#x2F;*触发的回调函数*&#x2F;() &#123;\n        &#x2F;*if (xmlHttpRequest.readyState &#x3D;&#x3D; 4 &amp;&amp; xmlHttpRequest.status &#x3D;&#x3D; 200) &#123;\n            var responseText &#x3D; xmlHttpRequest.responseText;\n            var flagObj &#x3D; JSON.parse(responseText);\n            if (flagObj.uname !&#x3D; &quot;ok&quot;) &#123;\n                if (flagObj.flag) &#123;\n                    get(&quot;unameErrMess&quot;).innerText &#x3D; &#39;可被注册&#39;;\n                    get(&quot;unameErrMess&quot;).style.color &#x3D; &quot;green&quot;;\n                &#125; else &#123;\n                    get(&quot;unameErrMess&quot;).innerText &#x3D; &#39;已被注册&#39;;\n                    get(&quot;unameErrMess&quot;).style.color &#x3D; &quot;red&quot;;\n                &#125;\n            &#125;else &#123;\n                get(&quot;unameErrMess&quot;).innerText &#x3D; &#39;&#39;;\n                get(&quot;unameErrMess&quot;).style.color &#x3D; &quot;white&quot;;\n            &#125;\n        &#125;*&#x2F;\n        \n        就是注释部分的方法体（两端互通后要做的事）\n    &#125;;\n\n    xmlHttpRequest.send(&quot;oper&#x3D;checkUname&amp;uname&#x3D;&quot; + uname);\n&#125;\n\n&#x2F;*function get(id) &#123;\n    return document.getElementById(id);\n&#125;*&#x2F;\n\n④ GET和POST请求数据区别\n使用Get请求时,参数在URL中显示,而使用Post方式,则放在send里面\n使用Get请求发送数据量小,Post请求发送数据量大\n使用Get请求安全性低，会被缓存，而Post请求反之 关于第一点区别，详情见下面两张图：\n\n\n\n⑤ ajax没有破坏js单线程机制对于这个问题, 我们先看下浏览器线程机制. 一般情况下, 浏览器有如下四种线程:\n\n* GUI渲染线程\n* javascript引擎线程\n* 浏览器事件触发线程\n* HTTP请求线程\n\n那么这么多线程, 它们究竟是怎么同js引擎线程交互的呢?\n\n通常, 它们的线程间交互以事件的方式发生, 通过事件回调的方式予以通知. 而事件回调, 又是以先进先出的方式添加到&#96;任务队列&#96; 的末尾 , 等到js引擎空闲时, &#96;任务队列&#96; 中排队的任务将会依次被执行. 这些事件回调包括 setTimeout, setInterval, click, ajax异步请求等回调.\n\n整个ajax请求过程中, 有涉及到浏览器的4种线程. 其中除了 GUI渲染线程 和 js引擎线程 是互斥的. 其他线程相互之间, 都是可以并行执行的. 通过这样的一种方式, ajax并没有破坏js的单线程机制.\n\n⑥ XMLHttpRequest 属性1. readyState只读属性, readyState属性记录了ajax调用过程中所有可能的状态. 它的取值简单明了, 如下:\n\n\n\nreadyState\n对应常量\n描述\n\n\n\n0 (未初始化)\nxhr.UNSENT\n请求已建立, 但未初始化(此时未调用open方法)\n\n\n1 (初始化)\nxhr.OPENED\n请求已建立, 但未发送 (已调用open方法, 但未调用send方法)\n\n\n2 (发送数据)\nxhr.HEADERS_RECEIVED\n请求已发送 (send方法已调用, 已收到响应头)\n\n\n3 (数据传送中)\nxhr.LOADING\n请求处理中, 因响应内容不全, 这时通过responseBody和responseText获取可能会出现错误\n\n\n4 (完成)\nxhr.DONE\n数据接收完毕, 此时可以通过通过responseBody和responseText获取完整的响应数据\n\n\n注意, readyState 是一个只读属性, 想要改变它的值是不可行的.\n2. status只读属性, status表示http请求的状态, 初始值为0. 如果服务器没有显式地指定状态码, 那么status将被设置为默认值, 即200.\n3. statusText只读属性, statusText表示服务器的响应状态信息, 它是一个 UTF-16 的字符串, 请求成功且status==20X时, 返回大写的 OK . 请求失败时返回空字符串. 其他情况下返回相应的状态描述. 比如: 301的 Moved Permanently , 302的 Found , 303的 See Other , 307 的 Temporary Redirect , 400的 Bad Request , 401的 Unauthorized 等等.\n4. onreadystatechangeonreadystatechange事件回调方法在readystate状态改变时触发, 在一个收到响应的ajax请求周期中, onreadystatechange 方法会被触发4次. 因此可以在 onreadystatechange 方法中绑定一些事件回调, 比如:\nxmlHttpRequest.onreadystatechange &#x3D; function checkUnameCB&#x2F;*触发的回调函数*&#x2F;() &#123;\n    if (xmlHttpRequest.readyState &#x3D;&#x3D; 4 &amp;&amp; xmlHttpRequest.status &#x3D;&#x3D; 200) &#123;\n        var responseText &#x3D; xmlHttpRequest.responseText;\n        var flagObj &#x3D; JSON.parse(responseText);\n        if (flagObj.uname !&#x3D; &quot;ok&quot;) &#123;\n            if (flagObj.flag) &#123;\n                get(&quot;unameErrMess&quot;).innerText &#x3D; &#39;可被注册&#39;;\n                get(&quot;unameErrMess&quot;).style.color &#x3D; &quot;green&quot;;\n            &#125; else &#123;\n                get(&quot;unameErrMess&quot;).innerText &#x3D; &#39;已被注册&#39;;\n                get(&quot;unameErrMess&quot;).style.color &#x3D; &quot;red&quot;;\n            &#125;\n        &#125;else &#123;\n            get(&quot;unameErrMess&quot;).innerText &#x3D; &#39;&#39;;\n            get(&quot;unameErrMess&quot;).style.color &#x3D; &quot;white&quot;;\n        &#125;\n    &#125;\n\n⑦ $.ajax$.ajax是jquery对原生ajax的一次封装. 通过封装ajax, jquery抹平了不同版本浏览器异步http的差异性, 取而代之的是高度统一的api. jquery作为js类库时代的先驱, 对前端发展有着深远的影响. 了解并熟悉其ajax方法, 不可谓不重要.\n\n1. 参数列表$.ajax() 只有一个参数, 该参数为key-value设置对象. 实际上, jq发送的所有ajax请求, 都是通过调用该ajax方法实现的. 它的详细参数如下表:\n\n\n\n序号\n参数\n类型\n描述\n\n\n\n1\naccepts\nPlainObject\n用于通知服务器该请求需要接收何种类型的返回结果. 如有必要, 推荐在 $.ajaxSetup() 方法中设置一次.\n\n\n2\nasync\nBoolean\n默认为true, 即异步.\n\n\n3\nbeforeSend\nFunction\n请求发送前的回调, 默认传入参数jqXHR和settings. 函数内显式返回false将取消本次请求.\n\n\n4\ncache\nBoolean\n请求是否开启缓存, 默认为true, 如不需要缓存请设置为false. 不过, dataType为”script”和”jsonp”时默认为false.\n\n\n5\ncomplete\nFunction\n请求完成后的回调(请求success 和 error之后均调用), 默认传入参数jqXHR和textStatus(请求状态, 取值为 “success”,”notmodified”,”error”,”timeout”,”abort”,”parsererror”之一). 从jq1.5开始, complete可以设置为一个包含函数的数组. 如此每个函数将依次被调用.\n\n\n6\ncontents\nPlainObject\n一个以”{字符串/正则表达式}”配对的对象, 根据给定的内容类型, 解析请求的返回结果.\n\n\n7\ncontentType\nString\n编码类型, 相对应于http请求头域的”Content-Type”字段. 默认值为”application/x-www-form-urlencoded; charset=UTF-8”.\n\n\n8\ncontext\nObject\n设置ajax回调函数的上下文. 默认上下文为ajax请求传入的参数设置对象. 如设置为document.body, 那么所有ajax回调函数中将以body为上下文.\n\n\n9\nconverters\nPlainObject\n一个数据类型到数据类型转换器的对象. 默认为 &#123;&quot;* text&quot;: window.String, &quot;text html&quot;: true, &quot;text json&quot;: jQuery.parseJSON, &quot;text xml&quot;: jQuery.parseXML&#125; . 如设置converters:&#123;&quot;json jsonp&quot;: function(msg)&#123;&#125;&#125;\n\n\n10\ncrossDomain\nBoolean\n默认同域请求为false, 跨域请求为true.\n\n\n11\ndata\nObject, Array\n发送到服务器的数据, 默认data为键值对格式对象, 若data为数组则按照traditional参数的值, 自动转化为一个同名的多值查询字符串. 如{a:1,b:2}将转换为”&amp;a=1&amp;b=2”.\n\n\n12\ndataFilter\nFunction\n处理XMLHttpRequest原始响应数据的回调, 默认传入data和type参数, data是Ajax返回的原始数据, type是调用$.ajax时提供的dataType参数\n\n\n13\ndataTyp\nString\n预期服务器返回的数据类型, 可设置为”xml”,”html”,”script”,”json”,”jsonp”,”text”之一, 其中设置为”xml”或”text”类型时, 数据不会经过处理.\n\n\n14\nerror\nFunction\n请求失败时的回调函数, 默认传入jqXHR(jq1.4以前为原生xhr对象),textStatus(请求状态,取值为null,”timeout”,”error”,”abort” 或 “parsererror”),errorString(错误内容), 当一个HTTP错误发生时, errorThrown 接收HTTP状态的文本部分,比如”Not Found”等. 从jq1.5开始, error可以设置为一个包含函数的数组. 如此每个函数将依次被调用.注意: 跨域脚本和JSONP请求时error不被调用.\n\n\n15\nglobal\nBoolean\n表示是否触发全局ajax事件, 默认为true. 设为false将不再触发ajaxStart,ajaxStop,ajaxSend,ajaxError等. 跨站脚本和jsonp请求, 该值自动设置为false.\n\n\n16\nheaders\nPlainObject\n设置请求头, 格式为k-v键值对对象. 由于该设置会在beforeSend函数被调用之前生效, 因此可在beforeSend函数内覆盖该对象.\n\n\n17\nifModified\nBoolean\n只有上次请求响应改变时, 才允许请求成功. 它使用HTTP包的Last-Modified 头信息判断, 默认为false. 若设置为true, 且数据自从上次请求后没有更改过就会报错.\n\n\n18\nisLocal\nBoolean\n运行当前环境设置为”本地”,默认为false, 若设置为true, 将影响请求发送时的协议.\n\n\n19\njsonp\nString\n显式指定jsonp请求中的回调函数的名称. 如jsonp:cb, jq会将cb代替callback, 以 “cb=?”传给服务器. 从jq1.5开始, 若设置jsonp:false, 那么需要明确设置jsonpCallback:”callbackName”.\n\n\n20\njsonpCallback\nString,Function\n为jsonp请求指定一个回调函数名, 以取代jq自动生成的随机函数名. 从jq1.5开始, 可以将该属性设置为一个函数, 函数的返回值就是jsonpCallback的结果.\n\n\n21\nmimeType\nString\n设置一个MIME类型, 以覆盖xhr的MIM类型(jq1.5新增)\n\n\n22\npassword\nString\n设置认证请求中的密码\n\n\n23\nprocessData\nBoolean\njq的ajax方法默认会将传入的data隐式转换为查询字符串(如”&amp;a=1&amp;b=2”), 以配合 默认内容类型 “application/x-www-form-urlencoded”, 如果不希望转换请设置为false. angular中想要禁用默认转换, 需要重写transformRequest方法.\n\n\n24\nscriptCharset\nString\n仅在”script”请求中使用(如跨域jsonp, dataType为”script”类型). 显式指定时, 请求中将在script标签上设置charset属性, 可在发现本地和远程编码不一致时使用.\n\n\n25\nstatusCode\nPlainObject\n一组http状态码和回调函数对应的键值对对象. 该对象以 {404:function(){}} 这种形式表示. 可用于根据不同的http状态码, 执行不同的回调.(jq1.5新增)\n\n\n26\ntimeout\nNumber\n设置超时时间.\n\n\n27\ntraditional\nBoolean\n是否按照默认方式序列化data对象, 默认值为false.\n\n\n28\ntype\nString\n可以设置为8种http method之一, jq中不区分大小写.\n\n\n29\nurl\nString\n请求的uri地址.\n\n\n30\nusername\nString\n设置认证请求中的用户名\n\n\n31\nxhr\nFunction\n在回调内创建并返回xhr对象\n\n\n32\nxhrField\nPlainObject\n键值对对象, 用于设置原生的xhr对象, 如可用来设置withCredentials:true(jq1.5.1新增\n\n\n2. 支持promise3. 使用转换器4. 事件触发顺序:beginner: Axios① 概述实际上, 如果你仅仅只是想要一个不错的http库, 相比于庞大臃肿的jquery, 短小精悍的Axios可能更加适合你. 原因如下:\n\n* Axios支持node, jquery并不支持.\n* Axios基于promise语法, jq3.0才开始全面支持.\n* Axios短小精悍, 更加适合http场景, jquery大而全, 加载较慢.\n* vue作者尤大放弃推荐vue-resource, 转向推荐Axios. 以下为尤大原话.\n&quot;最近团队讨论了一下, Ajax 本身跟 Vue 并没有什么需要特别整合的地方, 使用 fetch polyfill 或是 axios、superagent 等等都可以起到同等的效果, vue-resource 提供的价值和其维护成本相比并不划算, 所以决定在不久以后取消对 vue-resource 的官方推荐.&quot;\n\nAxios大小仅12k, 目前最新版本号为: npm version\n语法上Axios基本就和promise一样, 在then方法中处理回调, 在catch方法中处理异常. 如下:\n\naxios.get(&quot;https:&#x2F;&#x2F;api.github.com&#x2F;users&#x2F;louiszhai&quot;)\n  .then(function(response)&#123;\n    console.log(response);\n  &#125;)\n  .catch(function (error) &#123;\n    console.log(error);\n  &#125;);\n  \n除了get, 它还支持post, delete, head, put, patch, request请求. \n\n除了get, 它还支持post, delete, head, put, patch, request请求. \n② 使用使用Axios和使用Vue一样，导入对应的*.js文件即可。官方提供的script标签引入方式为：\n\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;axios&#x2F;dist&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;\n\n我们可以把这个axios.min.js文件下载下来保存到本地来使用。\n\n③ 基本用法1. 前端页面引入环境&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;demo&#x2F;static&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;demo&#x2F;static&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;\n\n2. 发送普通请求参数2.1 前端代码HTML标签：\n&lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;button @click&#x3D;&quot;commonParam&quot;&gt;普通请求参数&lt;&#x2F;button&gt;\n&lt;&#x2F;div&gt;\n\nVue+axios代码：\n&lt;script&gt;\nvar vue &#x3D; new Vue(&#123;\n    &quot;el&quot;:&quot;#app&quot;,\n    &quot;data&quot;:&#123;\n        &quot;message&quot;:&quot;&quot;\n    &#125;,\n    &quot;methods&quot;:&#123;\n        commonParam()&#123;\n            &#x2F;&#x2F;使用axios发送异步请求\n            axios(&#123;\n                &quot;method&quot;:&quot;post&quot;,\n                &quot;url&quot;:&quot;demo01&quot;,\n                &quot;params&quot;:&#123;\n                    &quot;userName&quot;:&quot;tom&quot;,\n                    &quot;userPwd&quot;:&quot;123456&quot;\n                &#125;\n            &#125;).then(response &#x3D;&gt; &#123;\n                &#x2F;&#x2F;then里面是处理请求成功的响应数据\n                &#x2F;&#x2F;response就是服务器端的响应数据,是json类型的\n                &#x2F;&#x2F;response里面的data就是响应体的数据\n                this.message &#x3D; response.data\n            &#125;).catch(error &#x3D;&gt; &#123;\n                &#x2F;&#x2F;error是请求失败的错误描述\n                &#x2F;&#x2F;error.response就是请求失败时候的响应信息\n                console.log(error.response)\n            &#125;)\n        &#125;\n    &#125;\n&#125;)\n&lt;&#x2F;script&gt;\n\n效果：所有请求参数都被放到URL地址后面了，哪怕我们现在用的是POST请求方式。\n2.2 后端代码package com.atguigu.servlet;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n&#x2F;**\n * @author Leevi\n * 日期2021-05-21  09:15\n *&#x2F;\npublic class ServletDemo01 extends HttpServlet &#123;\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        doGet(request, response);\n    &#125;\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        request.setCharacterEncoding(&quot;UTF-8&quot;);\n        response.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);\n        &#x2F;&#x2F;1. 接收请求参数userName和userPwd\n        String userName &#x3D; request.getParameter(&quot;userName&quot;);\n        String userPwd &#x3D; request.getParameter(&quot;userPwd&quot;);\n        System.out.println(userName + &quot;:&quot; + userPwd);\n\n        &#x2F;&#x2F;模拟出现异常\n        &#x2F;&#x2F;int num &#x3D; 10&#x2F;0;\n\n        &#x2F;&#x2F;2. 向浏览器响应数据\n        response.getWriter().write(&quot;hello world!!!&quot;);\n    &#125;\n&#125;\n\n3. axios接收响应对象的结构\n\n\n属性名\n作用\n\n\n\nconfig\n调用axios(config对象)方法时传入的JSON对象\n\n\ndata\n服务器端返回的响应体数据\n\n\nheaders\n响应消息头\n\n\nrequest\n原生JavaScript执行Ajax操作时使用的XMLHttpRequest\n\n\nstatus\n响应状态码\n\n\nstatusText\n响应状态码的说明文本\n\n\n4. 服务器处理请求失败后catch(error &#x3D;&gt; &#123;     &#x2F;&#x2F; catch()服务器端处理请求出错后，会调用\n\n    console.log(error);         &#x2F;&#x2F; error就是出错时服务器端返回的响应数据\n    console.log(error.response);        &#x2F;&#x2F; 在服务器端处理请求失败后，获取axios封装的JSON格式的响应数据对象\n    console.log(error.response.status); &#x2F;&#x2F; 在服务器端处理请求失败后，获取响应状态码\n    console.log(error.response.statusText); &#x2F;&#x2F; 在服务器端处理请求失败后，获取响应状态说明文本\n    console.log(error.response.data);   &#x2F;&#x2F; 在服务器端处理请求失败后，获取响应体数据\n\n&#125;);\n\n在给catch()函数传入的回调函数中，error对象封装了服务器端处理请求失败后相应的错误信息。其中，axios封装的响应数据对象，是error对象的response属性。response属性对象的结构如下图所示：\n\n可以看到，response对象的结构还是和then()函数传入的回调函数中的response是一样的：\n回调函数：开发人员声明，但是调用时交给系统来调用。像单击响应函数、then()、catch()里面传入的都是回调函数。回调函数是相对于普通函数来说的，普通函数就是开发人员自己声明，自己调用：\nfunction sum(a, b) &#123;\nreturn a+b;\n&#125;\n\nvar result &#x3D; sum(3, 2);\nconsole.log(&quot;result&#x3D;&quot;+result);\n\n④ 发送请求体JSON1. 前端代码HTML代码：\n&lt;button @click&#x3D;&quot;sendJsonBody&quot;&gt;请求体JSON&lt;&#x2F;button&gt;\n\nVue+axios代码：\n&lt;script&gt;\n    var vue &#x3D; new Vue(&#123;\n        &quot;el&quot;:&quot;#app&quot;,\n        &quot;data&quot;:&#123;\n            &quot;message&quot;:&quot;&quot;\n        &#125;,\n        &quot;methods&quot;:&#123;\n            sendJsonBody()&#123;\n                axios(&#123;\n                    &quot;method&quot;:&quot;post&quot;,\n                    &quot;url&quot;:&quot;demo02&quot;,\n                    &quot;data&quot;:&#123;\n                        &quot;username&quot;:&quot;奥巴马&quot;,\n                        &quot;password&quot;:&quot;123456&quot;,\n                        &quot;id&quot;:1,\n                        &quot;nickname&quot;:&quot;圣枪游侠&quot;\n                    &#125;\n                &#125;).then(response &#x3D;&gt; &#123;\n                    console.log(response.data)\n                &#125;)\n            &#125;\n        &#125;\n    &#125;)\n&lt;&#x2F;script&gt;\n\n2. 后端代码2.1 加入Gson包Gson是Google研发的一款非常优秀的==JSON数据解析和生成工具==，它可以帮助我们将数据在JSON字符串和Java对象之间互相转换。\n2.2 User类package com.atguigu.user;\n\n&#x2F;**\n * 包名:com.atguigu.user\n *\n * @author Leevi\n * 日期2021-05-21  10:18\n *&#x2F;\npublic class User &#123;\n    private Integer id;\n    private String username;\n    private String password;\n    private String nickname;\n\n    public User() &#123;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;User&#123;&quot; +\n                &quot;id&#x3D;&quot; + id +\n                &quot;, username&#x3D;&#39;&quot; + username + &#39;\\&#39;&#39; +\n                &quot;, password&#x3D;&#39;&quot; + password + &#39;\\&#39;&#39; +\n                &quot;, nickname&#x3D;&#39;&quot; + nickname + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n\n    public User(Integer id, String username, String password, String nickname) &#123;\n        this.id &#x3D; id;\n        this.username &#x3D; username;\n        this.password &#x3D; password;\n        this.nickname &#x3D; nickname;\n    &#125;\n\n    public Integer getId() &#123;\n        return id;\n    &#125;\n\n    public void setId(Integer id) &#123;\n        this.id &#x3D; id;\n    &#125;\n\n    public String getUsername() &#123;\n        return username;\n    &#125;\n\n    public void setUsername(String username) &#123;\n        this.username &#x3D; username;\n    &#125;\n\n    public String getPassword() &#123;\n        return password;\n    &#125;\n\n    public void setPassword(String password) &#123;\n        this.password &#x3D; password;\n    &#125;\n\n    public String getNickname() &#123;\n        return nickname;\n    &#125;\n\n    public void setNickname(String nickname) &#123;\n        this.nickname &#x3D; nickname;\n    &#125;\n&#125;\n\n2.3 Servlet代码package com.atguigu.servlet;\n\nimport com.atguigu.user.User;\nimport com.atguigu.utils.JsonUtils;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n&#x2F;**\n * @author Leevi\n * 日期2021-05-21  10:06\n *&#x2F;\npublic class ServletDemo02 extends HttpServlet &#123;\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        doGet(request, response);\n    &#125;\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        request.setCharacterEncoding(&quot;UTF-8&quot;);\n        response.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);\n\n        &#x2F;&#x2F; 1.由于请求体数据有可能很大，所以Servlet标准在设计API的时候要求我们通过输入流来读取\n        BufferedReader reader &#x3D; request.getReader();\n\n        &#x2F;&#x2F; 2.创建StringBuilder对象来累加存储从请求体中读取到的每一行\n        StringBuilder builder &#x3D; new StringBuilder();\n\n        &#x2F;&#x2F; 3.声明临时变量\n        String bufferStr &#x3D; null;\n\n        &#x2F;&#x2F; 4.循环读取\n        while((bufferStr &#x3D; reader.readLine()) !&#x3D; null) &#123;\n            builder.append(bufferStr);\n        &#125;\n\n        &#x2F;&#x2F; 5.关闭流\n        reader.close();\n\n        &#x2F;&#x2F; 6.累加的结果就是整个请求体\n        String requestBody &#x3D; builder.toString();\n\n        &#x2F;&#x2F; 7.创建Gson对象用于解析JSON字符串\n        Gson gson &#x3D; new Gson();\n\n        &#x2F;&#x2F; 8.将JSON字符串还原为Java对象\n        User user &#x3D; gson.fromJson(requestBody, User.class);\n        System.out.println(&quot;user &#x3D; &quot; + user);\n\n        System.out.println(&quot;requestBody &#x3D; &quot; + requestBody);\n\n        response.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);\n        response.getWriter().write(&quot;hello world&quot;);\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\nP.S.：看着很麻烦是吧？别担心，将来我们有了SpringMVC之后，一个@RequestBody注解就能够搞定，非常方便！\n⑤ 服务器端返回JSON数据1. 前端代码sendJsonBody()&#123;\n    axios(&#123;\n        &quot;method&quot;:&quot;post&quot;,\n        &quot;url&quot;:&quot;demo03&quot;\n    &#125;).then(response &#x3D;&gt; &#123;\n        console.log(response.data.nickname)\n    &#125;)\n&#125;\n\n2. 后端代码2.1 加入Gson包仍然需要Gson支持，不用多说\n\n2.2 Servlet代码package com.atguigu.servlet;\n\nimport com.atguigu.user.User;\nimport com.atguigu.utils.JsonUtils;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n&#x2F;**\n * @author Leevi\n * 日期2021-05-21  10:06\n *&#x2F;\npublic class ServletDemo03 extends HttpServlet &#123;\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        doGet(request, response);\n    &#125;\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        request.setCharacterEncoding(&quot;UTF-8&quot;);\n        response.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);\n\t\t&#x2F;&#x2F;1. 创建user对象设置数据\n\t\tUser user &#x3D; new User(1,&quot;aobama&quot;,&quot;123456&quot;,&quot;圣枪游侠&quot;);\n        &#x2F;&#x2F;2. 创建Gson对象用于将user对象转成json字符串\n        Gson gson &#x3D; new Gson();\n\n        &#x2F;&#x2F;3. 将user对象转成json字符串\n        String jsonStr &#x3D; gson.toJson(user);\n        response.getWriter().write(jsonStr);\n    &#125;\n&#125;\n\n6⃣️ 跨域问题\n为什么会出现跨域问题？\n\n出于浏览器的同源策略限制：\n\n\n所谓同源（即指在同一个域）就是两个地址具有相同的协议（protocol），主机（host）和端口号（port）\n同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。\n\n\n同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能。\n\n例如：\n\n\nhttp:&#x2F;&#x2F;www.atguigu.com&#x2F;index.html 调用 http:&#x2F;&#x2F;www.atguigu.com&#x2F;teacher&#x2F;listall （非跨域）\nhttp:&#x2F;&#x2F;www.atguigu.com&#x2F;index.html 调用 http:&#x2F;&#x2F;www.guigu.com&#x2F;server.php （主域名不同:atguigu&#x2F;guigu，跨域）\nhttp:&#x2F;&#x2F;abc.atguigu.com&#x2F;index.html 调用 http:&#x2F;&#x2F;def.atguigu.com&#x2F;server.php（子域名不同:abc&#x2F;def，跨域）\nhttp:&#x2F;&#x2F;www.atguigu.com:8080&#x2F;index.html调用 http:&#x2F;&#x2F;www.atguigu.com:8081&#x2F;server.php（端口不同:8080&#x2F;8081，跨域）\nhttp:&#x2F;&#x2F;www.atguigu.com&#x2F;index.html 调用 https:&#x2F;&#x2F;www.atguigu.com&#x2F;server.php（协议不同:http&#x2F;https，跨域）\n请注意：localhost和127.0.0.1虽然都指向本机，但也属于跨域。\n浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。\n\n==解决跨域问题：在有跨域问题的Controller或@RequestMapping上添加注解==\n原理：利用spring的拦截器实现往response里添加 Access-Control-Allow-Origin等响应头信息允许跨域访问\n@CrossOrigin &#x2F;&#x2F;解决跨域问题,springmvc4.2以上版本支持\n\n\n\n:beginner: ​Fetch说到ajax, 就不得不提及fetch, 由于篇幅较长, fetch已从本文中独立出来, 请戳 Fetch进阶指南 .\nfetch是前端发展的一种新技术产物。\n以下内容摘自mozilla：Fetch API 提供了一个 JavaScript接口，用于访问和操纵HTTP管道的部分，例如请求和响应。它还提供了一个全局 fetch()方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。\n这种功能以前是使用 XMLHttpRequest实现的。Fetch提供了一个更好的替代方法，可以很容易地被其他技术使用，例如 Service Workers。Fetch还提供了单个逻辑位置来定义其他HTTP相关概念，例如CORS和HTTP的扩展。\n在使用fetch的时候需要注意：\n\n当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。\n默认情况下，fetch 不会从服务端发送或接收任何 cookies, 如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项）。\n\n一个使用fetch获取数据的例子\nfetch(&#39;http:&#x2F;&#x2F;example.com&#x2F;movies.json&#39;)\n  .then(function(response) &#123;\n    return response.json();\n  &#125;)\n  .then(function(myJson) &#123;\n    console.log(myJson);\n  &#125;);\n\nfetch代表着更先进的技术方向，但是目前兼容性不是很好，在项目中使用的时候得慎重。\n:beginner: ​常见的状态码仅记录在 RFC2616 上的 HTTP 状态码就达 40 种，若再加上 WebDAV（RFC4918、5842）和附加 HTTP 状态码 （RFC6585）等扩展，数量就达 60 余种。接下来，我们就介绍一下这些具有代表性的一些状态码。\n\n200 表示从客户端发来的请求在服务器端被正常处理了。\n204 表示请求处理成功，但没有资源返回。\n301 表示永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。\n302 表示临时性重定向。\n304 表示客户端发送附带条件的请求时（指采用GET方法的请求报文中包含if-matched,if-modified-since,if-none-match,if-range,if-unmodified-since任一个首部）服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304Modified（服务器端资源未改变，可直接使用客户端未过期的缓存）\n400 表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。\n401 表示未授权（Unauthorized)，当前请求需要用户验证\n403 表示对请求资源的访问被服务器拒绝了\n404 表示服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。\n500 表示服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。\n503 表示服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。\n\n","slug":"38-Json Ajax","date":"2021-09-13T15:14:32.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"大黄"},{"id":"5e2a4e0d14846d085ea5bb260a2f8b57","title":"listener，filter，cookie，session","content":"1. Listener监听器1.1 Listener是什么？* Listener 监听器是 JavaWeb 的三大组件之一。\n* JavaWeb 的三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监 听器。\n\n* Listener 它是 JavaEE 的规范，就是接口 \n\n* 监听器的作用是，监听某种事物的变化。然后通过回调函数，反馈给客户（程序）去做一些相应的处理。\n\n* 有八个Listener监听器，但是随着技术的发展，现在就ServletContextListener 监听器还经常被使用\n\n1.2 ServletContextListener* ServletContextListener 它可以监听 ServletContext 对象的创建和销毁。 \n\n* ServletContext 对象在 web 工程启动的时候创建，在 web 工程停止的时候销毁。\n\n&#x3D;&#x3D; 监听到创建和销毁之后都会分别调用 ServletContextListener 监听器的方法反馈 &#x3D;&#x3D;\n\n 两个方法分别是\npublic interface ServletContextListener extends EventListener &#123;\n&#x2F;**\n* 在 ServletContext 对象创建之后马上调用，做初始化\n*&#x2F;\npublic void contextInitialized(ServletContextEvent sce);\n&#x2F;**\n* 在 ServletContext 对象销毁之后调用\n*&#x2F;\npublic void contextDestroyed(ServletContextEvent sce);\n&#125;\n\n使用 ServletContextListener 监听器监听 ServletContext 对象\n使用步骤如下： \n1. 编写一个类去实现 ServletContextListener \n2. 实现其两个回调方法 \n3. 到 web.xml 中去配置监听器\n\n监听器实现类\npublic class MyServletContextListenerImpl implements ServletContextListener &#123;\n\t@Override\n\tpublic void contextInitialized(ServletContextEvent sce) &#123;\n\t\tSystem.out.println(&quot;ServletContext 对象被创建了&quot;);\n\t&#125;\n\t@Override\n\tpublic void contextDestroyed(ServletContextEvent sce) &#123;\n\t\tSystem.out.println(&quot;ServletContext 对象被销毁了&quot;);\n\t&#125;\n&#125;\n\nweb.xml的配置\n&lt;!--配置监听器--&gt;\n&lt;listener&gt;\n&lt;listener-class&gt;com.atguigu.listener.MyServletContextListenerImpl&lt;&#x2F;listener-class&gt;\n&lt;&#x2F;listener&gt;\n\n\n2. Filter过滤器2.1 Filter 是什么？1、Filter 过滤器它是 JavaWeb 的三大组件之一。三大组件分别是：servlet程序，listener监听器，Filter过滤器\n\n2、Filter 过滤器它是 JavaEE 的规范。也就是 接口\n\n3、Filter 过滤器它的作用是：&#x3D;&#x3D; 拦截请求，过滤响应 &#x3D;&#x3D;\n\n​  拦截请求常见的应用场景有： &#x3D;&#x3D; 1、权限检查 2、日记操作 3、事务管理 ……等等 &#x3D;&#x3D;\n\n2.2 Filter 初体验2.2.1 示例\t\t要求：在你的 web 工程下，有一个 admin 目录。这个 admin 目录下的所有资源（html 页面、jpg 图片jsp 文件、等等）都必须是用户登录之后才允许访问。\n\n​\t\t思考：根据之前我们学过内容。我们知道，用户登录之后都会把用户登录的信息保存到 Session 域中。所以要检查用户是否登录，可以判断 Session 中否包含有用户登录的信息即可！！！\n\n2.2.2 工作流程图\n2.2.3 使用步骤编写一个类去实现 Filter 接口      实现过滤方法 doFilter()      到 web.xml 中去配置 Filter 的拦截路径\n@WebFilter(filterName &#x3D; &quot;Filter1&quot;,urlPatterns &#x3D; &quot;&#x2F;a.jsp&quot;)\npublic class Filter1 implements Filter &#123;\n    public void destroy() &#123;\n    &#125;\n\n    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;\n        System.out.println(&quot;filter1前置&quot;);\n        chain.doFilter(req, resp);\n        System.out.println(&quot;filter1后置&quot;);\n\n    &#125;\n\n    public void init(FilterConfig config) throws ServletException &#123;\n\n    &#125;\n&#125;\n\n2.3 Filter 生命周期Filter 的生命周期包含几个方法 \n 1. 构造器方法\t\n 2. init 初始化方法        第 1，2 步，在 web 工程启动的时候执行（Filter 已经创建） \n 3. doFilter 过滤方法      第 3 步，每次拦截到请求，就会执行 \n 4. destroy 销毁          第 4 步，停止 web 工程的时候，就会执行（停止 web 工程，也会销毁 Filter 过滤器）\n\n2.5 FilterConfig 类* FilterConfig 类见名知义，它是 Filter 过滤器的配置文件类。 \n* Tomcat 每次创建 Filter 的时候，也会同时创建一个 FilterConfig 类，这里包含了 Filter 配置文件的配置信息。 \n* FilterConfig 类的作用是获取 filter 过滤器的配置内容 \n  1. 获取 Filter 的名称 filter-name 的内容 \n  2. 获取在 Filter 中配置的 init-param 初始化参数 \n  3. 获取 ServletContext 对象\n\n2.6 FilterChain 过滤器链* Filter 过滤器 \n* Chain 链\n* 链条 FilterChain 就是过滤器链（多个过滤器如何一起工作）\n\n工作流程图\n\n2.7 Filter 的拦截路径 精确匹配 \n\n  &lt;url-pattern&gt; &#x2F;target.jsp  &lt;&#x2F;url-pattern&gt;\n\n  以上配置的路径，表示请求地址必须为：http:&#x2F;&#x2F;ip:port&#x2F;工程路径&#x2F;target.jsp \n\n​ 目录匹配 \n\n  &lt;url-pattern&gt; &#x2F;admin&#x2F;* &lt;&#x2F;url-pattern&gt;\n\n  以上配置的路径，表示请求地址必须为：http:&#x2F;&#x2F;ip:port&#x2F;工程路径&#x2F;admin&#x2F;* \n\n​ 后缀名匹配 \n\n  &lt;url-pattern&gt;*.html &lt;&#x2F;url-pattern&gt;\n\n  以上配置的路径，表示请求地址必须以.html 结尾才会拦截到     \n\n  &lt;url-pattern&gt;*.do &lt;&#x2F;url-pattern&gt;\n\n  以上配置的路径，表示请求地址必须以.do 结尾才会拦截到      \n\n  &lt;url-pattern&gt;*.action &lt;&#x2F;url-pattern&gt;\n\n  以上配置的路径，表示请求地址必须以.action 结尾才会拦截到 \n\n\n​ Filter 过滤器它只关心请求的地址是否匹配，不关心请求的资源是否存在！！！\n\n3. cookie3.1 什么是cookie？ 1、Cookie 翻译过来是饼干的意思。\n\n​ 2、Cookie 是服务器&lt;kbd&gt;通知客户端保存键值对&lt;&#x2F;kbd&gt;的一种技术。 \n\n​ 3、创建一个 cookie，cookie 是 servlet 发送到 Web 浏览器的少量信息，这些信息由浏览器保存，然后发送回服务器\n\n​ 4、客户端有了 Cookie 后，&lt;kbd&gt;每次请求都发送给服务器&lt;&#x2F;kbd&gt;。 \n\n​ 5、每个 Cookie 的大小不能超过 4kb\n\n​ 6、cookie  的值&lt;kbd&gt;可以唯一地标识客户端&lt;&#x2F;kbd&gt;，因此 cookie 常用于会话管理\n\n3.2 如何创建cookie？ 1. 通过new的方式，创建cookie对象\n\n\t Cookie cookie &#x3D; new Cookie(&quot;hh1&quot;,&quot;ww1&quot;);\n\n\t 服务器创建cookie对象后，一定要使用&lt;kbd&gt;response.addCookie()&lt;&#x2F;kbd&gt; ，通知客户端保存cookie（通过响应头的方式）\n\n\t response.addCookie(cookie);\n\n​ 2、也可以创建多个cookie对象，再依次添加多个cookie对象\n\n3.3 服务器如何获取cookiegetCookies()，返回的是所有cookie的map集合\nCookie[] cookies &#x3D; request.getCookies();\nfor (Cookie cookie : cookies) &#123;\n     response.getWriter().write(cookie.getName()+&quot;&#x3D;&quot;+cookie.getValue()+&quot;&lt;br&gt;&quot;);\n&#125;\n\n获取单个cookie\n&#x2F;&#x2F;获取相应的cookie对象，需要先得到所有cookie的集合（因为cookie没有单独获取一个cookie的方法），然后遍历cookie集合，\n&#x2F;&#x2F;在遍历的时候判断是否有与已知key值相等的cookie，如果有，则进行输出\nCookie cookie &#x3D; CookieUtil.findCookie(&quot;hh&quot;, cookies);\n  if (cookie!&#x3D;null)&#123;\n        response.getWriter().write(cookie.getName()+&quot;&#x3D;&quot;+cookie.getValue());\n  &#125;\n\n\npublic static Cookie findCookie(String name,Cookie[] cookies)&#123;\n     if (name&#x3D;&#x3D;null || cookies&#x3D;&#x3D;null || cookies.length&#x3D;&#x3D;0)&#123;\n         return null;\n     &#125;\n\n     for (Cookie cookie : cookies)&#123;\n            if (name.equals(cookie.getName()))&#123;\n                return cookie;\n         &#125;\n     &#125;\n     return null;\n&#125;\n\n3.4 修改cookie值 方案一： \n\n\t  1、先创建一个要修改的同名（指的就是 key）的 Cookie 对象 \n\n\t  2、在构造器，同时赋于新的 Cookie 值。 \n\n\t  3、调用 response.addCookie( Cookie );\n\n​ 方案二： \n\n\t  1、先查找到需要修改的 Cookie 对象 \n\n\t  2、调用 setValue()方法赋于新的 Cookie 值。 \n\n\t  3、调用 response.addCookie()通知客户端保存修改\n\n3.5 cookie的生命控制 Cookie 的生命控制指的是如何管理 Cookie ​ 什么时候被销毁（删除）\n\n​ setMaxAge(int expiry)  expiry(到期，满期)为到期时间，1代表一秒\n\n\t  &#x3D;&#x3D;正数&#x3D;&#x3D;，表示在指定的秒数后过期 \n\n\t  &#x3D;&#x3D;负数&#x3D;&#x3D;，表示浏览器一关，Cookie 就会被删除（默认值是-1） \n\n\t  &#x3D;&#x3D;零&#x3D;&#x3D;，表示马上删除 Cookie\n\n3.6 cookie有效路径 path 设置 1、Cookie 的 path 属性可以有效的过滤哪些 Cookie 可以发送给服务器，哪些不发。 \n\n​ 2、cookie的 path设置方法\t&lt;kbd&gt;cookie.setPath( url );&lt;&#x2F;kbd&gt; 设置完路径一定要调用addcookie() 方法\n\n​ 3、path 属性是&lt;kbd&gt;通过请求的地址&lt;&#x2F;kbd&gt;来进行有效的过滤。例子如下：\n\n\t  CookieA path&#x3D;&#x2F;工程路径 \tCookieB path&#x3D;&#x2F;工程路径&#x2F;abc \n\n\t  请求地址如下:  http:&#x2F;&#x2F;ip:port&#x2F;工程路径&#x2F;a.html \t\t\tCookieA 发送 \tCookieB 不发送 \n\n                   http:&#x2F;&#x2F;ip:port&#x2F;工程路径&#x2F;abc&#x2F;a.html \t CookieA 发送 \tCookieB 发送\n\n4. session4.1 session是什么？ 1、Session 就一个接口（HttpSession）\n\n​ 2、Session 就是会话。它是用来维护一个客户端和服务器之间关联的一种技术\n\n​ 3、每个客户端都有自己的一个 Session 会话\n\n​ 4、Session 会话中，我们经常用来保存 用户登录之后的信息\n\n4.2 创建 获取 ID值 如何创建和获取 Session。它们的 API 是一样的。 \n\n​ request.getSession()  第一次调用是：创建 Session 会话 \t之后调用都是：获取前面创建好的 Session 会话对象\n\n​ isNew(); 判断到底是不是刚创建出来的（新的） true 表示刚创建     false 表示获取之前创建 \n\n​ 每个会话都有一个身份证号。也就是 ID 值。而且这个 ID 唯一   getId() 得到 Session 的会话 id 值。\n\n4.3 Session 生命周期控制  1、public void setMaxInactiveInterval(int interval) \t\n  [ 最大非活动时间间隔 ] 设置 Session 的超时时间（以秒为单位），超过,Session 就会被销毁。 \n  值为正数的时候，设定 Session的超时时长。 负数表示永不超时（极少使用） \n  \n​  2、public int getMaxInactiveInterval()\t获取 Session 的超时时间\n\n​  3、public void invalidate() \t让当前 Session 会话马上超时无效。 \n\n​  4、Session 默认的超时时间长为 30 分钟。 \n   因为 Tomcat 服务器的配置文件 web.xml中默认配置，表示配置了当前 Tomcat 下所有的 Session 超时配置默认时长为 30 分钟。\n\n如果说。你希望你的 web 工程，默认的 Session 的超时时长为其他时长。\n你可以在你自己的 web.xml 配置文件中做以上相同的配置。就可以修改你的 web 工程所有 Seession 的默认超时时长。\n\n&lt;!--表示当前 web 工程。创建出来 的所有 Session 默认是 20 分钟 超时时长--&gt;\n&lt;session-config&gt;\n&lt;session-timeout&gt;20&lt;&#x2F;session-timeout&gt;\n&lt;&#x2F;session-config&gt;\n\n\n\t  5、如果你想只修改\t个别 Session 的超时时长。就可以使用上面的 API，setMaxInactiveInterval(int interval)来进行单独的设置\n\n​\t  6、Session 超时的概念介绍：session设置的超时时长，指的是 两次非活动时间间隔，例子如下\n\n\t     新建一个按钮，用来得到Session会话对象，设置3秒超时，如果在3秒内不断点击得到按钮，则session对象并不会超时；\n\t     但是，间隔3秒 不按按钮的话，session对象就会被销毁\n\n4.4 session 浏览器间关联的技术内幕\n5. 表单重复提交的三种情况一：提交完表单。服务器使用请求转发进行页面跳转。这个时候，用户按下功能键 F5，就会发起最后一次的请求。 造成表单重复提交问题。\n   （解决方法：使用重定向来进行跳转）\n   \n二：用户正常提交服务器，但是由于网络延迟等原因，迟迟未收到服务器的响应，这个时候，用户以为提交失败， 就会着急，然后多点了几次提交操作，也会造成表单重复提交。（解决方法，验证码）\n\n三：用户正常提交服务器。服务器也没有延迟，但是提交完成后，用户回退浏览器。重新提交。也会造成表单重复 提交。（解决方法，验证码）\n\n\n","slug":"37-listener filter cookie session","date":"2021-09-13T15:13:32.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"大黄"},{"id":"5be9ff575c28645ffc905ea202238d73","title":"Servlet（下）","content":"1. HttpServletRequest类1.1 作用每次只要有请求进入 Tomcat 服务器，Tomcat 服务器就会把请求过来的 HTTP 协议信息**解析好封装**到 Request 对象中。 然后传递到 service 方法（doGet 和 doPost）中给我们使用。我们可以通过 HttpServletRequest 对象，获取到所有请求的 信息。\n\n1.2 常用方法\n\n\n方法\n解释\n\n\n\ngetRequestURI()\n获取请求的资源路径\n\n\ngetRequestURL()\n获取请求的统一资源定位符（绝对路径）\n\n\ngetRemoteHost()\n获取客户端的 ip 地址\n\n\ngetHeader()\n获取请求头\n\n\ngetParameter()\n获取请求的参数\n\n\ngetParameterValues()\n获取请求的参数（多个值的时候使用）\n\n\ngetMethod()\n获取请求的方式 GET 或 POST\n\n\nsetAttribute(key, value);\n设置域数据\n\n\ngetAttribute(key);\n获取域数据\n\n\ngetRequestDispatcher()\n获取请求转发对象\n\n\nsetCharacterEncoding()\n设置请求参数字符集编吗（此方法只对服务器编码进行设置）\n\n\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n\n    &#x2F;*1.getRequestURI() 获取请求的资源路径*&#x2F;\n    System.out.println(&quot;URI &#x3D;&gt; &quot;+request.getRequestURI());\n    System.out.println(&quot;----URI &#x3D;&gt; &#x2F;Servlet&#x2F;HSR2----&quot;);\n\n    &#x2F;*2.getRequestURL() 获取请求的统一资源定位符（绝对路径）*&#x2F;\n    System.out.println(&quot;URL &#x3D;&gt; &quot;+request.getRequestURL());\n    System.out.println(&quot;---URL &#x3D;&gt; http:&#x2F;&#x2F;localhost:8080&#x2F;Servlet&#x2F;HSR2---&quot;);\n\n    &#x2F;*3. getRemoteHost() 获取客户端的 ip 地址*&#x2F;\n    System.out.println(&quot;访问ip &#x3D;&gt; &quot;+request.getRemoteHost());\n    &#x2F;*用localhost访问：得到0:0:0:0:0:0:0:1（ipv6地址，相当于ipv4的127.0.0.1）*&#x2F;\n    &#x2F;*用127.0.0.访问，得到127.0.0.1*&#x2F;\n    &#x2F;*用本机ip192.168.1.6范文，得到的是192.168.1.6*&#x2F;\n    System.out.println(&quot;---------------&quot;);\n\n    &#x2F;*4.getHeader() 获取请求头*&#x2F;\n    System.out.println(&quot;请求头 &#x3D;&gt; &quot;+request.getHeader(&quot;User-Agent&quot;));\n    System.out.println(&quot;----请求头 &#x3D;&gt; Mozilla&#x2F;5.0 (...) AppleWebKit&#x2F;537.36 (...) &quot; +\n                        &quot;Chrome&#x2F;83.0.4103.97 Safari&#x2F;537.36---&quot;);\n\n    &#x2F;*5.getMethod() 获取请求的方式 GET 或 POST*&#x2F;\n    System.out.println(&quot;Method &#x3D;&gt; &quot;+request.getMethod());\n    System.out.println(&quot;----Method &#x3D;&gt; GET----&quot;);\n&#125;\n\n1.3 获取请求参数返回多个参数时，一定要做转换，Arrays.toString()或者Arrays.asList()\n&#x2F;*1. getParameter() 获取请求的参数*&#x2F;\n   System.out.println(&quot;单个参数(username) &#x3D;》 &quot; + request.getParameter(&quot;username&quot;));\n   System.out.println(&quot;单个参数(password) &#x3D;》 &quot; + request.getParameter(&quot;password&quot;));\n\n   &#x2F;*2.getParameterValues() 获取请求的参数（多个值的时候使用）*&#x2F;\n   System.out.println(&quot;多个参数 &#x3D;》 &quot; + Arrays.toString(request.getParameterValues(&quot;hobby&quot;)));\n   String[] hobbies &#x3D; request.getParameterValues(&quot;hobby&quot;);\n   System.out.println(Arrays.toString(hobbies));\n\ndoGet请求乱码问题\n&#x2F;&#x2F; 获取请求参数\nString username &#x3D; req.getParameter(&quot;username&quot;);\n&#x2F;&#x2F;1 先以 iso8859-1 进行编码\n&#x2F;&#x2F;2 再以 utf-8 进行解码\nusername &#x3D; new String(username.getBytes(&quot;iso-8859-1&quot;), &quot;UTF-8&quot;);\n\n1.4 解决 Post请求乱码 问题设置请求参数字符集编码为 utf8\n&#x2F;*1.设置请求参数字符集编码为utf8*&#x2F;\n&#x2F;*2.要写在获取请求参数之前，尽量写在一开始 *&#x2F;\nrequest.setCharacterEncoding(&quot;UTF-8&quot;);\n\n1.5 请求转发* 什么是请求的转发? \n\n  请求转发是指，服务器收到请求后，从一次资源跳转到另一个资源的操作叫请求转发。\n\n* 请求转发特点\n\n  1. 浏览器  **地址栏的地址没有变化** （a找b做手术，打麻药晕了，b突然发现不会治转给了c，c治疗好a后，a醒的时候还是以为a治疗的）\n  2. 他们是  **一次请求**\n  3. 他们可以共享Request域中的数据\n  4. 可以转发到WEB-INF目录下\n  5. 不可以访问工程以外的资源\n\n\nServlet1 代码\n    public class Servlet1 extends HttpServlet &#123;\n    @Override\n        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException,\n            IOException &#123;\n            &#x2F;&#x2F; 获取请求的参数（办事的材料）查看\n            String username &#x3D; req.getParameter(&quot;username&quot;);\n            System.out.println(&quot;在 Servlet1（柜台 1）中查看参数（材料）：&quot; + username);\n            &#x2F;&#x2F; 给材料 盖一个章，并传递到 Servlet2（柜台 2）去查看\n            req.setAttribute(&quot;key1&quot;,&quot;柜台 1 的章&quot;);\n            &#x2F;&#x2F; 问路：Servlet2（柜台 2）怎么走\n            &#x2F;&#x2F; 请求转发必须要以斜杠打头，&#x2F; 斜杠表示地址为：http:&#x2F;&#x2F;ip:port&#x2F;工程名&#x2F; , 映射到 IDEA 代码的 web 目录\n            RequestDispatcher requestDispatcher &#x3D; req.getRequestDispatcher(&quot;&#x2F;servlet2&quot;);\n            &#x2F;&#x2F; RequestDispatcher requestDispatcher &#x3D; req.getRequestDispatcher(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;);\n            &#x2F;&#x2F; 走向 Sevlet2（柜台 2）\n            requestDispatcher.forward(req,resp);\n            &#125;\n        &#125;\n        \nServlet2 代码\n    public class Servlet2 extends HttpServlet &#123;\n    @Override\n        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException,\n            IOException &#123;\n            &#x2F;&#x2F; 获取请求的参数（办事的材料）查看\n            String username &#x3D; req.getParameter(&quot;username&quot;);\n            System.out.println(&quot;在 Servlet2（柜台 2）中查看参数（材料）：&quot; + username);\n            &#x2F;&#x2F; 查看 柜台 1 是否有盖章\n            Object key1 &#x3D; req.getAttribute(&quot;key1&quot;);\n            System.out.println(&quot;柜台 1 是否有章：&quot; + key1);\n            &#x2F;&#x2F; 处理自己的业务\n            System.out.println(&quot;Servlet2 处理自己的业务 &quot;);\n            &#125;\n\t\t&#125;\n\n1.6 base 标签的作用&lt;!-- base标签设置页面相对路径工作时参照的地址\n   herf属性就是参数的地址值\n   --&gt;\n&lt;base href&#x3D;&quot;http:&#x2F;&#x2F;localhost:8088&#x2F;hhh&#x2F;a&#x2F;b&#x2F;c.html&quot;&gt;\n\n\n2. 绝对与相对路径2.1 相对路径(不建议使用)2.1.1 目标目标: 在A资源中访问B资源\n\nA资源的uri路径: &#96;&#x2F;app&#x2F;pages&#x2F;a.html&#96;\n\nB资源的uri路径:&#96;&#x2F;app&#x2F;static&#x2F;vue.js&#96;\n\n2.2 相对路径的概念相对路径是不以/开头的路径写法，编写相对路径的原则是以目标资源的uri路径相对当前资源的uri路径\n2.3 相对路径实例那么要实现在A资源中访问B资源的相对路径写法是../static/vue.js,其中../static表示找到当前资源的上一级目录下的static目录\n2.2 绝对路径(建议使用)2.2.1 目标目标: 在A资源中访问B资源\n\nA资源的uri路径: &#96;&#x2F;app&#x2F;pages&#x2F;a.html&#96;\n\nB资源的uri路径:&#96;&#x2F;app&#x2F;static&#x2F;vue.js&#96;\n\n2.2.2 绝对路径的概念绝对路径是以/开头的路径写法，编写绝对路径的原则是通过目标资源的uri访问目标资源，但是特殊情况是请求转发，如果是请求转发访问目标资源的话，那么绝对路径是在uri的基础之上省略/项目部署名\n2.2.3 绝对路径实例那么要实现在A资源中访问B资源的绝对路径写法是/app/static/vue.js\n2.2.4 在请求转发的时候使用绝对路径请求转发在后续内容中会讲解，现在我们只需要搞懂在请求转发的时候绝对路径的写法是/资源名，其实就是在uri的基础上省略/项目部署名\n2.3 动态获取上下文路径2.3.1 上下文路径的概念上下文路径（context path）=/Web应用名称\n2.3.2 为什么要动态获取上下文路径因为我们使用绝对路径的时候需要用到资源的uri路径，而uri路径中是包含上下文路径的，所以如果采用静态方式写绝对路径，那么就会将上下文路径写死在绝对路径中；而我们在部署项目的时候，上下文路径是可变的，所以这样就会因为部署时设置的上下文路径不同从而导致绝对路径出错的问题\n2.3.3 动态获取上下文路径的APIrequest.getContextPath()\n\n使用上述API可以动态获取项目的上下文路径，每一次获取的都是当前环境下实际的上下文路径的值\n2.4  /（斜杠） 不同的意义1. 在 web 中 &#x2F; 斜杠 是一种绝对路径。\n\n2. &#x2F; 斜杠 如果被浏览器解析，得到的地址是：http:&#x2F;&#x2F;ip:port&#x2F; [斜杠]() \n\n3. &#x2F; 斜杠 如果被&lt;kbd&gt;服务器解析&lt;&#x2F;kbd&gt;，得到的地址是：http:&#x2F;&#x2F;ip:port&#x2F;工程路径 \n   * &#x2F;servlet\n   * servletContext.getRealPath(“&#x2F;”); \n   * request.getRequestDispatcher(“&#x2F;”);\n   \n4. &lt;kbd&gt;特殊情况&lt;&#x2F;kbd&gt;： response.sendRediect(“&#x2F;”); 把斜杠发送给浏览器解析。得到 http:&#x2F;&#x2F;ip:port&#x2F;\n\n3. HttpServletResponse类3.1 概念HttpServletResponse 类和 HttpServletRequest 类一样。每次请求进来，Tomcat 服务器都会创建一个 Response 对象传 递给 Servlet 程序去使用。HttpServletRequest 表示请求过来的信息，HttpServletResponse 表示所有响应的信息， 我们如果需要设置返回给客户端的信息，都可以通过 HttpServletResponse 对象来进行设置\n\n3.2 两个输出流的说明* 字节流：getOutputStream();\t常用于下载（传递二进制数据）\n\n* 字符流：getWriter();\t常用语回传字符串（常用）\n\n* 注意：&#x2F;*两个流同时只能使用一个，选择其一，第二个就不能再用*&#x2F;\n\n* 如何回传数据， &#x2F;*字符流的write方法*&#x2F;\n\n\n3.3 响应的中文乱码解决0.无论使用下列两种方法的哪一个，都必须在获取流对象前进行设置，否则无效\n    \n1.先修改服务器端的编码：setCharacterEncoding（）;(&#x2F;&#x2F;此方法只对服务器编码进行设置)\n  再设置浏览器端的编码：setHeader(&quot;Content-Type&quot;,&quot;text&#x2F;html;Charset&#x3D;utf-8&quot;)\n    \n2.直接调用方法：setContentType(&quot;text&#x2F;html;Charset&#x3D;utf-8&quot;);(&#x2F;&#x2F;此方法对服务器和浏览器编码同时设置)\n  注意：括号内的参数必须完整，两个参数之间必须是分号（;）\n        \n  &#x2F;&#x2F; 设置服务器字符集为 UTF-8\n  resp.setCharacterEncoding(&quot;UTF-8&quot;);\n  &#x2F;&#x2F; 通过响应头，设置浏览器也使用 UTF-8 字符集\n  resp.setHeader(&quot;Content-Type&quot;, &quot;text&#x2F;html; charset&#x3D;UTF-8&quot;);   \n\n  &#x2F;&#x2F; 它会同时设置服务器和客户端都使用 UTF-8 字符集，还设置了响应头\n  &#x2F;&#x2F; 此方法一定要在获取流对象之前调用才有效\n  resp.setContentType(&quot;text&#x2F;html&quot;); \n\n3.4 请求重定向* 重定向的特点\n  1. 能访问工程以外的路径（例如百度）\n  2. 无法访问WEB-INF目录下的内容（例如web.xml）\n  3. 浏览器地址栏的地址发生改变\n  4. 进行了两次请求（请求转发是一次）\n  5. 不共享request域中的数据\n  \n* 设置重定向的两种方法\n  1. 设置响应状态码 302 ，表示重定向，（已搬迁）\n     resp.setStatus(302);\n     设置响应头，说明 新的地址在哪里\n     resp.setHeader(&quot;Location&quot;, &quot;http(新地址)&quot;);\n  2. resp.sendRedirect(&quot;新地址&quot;);\n\n4. javaEE三层架构分层的目的是为了解耦。解耦就是为了降低代码的耦合度。方便项目后期的维护和升级。\n\n* web层\t\t\t  web&#x2F;servlet&#x2F;controller \n\n* service层 \t\t  service Service              接口包 \n\n  \t\t\t\t   service.impl Service         接口实现类 \n\n* dao 持久层        dao Dao                      接口包 \n\n                   dao.impl Dao \t\t\t\t接口实现类 实体 bean 对象 \n\n* pojo&#x2F;entity&#x2F;domain&#x2F;bean  JavaBean 类 \n\n* 测试包             test&#x2F;junit \n\n* 工具类             utils\n\n5. url uri介绍 request获取路径5.1 url的介绍5.1.1 url的概念url是uniform Resource Locater的简写，中文翻译为统一资源定位符，它是某个互联网资源的唯一访问地址，客户端可以通过url访问到具体的互联网资源\n5.1.2 url的组成\n5.1.3 url的使用场景客户端访问服务器的资源，或者一台服务器中要访问另外一台服务器的资源都是通过url访问\n5.2 uri的介绍5.2.1 uri的概念uri是Uniform Resource identifier的缩写，中文翻译为统一资源标识符, 它是服务器中某个资源的唯一标识，通过uri可以实现同一项目中的某个资源中访问另一个资源\n5.2.2 uri的组成uri的写法是/项目部署名/资源路径\n\n5.2.3 uri的使用场景在同一个项目的某个资源中访问该项目中的另一个资源\n5.3 request获取路径介绍&lt;%&#x3D; request.getRequestURL()%&gt;  &lt;%-- http:&#x2F;&#x2F;192.168.124.7:8080&#x2F;bookstore&#x2F;index.jsp --%&gt;\n&lt;%&#x3D; request.getRequestURI()%&gt;  &lt;%--&#x2F;bookstore&#x2F;index.jsp--%&gt;\n&lt;%&#x3D; request.getScheme()%&gt;      &lt;%--http--%&gt;\n&lt;%&#x3D; request.getServerName()%&gt;  &lt;%-- 192.168.124.7 --%&gt;\n&lt;%&#x3D; request.getServerPort()%&gt;  &lt;%-- 8080 --%&gt;\n&lt;%&#x3D; request.getContextPath()%&gt; &lt;%-- &#x2F;bookstore --%&gt;\n&lt;%&#x3D; request.getServletPath()%&gt; &lt;%-- &#x2F;index.jsp --%&gt;\n\n","slug":"36-Servlet（下）","date":"2021-09-13T15:12:32.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"大黄"},{"id":"e273b80f255b91b744fcbcd9e45a6bf0","title":"Servlet（上）","content":"1. JavaEE概述1.1 什么是API？ 包括什么？* API：应用程序编程接口（这里所描述的接口不是interface）\n\n* API包括：源码，字节码，帮助文档（使用的时候要注意版本一致）\n\n\n1.2 什么是JavaSE？* Java 标准版本\n* SUN公司为程序员提供的一套基础类库\n* 这套类库包括：基础语法，面向对象，异常，IO，集合，反射，线程......\n* JavaSE版本：目前JavaSE由Oracle维护，最高版本16\n\n1.3 什么是JavaEE？* Java 企业版\n* SUN 公司为程序员提供的另外一套庞大的类库，帮助程序员完成企业级项目开发\n* JavaEE规范是一个比较较大的规范，包含了13个子规范（子规范下还有其他子规范）\n\n2. Servlet简介2.1 什么是servlet？* servlet 是JavaEE规范之一。 规范就是接口\n\n* servlet 是JavaWeb  &#x3D;&#x3D; 三大组件之一 &#x3D;&#x3D;，三大组件分别是：servlet程序，Fiiter过滤器，Listener监听器\n\n* servlet 是运行在服务器上的一个java小程序，他可以接收客户端发送的请求，并响应数据给客户端\n\n* 但servlet的实质就是java代码，通过java的API 动态的向客户端输出内容\n\n2.2 Servlet API (生命周期)Servlet 接口中的方法\n1. 执行 Servlet 构造器方法\n2. init(ServletConfig config)：  \n   * 何时执行：servlet对象创建的时候执行        \n   * ServletConfig ： 代表的是该servlet对象的配置信息\n3. service（ServletRequest request,ServletResponse response）\n\n   * 何时执行：每次请求都会执行\n   * ServletRequest ：代表请求 认为ServletRequest 内部封装的是 http请求的信息\n   * ServletResponse ：代表响应 认为要封装的是响应的信息\n4. destroy()\n\n   * 何时执行：servlet销毁的时候执行\n\n* 第一、二步，是在第一次访问，的时候创建 Servlet 程序会调用\n* 第三步，每次访问都会调用。\n* 第四步，在 web 工程停止的时候调用。\n\n2.3 HttpServlet类的方法* init()\n\n* doGet(HttpServletRequest request,HttpServletResponse response)\n\n* doPost(HttpServletRequest request,HttpServletResponse response)\n\n* destroy()\n\n3. 创建Servlet的两种方式3.1 实现 Servlet 接口【此方法不常用】实现步骤：\n1）创建类实现Servlet接口\n\n2）覆盖尚未实现的方法---service方法，处理请求并响应数据\n\n3）在web.xml进行servlet的配置（可以使用注解）\n\n\n\n3.2 创建类继承HttpServlet实际开发中，我们不会直接去实现Servlet接口，因为需要覆盖的方法太多， 我们一般创建类继承HttpServlet\n实现步骤：\n\n1）创建类继承HttpServlet类\n\n2）根据新需要覆盖doGet和doPost\n\n3）在web.xml中进行servlet的配置\n\n\n4. 如何访问Servlet，路径配置4.1 url 地址到 Servlet的访问\n4.2 Servlet的三种映射路径的配置4.2.1 映射路径的作用Servlet的映射路径是提供一个让别人能够访问该Servlet的路径，例如Servlet的映射路径是&quot;&#x2F;hello&quot;,那么在浏览器上访问该Servlet的路径是&#96;http:&#x2F;&#x2F;localhost:8080&#x2F;项目部署名&#x2F;hello&#96;\n\n\n\n注意:一个Servlet可以配置多个映射路径，但是多个Servlet不能配置相同的映射路径\n4.2.2 映射路径的分类4.2.2.1 完全路径匹配访问当前Servlet的路径需要和配置的映射路径完全一致，例如Servlet的配置是&#96;&#x2F;demo01&#96;，那么访问该Servlet的时候的路径也必须是&#96;http:&#x2F;&#x2F;localhost:8080&#x2F;项目部署名&#x2F;demo01&#96;才可以访问到\n\n4.2.2.2 目录匹配以 / 开始需要以 * 结束，注: Servlet里面用的不多, 但是过滤器里面通常就使用目录匹配\n例如:  配置&#x2F;* 访问的路径可写成&#x2F;任意字符串,比方: &#x2F;aa, &#x2F;aaa; 配置 &#x2F;aa&#x2F;*  访问的路径可写成&#x2F;aa&#x2F;任意字符串,比方: &#x2F;aa&#x2F;b , &#x2F;aa&#x2F;cc\n\n4.2.2.3 扩展名匹配以*开头，以.扩展名结束，能够匹配所有以.相同扩展名结尾的请求路径\n例如:  *.action;  访问路径可以是 任意字符串.action,比方: aa.action, bb.action, c.action;\n\n5. GET POST的分发处理(三种)5.1 实现servlet接口处理【此方法不常用】\n\n5.2 继承HttpServlet处理\n6. Servlet 配置 继承体系6.1 一个Web.xml能写多个servlet程序配置&lt;servlet&gt;\n    &lt;servlet-name&gt;HellowServlet&lt;&#x2F;servlet-name&gt;\n    &lt;servlet-class&gt;com.servlet.HellowServlet&lt;&#x2F;servlet-class&gt;\n&lt;&#x2F;servlet&gt;\n\n&lt;servlet&gt;\n    &lt;servlet-name&gt;HellowServlet_02&lt;&#x2F;servlet-name&gt;\n    &lt;servlet-class&gt;com.servlet.HellowServlet_02&lt;&#x2F;servlet-class&gt;\n&lt;&#x2F;servlet&gt;\n\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;HellowServlet&lt;&#x2F;servlet-name&gt;\n    &lt;url-pattern&gt;&#x2F;HS1&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;servlet-mapping&gt;\n\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;HellowServlet_02&lt;&#x2F;servlet-name&gt;\n    &lt;url-pattern&gt;&#x2F;HS2&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;servlet-mapping&gt;\n\n6.2 Servlet 继承体系（源码解读）只需要根据自己的业务重写 doGet 或 doPost 方法即可，其他的事情（例如抛错误等）已经被实现，不需要我们管\n\n7. ServletConfig类7.1 ServletConfig概述* ServletConfig 类从类名上来看，就是 Servlet 程序的配置信息类\n* Servlet 程序和 ServletConfig 对象都是由 Tomcat 负责创建，我们负责使用\n* Servlet 程序默认是第一次访问的时候创建，ServletConfig 是每个 Servlet 程序创建时，就创建一个对应的 ServletConfig 对 象。\n\n7.2 ServletConfig 三大作用* 可以获取servlet程序的别名 servlet-name的值\n\n* 可以获取初始化参数 init-param\n\n* 获取 servletContext对象\n\nweb.xml 中的配置：\n&lt;servlet&gt;\n    \n&lt;!--servlet-name 标签 Servlet 程序起一个别名（一般是类名） --&gt;\n&lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;\n&lt;!--servlet-class 是 Servlet 程序的全类名--&gt;\n&lt;servlet-class&gt;com.atguigu.servlet.HelloServlet&lt;&#x2F;servlet-class&gt;\n&lt;!--init-param 是初始化参数--&gt;\n    \n&lt;init-param&gt;\n&lt;!--是参数名--&gt;\n&lt;param-name&gt;username&lt;&#x2F;param-name&gt;\n&lt;!--是参数值--&gt;\n&lt;param-value&gt;root&lt;&#x2F;param-value&gt;\n&lt;&#x2F;init-param&gt;\n&lt;!--init-param 是初始化参数--&gt;\n&lt;init-param&gt;\n&lt;!--是参数名--&gt;\n&lt;param-name&gt;url&lt;&#x2F;param-name&gt;\n&lt;!--是参数值--&gt;\n&lt;param-value&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test&lt;&#x2F;param-value&gt;\n&lt;&#x2F;init-param&gt;\n    \n&lt;&#x2F;servlet&gt;\n\n&lt;!--servlet-mapping 标签给 servlet 程序配置访问地址--&gt;\n&lt;servlet-mapping&gt;\n&lt;!--servlet-name 标签的作用是告诉服务器，我当前配置的地址给哪个 Servlet 程序使用--&gt;\n&lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;\n&lt;!--\nurl-pattern 标签配置访问地址 &lt;br&#x2F;&gt;\n&#x2F; 斜杠在服务器解析的时候，表示地址为：http:&#x2F;&#x2F;ip:port&#x2F;工程路径 &lt;br&#x2F;&gt;\n&#x2F;hello 表示地址为：http:&#x2F;&#x2F;ip:port&#x2F;工程路径&#x2F;hello &lt;br&#x2F;&gt;\n--&gt;\n&lt;url-pattern&gt;&#x2F;hello&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;servlet-mapping&gt;\n\nservlet中的代码\n&#x2F;**\n * @content 1.使用idea工具创建Servlet.java\n *          2.测试ServletConfig类的三大作用\n **&#x2F; \n\n@Override\n    public void init(ServletConfig config) throws ServletException &#123;\n        &#x2F;*重写init方法必须加上调用父类的init()方法*&#x2F;\n        super.init(config);\n\n        &#x2F;*1.获取别名*&#x2F;\n        String servletName &#x3D; config.getServletName();\n        System.out.println(&quot;1.servletName是：&quot;+servletName);\n\n        &#x2F;*2.获取ServletContext对象*&#x2F;\n        ServletContext servletContext &#x3D; config.getServletContext();\n        System.out.println(&quot;2.ServletContext对象是：&quot;+servletContext);\n\n        &#x2F;*3.获取init-param*&#x2F;\n        String username &#x3D; config.getInitParameter(&quot;username&quot;);\n        System.out.println(&quot;3.username是:&quot;+username);\n        String url &#x3D; config.getInitParameter(&quot;url&quot;);\n        System.out.println(&quot;4.url是:&quot;+url);\n    &#125;\n\n\n8. ServletContext类8.1 什么是ServletContext？* ServletContext 是一个接口，他表示Servlet 上下文对象\n\n* 一个Web工程，只有一个ServletContext对象\n\n* ServletContext对象 是一个域对象\n\n* ServletContext 是在 web工程部署启动的时候创建的，在 web 工程停止时，销毁\n\n8.2 什么是域对象？\n    域对象，是可以像map一样存取数据的对象\n    域，指的是对象存取数据的操作范围，范围是：整个web工程\n\n#### 8.3 域对象存取数据的方法\n\n\n\n\n\n存数据\n取数据\n删除数据\n\n\n\nMap\nput()\nget()\nremove()\n\n\n域对象\nsetAttribute()\ngetAttribute()\nremoveAttribute()\n\n\n8.4 ServletContext 四个作用1. 获取web.xml中配置的上下文参数 context-param\n\n   * 方法：getInitparameter()\n\n2. 获取当前的工程路径，格式：&#x2F;工程路径\n\n   * 方法：getContextpath()\n\n3. &lt;span style&#x3D;&quot;color:red;&quot;&gt;获取工程部署后在服务器硬盘上的绝对路径 ​【**重要**】​\n\n   * 方法：getrealpath()\n\n4. 像 Map一样存储数据\n\n   * 方法：setAttribute(“key”，“value”)    getAttribute()\n\n   * 注意：1.像 Map一样获取数据前（前提是已经存储了数据，不然获得的是空值）\n\n     ​\t\t   2.在储存数据之前获取，得到的也是空值\n\n     ​\t\t   3.ServletContext是域对象，一处存储数据，整个web工程内都能获取到（前提是，已经储存值）\n\n&lt;context-param&gt;\n    &lt;param-name&gt;username&lt;&#x2F;param-name&gt;\n    &lt;param-value&gt;hh&lt;&#x2F;param-value&gt;\n&lt;&#x2F;context-param&gt;\n&lt;context-param&gt;\n    &lt;param-name&gt;password&lt;&#x2F;param-name&gt;\n    &lt;param-value&gt;521&lt;&#x2F;param-value&gt;\n&lt;&#x2F;context-param&gt;\n\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) \n    \t\t\t\t\t\t\t\tthrows ServletException, IOException &#123;\n\n    \t&#x2F;*0.获取ServletContext对象*&#x2F;\n        ServletContext servletContext &#x3D; getServletConfig().getServletContext();\n\n        &#x2F;*1.获取 web.xml 中配置的上下文参数 context-param*&#x2F;\n        String username &#x3D; servletContext.getInitParameter(&quot;username&quot;);\n        Object password &#x3D; servletContext.getInitParameter(&quot;password&quot;);\n        System.out.println(username+&quot;:&quot;+password);\n        System.out.println(&quot;-----------------------&quot;);\n\n        &#x2F;*2.获取项目工程路径*&#x2F;\n        String contextPath &#x3D; servletContext.getContextPath();\n        System.out.println(contextPath);\n        System.out.println(&quot;-----------------------&quot;);\n\n        &#x2F;*3.获取web工程绝对路径*&#x2F;\n        String realPath &#x3D; servletContext.getRealPath(&quot;&#x2F;&quot;);\n        System.out.println(realPath);\n        System.out.println(&quot;-----------------------&quot;);\n\n        &#x2F;*4.像 Map一样存储数据*&#x2F;\n        servletContext.setAttribute(&quot;key1&quot;,&quot;value(h123)&quot;);\n\n        &#x2F;*4.像 Map一样获取数据（前提是已经存储了数据，不然获得的是空值）*&#x2F;\n        Object value &#x3D; servletContext.getAttribute(&quot;key1&quot;);\n        System.out.println(value);\n        System.out.println(&quot;-----------------------&quot;);\n    &#125;","slug":"35-Servlet（上）","date":"2021-09-13T15:11:32.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"大黄"},{"id":"1158d9e6c37bc3dd9f057cb155218f0c","title":"XML","content":"1. XML概述1.1 概念Extensible Markup Language   可扩展标记语言\n\n可扩展：标签是自定义的  &lt;user&gt;   &lt;学习&gt;\n\n1.2 功能作为配置文件，存储数据\n\n存储数据后也可以在网络中传输数据\n\n1.3 XML与HTML的区别XML标签都是自定义的，HTML标签是预定义的\n\nXML语法严格，HTML语法松散\n\nXML是存储数据，HTML是展示数据的\n\n2. 语法2.1 基本语法xml文档的后缀名是  .xml\n\nxml第一行必须是文档声明\n\nxml文档中有且仅有一个根标签\n\n属性值必须使用引号引起来\n\n标签必须正确关闭\n\nxml标签名称区分大小写\n\n2.2 快速入门&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;users&gt;\n\n    &lt;user id&#x3D;&quot;1&quot;&gt;\n        &lt;name&gt;黄任翔&lt;&#x2F;name&gt;\n        &lt;sex&gt;男&lt;&#x2F;sex&gt;\n        &lt;age&gt;21&lt;&#x2F;age&gt;\n    &lt;&#x2F;user&gt;\n\n    &lt;user id&#x3D;&quot;2&quot;&gt;\n        &lt;name&gt;想想&lt;&#x2F;name&gt;\n        &lt;sex&gt;女&lt;&#x2F;sex&gt;\n        &lt;age&gt;21&lt;&#x2F;age&gt;\n    &lt;&#x2F;user&gt;\n&lt;&#x2F;users&gt;\n\n2.3 组成部分1.文档声明\n\t* 格式：&lt;?xml 属性?&gt;\n\t* 属性之 version：版本号\n\t* 属性之 encoding：编码方式（当前文档使用的字符集）\n\t* 属性之 standalone：是否独立（值是yes或no）\n2.指令（了解就可，早期结合css使用）\n3.标签\n\t* 标签名称自定义，命名规则如下：\n\t\t名称可以包含字母、数字以及其他的字符\n\t\t名称不能以数字或者标点符号开始\n\t\t名称不能以字母 xml（或者 XML、Xml 等等）开始\n\t\t名称不能包含空格\n4.属性\n\t* 必须加引号\n\t* 属性难以阅读和维护。请尽量使用元素来描述数据\n5.文本\n\t* CDATA区：在该区域被原样展示\n\t* 格式：&lt;![CDATA[if(a&lt;b &amp;&amp; a&gt;c)&#123;&#125;]]&gt;\n\n2.4 约束1.约束\n\t*规定xml文档的书写规则\n\n2.作为框架的使用者（程序员）\n\t*能够在xml中引入约束文档\n\t*能够简单地读懂约束文档\n\n3.约束分类\n\t*DTD（简单）\n\t\t引入dtd文档到xml文档中\n\t\t\t*内部dtd：直接将约束规则定义在xml文档中(示例在下个框)\n\t\t\t*外部dtd：将约束的规则定义在外部的dtd文件中\n\t\t\t\t-本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件路径名&quot;&gt;\n\t\t\t\t-网络：&lt;!DOCTYPE 根标签名 PUBLIC “dtd文件名字” &quot;dtd文件的网络位置（url）&quot;&gt;\n\t*DTD约束缺点：不能限定内容，所以有了Schema\n\n\t*Schema（复杂）\n\t\t引入方式（内部引入）\n\t\t1.填写xml文档根元素\n\t\t2.引入xsi前缀. xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n\t\t3.引入xsd文件命名空间.xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.student.cn&#x2F;xml student.xsd&quot;\n\t\t4.为每一个xsd约束声明一个前缀，作为标识.xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.student.cn&#x2F;xml&quot;\n\t*代码\n\t\t&lt;students xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n          xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.student.cn&#x2F;xml student.xsd&quot;\n          xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.student.cn&#x2F;xml&quot;&gt;\n\n\n* DTD(内部直接添加)\n&lt;!DOCTYPE NEWSPAPER [\n\n&lt;!ELEMENT NEWSPAPER (ARTICLE+)&gt;\n&lt;!ELEMENT ARTICLE (HEADLINE,BYLINE,LEAD,BODY,NOTES)&gt;\n&lt;!ELEMENT HEADLINE (#PCDATA)&gt;\n&lt;!ELEMENT BYLINE (#PCDATA)&gt;\n&lt;!ELEMENT LEAD (#PCDATA)&gt;\n&lt;!ELEMENT BODY (#PCDATA)&gt;\n&lt;!ELEMENT NOTES (#PCDATA)&gt; \n\n&lt;!ATTLIST ARTICLE AUTHOR CDATA #REQUIRED&gt;\n&lt;!ATTLIST ARTICLE EDITOR CDATA #IMPLIED&gt;\n&lt;!ATTLIST ARTICLE DATE CDATA #IMPLIED&gt;\n&lt;!ATTLIST ARTICLE EDITION CDATA #IMPLIED&gt;\n\n]&gt;\n\n2.5 命名空间&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;\n         version&#x3D;&quot;4.0&quot;&gt;\n\n\n\n\n属性名\n作用\n\n\n\nxmlns\n指出当前XML文档约束规则的名称空间在哪里我们就是通过这个属性来引用一个具体的名称空间\n\n\nxmlns:xsi\n指出xmlns这个属性是在哪个约束文档中被定义的\n\n\nxsi:schemaLocation\n语法格式：在xsi名称空间下引用schemaLocation属性配置含义：指定当前XML文档中所用到的约束文档本身的文件的地址\n\n\nxmlns和xsi:schemaLocation对应关系如下图：\n\n3. 解析3.1 概念操作xml文档，将文档中的数据，读取到内存中\n\n3.2 操作xml文档解析（读取）：将文档中的数据读取到内存中\n\n写入：将内存中的数据保存到xml文档中，持久化储存\n\n3.3 解析xml的方式（三中解析方式，解析方式是解析方式，解析器是解析器）DOM：将标记语言文档一次性加载进内存，在内存中形成dom树\n\n​\t优点：操作简单，可以对文档进行CRUD的所有操作\n\n​\t缺点：占内存\n\nSAX：逐行读取，基于事件驱动的\n\n​\t优点：不占内存，永远只有一行\n\n​\t缺点：只能读取，不能增删改\n\npull：android操作系统的内置解析器，支持sax\n\n3.4 xml常见的解析器JAXP：sun公司提供，支持dom和sax两种思想（基本不用）\n\nJDOM：上面的兄弟\n\nDOM4J：一款非常优秀的解析器\n\nJsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。\n\n 3.5 jsoup使用步骤1.导入jar包\n\n2.获取Document对象\n\n3.获取对应的标签element对象\n\n4.获取数据（如果路径中有空格，会被程序编译为%20，所以用   toURI()方法转译）\n\npublic class JsoupTest_01 &#123;\n\n    public static void main(String[] args) throws IOException, URISyntaxException &#123;\n\n        &#x2F;**\n         * getClassLoader():获取父类加载器\n         * getReSource（）：获取指定文件名的文件\n         * getPath（）：获取文件的路径\n         * parse(new File(),charsetName):jsoup获取document对象\n         * 路径如果有空格，程序会把空格编译为%20，这样路径就不对了，用toURI()方法去除空格\n         *&#x2F;\n        URI uri &#x3D; JsoupTest_01.class.getClassLoader().getResource(&quot;student.xml&quot;).toURI();\n\n        &#x2F;&#x2F;file:&#x2F;D:&#x2F;my%20idea&#x2F;work&#x2F;HrxDemo&#x2F;out&#x2F;production&#x2F;XML&#x2F;student.xml\n        System.out.println(uri);\n\n        String path &#x3D; uri.getPath();\n\n        &#x2F;&#x2F;&#x2F;D:&#x2F;my idea&#x2F;work&#x2F;HrxDemo&#x2F;out&#x2F;production&#x2F;XML&#x2F;student.xml\n        System.out.println(path);\n\n        Document parse &#x3D; Jsoup.parse(new File(path), &quot;utf-8&quot;);\n\n        Elements elements &#x3D; parse.getElementsByTag(&quot;name&quot;);\n\n        System.out.println(elements.size());\n\n        Element ele &#x3D; elements.get(0);\n\n        String text &#x3D; ele.text();\n\n        System.out.println(text);\n    &#125;\n&#125;\n\n3.6 对象的使用jsoup：工具类，可以解析html或xml文档，返回document对象\n&#x2F;&#x2F; 1.parse(File in,charsetName):解析xml或者html文件\n\tDocument document &#x3D; Jsoup.parse(new File(path), &quot;utf-8&quot;);\n\tSystem.out.println(document);\n\n&#x2F;&#x2F; 2.parse(String html);[基本不用，了解]\n\n&#x2F;&#x2F; 3.parse(URL url,int timeoutMillis):通过网络路径获取指定的html或者xml的文档对象.\n\tURL url &#x3D; new URL(&quot;https:&#x2F;&#x2F;www.runoob.com&#x2F;xml&#x2F;xml-parser.html&quot;);\n\tDocument document &#x3D; Jsoup.parse(url,10000);\n\tSystem.out.println(document);\n\nDocument：文档对象，代表内存中的dom树（可以用来获取Element元素对象或Element元素集合对象）\n&#x2F;&#x2F; 1.getElementById(String id):根据id值获取唯一的Element对象\nElement hh &#x3D; document.getElementById(&quot;hh&quot;);\nSystem.out.println(hh);\nSystem.out.println(&quot;--------------&quot;);\n\n&#x2F;&#x2F; 2.getElementsByTag(string TagName):根据标签名称，获取Element对象集合\nElements name &#x3D; document.getElementsByTag(&quot;name&quot;);\nSystem.out.println(name);\nSystem.out.println(&quot;--------------&quot;);\n\n&#x2F;&#x2F; 3.getElementsByAttribute(String key):根据属性名称获取元素对象集合\nElements name1 &#x3D; document.getElementsByAttribute(&quot;number&quot;);\nSystem.out.println(name1);\nSystem.out.println(&quot;--------------&quot;);\n\n&#x2F;&#x2F; 4.getElementsByAttribyteValue(String key,String value)：根据对应的属性名和属性值获取元素对象集合\nElements Value &#x3D; document.getElementsByAttributeValue(&quot;number&quot;, &quot;ID3&quot;);\nSystem.out.println(Value);\nSystem.out.println(&quot;--------------&quot;);\n\nElements：元素对象集合，相当于ArrayList\nElement：元素对象\n1.获取元素内容\n    * 就是上面document获取的Element元素\n    * 或者通过document获取的Element元素集合对象的 get(索引)方法，得到具体的元素值\n    \n2.获取属性对象\n\t* String attr(String key):根据属性名获取属性值\n    \n3.获取文本内容\n    * String text() 只获取文本内容\n\t* String html() 获取标签所有内容，包括标签和文本内容\n\nnode：节点对象\n是Document和Element的父类，里面大多方法关于标签的查找，添加删除等（xml中不常用增删改查）\n3.7 快捷查询方式1. selector:选择器\n   * 使用的方法：Elements    select(String cssQuery)\n   cssQuery按照以前css选择器名字来做\n   * 语法：参考Selector类中定义的语法\n       \n2. XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言\n   * 使用Jsoup的Xpath需要额外导入jar包。\n   * 查询w3cshool参考手册，使用xpath的语法完成查询\n\n4. dom4j解析器1. 导入jar包 dom4j.jar\n2. 创建解析器对象(SAXReader)\n3. 解析xml 获得Document对象\n4. 获取根节点RootElement\n5. 获取根节点下的子节点\n\n获取解析器 ----&gt; 获取document对象 ----&gt; 依步获取所需子元素\n    \n常用（common）API（那个对象里的方法，由哪个元素对象调用）\n *   -- SAXReader对象\n *      read():加载执行的xml文档\n *   -- Document对象\n *      getRootElement():获取根元素\n *   -- Element对象\n *      elements():获取指定名称的全部子元素，可以不指定名称\n *      elements （可以用 get(index)跟索引得到具体元素，或者用 字段.equals(元素.getName)）\n *      element():获取指定元素第一个子元素，可以不指定名称\n *      getName():获取当前元素的元素名\n *      attributeValue():获取指定属性名的属性值\n *      elementText():获得指定子元素名称的文本\n *      getText():获得当前元素的文本内容\n\n&#x2F;**\n * @author Charon\n * @date 2020&#x2F;6&#x2F;18\n * 1.学习dom4j，了解使用步骤\n * 2.学会元素的选取\n * 3.常用（common）API（那个对象里的方法，由哪个元素对象调用）\n *   -- SAXReader对象\n *      read():加载执行的xml文档\n *   -- Document对象\n *      getRootElement():获取根元素\n *   -- Element对象\n *      elements():获取指定名称的全部子元素，可以不指定名称\n *      elements （可以用 get(index)跟索引得到具体元素，或者用 字段.equals(元素.getName)）\n *      element():获取指定元素第一个子元素，可以不指定名称\n *      getName():获取当前元素的元素名\n *      attributeValue():获取指定属性名的属性值\n *      elementText():获得指定子元素名称的文本\n *      getText():获得当前元素的文本内容\n **&#x2F;\npublic class test_01_dom4j &#123;\n\n    @Test\n    public void testReadXml() throws DocumentException &#123;\n\n        &#x2F;&#x2F;1.获取解析器\n        SAXReader saxReader&#x3D;new SAXReader();\n\n        &#x2F;&#x2F;2.获取document对象\n        String path &#x3D; test_01_dom4j.class.getClassLoader().getResource(&quot;Util.xml&quot;).getPath();\n        Document document &#x3D; saxReader.read(path);\n\n        &#x2F;&#x2F;3.获取根元素\n        Element rootElement &#x3D; document.getRootElement();\n        System.out.println(rootElement);&#x2F;&#x2F;org.dom4j.tree.DefaultElement@2d363fb3 [Element: &lt;students attributes: []&#x2F;&gt;]\n        System.out.println(rootElement.getName());&#x2F;&#x2F;students\n        System.out.println(&quot;--------------------------------------------------------&quot;);\n\n        &#x2F;&#x2F;3.1.获取根元素的子元素\n        List&lt;Element&gt; elements &#x3D; rootElement.elements();\n        for (Element ele : elements)&#123;\n            System.out.println(ele);\n            String name &#x3D; ele.getName();\n            System.out.println(name);\n        &#125;\n        System.out.println(&quot;--------------------------------------------------------&quot;);\n\n        &#x2F;&#x2F;3.2.获取根元素的第一个子元素\n        Element element &#x3D; rootElement.element(&quot;student&quot;);\n        System.out.println(element);\n        System.out.println(element.getName());\n        System.out.println(&quot;--------------------------------------------------------&quot;);\n\n        &#x2F;&#x2F;3.3.获得指定属性的属性值(属性是元素标签括号内的，别记混了)\n        String id &#x3D; element.attributeValue(&quot;id&quot;);\n        System.out.println(id);\n        String number &#x3D; elements.get(1).attributeValue(&quot;number&quot;);\n        System.out.println(number);\n        System.out.println(&quot;--------------------------------------------------------&quot;);\n\n        &#x2F;&#x2F;3.4.获取当前元素的文本值\n        String name &#x3D; element.element(&quot;name&quot;).getText();\n        System.out.println(name);\n        System.out.println(&quot;--------------------------------------------------------&quot;);\n\n        &#x2F;&#x2F;3.5.获取指定名称子元素的文本值\n        String ageText &#x3D; element.elementText(&quot;age&quot;);\n        System.out.println(ageText);\n    &#125;\n&#125;\n\n5. 重要dom4j 可以与反射连用获取xml文件中的配置信息，然后调用其他实现类的功能\n* 使用反射获取类的字节码文件，将其装载到jvm虚拟机中\n  A a &#x3D; (A)Class.forName(name).newInstance()；\n  等同于\n  A a &#x3D; new A();\n\n","slug":"34-Xml","date":"2021-09-13T15:10:32.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"大黄"},{"id":"5f258f833478a2a0e21ce42d19305683","title":"Vue","content":":beginner: ​Vue 基础要点① 什么是框架任何编程语言在最初的时候都是没有框架的，后来随着在实际开发过程中不断总结『经验』，积累『最佳实践』，慢慢的人们发现很多『特定场景』下的『特定问题』总是可以『套用固定解决方案』。\n于是有人把成熟的『固定解决方案』收集起来，整合在一起，就成了『框架』。\n对于Java程序来说，我们使用框架就是导入那些封装了『固定解决方案』的jar包，然后通过『配置文件』告诉框架做什么，就能够大大简化编码，提高开发效率。\n而对于JavaScript程序来说，我们使用框架就是导入那些封装了『固定解决方案』的『js文件』，然后在框架的基础上编码。\n==idea中前端绑定的那些代码爆红，在idea插件库中下载一个vue.js就可以了==\n② VueJs 介绍1. Vue (读音 /vjuː/，类似于view) 是一套用于构建用户界面的渐进式框架。\n2. Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！\n3. 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\n4. 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果；\n5. 官网地址:https://cn.vuejs.org/\n③ VueJs 环境1. Vue框架的js文件获取\n\n   官网提供的下载地址：https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js\n\n2. 创建空vue.js文件,将官网提供的vue.js文件的内容复制粘贴到本地vue.js文件中\n\n   &lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n\n④ 小结==VueJS是前端渐进式框架，让Html和JavaScript无缝的整合，实现了视图和模型的双向数据绑定（MVVM）。==\n:beginner: ​MVVM 模式① mvvm 简介==MVVM是Model-View-ViewModel的简写==。它本质上就是MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开\nMVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model）\nMVVM是前端视图层的分层开发思想，主要是把每个页面，分成了M , V 和 VM 其中，VM是 MVVM 思想核心；\n因为VM 是 M 和 V 之间的调度者\n② mvvm 的调度关系\n    \n    \n\n\n③ 小结MVVM 模式是视图和模型的双向数据绑定，通过ViewModel实现，当View发生变化，Model变化；当Model变化，View也相应的变化\n:beginner: ​Vue 入门案例① 导入vue.js文件② 入门程序&lt;!-- 将来 new 的Vue实例，会控制这个 元素中的所有内容 --&gt;\n&lt;!-- Vue 实例所控制的这个元素区域，就是我们的 V  --&gt;\n&lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n\n&lt;script&gt;\n    &#x2F;&#x2F; 2. 创建一个Vue的实例\n    &#x2F;&#x2F; 当我们导入包之后，在浏览器的内存中，就多了一个 Vue 构造函数\n    &#x2F;&#x2F;  注意：我们 new 出来的这个 vm 对象，就是我们 MVVM中的 VM调度者\n    var vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,  &#x2F;&#x2F; 表示，当前我们 new 的这个 Vue 实例，要控制页面上的哪个区域\n        &#x2F;&#x2F; 这里的 data 就是 MVVM中的 M，专门用来保存 每个页面的数据的\n        data: &#123; &#x2F;&#x2F; data 属性中，存放的是 el 中要用到的数据\n            msg: &#39;欢迎学习Vue&#39; &#x2F;&#x2F; 通过 Vue 提供的指令，很方便的就能把数据渲染到页面上，程序员不再手动操作DOM元素了【前端的Vue之类的框架，不提倡我们去手动操作DOM元素了】\n        &#125;\n    &#125;)\n&lt;&#x2F;script&gt;\n\n③ 声明式渲染声明式是相对于『编程式』而言的。\n\n声明式：告诉框架做什么，具体操作由框架完成\n编程式：自己编写代码完成具体操作\n\nVue对象和页面上的HTML标签确实是始终保持着关联的关系，同时Vue在背后确实是做了大量的工作。\n:beginner: 模板语法① 插值数据绑定最常见的形式就是使用“Mustache”语法 ( 双大括号 ) 的文本插值：\n&lt;span&gt;Message: &#123;&#123; msg &#125;&#125; &lt;&#x2F;span&gt;\n\n② 插值 v-textv-text 输出文本内容，不会解析html元素：\n&lt;div v-text&#x3D;&quot;message&quot;&gt;&lt;&#x2F;div&gt;\n\n&lt;script&gt;\n    new Vue(&#123;\n        el:&quot;#app&quot;,\n        data:&#123;\n            message:&quot;&lt;h1&gt;hello world&lt;&#x2F;h1&gt;&quot;&#x2F;&#x2F;model\n        &#125;\n    &#125;);\n&lt;&#x2F;script&gt;\n\n③ 插值 v-html双大括号，v-text将数据解释为普通文本。为了输出真正的 HTML，你需要使用v-html 指令：\n&lt;div v-html&#x3D;&quot;message&quot;&gt;&lt;&#x2F;div&gt;\n\n&lt;script&gt;\n    new Vue(&#123;\n        el:&quot;#app&quot;,\n        data:&#123;\n            message:&quot;&lt;h1&gt;hello world&lt;&#x2F;h1&gt;&quot;&#x2F;&#x2F;model\n        &#125;\n    &#125;);\n&lt;&#x2F;script&gt;\n\n在你的站点上动态渲染任意的 HTML 是非常危险的，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要将用户提供的内容作为插值。\n④ Attribute 中插值Mustache 语法不能在 HTML attribute 中使用，然而，可以使用 v-bind 指令：\n&lt;div v-bind:id&#x3D;&quot;dynamicId&quot;&gt;&lt;&#x2F;div&gt;\n\n如果绑定的值是 null 或 undefined，那么该 attribute 将不会被包含在渲染的元素上。\n&lt;!-- 完整语法 --&gt;\n&lt;a v-bind:href&#x3D;&quot;url&quot;&gt; ... &lt;&#x2F;a&gt;\n\n&lt;!-- 缩写 --&gt;\n&lt;a :href&#x3D;&quot;url&quot;&gt; ... &lt;&#x2F;a&gt;\n\n&lt;!-- 动态参数的缩写 --&gt;\n&lt;a :[key]&#x3D;&quot;url&quot;&gt; ... &lt;&#x2F;a&gt;\n\n⑤ 使用javascript表达式迄今为止，在我们的模板中，我们一直都只绑定简单的 property 键值。但实际上，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。\n&#123;&#123; number + 1 &#125;&#125;\n\n&#123;&#123; ok ? &#39;YES&#39; : &#39;NO&#39; &#125;&#125;\n\n&#123;&#123; message.split(&#39;&#39;).reverse().join(&#39;&#39;) &#125;&#125;\n\n&lt;div v-bind:id&#x3D;&quot;&#39;list-&#39; + id&quot;&gt;&lt;&#x2F;div&gt;\n\n\n\n:beginner: ​双向绑定 v-model① 需求使用vue赋值json数据，并显示到页面的输入框中（表单回显）。\n 测试：改变输入框的值，同时验证模型的数据发生改变。\n 测试：改变json数据，验证同时输入框的内容也发生改变。\n这就是MVVM模式\n&lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;!-- v-bind:属性名 效果是从Vue对象渲染到页面 --&gt;\n    &lt;!-- v-model:属性名 效果不仅是从Vue对象渲染到页面，而且能够在页面上数据修改后反向修改Vue对象中的数据属性 --&gt;\n    &lt;input type&#x3D;&quot;text&quot; v-model:value&#x3D;&quot;vueValue&quot; &#x2F;&gt;\n\n    &lt;p&gt;&#123;&#123;vueValue&#125;&#125;&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n\n&lt;script&gt;\n    &#x2F;&#x2F; 创建Vue对象，挂载#app这个div标签\n    var app &#x3D; new Vue(&#123;\n        &quot;el&quot;:&quot;#app&quot;,\n        &quot;data&quot;:&#123;\n            &quot;vueValue&quot;:&quot;太阳当空照&quot;\n        &#125;\n    &#125;);\n&lt;&#x2F;script&gt;\n\n② 页面效果p标签内的数据能够和文本框中的数据实现同步修改：\n\n③ 扩展1. v-model:value=”值” 可以简写成 v-model=”值”\n2. trim修饰符\n实际开发中，要考虑到用户在输入数据时，有可能会包含前后空格。而这些前后的空格对我们程序运行来说都是干扰因素，要去掉。在v-model后面加上.trim修饰符即可实现。\n&lt;input type&#x3D;&quot;text&quot; v-model.trim&#x3D;&quot;vueValue&quot; &#x2F;&gt;\n\nVue会帮助我们在文本框失去焦点时自动去除前后空格。\n:beginner:  条件渲染根据Vue对象中，数据属性的值来判断是否对HTML页面内容进行渲染。\n① v-ifv-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。\n&lt;h1 v-if&#x3D;&quot;awesome&quot;&gt;Vue is awesome!&lt;&#x2F;h1&gt;\n\n&lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;h3&gt;if&lt;&#x2F;h3&gt;\n    &lt;img v-if&#x3D;&quot;flag&quot; src&#x3D;&quot;&#x2F;pro03-vue&#x2F;images&#x2F;one.jpg&quot; &#x2F;&gt;\n    &lt;img v-if&#x3D;&quot;!flag&quot; src&#x3D;&quot;&#x2F;pro03-vue&#x2F;images&#x2F;two.jpg&quot; &#x2F;&gt;\n&lt;&#x2F;div&gt;\n\n&lt;script&gt;\n    var app &#x3D; new Vue(&#123;\n        &quot;el&quot;:&quot;#app&quot;,\n        &quot;data&quot;:&#123;\n            &quot;flag&quot;:true\n        &#125;\n    &#125;);\n&lt;&#x2F;script&gt;\n\n② v-else你可以使用 v-else 指令来表示 v-if 的“else 块”：\n&lt;div v-if&#x3D;&quot;Math.random() &gt; 0.5&quot;&gt;\n  Now you see me\n&lt;&#x2F;div&gt;\n&lt;div v-else&gt;\n  Now you don&#39;t\n&lt;&#x2F;div&gt;\n\nv-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。\n③ v-else-ifv-else-if，顾名思义，充当 v-if 的“else-if 块”，并且可以连续使用：\n&lt;div v-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;A&#39;&quot;&gt;\n  A\n&lt;&#x2F;div&gt;\n&lt;div v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;B&#39;&quot;&gt;\n  B\n&lt;&#x2F;div&gt;\n&lt;div v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;C&#39;&quot;&gt;\n  C\n&lt;&#x2F;div&gt;\n&lt;div v-else&gt;\n  Not A&#x2F;B&#x2F;C\n&lt;&#x2F;div&gt;\n\n与 v-else 的用法类似，v-else-if 也必须紧跟在带 v-if 或者 v-else-if 的元素之后。\n④ v-show另一个用于条件性展示元素的选项是 v-show 指令。用法大致一样：\n&lt;h1 v-show&#x3D;&quot;ok&quot;&gt;Hello!&lt;&#x2F;h1&gt;\n\n不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS property display。\n注意，v-show 不支持 &lt;template&gt; 元素，也不支持 v-else。\n⑤ v-if vs v-showv-if 是“真正”的条件渲染，因为它会确保在切换过程中，条件块内的事件监听器和子组件适当地被销毁和重建。\nv-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。\n一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。\n⑥ 避免 v-if v-for 一起使用永远不要把 v-if 和 v-for 同时用在同一个元素上。\n&lt;ul&gt;\n  &lt;li\n    v-for&#x3D;&quot;user in activeUsers&quot;\n    :key&#x3D;&quot;user.id&quot;\n  &gt;\n    &#123;&#123; user.name &#125;&#125;\n  &lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n&lt;ul&gt;\n  &lt;template v-for&#x3D;&quot;user in users&quot; :key&#x3D;&quot;user.id&quot;&gt;\n    &lt;li v-if&#x3D;&quot;user.isActive&quot;&gt;\n      &#123;&#123; user.name &#125;&#125;\n    &lt;&#x2F;li&gt;\n  &lt;&#x2F;template&gt;\n&lt;&#x2F;ul&gt;\n\n\n\n:beginner: ​列表渲染① v-for 将数组对应为数据我们可以用 v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。\n&lt;ul id&#x3D;&quot;array-rendering&quot;&gt;\n  &lt;li v-for&#x3D;&quot;item in items&quot;&gt;\n    &#123;&#123; item.message &#125;&#125;\n  &lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\nVue.createApp(&#123;\n  data() &#123;\n    return &#123;\n      items: [&#123; message: &#39;Foo&#39; &#125;, &#123; message: &#39;Bar&#39; &#125;]\n    &#125;\n  &#125;\n&#125;).mount(&#39;#array-rendering&#39;)\n\n② v-for 将对象对应为数据&lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;table&gt;\n        &lt;tr&gt;\n            &lt;th&gt;编号&lt;&#x2F;th&gt;\n            &lt;th&gt;姓名&lt;&#x2F;th&gt;\n            &lt;th&gt;年龄&lt;&#x2F;th&gt;\n            &lt;th&gt;专业&lt;&#x2F;th&gt;\n        &lt;&#x2F;tr&gt;\n        &lt;tr v-for&#x3D;&quot;employee in employeeList&quot;&gt;\n            &lt;td&gt;&#123;&#123;employee.empId&#125;&#125;&lt;&#x2F;td&gt;\n            &lt;td&gt;&#123;&#123;employee.empName&#125;&#125;&lt;&#x2F;td&gt;\n            &lt;td&gt;&#123;&#123;employee.empAge&#125;&#125;&lt;&#x2F;td&gt;\n            &lt;td&gt;&#123;&#123;employee.empSubject&#125;&#125;&lt;&#x2F;td&gt;\n        &lt;&#x2F;tr&gt;\n    &lt;&#x2F;table&gt;\n&lt;&#x2F;div&gt;\n\n&lt;script&gt;\n    var app &#x3D; new Vue(&#123;\n        &quot;el&quot;:&quot;#app&quot;,\n        &quot;data&quot;:&#123;\n            &quot;employeeList&quot;:[\n                &#123;\n                    &quot;empId&quot;:11,\n                    &quot;empName&quot;:&quot;tom&quot;,\n                    &quot;empAge&quot;:111,\n                    &quot;empSubject&quot;:&quot;java&quot;\n                &#125;\n            ]\n        &#125;\n    &#125;);\n&lt;&#x2F;script&gt;\n\n③ v-for 中 绑定key的使用需求：先选中吕不韦，添加新的人物后，还继续自动选中吕不韦\n不加key时，我们发现选中的是李斯\n&lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;div&gt;\n        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;name&quot;&gt;\n            &lt;button @click&#x3D;&quot;add&quot;&gt;添加&lt;&#x2F;button&gt;\n            &lt;&#x2F;div&gt;\n        &lt;ul&gt;\n            &lt;li v-for&#x3D;&quot;(item, i) in list&quot; :key&#x3D;&quot;item.id&quot;&gt;\n                &lt;input type&#x3D;&quot;checkbox&quot;&gt; &#123;&#123;item.name&#125;&#125;\n                    &lt;&#x2F;li&gt;\n                &lt;&#x2F;ul&gt;\n            &lt;script&gt;\n                &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel\n                var vm &#x3D; new Vue(&#123;\n                    el: &#39;#app&#39;,\n                    data: &#123;\n                    name: &#39;&#39;,\n                    newId: 3,\n                    list: [\n                        &#123; id: 1, name: &#39;李斯&#39; &#125;,\n                        &#123; id: 2, name: &#39;吕不韦&#39; &#125;,\n                        &#123; id: 3, name: &#39;嬴政&#39; &#125;\n                        ]\n                    &#125;,\n                    methods: &#123;\n                        add() &#123;\n                        &#x2F;&#x2F;注意这里是unshift\n                        this.list.unshift(&#123; id: ++this.newId, name: this.name &#125;)\n                        this.name &#x3D; &#39;&#39;\n                        &#125;\n                    &#125;\n                &#125;);\n            &lt;&#x2F;script&gt;\n            &lt;&#x2F;div&gt;\n\n\n\n:beginner: 数组更新检测① 变更方法Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：\n\npush()：添加到数组的最后的位置\npop()\nshift()\nunshift()：往最前面的位置添加\nsplice()\nsort()\nreverse()\n\n你可以打开控制台，然后对前面例子的 items 数组尝试调用变更方法。比如 example1.items.push(&#123; message: &#39;Baz&#39; &#125;)\n② 替换数组变更方法，顾名思义，会变更调用了这些方法的原始数组。相比之下，也有非变更方法，例如 filter()、concat() 和 slice()。它们不会变更原始数组，而总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组：\nexample1.items &#x3D; example1.items.filter(item &#x3D;&gt; item.message.match(&#x2F;Foo&#x2F;))\n\n你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的启发式方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。\n③ 显示过滤/排序后的效果有时，我们想要显示一个数组经过过滤或排序后的版本，而不实际变更或重置原始数据。在这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组。\n例如：\n&lt;li v-for&#x3D;&quot;n in evenNumbers&quot; :key&#x3D;&quot;n&quot;&gt;&#123;&#123; n &#125;&#125;&lt;&#x2F;li&gt;\n\ndata() &#123;\n  return &#123;\n    numbers: [ 1, 2, 3, 4, 5 ]\n  &#125;\n&#125;,\ncomputed: &#123;\n  evenNumbers() &#123;\n    return this.numbers.filter(number &#x3D;&gt; number % 2 &#x3D;&#x3D;&#x3D; 0)\n  &#125;\n&#125;\n\n在计算属性不适用的情况下 (例如，在嵌套 v-for 循环中) 你可以使用一个方法：\n&lt;ul v-for&#x3D;&quot;numbers in sets&quot;&gt;\n  &lt;li v-for&#x3D;&quot;n in even(numbers)&quot; :key&#x3D;&quot;n&quot;&gt;&#123;&#123; n &#125;&#125;&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\ndata() &#123;\n  return &#123;\n    sets: [[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]]\n  &#125;\n&#125;,\nmethods: &#123;\n  even(numbers) &#123;\n    return numbers.filter(number &#x3D;&gt; number % 2 &#x3D;&#x3D;&#x3D; 0)\n  &#125;\n&#125;\n\n\n\n:beginner: 事件处理① 监听事件 v-on使用 v-on 指令 (通常缩写为 @ 符号) 来监听 DOM 事件，并在触发事件时执行一些 JavaScript。用法为 v-on:click=&quot;methodName&quot; 或使用快捷方式 @click=&quot;methodName&quot;\n例如：\n&lt;div id&#x3D;&quot;basic-event&quot;&gt;\n  &lt;button @click&#x3D;&quot;counter +&#x3D; 1&quot;&gt;Add 1&lt;&#x2F;button&gt;\n  &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n\nVue.createApp(&#123;\n  data() &#123;\n    return &#123;\n      counter: 0\n    &#125;\n  &#125;\n&#125;).mount(&#39;#basic-event&#39;)\n\n② 事件处理方法然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收一个需要调用的方法名称。\n例如：\n&lt;div id&#x3D;&quot;event-with-method&quot;&gt;\n  &lt;!-- &#96;greet&#96; 是在下面定义的方法名 --&gt;\n  &lt;button @click&#x3D;&quot;greet&quot;&gt;Greet&lt;&#x2F;button&gt;\n&lt;&#x2F;div&gt;\n\nVue.createApp(&#123;\n  data() &#123;\n    return &#123;\n      name: &#39;Vue.js&#39;\n    &#125;\n  &#125;,\n  methods: &#123;\n    greet(event) &#123;\n      &#x2F;&#x2F; &#96;methods&#96; 内部的 &#96;this&#96; 指向当前活动实例\n      alert(&#39;Hello &#39; + this.name + &#39;!&#39;)\n      &#x2F;&#x2F; &#96;event&#96; 是原生 DOM event\n      if (event) &#123;\n        alert(event.target.tagName)\n      &#125;\n    &#125;\n  &#125;\n&#125;).mount(&#39;#event-with-method&#39;)\n\n③ 内联处理器的方法除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法：\n&lt;div id&#x3D;&quot;inline-handler&quot;&gt;\n  &lt;button @click&#x3D;&quot;say(&#39;hi&#39;)&quot;&gt;Say hi&lt;&#x2F;button&gt;\n  &lt;button @click&#x3D;&quot;say(&#39;what&#39;)&quot;&gt;Say what&lt;&#x2F;button&gt;\n&lt;&#x2F;div&gt;\n\nVue.createApp(&#123;\n  methods: &#123;\n    say(message) &#123;\n      alert(message)\n    &#125;\n  &#125;\n&#125;).mount(&#39;#inline-handler&#39;)\n\n有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法：\n&lt;button @click&#x3D;&quot;warn(&#39;Form cannot be submitted yet.&#39;, $event)&quot;&gt;\n  Submit\n&lt;&#x2F;button&gt;\n\n&#x2F;&#x2F; ...\nmethods: &#123;\n  warn(message, event) &#123;\n    &#x2F;&#x2F; 现在可以访问到原生事件\n    if (event) &#123;\n      event.preventDefault()\n    &#125;\n    alert(message)\n  &#125;\n&#125;\n\n④ 多事件处理器事件处理程序中可以有多个方法，这些方法由逗号运算符分隔：\n&lt;!-- 这两个 one() 和 two() 将执行按钮点击事件 --&gt;\n&lt;button @click&#x3D;&quot;one($event), two($event)&quot;&gt;\n  Submit\n&lt;&#x2F;button&gt;\n\n&#x2F;&#x2F; ...\nmethods: &#123;\n  one(event) &#123;\n    &#x2F;&#x2F; 第一个事件处理器逻辑...\n  &#125;,\n  two(event) &#123;\n   &#x2F;&#x2F; 第二个事件处理器逻辑...\n  &#125;\n&#125;\n\n⑤ 事件修饰符在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。\n为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。\n\n.stop：阻止冒泡事件的发生\n.prevent：取消控件的默认行为\n.capture\n.self\n.once\n.passive\n\n&lt;!-- 阻止单击事件继续传播 --&gt;\n&lt;a @click.stop&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;\n\n&lt;!-- 提交事件不再重载页面 --&gt;\n&lt;form @submit.prevent&#x3D;&quot;onSubmit&quot;&gt;&lt;&#x2F;form&gt;\n\n&lt;!-- 修饰符可以串联 --&gt;\n&lt;a @click.stop.prevent&#x3D;&quot;doThat&quot;&gt;&lt;&#x2F;a&gt;\n\n&lt;!-- 只有修饰符 --&gt;\n&lt;form @submit.prevent&gt;&lt;&#x2F;form&gt;\n\n&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;\n&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;\n&lt;div @click.capture&#x3D;&quot;doThis&quot;&gt;...&lt;&#x2F;div&gt;\n\n&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;\n&lt;!-- 即事件不是从内部元素触发的 --&gt;\n&lt;div @click.self&#x3D;&quot;doThat&quot;&gt;...&lt;&#x2F;div&gt;\n\n\n\n\n\n\n\n\n\n\nTIP\n使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。\n⑥ 按键修饰符在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 或者 @ 在监听键盘事件时添加按键修饰符：\n&lt;!-- 只有在 &#96;key&#96; 是 &#96;Enter&#96; 时调用 &#96;vm.submit()&#96; --&gt;\n&lt;input @keyup.enter&#x3D;&quot;submit&quot; &#x2F;&gt;\n\n按键别名，Vue 为最常用的键提供了别名：\n\n.enter\n.tab\n.delete (捕获“删除”和“退格”键)\n.esc\n.space\n.up\n.down\n.left\n.right\n\n【需求】：在输入框中，如果输入回车键，就执行弹出窗口事件（可用于网页登录）。\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n \n   &lt;head&gt;\n      &lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;\n      &lt;title&gt;v-on:按键修饰符&lt;&#x2F;title&gt;\n \n      &lt;script src&#x3D;&quot;js&#x2F;vuejs-2.5.16.js&quot;&gt;&lt;&#x2F;script&gt;\n   &lt;&#x2F;head&gt;\n \n   &lt;body&gt;\n      &lt;div id&#x3D;&quot;app&quot;&gt;\n         &lt;!--当按下按键enter的时候，触发fun事件--&gt;\n         &lt;input type&#x3D;&quot;text&quot; @keydown.enter&#x3D;&quot;fun()&quot;&gt;\n         &lt;!--&lt;input type&#x3D;&quot;text&quot; @keydown&#x3D;&quot;fun($event)&quot; &#x2F;&gt;--&gt;\n      &lt;&#x2F;div&gt;\n   &lt;&#x2F;body&gt;\n   &lt;script&gt;\n      &#x2F;&#x2F;view model\n      new Vue(&#123;\n         el: &quot;#app&quot;,\n         methods: &#123;\n            fun1:function()&#123;\n               alert(&quot;输入的回车键！&quot;);\n            &#125;\n&#x2F;&#x2F;          fun1:function (e) &#123;\n&#x2F;&#x2F;             var keyCode &#x3D; e.keyCode;\n&#x2F;&#x2F;             &#x2F;&#x2F;alert(keyCode);\n&#x2F;&#x2F;             if(keyCode &#x3D;&#x3D; 13)&#123;\n&#x2F;&#x2F;                 alert(&quot;输入的回车键！&quot;)\n&#x2F;&#x2F;             &#125;\n&#x2F;&#x2F;          &#125;\n         &#125;\n      &#125;);\n   &lt;&#x2F;script&gt;\n \n&lt;&#x2F;html&gt;\n\n⑦ v-on:keydownkeycode对照表\n\n【需求】：对文本输入框做校验，使用键盘按下事件，如果按下0-9的数字，正常显示，其他按键则阻止事件执行。\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n \n   &lt;head&gt;\n      &lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;\n      &lt;title&gt;v-on:keydown&lt;&#x2F;title&gt;\n      &lt;script src&#x3D;&quot;js&#x2F;vuejs-2.5.16.js&quot;&gt;&lt;&#x2F;script&gt;\n   &lt;&#x2F;head&gt;\n \n   &lt;body&gt;\n      &lt;div id&#x3D;&quot;app&quot;&gt;\n         &lt;input type&#x3D;&quot;text&quot; v-on:keydown&#x3D;&quot;fun($event)&quot;&gt;    \n         &lt;!-- &lt;input type&#x3D;&quot;text&quot; @keydown&#x3D;&quot;fun($event)&quot; &#x2F;&gt; --&gt;\n      &lt;&#x2F;div&gt;\n   &lt;&#x2F;body&gt;\n   &lt;script&gt;\n      &#x2F;&#x2F;view model\n      new Vue(&#123;\n         el: &quot;#app&quot;,\n         data: &#123;\n           message: 10 &#x2F;&#x2F;model\n         &#125;,\n         methods: &#123;\n            fun: function(e) &#123;\n               &#x2F;&#x2F;1.捕获keyCode 判断它是否是0-9  需要使用event对象\n               var keyCode &#x3D; e.keyCode;\n                &#x2F;&#x2F; 只能输入数字\n               if(!(keyCode &gt;&#x3D; 48 &amp;&amp; keyCode &lt;&#x3D; 57)) &#123;\n                  &#x2F;&#x2F;2.阻止默认行为执行\n                  e.preventDefault();\n               &#125;\n            &#125;\n         &#125;\n      &#125;);\n   &lt;&#x2F;script&gt;\n&lt;&#x2F;html&gt;\n\n输入框中只能输入0-9的数字，如果不是0-9的数字，不能输入。\n:beginner: ​Vue 生命周期① 概念在我们各种语言的编程领域中，『生命周期』都是一个非常常见的概念。一个对象从创建、初始化、工作再到释放、清理和销毁，会经历很多环节的演变。比如我们在JavaSE阶段学习过线程的生命周期，今天学习Vue对象的生命周期，将来还要学习Servlet、Filter等Web组件的生命周期。\n1. 什么叫生命周期？\n每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 、并在数据变化时更新 DOM 等。\n2. 什么叫钩子函数？\n同时在生命周期执行的这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。\n② Vue对象的生命周期\n③ 生命周期钩子函数Vue允许我们在特定的生命周期环节中通过钩子函数来加入我们的代码。\n【需求】：演示vue对象的创建、赋值、显示、改值、销毁的全过程，即Vue的生命周期，同时使用钩子函数添加自己的业务逻辑\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n \n   &lt;head&gt;\n      \n      &lt;script src&#x3D;&quot;js&#x2F;vuej&lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;\n      &lt;title&gt;vuejs生命周期&lt;&#x2F;title&gt;s-2.5.16.js&quot;&gt;&lt;&#x2F;script&gt;\n   &lt;&#x2F;head&gt;\n \n   &lt;body&gt;\n      &lt;div id&#x3D;&quot;app&quot;&gt;\n         &#123;&#123;message&#125;&#125;\n      &lt;&#x2F;div&gt;\n   &lt;&#x2F;body&gt;\n   &lt;script&gt;\n      var vue &#x3D; new Vue(&#123;\n         el: &quot;#app&quot;,\n         &#x2F;&#x2F;template:&quot;&lt;h1&gt;&lt;font color&#x3D;&#39;red&#39;&gt;你好硅谷&lt;&#x2F;font&gt;&lt;&#x2F;h1&gt;&quot;, &#x2F;&#x2F;在vue配置项中修改的\n         data: &#123;\n            message: &#39;hello world&#39;\n         &#125;,\n         beforeCreate: function() &#123;\n            showData(&#39;创建vue实例前&#39;, this);\n         &#125;,\n         created: function() &#123;\n            showData(&#39;创建vue实例后&#39;, this);\n         &#125;,\n         beforeMount: function() &#123;\n            showData(&#39;挂载到dom前&#39;, this);\n         &#125;,\n         mounted: function() &#123;\n            showData(&#39;挂载到dom后&#39;, this);\n         &#125;,\n         beforeUpdate: function() &#123;\n            showData(&#39;数据变化更新前&#39;, this);\n         &#125;,\n         updated: function() &#123;\n            showData(&#39;数据变化更新后&#39;, this);\n         &#125;,\n         beforeDestroy: function() &#123;\n            showData(&#39;vue实例销毁前&#39;, this);\n         &#125;,\n         destroyed: function() &#123;\n            showData(&#39;vue实例销毁后&#39;, this);\n         &#125;\n      &#125;);\n \n      function showData(process, obj) &#123;\n         console.log(process);\n         console.log(&#39;data 数据：&#39; + obj.message)\n         console.log(&#39;vue挂载的虚拟dom对象：&#39;)\n         console.log(obj.$el)\n         console.log(&#39;真实dom结构：&#39; + document.getElementById(&#39;app&#39;).innerHTML);\n         console.log(&#39;------------------&#39;)\n         console.log(&#39;------------------&#39;)\n      &#125;\n      &#x2F;&#x2F;vue.$mount(&quot;#app&quot;);\n      vue.message &#x3D; &quot;good...&quot;;\n      vue.$destroy(); &#x2F;&#x2F; 销毁了监听，不会执行数据变化的监听，即不会将message的值改成good...\n   &lt;&#x2F;script&gt;\n \n&lt;&#x2F;html&gt;\n\n查看谷歌浏览器\n分析生命周期相关方法的执行时机\n&lt;script src&#x3D;&quot;vue.min.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script&gt;\n    new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n            message: &#39;床前明月光&#39;\n        &#125;,\n        &#x2F;&#x2F; 页面在内存中已经初始化完毕：\n        &#x2F;&#x2F; 可以操作 data 中的数据、调用methods中的方法\n        &#x2F;&#x2F; 但是数据尚未被渲染到页面中：用户看不见\n        created() &#123;\n            console.log(&#39;created&#39;)\n            &#x2F;&#x2F;可以操作 data 中的数据\n            console.log(this.message)\n            &#x2F;&#x2F;可以调用methods中的方法\n            this.show()\n            &#x2F;&#x2F;无法取出dom节点取数据，说明用户无法在浏览器中看见这个内容\n            console.log(document.getElementById(&#39;h3&#39;).innerText)\n        &#125;,\n        \n        &#x2F;&#x2F; 数据已经被渲染到页面中\n        mounted() &#123; &#x2F;&#x2F; 第四个被执行的钩子方法\n            console.log(&#39;mounted&#39;)\n            &#x2F;&#x2F;可以取出dom节点取数据，说明用户已经在浏览器中看见内容\n            console.log(document.getElementById(&#39;h3&#39;).innerText)\n        &#125;,\n        \n        methods: &#123;\n            show() &#123;\n                console.log(&#39;show方法被调用&#39;)\n            &#125;\n        &#125;,\n    &#125;)\n&lt;&#x2F;script&gt;\n\n\n\n:beginner: Vue 路由一、锚点的概念案例：百度百科\n特点：单页Web应用，预先加载页面内容\n形式：url#锚点\n二、路由的作用Vue.js 路由允许我们通过锚点定义不同的 URL， 达到访问不同的页面的目的，每个页面的内容通过延迟加载渲染出来。\n通过 Vue.js 可以实现多视图的单页Web应用（single page web application，SPA）\n==SSP单页面应用，项目只有一个页面，在页面中动态显示的内容只要切换加载页面碎片即可==\n==容器内通过router-view显示vue路由动态加载的页面碎片==\n==容器内提供一组路由链接router-link(菜单列表)，每个路由链接点击时可以加载自己的页面碎片到routerview中显示==\n三、路由实例创建文件夹router_pro\n1、复制js资源vue.min.js\nvue-router.min.js\n2、创建 路由.html3、引入js&lt;script src&#x3D;&quot;vue.min.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;vue-router.min.js&quot;&gt;&lt;&#x2F;script&gt;\n\n4、编写html&lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;h1&gt;Hello App!&lt;&#x2F;h1&gt;\n    &lt;p&gt;\n        &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 &#96;&lt;a&gt;&#96; 标签 --&gt;\n        &lt;!-- 通过传入 &#96;to&#96; 属性指定链接. --&gt;\n        &lt;router-link to&#x3D;&quot;&#x2F;&quot;&gt;首页&lt;&#x2F;router-link&gt;\n        &lt;router-link to&#x3D;&quot;&#x2F;student&quot;&gt;会员管理&lt;&#x2F;router-link&gt;\n        &lt;router-link to&#x3D;&quot;&#x2F;teacher&quot;&gt;讲师管理&lt;&#x2F;router-link&gt;\n    &lt;&#x2F;p&gt;\n    &lt;!-- 路由出口 --&gt;\n    &lt;!-- 路由匹配到的组件将渲染在这里 --&gt;\n    &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n&lt;&#x2F;div&gt;\n\n5、编写js&lt;script&gt;\n  &#x2F;&#x2F; 1. 定义（路由）组件。\n  &#x2F;&#x2F; 复杂的组件也可以从独立的vue文件中引入\n  const Welcome &#x3D; &#123; template: &#39;&lt;div&gt;欢迎&lt;&#x2F;div&gt;&#39; &#125;\n  const Student &#x3D; &#123; template: &#39;&lt;div&gt;student list&lt;&#x2F;div&gt;&#39; &#125;\n  const Teacher &#x3D; &#123; template: &#39;&lt;div&gt;teacher list&lt;&#x2F;div&gt;&#39; &#125;\n  &#x2F;&#x2F; 2. 定义路由\n  &#x2F;&#x2F; 每个路由应该映射一个组件。\n  const routes &#x3D; [\n    &#123; path: &#39;&#x2F;&#39;, redirect: &#39;&#x2F;welcome&#39; &#125;, &#x2F;&#x2F;设置默认指向的路径\n    &#123; path: &#39;&#x2F;welcome&#39;, component: Welcome &#125;,\n    &#123; path: &#39;&#x2F;student&#39;, component: Student &#125;,\n    &#123; path: &#39;&#x2F;teacher&#39;, component: Teacher &#125;\n  ]\n  &#x2F;&#x2F; 3. 创建 router 实例，然后传 &#96;routes&#96; 配置\n  const router &#x3D; new VueRouter(&#123;\n    routes &#x2F;&#x2F; （缩写）相当于 routes: routes\n  &#125;)\n  &#x2F;&#x2F; 4. 创建和挂载根实例。\n  &#x2F;&#x2F; 从而让整个应用都有路由功能\n  new Vue(&#123;\n    el: &#39;#app&#39;,\n    router\n      &#x2F;&#x2F; router: new VueRouter(&#123;\n      &#x2F;&#x2F;     routes: [\n      &#x2F;&#x2F;         &#123; path: &#39;&#x2F;&#39;, redirect: &#39;&#x2F;index&#39; &#125;,\n      &#x2F;&#x2F;         &#123; path: &#39;&#x2F;index&#39;, component: &#123; template: &#39;&lt;div&gt;欢迎&lt;&#x2F;div&gt;&#39; &#125; &#125;,\n      &#x2F;&#x2F;         &#123; path: &#39;&#x2F;course&#39;, component: &#123; template: &#39;&lt;div&gt;course list&lt;&#x2F;div&gt;&#39; &#125; &#125;,\n      &#x2F;&#x2F;         &#123; path: &#39;&#x2F;teacher&#39;, component: &#123; template: &#39;&lt;div&gt;teacher list&lt;&#x2F;div&gt;&#39; &#125; &#125;\n      &#x2F;&#x2F;     ]\n      &#x2F;&#x2F; &#125;)\n  &#125;)\n  &#x2F;&#x2F; 现在，应用已经启动了！\n&lt;&#x2F;script&gt;\n","slug":"32-Vue","date":"2021-09-13T15:09:32.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"大黄"},{"id":"6f6443e7d108482a5cb5a126a4a24a84","title":"Thymeleaf","content":"1. 创建模板文件创建一个 HTML 模板文件：\n&lt;!DOCTYPE HTML&gt;\n&lt;html xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;title&gt;Index Page&lt;&#x2F;title&gt;\n    &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot; &#x2F;&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    &lt;p th:text&#x3D;&quot;$&#123;message&#125;&quot;&gt;Welcome to BeiJing!&lt;&#x2F;p&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n通过&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;引入 Thymeleaf 命名空间。th:text用于处理p标签体的文本内容。该模板文件直接在任何浏览器中正确显示，浏览器会自动忽略它们不能理解的属性th:text。但这不是一个真正有效的 HTML5 文档，因为 HTML5 规范是不允许使用th:*这些非标准属性的。我们可以切换到 Thymeleaf 的data-th-*语法，以此来替换th:*语法：\n&lt;!DOCTYPE HTML&gt;\n&lt;html xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;title&gt;Index Page&lt;&#x2F;title&gt;\n    &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot; &#x2F;&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    &lt;p data-th-text&#x3D;&quot;$&#123;message&#125;&quot;&gt;Welcome to BeiJing!&lt;&#x2F;p&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nHTML5 规范是允许data-*这样自定义的属性的。th:*和data-th-*这两个符号是完全等效且可以互换的。但为了简单直观和代码的紧凑性，本文采用th:*的表示形式。\n2. 标准表达式语法Thymeleaf 提供了非常丰富的标准表达式语法，总共有 8 大类：\n\n简单表达式\n字面值\n文本操作\n算术运算\n布尔运算\n比较和相等\n条件运算\n无操作符\n\n2.1 简单表达式\n\n\n语法\n名称\n描述\n作用\n\n\n\n${…}\nVariable Expressions\n变量表达式\n取出上下文变量的值\n\n\n*{…}\nSelection Variable Expressions\n选择变量表达式\n取出选择的对象的属性值\n\n\n#{…}\nMessage Expressions\n消息表达式\n使文字消息国际化，I18N\n\n\n@{…}\nLink URL Expressions\n链接表达式\n用于表示各种超链接地址\n\n\n~{…}\nFragment Expressions\n片段表达式\n引用一段公共的代码片段\n\n\n2.1.1 ${…}@GetMapping(&quot;&#x2F;standard-expression-syntax&#x2F;variables&quot;)\npublic String variables(ModelMap model, HttpSession session) &#123;\n    model.put(&quot;now&quot;, new Date());\n    model.put(&quot;message&quot;, &quot;Welcome to BeiJing!&quot;);\n    session.setAttribute(&quot;user&quot;, new User(&quot;fanlychie&quot;, &quot;男&quot;, 24));\n    ... ...\n&#125;\n\n通过变量表达式$&#123;&#125;取出上下文环境中的message变量：\n&lt;!-- Welcome to BeiJing! --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;message&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n它相当于：\nctx.getVariable(&quot;message&quot;);\n\n2.1.2  *{…}变量表达式$&#123;&#125;是面向整个上下文的，而选择变量表达式*&#123;&#125;的上下文是父标签（th:object）所选择的对象：\n&lt;div th:object&#x3D;&quot;$&#123;session.user&#125;&quot;&gt;\n    &lt;p th:text&#x3D;&quot;*&#123;name&#125;&quot;&gt;&lt;&#x2F;p&gt;\n    &lt;p th:text&#x3D;&quot;*&#123;sex&#125;&quot;&gt;&lt;&#x2F;p&gt;\n    &lt;p th:text&#x3D;&quot;*&#123;age&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n\n它相当于：\n&lt;div&gt;\n    &lt;p th:text&#x3D;&quot;$&#123;session.user.name&#125;&quot;&gt;&lt;&#x2F;p&gt;\n    &lt;p th:text&#x3D;&quot;$&#123;session.user.sex&#125;&quot;&gt;&lt;&#x2F;p&gt;\n    &lt;p th:text&#x3D;&quot;$&#123;session.user.age&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n\n如果对象没有被选择，那么，*&#123;&#125;和$&#123;&#125;表达式所达到的效果是完全相同的：\n&lt;p th:text&#x3D;&quot;*&#123;session.user.name&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;p th:text&#x3D;&quot;$&#123;session.user.name&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n2.1.3 #{…}消息表达式可用于国际化文字信息。首先我们来了解一下 i18n 资源文件的命名规则：\n\nbasename.properties\nbasename_language.properties\nbasename_language_country.properties\n\nbasename是自定义的资源文件名称，language和country必须是 Java 支持的语言和国家。basename.properties是缺省加载的资源文件，当客户端根据本地语言查找不到相关的资源文件时，则使用该配置文件。\n创建文件src/main/resources/messages.properties\nwelcome.message &#x3D; 北京欢迎你！\n\n创建文件src/main/resources/messages_en_US.properties\nwelcome.message &#x3D; Welcome to BeiJing!\n\n在 IntelliJ IDEA 编辑视图：\n\nmessages是 Spring Boot 加载资源文件默认采用的名称（basename），如果你所使用的资源文件名称不是以messages命名或所使用的资源文件不是在src/main/resources根目录，你可以通过spring.messages.basename属性来做具体的配置。如，资源文件messages.properties和messages_en_US.properties假设它们所在的目录位置是src/main/resources/i18n。\napplication.properties 配置示例：\nspring.messages.basename:i18n&#x2F;messages\n\napplication.yml 配置示例：\nspring\n  messages\n    basename: i18n&#x2F;messages\n\n静态文本消息示例：\n&lt;!-- 北京欢迎你！ --&gt;\n&lt;p th:text&#x3D;&quot;#&#123;welcom.message&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n消息表达式#&#123;&#125;是不允许直接处理非静态的文本消息的，但是你可以在资源文件中通过使用占位符&#123;&#125;来处理非静态的文本消息：\nmessages.properties 配置示例：\nwelcome.user.message &#x3D; &#123;0&#125;, 北京欢迎你！\n\nmessages_en_US.properties 配置示例：\nwelcome.user.message &#x3D; &#123;0&#125;, Welcome to BeiJing!\n\n非静态文本消息，以参数的形式传递变量的值：\n&lt;!-- fanlychie, 北京欢迎你！ --&gt;\n&lt;p th:text&#x3D;&quot;#&#123;welcome.user.message($&#123;session.user.name&#125;)&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n2.1.4 @{…}链接表达式@&#123;&#125;是专门用来处理 URL 链接地址的。\n绝对地址示例：\n&lt;!-- https:&#x2F;&#x2F;fanlychie.github.io --&gt;\n&lt;p th:text&#x3D;&quot;@&#123;https:&#x2F;&#x2F;fanlychie.github.io&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n页面相对地址示例：\n&lt;!-- commons&#x2F;base.html --&gt;\n&lt;p th:text&#x3D;&quot;@&#123;commons&#x2F;base.html&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n上下文相对地址（相对于当前的服务）示例：\n&lt;!-- &#x2F;css&#x2F;mian.css --&gt;\n&lt;p th:text&#x3D;&quot;@&#123;&#x2F;css&#x2F;mian.css&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n服务器相对地址（相对于部署在同一个服务器中的不同服务）示例：\n&lt;!-- &#x2F;image&#x2F;upload --&gt;\n&lt;p th:text&#x3D;&quot;@&#123;~&#x2F;image&#x2F;upload&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n参数使用示例：\n&lt;!-- &#x2F;css&#x2F;mian.css?v&#x3D;1.0 --&gt;\n&lt;p th:text&#x3D;&quot;@&#123;&#x2F;css&#x2F;mian.css(v&#x3D;1.0)&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- &#x2F;user&#x2F;order?username&#x3D;fanlychie --&gt;\n&lt;p th:text&#x3D;&quot;@&#123;&#x2F;user&#x2F;order(username&#x3D;$&#123;session.user.name&#125;)&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- &#x2F;user&#x2F;order?username&#x3D;fanlychie&amp;status&#x3D;PAIED --&gt;\n&lt;p th:text&#x3D;&quot;@&#123;&#x2F;user&#x2F;order(username&#x3D;$&#123;session.user.name&#125;,status&#x3D;&#39;PAIED&#39;)&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- &#x2F;user&#x2F;fanlychie&#x2F;info --&gt;\n&lt;p th:text&#x3D;&quot;@&#123;&#x2F;user&#x2F;&#123;username&#125;&#x2F;info(username&#x3D;$&#123;session.user.name&#125;)&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n2.1.5 ~{…}片段表达式~&#123;&#125;可以用来引用一段公共的 HTML 代码片段。\n\n\n\n语法\n描述\n\n\n\n~{templatename}\n引用整个模板文件的代码片段\n\n\n~{templatename :: selector}\nselector 可以是 th:fragment 指定的名称或其他选择器。 如类选择器、ID选择器等\n\n\n~{::selector}\n相当于 ~{this :: selector}，表示引用当前模板定义的代码片段\n\n\n在 Thymeleaf 模板文件中，你可以使用th:fragment属性来定义一段公共的代码片段，然后你可以通过使用th:insert、th:replace、th:include（Thymeleaf 3.0 开始不再推荐使用，本文也将不再介绍它）属性来将这些公共的代码片段引入到模板文件中来。\nsrc/main/resources/templates/base.html，通过th:fragment属性定义一段公共的代码片段：\n&lt;div id&#x3D;&quot;footer&quot; th:fragment&#x3D;&quot;footerFragment&quot;&gt;&amp;copy; 2017 fanlychie&lt;&#x2F;div&gt;\n\nsrc/main/resources/templates/index.html，通过th:insert属性引用一段公共的代码片段：\n&lt;div th:insert&#x3D;&quot;~&#123;base :: footerFragment&#125;&quot;&gt;&lt;&#x2F;div&gt;\n\n其中，~&#123;&#125;是可选的，我们可以去掉这层的包裹：\n&lt;div th:insert&#x3D;&quot;base :: footerFragment&quot;&gt;&lt;&#x2F;div&gt;\n\n若 index.html 与 base.html 不在同级目录，如 templates/commons/base.html：\n&lt;div th:insert&#x3D;&quot;~&#123;commons&#x2F;base :: footerFragment&#125;&quot;&gt;&lt;&#x2F;div&gt;\n\n使用th:fragment属性定义代码片段时，你还可以声明一组参数：\n&lt;div th:fragment&#x3D;&quot;crumbs(parent, child)&quot;&gt;\n    &lt;i th:text&#x3D;&quot;$&#123;parent&#125;&quot;&gt;&lt;&#x2F;i&gt; &lt;i th:text&#x3D;&quot;$&#123;child&#125;&quot;&gt;&lt;&#x2F;i&gt;\n&lt;&#x2F;div&gt;\n    \n&lt;!--\n&lt;i&gt;用户中心&lt;&#x2F;i&gt;\n&lt;i&gt;我的订单&lt;&#x2F;i&gt;\n--&gt;\n&lt;div th:insert&#x3D;&quot;::crumbs(&#39;用户中心&#39;, &#39;我的订单&#39;)&quot;&gt;&lt;&#x2F;div&gt;\n\n此外，我们还可以通过类选择器、ID选择器等来引用公共的代码片段：\n&lt;div th:insert&#x3D;&quot;~&#123;base :: #footer&#125;&quot;&gt;&lt;&#x2F;div&gt;\n\n除了th:insert属性th:replace也可以用来引用公共的代码片段。不同的是，th:insert是直接将代码片段插入到标签体内，而th:replace则是用代码片段直接替换标签体内容。\n&lt;!--\n&lt;div&gt;\n    &lt;div id&#x3D;&quot;footer&quot;&gt;© 2017 fanlychie&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n--&gt;\n&lt;div th:insert&#x3D;&quot;~&#123;base :: footerFragment&#125;&quot;&gt;&lt;&#x2F;div&gt;\n    \n&lt;!--\n&lt;div id&#x3D;&quot;footer&quot;&gt;© 2017 fanlychie&lt;&#x2F;div&gt;\n--&gt;\n&lt;div th:replace&#x3D;&quot;~&#123;base :: footerFragment&#125;&quot;&gt;&lt;&#x2F;div&gt;\n\n2.1.6 内置对象\n\n\n对象\n描述\n\n\n\n#ctx\n上下文对象\n\n\n#vars\n同 #ctx，表示上下文变量\n\n\n#locale\n上下文本地化（特定的地理区域）变量，可参考 java.util.Locale\n\n\n#request\nHttpServletRequest 对象，可参考 javax.servlet.http.HttpServletRequest\n\n\n#response\nHttpServletResponse 对象，可参考 javax.servlet.http.HttpServletResponse\n\n\n#session\nHttpSession 对象，可参考 javax.servlet.http.HttpSession\n\n\n#servletContext\nServletContext 对象，可参考 javax.servlet.ServletContext\n\n\n#ctx示例：\n&lt;!-- zh_CN --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#ctx.getLocale()&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- Welcome to BeiJing! --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#ctx.getVariable(&#39;message&#39;)&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- true --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#ctx.containsVariable(&#39;message&#39;)&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n#vars示例：\n&lt;!-- zh_CN --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#vars.getLocale()&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- Welcome to BeiJing! --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#vars.getVariable(&#39;message&#39;)&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- true --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#vars.containsVariable(&#39;message&#39;)&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n#locale示例：\n&lt;!-- zh_CN --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#locale&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- CN --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#locale.country&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- 中国 --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#locale.displayCountry&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- zh --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#locale.language&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- 中文 --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#locale.displayLanguage&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- 中文 (中国) --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#locale.displayName&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n#request示例：\n&lt;!-- HTTP&#x2F;1.1 --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#request.protocol&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- http --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#request.scheme&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- localhost --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#request.serverName&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- 8080 --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#request.serverPort&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- GET --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#request.method&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- &#x2F;standard-expression-syntax&#x2F;variables --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#request.requestURI&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- http:&#x2F;&#x2F;localhost:8080&#x2F;standard-expression-syntax&#x2F;variables --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#request.requestURL&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- &#x2F;standard-expression-syntax&#x2F;variables --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#request.servletPath&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- java.util.Collections$3@203646fe --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#request.parameterNames&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- &#123;q&#x3D;[Ljava.lang.String;@3308c69f&#125; --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#request.parameterMap&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- q&#x3D;expression --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#request.queryString&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n注意，请求地址的 URL 参数直接通过#request.x是取不出来的，需要使用param.x语法来取出。如，URL：/standard-expression-syntax/variables?q=expression，取出 q 参数的正确姿势：\n&lt;p th:text&#x3D;&quot;$&#123;param.q&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n#response示例：\n&lt;!-- 200 --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#response.status&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- 8192 --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#response.bufferSize&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- UTF-8 --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#response.characterEncoding&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- text&#x2F;html;charset&#x3D;UTF-8 --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#response.contentType&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n#session示例：\n&lt;!-- 2BCB2A0EACFF2D9D249D9799431B5127 --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#session.id&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- 1499786693244 --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#session.lastAccessedTime&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- fanlychie --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#session.getAttribute(&#39;user&#39;).name&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n注意，放到会话里面的对象直接通过#session.x是取不出来的，需要使用session.x语法来取出。如，取出会话里面的 user 对象的正确姿势：\n&lt;p th:text&#x3D;&quot;$&#123;session.user.name&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n2.1.7 工具类\n\n\n对象\n描述\n\n\n\n#messages\n消息工具类，与 ＃{…} 作用相同\n\n\n#uris\n地址相关的工具类\n\n\n#conversions\n对象转换工具类\n\n\n#dates\n日期时间工具类\n\n\n#calendars\n日历工具类\n\n\n#numbers\n数字工具类\n\n\n#strings\n字符串工具类\n\n\n#objects\n对象工具类\n\n\n#bools\n布尔工具类\n\n\n#arrays\n数组工具类\n\n\n#lists\nList 工具类\n\n\n#sets\nSet 工具类\n\n\n#maps\nMap 工具类\n\n\n#aggregates\n在数组或集合上创建聚合的实用方法\n\n\n&lt;!-- false --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#strings.isEmpty(message)&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- 2017-07-12 00:37:25 --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;#dates.format(now, &#39;yyyy-MM-dd HH:mm:ss&#39;)&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n&#x2F;*\n * Compute sum. Returns null if array or collection is empty\n *&#x2F;\n$&#123;#aggregates.sum(array)&#125;\n$&#123;#aggregates.sum(collection)&#125;\n\n&#x2F;*\n * Compute average. Returns null if array or collection is empty\n *&#x2F;\n$&#123;#aggregates.avg(array)&#125;\n$&#123;#aggregates.avg(collection)&#125;\n\n[[$&#123;#aggregates.sum(session.cart.cartItemMap.&#123;price * buyCount&#125;)&#125;]]\n\n2.1.8 内置方法\nstrings：字符串格式化方法，常用的Java方法它都有。比如：equals，equalsIgnoreCase，length，trim，toUpperCase，toLowerCase，indexOf，substring，replace，startsWith，endsWith，contains，containsIgnoreCase等\nnumbers：数值格式化方法，常用的方法有：formatDecimal等\nbools：布尔方法，常用的方法有：isTrue，isFalse等\narrays：数组方法，常用的方法有：toArray，length，isEmpty，contains，containsAll等\nlists，sets：集合方法，常用的方法有：toList，size，isEmpty，contains，containsAll，sort等\nmaps：对象方法，常用的方法有：size，isEmpty，containsKey，containsValue等\ndates：日期方法，常用的方法有：format，year，month，hour，createNow等\naggregates:    在数组或集合上创建聚合的实用方法，sum，avg（就这俩）\n\n2.2 字面值所谓字面值，首先它不是一个变量，它是一个具体的确切的值，通常这些值是比较简单的，例如：18、&#39;welcome&#39;等，它们没有名称，以至于我们只能用值来称呼它们，因此我们称其为字面值。\n2.2.1 文字字面值文字字面值是用单引号引起来的任何字符内容，如果字符内容里面含有单引号，则需要进行转义：\n&lt;!-- Welcome to BeiJing! --&gt;\n&lt;p th:text&#x3D;&quot;&#39;Welcome to BeiJing!&#39;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- &#39;Welcome to BeiJing!&#39; --&gt;\n&lt;p th:text&#x3D;&quot;&#39;\\&#39;Welcome to BeiJing!\\&#39;&#39;&quot;&gt;&lt;&#x2F;p&gt;\n\n2.2.2 数字字面值&lt;!-- 2017 --&gt;\n&lt;p th:text&#x3D;&quot;2017&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- 2018 --&gt;\n&lt;p th:text&#x3D;&quot;2017 + 1&quot;&gt;&lt;&#x2F;p&gt;\n\n2.2.3 布尔字面值&lt;!-- false --&gt;\n&lt;p th:text&#x3D;&quot;1 &gt; 2&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- 否 --&gt;\n&lt;p th:text&#x3D;&quot;1 &gt; 2 ? &#39;是&#39; : &#39;否&#39;&quot;&gt;&lt;&#x2F;p&gt;\n\n2.2.4 空字面值&lt;!-- false --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;user &#x3D;&#x3D; null&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n2.2.5 字面令牌字面令牌（Literal Tokens）的内容只能含有（不能含有空格、特殊符号等）：\n\n大写或小写的字母、中文等不含空格和特殊符号的文本\n0 到 9 的数字\n中括号\n下划线\n连字符（-）\n点符号（.）\n\n实际上，数字、布尔和空字面值都是字面令牌的特殊情况。字面令牌能够用来对标准表达式语法进行简化，我们可以将包裹它的内容的单引号去掉：\n&lt;p th:text&#x3D;&quot;Welcome to BeiJing!&quot;&gt;&lt;&#x2F;p&gt;\n\n它等效于：\n&lt;p th:text&#x3D;&quot;&#39;Welcome to BeiJing!&#39;&quot;&gt;&lt;&#x2F;p&gt;\n\n2.3 文本操作我们可以对文本内容进行两种常用的操作，它们分别为字符串连接和字符串替换。\n2.3.1 字符串连接不管是字面值还是表达式的结果，我们都可以使用+符号将它们连接起来：\n&lt;!-- Welcome to BeiJing! --&gt;\n&lt;p th:text&#x3D;&quot;&#39;Welcome to &#39; + $&#123;location&#125; + &#39;!&#39;&quot;&gt;&lt;&#x2F;p&gt;\n\n2.3.2 字面值替换符号||可以用来将字面值和表达式包裹起来，这样就能方便的替换变量的值，而不需要使用+连接符：\n&lt;!-- Welcome to BeiJing! --&gt;\n&lt;p th:text&#x3D;&quot;|Welcome to $&#123;location&#125;!|&quot;&gt;&lt;&#x2F;p&gt;\n\n2.4 算术运算支持+（加）、-（减）、*（乘）、/（除）、%（模）运算：\n&lt;!-- 6 --&gt;\n&lt;p th:text&#x3D;&quot;4 + 2&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- 2 --&gt;\n&lt;p th:text&#x3D;&quot;4 - 2&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- 8 --&gt;\n&lt;p th:text&#x3D;&quot;4 * 2&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- 2 --&gt;\n&lt;p th:text&#x3D;&quot;4 &#x2F; 2&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- 0 --&gt;\n&lt;p th:text&#x3D;&quot;4 % 2&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- 2 --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;pagination.page + 1&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- 2 --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;pagination.page&#125; + 1&quot;&gt;&lt;&#x2F;p&gt;\n\n2.5 布尔运算支持and（且）、or（或）、!（非）、not（非）运算：\n&lt;p th:text&#x3D;&quot;$&#123;user.online and user.vip&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;p th:text&#x3D;&quot;$&#123;user.online or user.vip&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;p th:text&#x3D;&quot;$&#123;!user.online&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;p th:text&#x3D;&quot;$&#123;not user.online&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n2.6 比较和相等支持&lt;（lt）、&gt;（gt）、&lt;=（le）、&gt;=（ge）、==（eq）、！=（ne）：\n&lt;p th:text&#x3D;&quot;$&#123;user.age &lt; 60&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;p th:text&#x3D;&quot;$&#123;user.age &lt;&#x3D; 60&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;p th:text&#x3D;&quot;$&#123;user.age &gt; 18&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;p th:text&#x3D;&quot;$&#123;user.age &gt;&#x3D; 18&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;p th:text&#x3D;&quot;$&#123;user.age &#x3D;&#x3D; 18&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;p th:text&#x3D;&quot;$&#123;user.age !&#x3D; 18&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n2.7 条件运算三元运算符：(if) ? (then) : (else)\n&lt;p th:text&#x3D;&quot;$&#123;user.online ? &#39;在线&#39; : &#39;离线&#39;&#125;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;p th:text&#x3D;&quot;$&#123;user.online ? (user.vip ? &#39;VIP用户在线&#39; : &#39;普通用户在线&#39;) : &#39;离线&#39;&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n二元运算符：(value) ?: (defaultValue)。\n其中，value非空（null）即真，条件为真时输出value，否则输出defaultValue。假设token = null，user.email = fanlychie@gmail.com\n&lt;!-- 你还没有登录，请先登录 --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;token&#125; ?: &#39;你还没有登录，请先登录&#39;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;!-- fanlychie@gmail.com --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;user.email&#125; ?: &#39;你还没有绑定邮箱&#39;&quot;&gt;&lt;&#x2F;p&gt;\n\n2.8 无操作符当模板运行在服务器端时，Thymeleaf 会解析th:*属性的具体值替换标签体的内容。无操作符（_）则允许你使用原型标签体的内容作为默认值：\n&lt;!-- 你还没有登录，请先登录 --&gt;\n&lt;p th:text&#x3D;&quot;$&#123;token&#125; ?: _&quot;&gt;你还没有登录，请先登录&lt;&#x2F;p&gt;\n\n3. 使用文本首先介绍两个最基础的th:*属th:text和th:utext，它们都是用于处理文本消息内容。\n3.1 th:text在标签体中展示表达式评估结果的文本内容：\n&lt;p th:text&#x3D;&quot;$&#123;message&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\n使用外部化的文本内容：\n&lt;p th:text&#x3D;&quot;$&#123;message&#125;&quot;&gt;Welcome to BeiJing!&lt;&#x2F;p&gt;\n\n当它作为静态文件直接运行时，浏览器会自动忽略它不能识别的th:text属性，而显示&lt;p&gt;标签体的文本内容Welcome to BeiJing!\n当它作为模板文件运行在服务器端时，th:text属性的具体值将会替换&lt;p&gt;标签体的文本内容。\n3.2 th:utext属性th:utext与th:text的区别在于：\n\nth:text默认会对含有 HTML 标签的内容进行字符转义；\nth:utext（Unescaped Text）则不会对含有 HTML 标签的内容进行字符转义；\n\n假设：message = &quot;&lt;b&gt;Welcome to BeiJing!&lt;/b&gt;&quot;。\n使用th:text属性：\n&lt;p th:text&#x3D;&quot;$&#123;message&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\nth:text效果：Welcome to BeiJing!\n使用th:utext属性：\n&lt;p th:utext&#x3D;&quot;$&#123;message&#125;&quot;&gt;&lt;&#x2F;p&gt;\n\nth:utext效果：Welcome to BeiJing!\n4. 设置属性值在 Thymeleaf 模板文件中，你可以使用th:*（或者使用th:attr属性）来设置任意的 HTML5 标签属性的值。不仅如此，你还可以th:*-*来同时为多个不同的标签属性设置相同的一个值，甚至你可以使用th:attrappend和th:attrprepend来追加新的值到现有的标签属性值中。\n4.0. th属性\n\n\n关键字\n功能介绍\n例子\n\n\n\nth:id\n设置当前元素的Id，如果存在则覆盖\n&lt;div th:id=&quot;$&#123;值&#125;&quot;&gt;&lt;/div&gt;\n\n\nth:text\n设置当前元素的文本内容\n&lt;div th:text=&quot;$&#123;值&#125;&quot;&gt;&lt;/div&gt;\n\n\nth:object\n一般用来接受后端传给前端的对象，一般用来配合th:field\n&lt;divth:object=&quot;$&#123;值&#125;&quot;&gt;&lt;/div&gt;\n\n\nth:field\n设置当前元素Value值，并且赋予当前元素id值和name，值为你所绑定的数值名称，一般写在th:object的元素内\n&lt;div th:field=&quot;*&#123;值&#125;&quot;&gt;&lt;/div&gt;\n\n\nth:value\n设置当前元素的Value值\n&lt;div th:value=&quot;$&#123;值&#125;&quot;&gt;&lt;/div&gt;\n\n\nth:onclick\n和原生onclick事件一样，加了th可以传递参数时候可以用Thymeleaf的函数值\n&lt;button th:onclick=&quot;方法名(值)&quot;&gt;&lt;/button&gt;\n\n\nth:each\n循环当前元素，可以名.取到你想要的值（如果值是一个对象的话）\n&lt;div th:each=&quot;名:$&#123;值&#125;&quot;&gt;&lt;/div&gt;\n\n\nth:if\n条件成立则显示，否则不显示\n&lt;div th:if=&quot;*&#123;num==50&#125;&quot;&gt;等于50&lt;/div&gt;\n\n\nth:href\n效果等同于原生href，但稍有不同。原生始终从端口号开始作为跟路径，th:href会寻找项目路径作为根路径。\n&lt;a th:href=&quot;地址&quot;&gt;&lt;/a&gt;\n\n\nth:src\n图片类地址引入\n&lt;img th:src=&#39;@&#123;/DemoJpg/main.jpg&#125;&#39; &gt;\n\n\nth:switch\n和java用法一样，取一个值配合case使用\n&lt;div th:switch=&quot;*&#123;num&#125;&quot;&gt;&lt;/div&gt;\n\n\nth:case\n写在对应的th:switch元素内，不符合条件的隐藏，只显示符合的\n&lt;span th:case=&quot;10&quot;&gt;我是10&lt;/span&gt;\n\n\nth:inline\n写在script标签上，使得js脚本可以使用Thymeleaf变量 [[${放到这里！}]]\n&lt;script th:inline=&quot;javascript&quot;&gt;&lt;/script&gt;\n\n\nth:fragment\n生成一个当前元素的模板，可以供其他页面使用（一般用来导入公共部分）\n&lt;div th:fragment=&quot;one&quot; style=&quot;&quot;&gt;&lt;/div&gt;\n\n\nth:insert\n把模板所有的代码块插入到该元素标签内（包含th:fragment声明的标签）\n&lt;div th:insert=&quot;Html名字:: one&quot;&gt;&lt;/div&gt;\n\n\nth:replace\n把该元素替换为模板代码（不包含原元素标签）\n&lt;div th:replace=&quot;Html名字:: one&quot;&gt;&lt;/div&gt;\n\n\nth:include\n把该元素的内容替换为模板代码（包含原元素标签。不包含th:fragment声明的标签）\n&lt;div th:include=&quot;Html名字:: one&quot;&gt;&lt;/div&gt;\n\n\nth:selected\n设置在select上，用来给option赋值来选择对应的值的下拉框\n&lt;div th:text=&quot;$&#123;值&#125;&quot;&gt;&lt;/div&gt;\n\n\n4.1 th:attr这种方式是不被推荐的，了解一下就行。下面是用th:attr=&quot;href=...&quot;来设置标签href属性的值：\n&lt;a th:attr&#x3D;&quot;href&#x3D;@&#123;https:&#x2F;&#x2F;www.google.com.hk&#125;&quot;&gt;谷歌一下你就知道&lt;&#x2F;a&gt;\n\n4.2 th:*显然th:attr=&quot;href=@&#123;http://www.baidu.com&#125;&quot;不够简洁，我们更推荐下面的这种语法：\n&lt;a th:href&#x3D;&quot;@&#123;https:&#x2F;&#x2F;www.google.com.hk&#125;&quot;&gt;谷歌一下你就知道&lt;&#x2F;a&gt;\n\n其中th:*中的*可以是 HTML5 支持的任意属性名称，甚至这些属性名称可以是自定义的：\n&lt;!-- &lt;div item-id&#x3D;&quot;1001&quot;&gt;Welcome to BeiJing!&lt;&#x2F;div&gt; --&gt;\n&lt;div th:item-id&#x3D;&quot;$&#123;user.id&#125;&quot;&gt;Welcome to BeiJing!&lt;&#x2F;div&gt;\n\n4.3 th:-如果想要同时为标签的多个不同属性设置相同的一个值，可以使用th:*-*的语法：\n&lt;img src&#x3D;&quot;logo.png&quot; th:alt-title&#x3D;&quot;LOGO图片&quot;&gt;\n\n它相当于：\n&lt;img src&#x3D;&quot;logo.png&quot; th:alt&#x3D;&quot;LOGO图片&quot; th:title&#x3D;&quot;LOGO图片&quot;&gt;\n\n4.4 th:attrappend &amp; th:attrprependth:attrappend和th:attrprepend可以将表达式的结果分别追加到指定的属性值之后和之前。\n&lt;!-- &lt;button class&#x3D;&quot;btn enable&quot;&gt;购买&lt;&#x2F;button&gt; --&gt;\n&lt;button class&#x3D;&quot;btn&quot; th:attrappend&#x3D;&quot;class&#x3D;$&#123;outOfStock&#125; ? &#39; enable&#39; : &#39; disable&#39;&quot;&gt;购买&lt;&#x2F;button&gt;\n&lt;!-- &lt;button class&#x3D;&quot;enable btn&quot;&gt;购买&lt;&#x2F;button&gt; --&gt;\n&lt;button class&#x3D;&quot;btn&quot; th:attrprepend&#x3D;&quot;class&#x3D;$&#123;outOfStock&#125; ? &#39;enable &#39; : &#39;disable &#39;&quot;&gt;购买&lt;&#x2F;button&gt;\n\n另外，还有两个常用的具体附加属性th:classappend=&quot;...&quot;和th:styleappend=&quot;&quot;。\n它们分别用来代替th:attrappend=&quot;class=...&quot;和th:attrappend=&quot;style=...&quot;。\n&lt;!-- &lt;button class&#x3D;&quot;btn enable&quot;&gt;购买&lt;&#x2F;button&gt; --&gt;\n&lt;button class&#x3D;&quot;btn&quot; th:classappend&#x3D;&quot;$&#123;outOfStock&#125; ? &#39; enable&#39; : &#39; disable&#39;&quot;&gt;购买&lt;&#x2F;button&gt;\n\n4.5 布尔属性在 HTML 中有些属性是布尔属性，布尔属性是指没有值的属性，如readonly、checked、selected等。它们若存在那就意味着值为 true。\n&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;rememberme&quot; checked &#x2F;&gt; 记住我\n&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;sex&quot; value&#x3D;&quot;male&quot; checked&gt; 男\n&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;sex&quot; value&#x3D;&quot;female&quot;&gt; 女\n&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;appId&quot; value&#x3D;&quot;J123654&quot; readonly&gt;\n&lt;select&gt;\n    &lt;option selected&gt;北京&lt;&#x2F;option&gt;\n    &lt;option&gt;上海&lt;&#x2F;option&gt;\n    &lt;option&gt;广州&lt;&#x2F;option&gt;\n    &lt;option&gt;深圳&lt;&#x2F;option&gt;\n&lt;&#x2F;select&gt;\n\nThymeleaf 也允许我们通过th:*（这里的*表示任意的布尔属性） 来选择是否使用这些布尔属性。\n&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;rememberme&quot; ch:checked&#x3D;&quot;$&#123;rememberme&#125;&quot; &#x2F;&gt; 记住我\n\n正如你所见，如果表达式的结果为true，则自动勾选复选框，若为false，则不会自动勾选。\n5. 遍历遍历（迭代）的语法th:each=&quot;自定义的元素变量名称 : $&#123;集合变量名称&#125;&quot;：\n&lt;div&gt;\n    &lt;spn&gt;你所在城市：&lt;&#x2F;spn&gt;\n    &lt;select name&#x3D;&quot;mycity&quot;&gt;\n        &lt;option th:each&#x3D;&quot;city : $&#123;cities&#125;&quot; th:text&#x3D;&quot;$&#123;city.name&#125;&quot;&gt;&lt;&#x2F;option&gt;\n    &lt;&#x2F;select&gt;\n&lt;&#x2F;div&gt;\n\n属性th:each提供了一个用于跟踪迭代的状态变量，它包含以下几个属性：\n\n\n\n属性\n类型\n描述\n\n\n\nindex\nint\n当前迭代的索引，从 0 开始\n\n\ncount\nint\n当前迭代的计数，从 1 开始\n\n\nsize\nint\n集合中元素的总个数\n\n\ncurrent\nint\n当前的元素对象\n\n\neven\nboolean\n当前迭代的计数是否是偶数\n\n\nodd\nboolean\n当前迭代的计数是否是奇数\n\n\nfirst\nboolean\n当前元素是否是集合的第一个元素\n\n\nlast\nboolean\n当前元素是否是集合的最后一个元素\n\n\n状态变量的使用语法：th:each=&quot;自定义的元素变量名称, 自定义的状态变量名称 : $&#123;集合变量名称&#125;&quot;：\n&lt;div&gt;\n    &lt;spn&gt;所在城市：&lt;&#x2F;spn&gt;\n    &lt;select name&#x3D;&quot;mycity&quot;&gt;\n        &lt;option th:each&#x3D;&quot;city, status : $&#123;cities&#125;&quot; th:text&#x3D;&quot;$&#123;city.name&#125;&quot; th:item-index&#x3D;&quot;$&#123;status.count&#125;&quot;&gt;&lt;&#x2F;option&gt;\n    &lt;&#x2F;select&gt;\n&lt;&#x2F;div&gt;\n\n不管什么时候，Thymeleaf 始终会为每个th:each创建一个状态变量，默认的状态变量名称就是自定义的元素变量名称后面加Stat字符串组成：\n&lt;div&gt;\n    &lt;spn&gt;所在城市：&lt;&#x2F;spn&gt;\n    &lt;select name&#x3D;&quot;mycity&quot;&gt;\n        &lt;option th:each&#x3D;&quot;city : $&#123;cities&#125;&quot; th:text&#x3D;&quot;$&#123;city.name&#125;&quot; th:item-index&#x3D;&quot;$&#123;cityStat.count&#125;&quot;&gt;&lt;&#x2F;option&gt;\n    &lt;&#x2F;select&gt;\n&lt;&#x2F;div&gt;\n\n6. 条件判断条件判断语句有三种，分别是：th:if、th:unless、th:swith。\n6.1 th:if当表达式的评估结果为真时则显示内容，否则不显示：\n&lt;a th:href&#x3D;&quot;@&#123;&#x2F;user&#x2F;order(uid&#x3D;$&#123;user.id&#125;)&#125;&quot; th:if&#x3D;&quot;$&#123;user !&#x3D; null&#125;&quot;&gt;我的订单&lt;&#x2F;a&gt;\n\n真假评估的依据：\n\n当表达式的值不为空（null）时\n如果表达式的值是一个布尔类型，且值为true评估为真，否则为假\n如果表达式的值是一个数字类型，且值为非0评估为真，否则为假\n如果表达式的值是一个字符类型，且值为非0评估为真，否则为假\n如果表达式的值是一个字符串类型，且值为非&quot;false&quot;、&quot;off&quot;、&quot;no&quot;评估为真，否则为假\n如果表达式的值不是一个布尔、数字、字符或字符串评估为真\n\n\n当表达式的值为空（null）时，评估结果为假\n\n因此，上面代码我们也可以简写成：\n&lt;a th:href&#x3D;&quot;@&#123;&#x2F;user&#x2F;order(uid&#x3D;$&#123;user.id&#125;)&#125;&quot; th:if&#x3D;&quot;$&#123;user&#125;&quot;&gt;我的订单&lt;&#x2F;a&gt;\n\n但是，为了代码的可读性，我们并不建议这样使用。\n6.2 th:unlessth:unless与th:if判断恰好相反，当表达式的评估结果为假时则显示内容，否则不显示：\n&lt;a th:href&#x3D;&quot;@&#123;&#x2F;user&#x2F;order(uid&#x3D;$&#123;user.id&#125;)&#125;&quot; th:unless&#x3D;&quot;$&#123;user &#x3D;&#x3D; null&#125;&quot;&gt;我的订单&lt;&#x2F;a&gt;\n\n6.3 th:swith多路选择语句，它需要搭配th:case来使用：\n&lt;div th:switch&#x3D;&quot;$&#123;user.role&#125;&quot;&gt;\n    &lt;p th:case&#x3D;&quot;admin&quot;&gt;管理员&lt;&#x2F;p&gt;\n    &lt;p th:case&#x3D;&quot;user&quot;&gt;普通用户&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n\n7. 定义局部变量使用th:with属性可以定义局部变量：\n&lt;p th:with&#x3D;&quot;name&#x3D;&#39;fanlychie&#39;&quot;&gt;\n    &lt;span th:text&#x3D;&quot;$&#123;name&#125;&quot;&gt;&lt;&#x2F;span&gt;\n&lt;&#x2F;p&gt;\n\n同时定义多个局部变量时，用英文,号分隔开：\n&lt;p th:with&#x3D;&quot;name&#x3D;$&#123;user.name&#125;,age&#x3D;&#123;user.age&#125;&quot;&gt;\n    ......\n&lt;&#x2F;p&gt;\n\n8. 注释下面介绍常见的两种注释：\n8.1 标准注释语法：&lt;!-- ... ---&gt;，注释的代码块会在文件源代码中显示出来。\n8.1.1 单行注释&lt;!-- &lt;span&gt;$&#123;message&#125;&lt;&#x2F;span&gt; ---&gt;\n\n8.1.2 多行注释&lt;!--\n&lt;div th:switch&#x3D;&quot;$&#123;user.role&#125;&quot;&gt;\n    &lt;p th:case&#x3D;&quot;admin&quot;&gt;管理员&lt;&#x2F;p&gt;\n    &lt;p th:case&#x3D;&quot;user&quot;&gt;普通用户&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n---&gt;\n\n8.2 解析器级注释语法：&lt;!--/* ... */--&gt;，注释的代码块会在引擎解析的时候抹去。\n8.2.1 单行注释：&lt;!--&#x2F;* &lt;span&gt;$&#123;message&#125;&lt;&#x2F;span&gt; *&#x2F;--&gt;\n\n8.2.2 多行注释&lt;!--&#x2F;*--&gt;\n&lt;div th:switch&#x3D;&quot;$&#123;user.role&#125;&quot;&gt;\n    &lt;p th:case&#x3D;&quot;admin&quot;&gt;管理员&lt;&#x2F;p&gt;\n    &lt;p th:case&#x3D;&quot;user&quot;&gt;普通用户&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n&lt;!--*&#x2F;--&gt;\n\n9. 内联表达式内联表达式允许我们直接在 HTML 文本中使用标准表达式，而不需要使用th:*标签属性。\n9.1 [[…]][[]]相当于th:text，对含有 HTML 标签的内容自动进行字符转义。\n&lt;p&gt;The message is : [[$&#123;htmlContent&#125;]]&lt;&#x2F;p&gt;\n\n9.2 [(…)][()]相当于th:utext，对含有 HTML 标签的内容不进行字符转义。\n&lt;p&gt;The message is : [($&#123;htmlContent&#125;)]&lt;&#x2F;p&gt;\n\n9.3 th:inline我们已经了解到，使用[[]]和[()]语法可以直接在 HTML 文本中使用标准表达式，如果想要使用更多高级的功能，需要使用th:inline属性来激活，它的取值如下：\n\n\n\n值\n描述\n\n\n\nnone\n禁止内联表达式，可以原样输出 [[]] 和 [()] 字符串\n\n\ntext\n文本内联，可以使用 th:each 等高级语法\n\n\ncss\n样式内联，如：&lt;style th:inline=&quot;css&quot;&gt;\n\n\njavascript\n脚本内联，如：&lt;style th:inline=&quot;javascript&quot;&gt;\n\n\n9.3.1 none&lt;!-- [[1, 2], [3, 4]] --&gt;\n&lt;p th:inline&#x3D;&quot;none&quot;&gt;[[1, 2], [3, 4]]&lt;&#x2F;p&gt;\n\n9.3.2 text&lt;!-- 北京 上海 广州 深圳 --&gt;\n&lt;p th:inline&#x3D;&quot;text&quot;&gt;\n    [# th:each&#x3D;&quot;city : $&#123;cities&#125;&quot;]\n        [($&#123;city.name&#125;)]\n    [&#x2F;]\n&lt;&#x2F;p&gt;\n\n9.3.3 css&lt;style th:inline&#x3D;&quot;css&quot;&gt;\n    body &#123;\n        background-color:[[$&#123;bgColor&#125;]];\n    &#125;\n&lt;&#x2F;style&gt;\n\n9.3.4 javascript&lt;script th:inline&#x3D;&quot;javascript&quot;&gt;\n    var user &#x3D; [[$&#123;user&#125;]];\n    alert(&quot;用户名：&quot; + user.name);\n&lt;&#x2F;script&gt;\n\n\n\n10. 补充10.1 拼接字符串注意，不能在th:field中使用拼接\n thymeleaf th:value 可以使用+号拼接两个字符串\n&lt;div class&#x3D;&quot;col-sm-9&quot;&gt;\n    &lt;label th:each&#x3D;&quot;brand:$&#123;brands&#125;&quot; class&#x3D;&quot;check-box&quot;&gt;\n\n    &lt;input id&#x3D;&quot;brands&quot; name&#x3D;&quot;brands&quot; type&#x3D;&quot;checkbox&quot; th:value&#x3D;&quot;$&#123;brand.brandId&#125;+&#39;,&#39;+$&#123;brand.brandShortName&#125;&quot; th:text&#x3D;&quot;$&#123;brand.brandShortName&#125;&quot;&gt;\n\n    &lt;&#x2F;label&gt;\n&lt;&#x2F;div&gt;\n\n另外  可以使用||符号将需要需要拼接的字符串包起来：参考地址\n&lt;div class&#x3D;&quot;col-sm-9&quot;&gt;\n\n    &lt;label th:each&#x3D;&quot;brand:$&#123;brands&#125;&quot; class&#x3D;&quot;check-box&quot;&gt;\n\n    &lt;input id&#x3D;&quot;brands&quot; name&#x3D;&quot;brands&quot; type&#x3D;&quot;checkbox&quot; th:value&#x3D;&quot;|$&#123;brand.brandId&#125;,$&#123;brand.brandShortName&#125;|&quot; th:text&#x3D;&quot;$&#123;brand.brandShortName&#125;&quot;&gt;\n\n    &lt;&#x2F;label&gt;\n&lt;&#x2F;div&gt;\n\n","slug":"31-Thymeleaf","date":"2021-09-13T15:08:32.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"大黄"},{"id":"011b445bb73b7101b5e897c141561df0","title":"Regular Expression","content":"一、概述正则表达式用于文本内容的查找和替换。\n正则表达式内置于其它语言或者软件产品中，它本身不是一种语言或者软件。\n正则表达式在线工具\n二、匹配单个字符.   可以用来匹配任何的单个字符，但是在绝大多数实现里面，不能匹配换行符；\n.   是元字符，表示它有特殊的含义，而不是字符本身的含义。如果需要匹配 . ，那么要用 \\ 进行转义，即在 . 前面加上 \\ 。\n正则表达式一般是区分大小写的，但也有些实现不区分。\n正则表达式C.C2018\n\n匹配结果My name is   CyC2018  .\n三、匹配一组字符[ ]   定义一个字符集合；\n0-9、a-z 定义了一个字符区间，区间使用 ASCII 码来确定，字符区间在 [ ] 中使用。\n-   只有在 [ ] 之间才是元字符，在 [ ] 之外就是一个普通字符；\n^   在 [ ] 中是取非操作。\n应用  \n匹配以 abc 为开头，并且最后一个字母不为数字的字符串：\n正则表达式  \nabc[^0-9]\n\n匹配结果  \n\n  abcd  \nabc1\nabc2\n\n四、使用元字符4.1 匹配空白字符\n\n\n元字符\n说明\n\n\n\n[\\b]\n回退（删除）一个字符\n\n\n\\f\n换页符\n\n\n\\n\n换行符\n\n\n\\r\n回车符\n\n\n\\t\n制表符\n\n\n\\v\n垂直制表符\n\n\n\\r\\n 是 Windows 中的文本行结束标签，在 Unix/Linux 则是 \\n。\n\\r\\n\\r\\n 可以匹配 Windows 下的空白行，因为它匹配两个连续的行尾标签，而这正是两条记录之间的空白行；\n4.2 匹配特定的字符4.2.1 数字元字符\n\n\n元字符\n说明\n\n\n\n\\d\n数字字符，等价于 [0-9]\n\n\n\\D\n非数字字符，等价于 [^0-9]\n\n\n4.2.2 字母数字元字符\n\n\n元字符\n说明\n\n\n\n\\w\n大小写字母，下划线和数字，等价于 [a-zA-Z0-9_]\n\n\n\\W\n对 \\w 取非\n\n\n4.2.3 空白字符元字符\n\n\n元字符\n说明\n\n\n\n\\s\n任何一个空白字符，等价于 [\\f\\n\\r\\t\\v]\n\n\n\\S\n对 \\s 取非\n\n\n\\x 匹配十六进制字符，\\0 匹配八进制，例如 \\xA 对应值为 10 的 ASCII 字符 ，即 \\n。\n五、重复匹配\n  +   匹配 1 个或者多个字符\n  **  * 匹配 0 个或者多个字符\n  ?   匹配 0 个或者 1 个字符\n\n应用  \n匹配邮箱地址。\n正则表达式  \n[\\w.]+@\\w+\\.\\w+\n\n[\\w.] 匹配的是字母数字或者 . ，在其后面加上 + ，表示匹配多次。在字符集合 [ ] 里，. 不是元字符；\n匹配结果  \nabc.def&lt;span&gt;@&lt;/span&gt;qq.com  \n\n  {n}   匹配 n 个字符\n  {m,n}   匹配 m~n 个字符\n  {m,}   至少匹配 m 个字符\n\n* 和 + 都是贪婪型元字符，会匹配尽可能多的内容。在后面加 ? 可以转换为懒惰型元字符，例如 *?、+? 和 {m,n}? 。\n正则表达式  \na.+c\n\n匹配结果  \nabcabcabc  \n由于 + 是贪婪型的，因此 .+ 会匹配更可能多的内容，所以会把整个 abcabcabc 文本都匹配，而不是只匹配前面的 abc 文本。用懒惰型可以实现匹配前面的。\n六、位置匹配单词边界\\b   可以匹配一个单词的边界，边界是指位于 \\w 和 \\W 之间的位置；\\B 匹配一个不是单词边界的位置。\n\\b 只匹配位置，不匹配字符，因此 \\babc\\b 匹配出来的结果为 3 个字符。\n字符串边界^   匹配整个字符串的开头，**$** 匹配结尾。\n^ 元字符在字符集合中用作求非，在字符集合外用作匹配字符串的开头。\n分行匹配模式（multiline）下，换行被当做字符串的边界。\n应用  \n匹配代码中以 // 开始的注释行\n正则表达式  \n^\\s*\\&#x2F;\\&#x2F;.*$\n\n匹配结果  \n\npublic void fun() {\n      // 注释 1  \n    int a = 1;\n    int b = 2;\n      // 注释 2  \n    int c = a + b;\n}\n\n七、使用子表达式使用   ( )   定义一个子表达式。子表达式的内容可以当成一个独立元素，即可以将它看成一个字符，并且使用 * 等元字符。\n子表达式可以嵌套，但是嵌套层次过深会变得很难理解。\n正则表达式  \n(ab)&#123;2,&#125;\n\n匹配结果  \nababab  \n|   是或元字符，它把左边和右边所有的部分都看成单独的两个部分，两个部分只要有一个匹配就行。\n正则表达式  \n(19|20)\\d&#123;2&#125;\n\n匹配结果  \n\n  1900  \n  2010  \n1020\n\n应用  \n匹配 IP 地址。\nIP 地址中每部分都是 0-255 的数字，用正则表达式匹配时以下情况是合法的：\n\n一位数字\n不以 0 开头的两位数字\n1 开头的三位数\n2 开头，第 2 位是 0-4 的三位数\n25 开头，第 3 位是 0-5 的三位数\n\n正则表达式  \n((25[0-5]|(2[0-4]\\d)|(1\\d&#123;2&#125;)|([1-9]\\d)|(\\d))\\.)&#123;3&#125;(25[0-5]|(2[0-4]\\d)|(1\\d&#123;2&#125;)|([1-9]\\d)|(\\d))\n\n匹配结果  \n\n  192.168.0.1  \n00.00.00.00\n555.555.555.555\n\n八、回溯引用回溯引用使用   \\n   来引用某个子表达式，其中 n 代表的是子表达式的序号，从 1 开始。它和子表达式匹配的内容一致，比如子表达式匹配到 abc，那么回溯引用部分也需要匹配 abc 。\n8.1 应用匹配 HTML 中合法的标题元素。\n正则表达式\n\\1 将回溯引用子表达式 (h[1-6]) 匹配的内容，也就是说必须和子表达式匹配的内容一致。\n&lt;(h[1-6])&gt;\\w*?&lt;\\&#x2F;\\1&gt;\n\n匹配结果  \n\n  &lt;h1&gt;x&lt;/h1&gt;  \n  &lt;h2&gt;x&lt;/h2&gt;  \n&lt;h3&gt;x&lt;/h1&gt;\n\n8.2 替换需要用到两个正则表达式。\n应用  \n修改电话号码格式。\n文本  \n313-555-1234\n查找正则表达式  \n(\\d&#123;3&#125;)(-)(\\d&#123;3&#125;)(-)(\\d&#123;4&#125;)\n\n替换正则表达式  \n在第一个子表达式查找的结果加上 () ，然后加一个空格，在第三个和第五个字表达式查找的结果中间加上 - 进行分隔。\n($1) $3-$5\n\n结果  \n(313) 555-1234\n8.3 大小写转换\n\n\n元字符\n说明\n\n\n\n\\l\n把下个字符转换为小写\n\n\n\\u\n把下个字符转换为大写\n\n\n\\L\n把\\L 和\\E 之间的字符全部转换为小写\n\n\n\\U\n把\\U 和\\E 之间的字符全部转换为大写\n\n\n\\E\n结束\\L 或者\\U\n\n\n应用  \n把文本的第二个和第三个字符转换为大写。\n文本  \nabcd\n查找  \n(\\w)(\\w&#123;2&#125;)(\\w)\n\n替换  \n$1\\U$2\\E$3\n\n结果  \naBCd\n九、前后查找前后查找规定了匹配的内容首尾应该匹配的内容，但是又不包含首尾匹配的内容。\n向前查找使用   ?=   定义，它规定了尾部匹配的内容，这个匹配的内容在 ?= 之后定义。所谓向前查找，就是规定了一个匹配的内容，然后以这个内容为尾部向前面查找需要匹配的内容。向后匹配用 ?&lt;= 定义（注: JavaScript 不支持向后匹配，Java 对其支持也不完善）。\n应用  \n查找出邮件地址 @ 字符前面的部分。\n正则表达式  \n\\w+(?&#x3D;@)\n\n结果  \nabc  @qq.com\n对向前和向后查找取非，只要把 = 替换成 ! 即可，比如 (?=) 替换成 (?!) 。取非操作使得匹配那些首尾不符合要求的内容。\n十、嵌入条件10.1 回溯引用条件条件为某个子表达式是否匹配，如果匹配则需要继续匹配条件表达式后面的内容。\n正则表达式  \n子表达式 (\\() 匹配一个左括号，其后的 ? 表示匹配 0 个或者 1 个。 ?(1) 为条件，当子表达式 1 匹配时条件成立，需要执行 ) 匹配，也就是匹配右括号。\n(\\()?abc(?(1)\\))\n\n结果  \n\n  (abc)  \n  abc  \n(abc\n\n10.2 前后查找条件条件为定义的首尾是否匹配，如果匹配，则继续执行后面的匹配。注意，首尾不包含在匹配的内容中。\n正则表达式  \n ?(?=-) 为前向查找条件，只有在以 - 为前向查找的结尾能匹配 \\d{5} ，才继续匹配 -\\d{4} 。\n\\d&#123;5&#125;(?(?&#x3D;-)-\\d&#123;4&#125;)\n\n结果  \n\n  11111  \n22222-\n  33333-4444  \n\n","slug":"30-Regular expression","date":"2021-09-13T15:07:32.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"大黄"},{"id":"423214af91a95c0f0996d8a59fd1a243","title":"Javascript 简单总结","content":"1. JavaScript的起源在1995年时，由Netscape公司的Brendan Eich，在网景导航者浏览器上首次设计实现而成。Netscape在最初将其脚本语言命名为LiveScript，因为Netscape与Sun合作，网景公司管理层希望蹭Java的热度，因此取名为JavaScript。\nJavaScript总共分成三部分: ECMAScript(基本语法)、BOM(浏览器对象模型)、DOM(文档对象模型)\n2. JavaScript的特性2.1 脚本语言JavaScript是一种解释型的脚本语言。不同于C、C++、Java等语言先编译后执行,    JavaScript不会产生编译出来的字节码文件，而是在程序的运行过程中对源文件逐行进行解释。\n2.2 基于对象JavaScript是一种基于对象的脚本语言，它不仅可以创建对象，也能使用现有的对象。但是面向对象的三大特性：『封装』、『继承』、『多态』中，JavaScript能够实现封装，可以模拟继承，不支持多态，所以它不是一门面向对象的编程语言。\n2.3 弱类型JavaScript中也有明确的数据类型，但是声明一个变量后它可以接收任何类型的数据，并且会在程序执行过程中根据上下文自动转换类型。\n2.4 事件驱动JavaScript是一种采用事件驱动的脚本语言，它不需要经过Web服务器就可以对用户的输入做出响应。\n2.5 跨平台性JavaScript脚本语言不依赖于操作系统，仅需要浏览器的支持。因此一个JavaScript脚本在编写后可以带到任意机器上使用，前提是机器上的浏览器支持JavaScript脚本语言。目前JavaScript已被大多数的浏览器所支持。\n3. 入门程序功能效果图\n\n\n代码实现\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;JS的入门程序&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    &lt;!-- 在HTML代码中定义一个按钮 --&gt;\n    &lt;button type&#x3D;&quot;button&quot; id&#x3D;&quot;helloBtn&quot;&gt;SayHello&lt;&#x2F;button&gt;\n    &lt;!--\n        目标: 点击按钮的时候弹出一个警告框\n    --&gt;\n    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n        &#x2F;&#x2F;1. 通过js代码获取到按钮对象\n        &#x2F;&#x2F;document代表当前HTML文档\n        var btn &#x3D; document.getElementById(&quot;helloBtn&quot;);\n\n        &#x2F;&#x2F;2. 给获取到的btn对象绑定点击事件\n        btn.onclick &#x3D; function () &#123;\n            &#x2F;&#x2F;弹出警告框\n            alert(&quot;hello world&quot;)\n        &#125;\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4. JavaScript的基本语法4.1 JavaScript的引入方式4.1.1 内部脚本方式\nJavaScript代码要写在script标签内\nscript标签可以写在文档内的任意位置\n为了能够方便查询或操作HTML标签（元素）script标签可以写在body标签后面\n\n在我们的入门程序中使用的就是内部脚本方式引入的JavaScript\n4.1.2 外部脚本方式在script标签内通过src属性指定外部xxx.js文件的路径即可。但是要注意以下两点：\n\n引用外部JavaScript文件的script标签里面不能写JavaScript代码\n先引入，再使用\nscript标签不能写成单标签\n\n4.1.3 js在html中的引入位置具体将引入的JS放在哪里与代码执行的顺序有关。网页文件的读取是从上到下的，如果将JavaScript文件放置在head当中，会先加载JS文件，之后再继续执行，那么此时，==如果JS文件比较大，页面加载就会比较慢，导致空白==。\n那么，如果将JavaScript文件放置在底部，如果说，也是比较大型的JS文件的话，是不是就没有问题了呢？\n其实，如果将JS文件放置在底部的话，可以让JS文件与图片几乎同时下载，使得页面当中的内容能够尽快的下载下来，但是，由于网页基本结构与样式均已经加载完成，那么此时负责交互的JS并没有下载下来，必然也会对用户的体验造成影响。\n==因此，整体来说，如果“交互性优先”，那么我们应当将JS放置在顶部。如果对于交互性要求没那么高的页面，我们将JS放置在底部。==\n引入方式如下\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;JS的引入方式&lt;&#x2F;title&gt;\n    &lt;!--\n        建议在head中引入外部的js文件\n    --&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;js&#x2F;outer.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n    &lt;!--\n        第一种引入方式: 内部引入方式，在HTML文档内部，通过script标签去编写js代码\n    --&gt;\n    &lt;!--\n        第二种引入方式: 外部引入方式，在当前项目中创建一个js文件，然后在需要引入的HTML里面使用script标签引入\n        一个script标签要么负责编写内部的js代码，要么负责引入外部的js文件\n    --&gt;\n    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n        &#x2F;&#x2F;调用外部js文件中的方法\n        showMessage()\n        alert(&quot;hello world&quot;)\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4.2 声明和使用变量4.2.1 JavaScript数据类型\n基本数据类型\n\n数值型number：JavaScript不区分整数、小数\n\n字符串string：JavaScript不区分字符、字符串；单引号、双引号意思一样。\n\n布尔型boolean：true、false\n在JavaScript中，其他类型和布尔类型的自动转换。\ntrue：非零的数值，非空字符串，非空对象\nfalse：零，空字符串，null，undefined \n例如：”false”放在if判断中\n&#x2F;&#x2F; &quot;false&quot;是一个非空字符串，直接放在if判断中会被当作『真』处理\nif(&quot;false&quot;)&#123;\n\talert(&quot;true&quot;);\n&#125;else&#123;\n\talert(&quot;false&quot;);\n&#125;\n\n\n引用类型\n\n所有new出来的对象\n用[]声明的数组\n用{}声明的对象\n\n\n\n4.2.2 变量\n==关键字：var,其实ECMAScript6之后建议使用let==   \n\nvar和let定义后都不需要立即赋值，但const声明变量后就要赋值\nlet和const都是块级元素，在自己的花括号内有用\nvar一般用来在方法外定义全局变量\n\n\n数据类型：JavaScript变量是弱类型的，可以接收任意类型的数据\n\n标识符：严格区分大小写\n\n变量使用规则\n\n如果使用了一个没有声明的变量，那么会在运行时报错\nUncaught ReferenceError: b is not defined\n\n如果声明一个变量没有初始化，那么这个变量的值就是undefined\n\n\n\n\n4.3 函数(重点)4.3.1 内置函数内置函数就是JavaScript中内置好的函数，我们可以直接使用\n\n弹出警告框\n\nalert(&quot;警告框内容&quot;);\n\n\n弹出确认框\n\nvar result &#x3D; confirm(&quot;确定要删除吗？&quot;);\nif(result) &#123;\n    &#x2F;&#x2F; 执行删除\n&#125;\n\n用户点击『确定』返回true，点击『取消』返回false\nvar result &#x3D; confirm(&quot;老板，你真的不加个钟吗？&quot;);\nif(result) &#123;\n\tconsole.log(&quot;老板点了确定，表示要加钟&quot;);\n&#125;else&#123;\n\tconsole.log(&quot;老板点了确定，表示不加钟&quot;);\n&#125;\n\n\n在控制台打印日志\n\nconsole.log(&quot;日志内容&quot;);\n\n\n4.3.2 声明函数声明函数就是使用者自己定义一个函数，它有两种写法:\n写法1：\nfunction sum(a, b) &#123;\n    return a+b;\n&#125;\n\n写法2：\nvar total &#x3D; function() &#123;\n    return a+b;\n&#125;;\n\n写法2可以这样解读：声明一个函数，相当于创建了一个『函数对象』，将这个对象的『引用』赋值给变量total。如果不给这个对象赋值，我们可以将其作为匿名函数使用(在后续学习内容中会用到)\n4.3.3 调用函数JavaScript中函数本身就是一种对象，函数名就是这个『对象』的『引用』。而调用函数的格式是：函数引用()。\nfunction sum(a, b) &#123;\n    return a+b;\n&#125;\n\nvar result &#x3D; sum(2, 3);\nconsole.log(&quot;result&#x3D;&quot;+result);\n\n或：\nvar total &#x3D; function() &#123;\n    return a+b;\n&#125;\n\nvar totalResult &#x3D; total(3,6);\nconsole.log(&quot;totalResult&#x3D;&quot;+totalResult);\n\n4.4 对象(重点)JavaScript中没有『类』的概念，对于系统内置的对象可以直接创建使用。\n4.4.1 使用new关键字创建对象&#x2F;&#x2F; 创建对象\nvar obj01 &#x3D; new Object();\n\n&#x2F;&#x2F; 给对象设置属性和属性值\nobj01.stuName &#x3D; &quot;tom&quot;;\nobj01.stuAge &#x3D; 20;\nobj01.stuSubject &#x3D; &quot;java&quot;;\n\n&#x2F;&#x2F; 在控制台输出对象\nconsole.log(obj01);\n\n4.4.2 使用{}创建对象(常用)&#x2F;&#x2F; 创建对象\nvar obj02 &#x3D; &#123;\n    &quot;soldierName&quot;:&quot;john&quot;,\n    &quot;soldierAge&quot;:35,\n    &quot;soldierWeapon&quot;:&quot;gun&quot;\n&#125;;\n\n&#x2F;&#x2F; 在控制台输出对象\nconsole.log(obj02);\n\n4.4.3 给对象设置函数属性&#x2F;&#x2F; 创建对象\nvar obj01 &#x3D; new Object();\n\n&#x2F;&#x2F; 给对象设置属性和属性值\nobj01.stuName &#x3D; &quot;tom&quot;;\nobj01.stuAge &#x3D; 20;\nobj01.stuSubject &#x3D; &quot;java&quot;;\n\nobj01.study &#x3D; function() &#123;\n\tconsole.log(this.stuName + &quot; is studying&quot;);\n&#125;;\n\n&#x2F;&#x2F; 在控制台输出对象\nconsole.log(obj01);\n&#x2F;&#x2F; 调用函数\nobj01.study();\n\n或者\n&#x2F;&#x2F; 创建对象\nvar obj02 &#x3D; &#123;\n\t&quot;soldierName&quot;:&quot;john&quot;,\n\t&quot;soldierAge&quot;:35,\n\t&quot;soldierWeapon&quot;:&quot;gun&quot;,\n\t&quot;soldierShoot&quot;:function()&#123;\n\t\tconsole.log(this.soldierName + &quot; is using &quot; + this.soldierWeapon);\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F; 在控制台输出对象\nconsole.log(obj02);\n&#x2F;&#x2F; 调用函数\nobj02.soldierShoot();\n\n4.4.4 this关键字this关键字只有两种情况：\n\n在函数外面：this关键字指向window对象（代表当前浏览器窗口）\n在函数里面：this关键字指向调用函数的对象\n\n&#x2F;&#x2F; 直接打印this\nconsole.log(this);\n\n&#x2F;&#x2F; 函数中的this\n&#x2F;&#x2F; 1.声明函数\nfunction getName() &#123;\n\tconsole.log(this.name);\n&#125;\n\n&#x2F;&#x2F; 2.创建对象\nvar obj01 &#x3D; &#123;\n\t&quot;name&quot;:&quot;tom&quot;,\n\t&quot;getName&quot;:getName\n&#125;;\nvar obj02 &#x3D; &#123;\n\t&quot;name&quot;:&quot;jerry&quot;,\n\t&quot;getName&quot;:getName\n&#125;;\n\n&#x2F;&#x2F; 3.调用函数\nobj01.getName();\nobj02.getName();\n\n4.5 数组(重点)4.5.1 使用new关键字创建数组&#x2F;&#x2F; 1.创建数组对象\nvar arr01 &#x3D; new Array();\n\n&#x2F;&#x2F; 2.压入数据\narr01.push(&quot;apple&quot;);\narr01.push(&quot;orange&quot;);\narr01.push(&quot;banana&quot;);\narr01.push(&quot;grape&quot;);\n\n&#x2F;&#x2F; 3.遍历数组\nfor (var i &#x3D; 0; i &lt; arr01.length; i++) &#123;\n\tconsole.log(arr01[i]);\n&#125;\n\n&#x2F;&#x2F; 4.数组元素反序\narr01.reverse();\nfor (var i &#x3D; 0; i &lt; arr01.length; i++) &#123;\n\tconsole.log(arr01[i]);\n&#125;\n\n&#x2F;&#x2F; 5.数组元素拼接成字符串\nvar arrStr &#x3D; arr01.join(&quot;,&quot;);\nconsole.log(arrStr);\n\n&#x2F;&#x2F; 6.字符串拆分成数组\nvar arr02 &#x3D; arrStr.split(&quot;,&quot;);\nfor (var i &#x3D; 0; i &lt; arr02.length; i++) &#123;\n\tconsole.log(arr02[i]);\n&#125;\n\n&#x2F;&#x2F; 7.弹出数组中最后一个元素\nvar ele &#x3D; arr01.pop();\nconsole.log(ele);\n\n4.5.2 使用[]创建数组(常用)&#x2F;&#x2F; 8.使用[]创建数组\nvar arr03 &#x3D; [&quot;cat&quot;,&quot;dog&quot;,&quot;tiger&quot;];\nconsole.log(arr03);\n\n4.6 JSON(最重点)4.6.1 JSON格式的用途在开发中凡是涉及到『跨平台数据传输』，JSON格式一定是首选。\n4.6.2 JSON格式的说明\nJSON数据两端要么是{}，要么是[]\n{}定义JSON对象\n[]定义JSON数组\nJSON对象的格式是：\n\n&#123;key:value,key:value,...,key:value&#125;\n\n\nJOSN数组的格式是：\n\n[value,value,...,value]\n\n\nkey的类型固定是字符串\nvalue的类型可以是：\n基本数据类型\n引用类型：JSON对象或JSON数组\n\n\n\n正因为JSON格式中value部分还可以继续使用JSON对象或JSON数组，所以JSON格式是可以『多层嵌套』的，所以JSON格式不论多么复杂的数据类型都可以表达。\n&#x2F;&#x2F;json的格式: &#123;key:value,key:value&#125;\nvar person1 &#x3D; &#123;\n    &quot;name&quot;:&quot;张三疯&quot;,\n    &quot;age&quot;:189,\n    &quot;address&quot;:&quot;武当山&quot;\n&#125;\n&#x2F;&#x2F;其实JSON对于前端而言，就是一个对象\n&#x2F;&#x2F;console.log(person1.name)\n\nvar person2 &#x3D; &#123;\n    &quot;name&quot;:&quot;张三疯&quot;,\n    &quot;age&quot;:189,\n    &quot;address&quot;:&quot;武当山&quot;,\n    &quot;wife&quot;:&#123;\n        &quot;name&quot;:&quot;小花&quot;,\n        &quot;age&quot;:18,\n        &quot;address&quot;:&quot;武当山下的小村庄&quot;\n    &#125;\n&#125;\n&#x2F;&#x2F;console.log(person2.wife.name)\n\nvar person3 &#x3D; &#123;\n    &quot;name&quot;:&quot;张三疯&quot;,\n    &quot;age&quot;:189,\n    &quot;address&quot;:&quot;武当山&quot;,\n    &quot;wife&quot;:&#123;\n        &quot;name&quot;:&quot;小花&quot;,\n        &quot;age&quot;:18,\n        &quot;address&quot;:&quot;武当山下的小村庄&quot;\n    &#125;,\n    &quot;sons&quot;:[\n        &#123;\n            &quot;name&quot;:&quot;奥巴马&quot;,\n            &quot;age&quot;:1,\n            &quot;address&quot;:&quot;武当山&quot;\n        &#125;,\n        &#123;\n            &quot;name&quot;:&quot;奥拉夫&quot;,\n            &quot;age&quot;:2,\n            &quot;address&quot;:&quot;少林寺&quot;\n        &#125;\n    ]\n&#125;\n\n&#x2F;&#x2F;json数组的格式: [&#123;key:value,key:value&#125;,&#123;key:value,key:value&#125;]\n&#x2F;&#x2F;var personList &#x3D; [person1,person2]\n\n4.6.3 JSON对象和JSON字符串互转\nJSON对象转JSON字符串\n\nvar jsonObj &#x3D; &#123;&quot;stuName&quot;:&quot;tom&quot;,&quot;stuAge&quot;:20&#125;;\nvar jsonStr &#x3D; JSON.stringify(jsonObj);\n\nconsole.log(typeof jsonObj); &#x2F;&#x2F; object\nconsole.log(typeof jsonStr); &#x2F;&#x2F; string\n\n\nJSON字符串转JSON对象\n\njsonObj &#x3D; JSON.parse(jsonStr);\nconsole.log(jsonObj); &#x2F;&#x2F; &#123;stuName: &quot;tom&quot;, stuAge: 20&#125;\n\n5. JavaScript的DOM(最重点)5.1 DOM的概念DOM是Document Object  Model的缩写，意思是『文档对象模型』——将HTML文档抽象成模型，再封装成对象方便用程序操作。\n这是一种非常常用的编程思想：将现实世界的事物抽象成模型，这样就非常容易使用对象来量化的描述现实事物，从而把生活中的问题转化成一个程序问题，最终实现用应用软件协助解决现实问题。而在这其中『模型』就是那个连通现实世界和代码世界的桥梁。\n5.2 DOM树的概念浏览器把HTML文档从服务器上下载下来之后就开始按照『从上到下』的顺序『读取HTML标签』。每一个标签都会被封装成一个『对象』。\n而第一个读取到的肯定是根标签html，然后是它的子标签head，再然后是head标签里的子标签……所以从html标签开始，整个文档中的所有标签都会根据它们之间的『父子关系』被放到一个『树形结构』的对象中。\n\n这个包含了所有标签对象的整个树形结构对象就是JavaScript中的一个可以直接使用的内置对象：document。\n例如，下面的标签结构：\n\n会被解析为：\n\n5.3 各个组成部分的类型整个文档中的一切都可以看做Node。各个具体组成部分的具体类型可以看做Node类型的子类。\n\n\n\n\n\n\n\n\n\n其实严格来说，JavaScript并不支持真正意义上的『继承』，这里我们借用Java中的『继承』概念，从逻辑上来帮助我们理解各个类型之间的关系。\n\n\n\n组成部分\n节点类型\n具体类型\n\n\n\n整个文档\n文档节点\nDocument\n\n\nHTML标签\n元素节点\nElement\n\n\nHTML标签内的文本\n文本节点\nText\n\n\nHTML标签内的属性\n属性节点\nAttr\n\n\n注释\n注释节点\nComment\n\n\n5.4 父子关系\n\n5.5 先辈后代关系\n\n5.6 DOM操作由于实际开发时基本上都是使用JavaScript的各种框架来操作，而框架中的操作方式和我们现在看到的原生操作完全不同，所以下面罗列的API仅供参考，不做要求。\n5.6.1 在整个文档范围内查询元素节点\n\n\n功能\nAPI\n返回值\n\n\n\n根据id值查询\ndocument.getElementById(“id值”)\n一个具体的元素节\n\n\n根据标签名查询\ndocument.getElementsByTagName(“标签名”)\n元素节点数组\n\n\n根据name属性值查询\ndocument.getElementsByName(“name值”)\n元素节点数组\n\n\n根据类名查询\ndocument.getElementsByClassName(“类名”)\n元素节点数组\n\n\n5.6.2 在具体元素节点范围内查找子节点\n\n\n功能\nAPI\n返回值\n\n\n\n查找子标签\nelement.children\n返回子标签数组\n\n\n查找第一个子标签\nelement.firstElementChild【W3C考虑换行，IE≤8不考虑】\n标签对象\n\n\n查找最后一个子标签\nelement.lastElementChild【W3C考虑换行，IE≤8不考虑】\n节点对象\n\n\n5.6.3 查找指定元素节点的父节点\n\n\n功能\nAPI\n返回值\n\n\n\n查找指定元素节点的父标签\nelement.parentElement\n标签对象\n\n\n5.6.4 查找指定元素节点的兄弟节点\n\n\n功能\nAPI\n返回值\n\n\n\n查找前一个兄弟标签\nnode.previousElementSibling【W3C考虑换行，IE≤8不考虑】\n标签对象\n\n\n查找后一个兄弟标签\nnode.nextElementSibling【W3C考虑换行，IE≤8不考虑】\n标签对象\n\n\n5.6.5 扩展内容(根据选择器查找标签)\n\n\n功能\nAPI\n返回值\n\n\n\n根据选择器查找一个标签\ndocument.querySelector(“选择器”)\n标签对象\n\n\n根据选择器查找多个标签\ndocument.querySelectorAll(“选择器”)\n标签数组\n\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n    &lt;head&gt;\n        &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n        &lt;title&gt;DOM查找节点&lt;&#x2F;title&gt;\n    &lt;&#x2F;head&gt;\n    &lt;body&gt;\n        &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot;&gt;\n        &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;c1&quot;&gt;\n        &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;c1&quot;&gt;\n        &lt;div&gt;\n            &lt;div&gt;&lt;&#x2F;div&gt;\n            &lt;div&gt;&lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n        &lt;script&gt;\n            &#x2F;&#x2F;根据id查询标签\n            var elementById &#x3D; document.getElementById(&quot;username&quot;);\n            &#x2F;&#x2F;console.log(elementById)\n            &#x2F;&#x2F;根据类名查询标签\n            var elementsByClassName &#x3D; document.getElementsByClassName(&quot;c1&quot;);\n            &#x2F;&#x2F;console.log(elementsByClassName)\n            &#x2F;&#x2F;根据标签名查询标签\n            var elementsByTagName &#x3D; document.getElementsByTagName(&quot;input&quot;);\n            &#x2F;&#x2F;console.log(elementsByTagName)\n\n            &#x2F;&#x2F;查找子节点: 查找body的所有子标签,要注意文本也属于子节点\n            &#x2F;*var childNodes &#x3D; document.getElementsByTagName(&quot;body&quot;)[0].childNodes;\n        console.log(childNodes)*&#x2F;\n\n            &#x2F;&#x2F;查找子标签: children\n            var children &#x3D; document.getElementsByTagName(&quot;body&quot;)[0].children;\n            &#x2F;&#x2F;console.log(children)\n\n            &#x2F;&#x2F;查找id为username的标签的父节点\n            var parentNode &#x3D; document.getElementById(&quot;username&quot;).parentNode;\n            &#x2F;&#x2F;console.log(parentNode)\n\n            &#x2F;&#x2F;查找id为username的标签的前一个兄弟标签\n            var previousElementSibling &#x3D; document.getElementById(&quot;username&quot;).previousElementSibling;\n            &#x2F;&#x2F;console.log(previousElementSibling)\n\n            &#x2F;&#x2F;查找id为username的标签的后一个兄弟标签\n            var nextElementSibling &#x3D; document.getElementById(&quot;username&quot;).nextElementSibling;\n            &#x2F;&#x2F;console.log(nextElementSibling)\n\n\n            &#x2F;&#x2F;根据选择器查找标签:document.querySelector(&quot;选择器&quot;)根据选择器查找一个标签, document.querySelectorAll(&quot;选择器&quot;)根据选择器查找多个标签\n            &#x2F;&#x2F;什么是选择器: 用于查找标签的一些表达式，其中最基本的三种选择器是:ID选择器、类选择器、标签选择器\n            &#x2F;&#x2F;选择器参考jQuery的文档\n            &#x2F;&#x2F;查找id为username的标签，使用的是id选择器\n            var ipt1 &#x3D; document.querySelector(&quot;#username&quot;);\n\n            &#x2F;&#x2F;console.log(ipt1)\n            &#x2F;&#x2F;查找body内的所有后代div，用的是层级选择器\n            var ipts &#x3D; document.querySelectorAll(&quot;body div&quot;);\n\n            &#x2F;&#x2F;查找id为username的标签的后面第一个兄弟\n            var i1 &#x3D; document.querySelector(&quot;#username+input&quot;);\n\n            &#x2F;&#x2F;查找id为username的标签的后面的所有兄弟\n            var i2 &#x3D; document.querySelectorAll(&quot;#username~input&quot;);\n\n            console.log(i2)\n        &lt;&#x2F;script&gt;\n    &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n5.6.5.1 属性操作\n\n\n需求\n操作方式\n\n\n\n读取属性值\n元素对象.属性名\n\n\n修改属性值\n元素对象.属性名=新的属性值\n\n\n5.6.5.2 标签体的操作\n\n\n需求\n操作方式\n\n\n\n获取或者设置标签体的文本内容\nelement.innerText\n\n\n获取或者设置标签体的内容\nelement.innerHTML\n\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n    &lt;head&gt;\n        &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n        &lt;title&gt;操作标签的属性和文本&lt;&#x2F;title&gt;\n    &lt;&#x2F;head&gt;\n    &lt;body&gt;\n        &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot; name&#x3D;&quot;username&quot; &#x2F;&gt;\n        &lt;div id&#x3D;&quot;d1&quot;&gt;\n            &lt;h1&gt;你好世界&lt;&#x2F;h1&gt;\n        &lt;&#x2F;div&gt;\n        &lt;script&gt;\n            &#x2F;&#x2F;目标: 获取id为username的输入框的value\n            &#x2F;&#x2F;1. 找到要操作的标签\n            var ipt &#x3D; document.getElementById(&quot;username&quot;);\n\n            &#x2F;&#x2F;2. 设置标签的value属性值\n            ipt.value &#x3D; &quot;张三&quot;\n\n            &#x2F;&#x2F;3. 获取标签的value属性的值\n            var value &#x3D; ipt.value;\n            console.log(value)\n\n            &#x2F;&#x2F;获取id为d1的div中的文本内容\n            &#x2F;&#x2F;获取标签的文本: element.innerText,获取文本的时候会将左右两端的空格去掉\n            var innerText &#x3D; document.getElementById(&quot;d1&quot;).innerText;\n            console.log(innerText)\n\n            &#x2F;&#x2F;获取标签体的内容: element.innerHTML,获取标签体的内容\n            var innerHTML &#x3D; document.getElementById(&quot;d1&quot;).innerHTML;\n            console.log(innerHTML)\n\n            &#x2F;&#x2F;设置标签体的内容:建议使用innerHTML，如果是使用innerText的话它会将标签当做普通文本处理\n            document.getElementById(&quot;d1&quot;).innerHTML &#x3D; &quot;&lt;h1&gt;hello world&lt;&#x2F;h1&gt;&quot;\n        &lt;&#x2F;script&gt;\n    &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n5.6.5.3 DOM增删改操作\n\n\nAPI\n功能\n\n\n\ndocument.createElement(“标签名”)\n创建元素节点并返回，但不会自动添加到文档中\n\n\ndocument.createTextNode(“文本值”)\n创建文本节点并返回，但不会自动添加到文档中\n\n\nelement.appendChild(ele)\n将ele添加到element所有子节点后面\n\n\nparentEle.insertBefore(newEle,targetEle)\n将newEle插入到targetEle前面\n\n\nparentEle.replaceChild(newEle, oldEle)\n用新节点替换原有的旧子节点\n\n\nelement.remove()\n删除某个标签\n\n\nelement.innerHTML\n读写HTML代码\n\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n    &lt;head&gt;\n        &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n        &lt;title&gt;创建和删除标签&lt;&#x2F;title&gt;\n    &lt;&#x2F;head&gt;\n    &lt;body&gt;\n        &lt;ul id&#x3D;&quot;city&quot;&gt;\n            &lt;li id&#x3D;&quot;bj&quot;&gt;北京&lt;&#x2F;li&gt;\n            &lt;li id&#x3D;&quot;sh&quot;&gt;上海&lt;&#x2F;li&gt;\n            &lt;li id&#x3D;&quot;sz&quot;&gt;深圳&lt;&#x2F;li&gt;\n            &lt;li id&#x3D;&quot;gz&quot;&gt;广州&lt;&#x2F;li&gt;\n        &lt;&#x2F;ul&gt;\n        &lt;script&gt;\n            &#x2F;&#x2F;目标1: 在城市列表的最后添加一个子标签 &lt;li id&#x3D;&quot;cs&quot;&gt;长沙&lt;&#x2F;li&gt;\n            &#x2F;&#x2F;1. 创建一个li标签  &lt;li&gt;&lt;&#x2F;li&gt;\n            var liElement &#x3D; document.createElement(&quot;li&quot;);\n            &#x2F;&#x2F;2. 给创建的li标签设置id属性和文本 &lt;li id&#x3D;&quot;cs&quot;&gt;长沙&lt;&#x2F;li&gt;\n            liElement.id &#x3D; &quot;cs&quot;\n            liElement.innerText &#x3D; &quot;长沙&quot;\n            &#x2F;&#x2F;3. 将创建的li标签添加到城市列表中（ul）\n            var cityUl &#x3D; document.getElementById(&quot;city&quot;);\n\n            &#x2F;&#x2F;父.appendChild(子)将子标签添加到父标签的最后面\n            &#x2F;&#x2F;cityUl.appendChild(liElement)\n\n            &#x2F;&#x2F;目标2:在城市列表的深圳之前添加一个子标签 &lt;li id&#x3D;&quot;cs&quot;&gt;长沙&lt;&#x2F;li&gt;\n            &#x2F;&#x2F;获取到深圳这个标签\n            var szElement &#x3D; document.getElementById(&quot;sz&quot;);\n            &#x2F;&#x2F;父.insertBefore(新标签,参照标签)\n            &#x2F;&#x2F;cityUl.insertBefore(liElement,szElement)\n\n            &#x2F;&#x2F;目标3: 在城市列表中添加一个子标签替换深圳 &lt;li id&#x3D;&quot;cs&quot;&gt;长沙&lt;&#x2F;li&gt;\n            &#x2F;&#x2F;父.replaceChild(新标签,被替换的标签)\n            &#x2F;&#x2F;cityUl.replaceChild(liElement,szElement)\n\n            &#x2F;&#x2F;目标4: 在城市列表中删除深圳\n            &#x2F;&#x2F;szElement.remove()\n\n            &#x2F;&#x2F;目标5: 清除城市列表中的所有城市,保留城市列表标签ul\n            cityUl.innerHTML &#x3D; &quot;&quot;\n        &lt;&#x2F;script&gt;\n    &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n5.7 DOM文档加载步骤：\n解析html结构；\n加载外部脚本和样式表文件；\n解析并执行脚本；\ndom树构建完成（触发DOMContentLoaded和 jquery ready事件）；\n加载图片等外部文件；（会触发图片load事件）\n页面加载完毕。（触发load事件）\n\n注意：凡是没有绑定加载事件(如：window.onload、$(document).ready())的js文件中的代码，在本文件（代码）加载完成后立即解析执行。\n6 事件驱动(很重要)6.1 事件的概念\nHTML 事件是发生在 HTML 元素上的“事情”， 是浏览器或用户做的某些事情\n事件通常与函数配合使用，这样就可以通过发生的事件来驱动函数执行。\n\n6.2 常见事件\n\n\n属性\n此事件发生在何时…\n\n\n\nonclick\n当用户点击某个对象时调用的事件句柄。\n\n\nondblclick\n当用户双击某个对象时调用的事件句柄。\n\n\nonchange\n域的内容被改变。\n\n\nonblur\n元素失去焦点。\n\n\nonfocus\n元素获得焦点。\n\n\nonload\n一张页面或一幅图像完成加载。\n\n\nonsubmit\n确认按钮被点击；表单被提交。\n\n\nonkeydown\n某个键盘按键被按下。\n\n\nonkeypress\n某个键盘按键被按住。\n\n\nonkeyup\n某个键盘按键被松开。\n\n\nonmousedown\n鼠标按钮被按下。\n\n\nonmouseup\n鼠标按键被松开。\n\n\nonmouseout\n鼠标从某元素移开。\n\n\nomouseover\n鼠标移到某元素之上。\n\n\nonmousemove\n鼠标被移动。\n\n\n6.3 事件绑定的方式6.3.1 普通函数方式说白了设置标签的属性\n&lt;标签 属性&#x3D;&quot;js代码，调用函数&quot;&gt;&lt;&#x2F;标签&gt;\n\n6.3.2 匿名函数方式&lt;script&gt;\n    标签对象.事件属性 &#x3D; function()&#123;\n        &#x2F;&#x2F;执行一段代码\n    &#125;\n&lt;&#x2F;script&gt;\n\n6.3.4 事件的使用介绍\n点击事件\n需求: 没点击一次按钮 弹出hello…\n\n\n&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;按钮&quot; onclick&#x3D;&quot;fn1()&quot;&gt;\n\n    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;另一个按钮&quot; id&#x3D;&quot;btn&quot;&gt;\n        &lt;script&gt;\n        &#x2F;&#x2F;当点击的时候要调用的函数\n        function fn1() &#123;\n        alert(&quot;我被点击了...&quot;)\n    &#125;\n\n&#x2F;&#x2F;给另外一个按钮，绑定点击事件:\n&#x2F;&#x2F;1.先根据id获取标签\nlet btn &#x3D; document.getElementById(&quot;btn&quot;);\n&#x2F;&#x2F;2. 设置btn的onclick属性(绑定事件)\n&#x2F;&#x2F;绑定命名函数\n&#x2F;&#x2F;btn.onclick &#x3D; fn1\n\n&#x2F;&#x2F;绑定匿名函数\nbtn.onclick &#x3D; function () &#123;\n    console.log(&quot;点击了另外一个按钮&quot;)\n&#125;\n&lt;&#x2F;script&gt;\n\n\n获得焦点(onfocus)和失去焦点(onblur)\n需求:给输入框设置获得和失去焦点\n\n\nvar ipt &#x3D; document.getElementById(&quot;ipt&quot;);\n\n&#x2F;&#x2F;绑定获取焦点事件\nipt.onfocus &#x3D; function () &#123;\n    console.log(&quot;获取焦点了...&quot;)\n&#125;\n\n&#x2F;&#x2F;绑定失去焦点事件\nipt.onblur &#x3D; function () &#123;\n    console.log(&quot;失去焦点了...&quot;)\n&#125;\n\n\n内容改变(onchange)\n需求: 给select设置内容改变事件\n\n\n&lt;body&gt;\n    &lt;!--内容改变(onchange)--&gt;\n    &lt;select onchange&#x3D;&quot;changeCity(this)&quot;&gt;\n        &lt;option value&#x3D;&quot;bj&quot;&gt;北京&lt;&#x2F;option&gt;\n        &lt;option value&#x3D;&quot;sh&quot;&gt;上海&lt;&#x2F;option&gt;\n        &lt;option value&#x3D;&quot;sz&quot;&gt;深圳&lt;&#x2F;option&gt;\n    &lt;&#x2F;select&gt;\n\n&lt;&#x2F;body&gt;\n&lt;script&gt;\n    function changeCity(obj) &#123;\n        console.log(&quot;城市改变了&quot;+obj.value);\n    &#125;\n&lt;&#x2F;script&gt;\n\n\n键盘相关的, 键盘按下(onkeydown)  键盘抬起(onkeyup)\n\n&#x2F;&#x2F;给输入框绑定键盘按键按下和抬起事件\nipt.onkeydown &#x3D; function () &#123;\n    &#x2F;&#x2F;当按键按下的时候，数据并没有到达输入框\n    &#x2F;&#x2F;输出输入框里面的内容\n    &#x2F;&#x2F;console.log(ipt.value)\n&#125;\n\nipt.onkeyup &#x3D; function () &#123;\n    &#x2F;&#x2F;输出输入框的内容:当键盘按键抬起的时候，数据已经到达了输入框\n    console.log(ipt.value)\n&#125;\n\n\n鼠标相关的, 鼠标在xx之上(onmouseover ), 鼠标按下(onmousedown),鼠标离开(onmouseout)\n\n&#x2F;&#x2F;给输入框绑定鼠标移入事件\nipt.onmouseover &#x3D; function () &#123;\n    console.log(&quot;鼠标移入了...&quot;)\n&#125;\n&#x2F;&#x2F;给输入框绑定鼠标移出事件\nipt.onmouseout &#x3D; function () &#123;\n    console.log(&quot;鼠标移出了...&quot;)\n&#125;\n\n\n\n2.5.7.5 综合案例需求\n\n代码实现\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n    &lt;head&gt;\n        &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n        &lt;title&gt;综合案例&lt;&#x2F;title&gt;\n        &lt;style&gt;\n            table,tr,td,th&#123;\n                border: 1px solid black;\n                width: 500px;\n                text-align: center;\n                margin: auto;\n            &#125;\n\n            div&#123;\n                text-align: center;\n            &#125;\n        &lt;&#x2F;style&gt;\n    &lt;&#x2F;head&gt;\n    &lt;body&gt;\n        &lt;table cellspacing&#x3D;&quot;0&quot; id&#x3D;&quot;tb&quot;&gt;\n            &lt;tr&gt;\n                &lt;th&gt;序号&lt;&#x2F;th&gt;\n                &lt;th&gt;用户名&lt;&#x2F;th&gt;\n                &lt;th&gt;性别&lt;&#x2F;th&gt;\n                &lt;th&gt;操作&lt;&#x2F;th&gt;\n            &lt;&#x2F;tr&gt;\n            &lt;tr&gt;\n                &lt;td&gt;1&lt;&#x2F;td&gt;\n                &lt;td&gt;张三&lt;&#x2F;td&gt;\n                &lt;td&gt;男&lt;&#x2F;td&gt;\n                &lt;td&gt;\n                    &lt;button onclick&#x3D;&quot;deletePerson(this)&quot;&gt;删除&lt;&#x2F;button&gt;\n                &lt;&#x2F;td&gt;\n            &lt;&#x2F;tr&gt;\n            &lt;tr&gt;\n                &lt;td&gt;2&lt;&#x2F;td&gt;\n                &lt;td&gt;李四&lt;&#x2F;td&gt;\n                &lt;td&gt;女&lt;&#x2F;td&gt;\n                &lt;td&gt;\n                    &lt;button onclick&#x3D;&quot;deletePerson(this)&quot;&gt;删除&lt;&#x2F;button&gt;\n                &lt;&#x2F;td&gt;\n            &lt;&#x2F;tr&gt;\n            &lt;tr&gt;\n                &lt;td&gt;3&lt;&#x2F;td&gt;\n                &lt;td&gt;王五&lt;&#x2F;td&gt;\n                &lt;td&gt;男&lt;&#x2F;td&gt;\n                &lt;td&gt;\n                    &lt;button onclick&#x3D;&quot;deletePerson(this)&quot;&gt;删除&lt;&#x2F;button&gt;\n                &lt;&#x2F;td&gt;\n            &lt;&#x2F;tr&gt;\n        &lt;&#x2F;table&gt;\n        &lt;div&gt;\n            &lt;form action&#x3D;&quot;#&quot;&gt;\n                序号&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;num&quot; id&#x3D;&quot;num&quot;&gt;&lt;br&#x2F;&gt;\n                用户&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; id&#x3D;&quot;username&quot;&#x2F;&gt;&lt;br&#x2F;&gt;\n                性别&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;gender&quot; id&#x3D;&quot;gender&quot;&#x2F;&gt;&lt;br&#x2F;&gt;\n                &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;添加用户&quot; onclick&#x3D;&quot;addPerson()&quot;&#x2F;&gt;\n            &lt;&#x2F;form&gt;\n        &lt;&#x2F;div&gt;\n        &lt;script&gt;\n            &#x2F;&#x2F;目标1:点击删除按钮，删除当前行\n            &#x2F;&#x2F;给所有按钮绑定点击事件\n            function deletePerson(obj) &#123;\n                &#x2F;&#x2F;此时obj就是你点击的那个按钮\n                &#x2F;&#x2F;我们要删除的就是obj的爷爷\n                obj.parentElement.parentElement.remove()\n            &#125;\n\n            function addPerson() &#123;\n                &#x2F;&#x2F;添加用户\n                &#x2F;&#x2F;1. 获取序号、用户名、性别\n                var numElement &#x3D; document.getElementById(&quot;num&quot;);\n                var num &#x3D; numElement.value;\n\n                var usernameElement &#x3D; document.getElementById(&quot;username&quot;);\n                var username &#x3D; usernameElement.value;\n\n                var genderElement &#x3D; document.getElementById(&quot;gender&quot;);\n                var gender &#x3D; genderElement.value;\n\n                &#x2F;&#x2F;2. 将获取到的序号、用户名、性别添加到td中，td放到tr中，tr添加到table中\n                &#x2F;&#x2F;2.1 创建一行  &lt;tr&gt;&lt;&#x2F;tr&gt;\n                var trElement &#x3D; document.createElement(&quot;tr&quot;);\n                &#x2F;&#x2F;2.2 往tr中添加标签体内容\n                trElement.innerHTML &#x3D; &quot;&lt;td&gt;&quot;+num+&quot;&lt;&#x2F;td&gt;\\n&quot; +\n                    &quot;            &lt;td&gt;&quot;+username+&quot;&lt;&#x2F;td&gt;\\n&quot; +\n                    &quot;            &lt;td&gt;&quot;+gender+&quot;&lt;&#x2F;td&gt;\\n&quot; +\n                    &quot;            &lt;td&gt;\\n&quot; +\n                    &quot;                &lt;button onclick&#x3D;\\&quot;deletePerson(this)\\&quot;&gt;删除&lt;&#x2F;button&gt;\\n&quot; +\n                    &quot;            &lt;&#x2F;td&gt;&quot;\n                &#x2F;&#x2F;2.3 将tr添加到表格中\n                var tb &#x3D; document.getElementById(&quot;tb&quot;);\n                tb.appendChild(trElement)\n\n                &#x2F;&#x2F;3. 清空序号、用户名、性别\n                numElement.value &#x3D; &quot;&quot;\n                usernameElement.value &#x3D; &quot;&quot;\n                genderElement.value &#x3D; &quot;&quot;\n            &#125;\n        &lt;&#x2F;script&gt;\n    &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n","slug":"29-JavaScript","date":"2021-09-13T15:06:32.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"大黄"},{"id":"93d9161737573474af9da23361a39a29","title":"Jsp的 EL JSTL","content":"1. EL表达式1.1 什么是EL* EL 表达式的全称是：&lt;kbd&gt;Expression Language&lt;&#x2F;kbd&gt;。是&lt;kbd&gt;表达式语言&lt;&#x2F;kbd&gt;，是JSP技术的主要特点之一，类似  javascript。\n\n* EL 表达式的格式是：&lt;kbd&gt;$&#123;表达式&#125;&lt;&#x2F;kbd&gt; \n\n1.2 EL的作用* EL 表达式主要是代替 jsp 页面中的表达式脚本在 jsp 页面中进行数据的输出。 \n\n* 因为 EL 表达式输出数据，比 jsp 表达式脚本简洁的多。\n\n1.3 EL输出null值EL 表达式在输出 null 值的时候，输出的是 空串。jsp 表达式脚本输出 null 值的时候，输出的是 null 字符串。\n\n1.4 EL搜索域数据顺序* EL 表达式主要是在 jsp 页面中输出数据。 主要是输出域对象中的数据。\n\n* 当四个域中都有相同的 key 的数据的时候，EL 表达式会按照四个域的 从小到大 的顺序去进行搜索，找到就输出。\n\n1.5 EL输出Bean对象的属性* 普通属性\t数组属性\tList 集合属性\tmap 集合属性\n\n* 在访问私有属性时，底层实际是在调用相关属性的get&#x2F;set方法。\n\n2. EL 表达式中的运算2.1 常见运算符\t关系运算：&#x3D;&#x3D;或eq\t!&#x3D;或ne\t&lt;或It\t&gt;或gt\t&lt;&#x3D;或le\t&gt;&#x3D;或ge\n\n​\t逻辑运算：&amp;&amp;或and\t||或or\t!或not\n\n​\t算术运算：x\t&#x2F;或div\t%或mod\t+\t-\n\n2.2 其他运算符 empty运算：empty 运算可以判断一个数据是否为空，如果为空，则输出 true,不为空输出 false。 (not empty表示非空)\n  1. 值为 null 值的时候，为空 \t\t\t\t值为空串的时候，为空 \n  2. 值是 Object 类型数组，长度为零的时候 \t list 集合，元素个数为零 map 集合，元素个数为零\n  \n​ 三元运算：表达式 1？表达式 2：表达式 3 如果表达式 1 的值为真，返回表达式 2 的值，如果表达式 1 的值为假，返回表达式 3 的值。\n\n​ “.”点运算：.点运算，可以输出 Bean 对象中某个属性的值。\n\n​ [] 中括号运算符：[ ]中括号运算，可以输出有序集合中某个元素的值。 并且**[]中括号运算，还可以输出 map 集合中 key 里含有特殊字符的 key 的值**\n\n3. EL的隐含对象3.1 可以直接使用\n\n\n变量\n类型\n作用\n\n\n\npageContext\nPageContextImpl\n它可以获取 jsp 中的九大内置对象\n\n\n————————————–\n——————————————————\n—————————————————————————\n\n\npageScope\nMap&lt;String,Object&gt;\n它可以获取 pageContext 域中的数据\n\n\nrequestScope\nMap&lt;String,Object&gt;\n它可以获取 Request 域中的数据\n\n\nsessionScope\nMap&lt;String,Object&gt;\n它可以获取 Session 域中的数据\n\n\napplicationScope\nMap&lt;String,Object&gt;\n它可以获取 ServletContext 域中的数据\n\n\n————————————-\n—————————————————-\n—————————————————————————-\n\n\nparam\nMap&lt;String,String&gt;\n它可以获取请求参数的值\n\n\nparamValues\nMap&lt;String,String[]&gt;\n它也可以获取请求参数的值，获取多个值的时候使用。\n\n\n————————————\n————————————————–\n—————————————————————————\n\n\nheader\nMap&lt;String,String&gt;\n它可以获取请求头的信息\n\n\nheaderValues\nMap&lt;String,String[]&gt;\n它可以获取请求头的信息，它可以获取多个值的情况\n\n\n————————————\n————————————————–\n—————————————————————————-\n\n\ncookie\nMap&lt;String,Cookie&gt;\n它可以获取当前请求的 Cookie 信息\n\n\ninitParam\nMap\n它可以获取在 web.xml 中配置的上下文参数\n\n\n3.2 获取四个与属性中的值\n3.3 其他隐含对象的使用\n4. JSTL标签库4.1 什么是JSTL 标签库* JSTL 标签库 全称是指 JSP Standard Tag Library JSP 标准标签库。是一个不断完善的开放源代码的 JSP 标 签库。 \n* EL 表达式主要是为了替换 jsp 中的表达式脚本，而标签库则是为了替换代码脚本。这样使得整个 jsp 页面 变得更佳简洁\n\n4.2 JSTL 标签库的组成\n\n\n功能范围\nURI\n前缀\n\n\n\n核心标签库–重点\nhttp://java.sun.com/jsp/jstl/core\nc\n\n\n格式化\nhttp://java.sun.com/jsp/jstl/fmt\nfmt\n\n\n函数\nhttp://java.sun.com/jsp/jstl/functions\nfn\n\n\n数据库(不使用)\nhttp://java.sun.com/jsp/jstl/sql\nsql\n\n\nXML(不使用)\nhttp://java.sun.com/jsp/jstl/xml\nx\n\n\n导入使用：在 jsp 标签库中使用 taglib 指令引入标签库       &lt;%@ taglib prefix=”前缀” uri=” 网址 “ %&gt;\n4.3 JSTL 标签库的使用步骤* 先导入 jstl 标签库的 jar 包。 taglibs-standard-impl-1.2.1.jar \ttaglibs-standard-spec-1.2.1.jar \n* 第二步，使用 taglib 指令引入标签库。 &lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;\n\n4.4 core 核心库的使用\n&lt;c:if /&gt;\n\n&lt;c:choose &gt;&lt;c:when &gt;&lt;c:otherwise &gt;&lt;c:choose&gt; &lt;c:when&gt; &lt;c:otherwise&gt;标签\n作用：多路判断。跟 switch ... case .... default 非常接近\nchoose 标签开始选择判断\nwhen 标签表示每一种判断情况\ntest 属性表示当前这种判断情况的值\notherwise 标签表示剩下的情况\n&lt;c:choose&gt; &lt;c:when&gt; &lt;c:otherwise&gt;标签使用时需要注意的点：\n1、标签里不能使用 html 注释，要使用 jsp 注释\n2、when 标签的父标签一定要是 choose 标签\n\n\n\n&lt;c:forEach /&gt;&lt;%--1.遍历 1 到 10，输出\nbegin 属性设置开始的索引\nend 属性设置结束的索引\nvar 属性表示循环的变量(也是当前正在遍历到的数据)\nfor (int i &#x3D; 1; i &lt; 10; i++)\n--%&gt;\n&lt;table border&#x3D;&quot;1&quot;&gt;\n&lt;c:forEach begin&#x3D;&quot;1&quot; end&#x3D;&quot;10&quot; var&#x3D;&quot;i&quot;&gt;\n&lt;tr&gt;\n&lt;td&gt;第$&#123;i&#125;行&lt;&#x2F;td&gt;\n&lt;&#x2F;tr&gt;\n&lt;&#x2F;c:forEach&gt;\n&lt;&#x2F;table&gt;\n\n","slug":"28-El Jstl","date":"2021-09-13T15:05:32.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"大黄"},{"id":"945a3d93a729714c86dd0543b3f0dd1a","title":"Jsp 知识总结","content":"1. 基础1.1 什么是Jspjsp 的全称是 java server pages。Java 的服务器页面。\n\njsp 的主要作用是代替 Servlet 程序回传 html 页面的数据。\n\n因为 Servlet 程序回传 html 页面数据是一件非常繁锁的事情。开发成本和维护成本都极高。\n\n1.2 jsp 如何访问？jsp 页面和 html 页面一样，都是存放在 web 目录下。访问也跟访问 html 页面一样。 \n\n比如： 在 web 目录下有如下的文件： \n\n​\t\t\ta.html 页面 访问地址是 &#x3D;&gt;&gt;&gt;&gt;&gt;&gt; http:&#x2F;&#x2F;ip:port&#x2F;工程路径&#x2F;a.html \n\n​\t\t\tb.jsp 页面 访问地址是 &#x3D;&gt;&gt;&gt;&gt;&gt;&gt; http:&#x2F;&#x2F;ip:port&#x2F;工程路径&#x2F;b.jsp\n\n2. Jsp本质1、jsp页面的本质就是一个Servlet程序\n\n2. 访问 jsp 后，tomcat 会帮我们将 jsp 转换为 .java 文件，进而解析为 .class 文件\n   Tomcat 把 jsp 页面翻译后得到的 Java 源文件中可以发现 jsp 页面继承了 org.apache.runtime.HttpJspBase\n   跟踪源代码发现 \tHttpJspBase 类直接继承了 HttpServlet\n   观察翻译出来的 Servlet 程序的源代码，不难发现。其底层实现，也是通过输出流。把 html 页面数据回传给客户端。\n\n\n3. print | write3.1 输出数据类型* out.write() 输出字符串没有问题 \n* out.print() 输出任意数据都没有问题（都转换成为字符串后调用的 write 输出）\n\n3.2 输出数据为null* print方法将输出内容为“null”的字符串\n* write方法则是抛出NullPointerException异常\n\n3.3 out | response.getWrite* response 中表示响应，我们经常用于设置返回给客户端的内容（输出） \n* \\r\\n 在客户端只会输出一个空格\n\n\n4. 三大指令4.1 page指令jsp 的 page 指令可以修改 jsp 页面中一些重要的属性，或者行为。\n&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt; \n\n\n\n属性\n释义\n\n\n\nlanguage\n表示 jsp 翻译后是什么语言文件。暂时只支持 java\n\n\ncontentType\n表示 jsp 返回的数据类型是什么。也是源码中 response.setContentType()参数值text/html;charset=UTF-8\n\n\npageEncoding\n表示当前 jsp 页面文件本身的字符集\n\n\nimport\n跟 java 源代码中一样。用于导包，导类\n\n\nautoFlush\n设置当 out 输出流缓冲区满了之后，是否自动刷新冲级区。默认值是 true\n\n\nbuffer\n设置 out 缓冲区的大小。默认是 8kb\n\n\nerrorPage\n设置当 jsp 页面运行时出错，自动跳转去的错误页面路径\n\n\nisErrorPage\n设置当前 jsp 页面是否是错误信息页面。默认是 false。如果是 true 可以 获取异常信息。\n\n\nsession\n设置访问当前 jsp 页面，是否会创建 HttpSession 对象。默认是 true。\n\n\nextends\n设置 jsp 翻译出来的 java 类默认继承谁\n\n\n4.2 taglib指令概述：导入额外功能\t\t\t例如：导入jstl标签\n\n&lt;%@ taglib uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; prefix&#x3D;&quot;c&quot; %&gt;\n\n4.3 include指令概述：静态包含\t\t格式：&lt;%@ include file&#x3D;&quot; &quot;%&gt;\n\nfile 属性指定你要包含的 jsp 页面的路径 \n\n地址中第一个斜杠 &#x2F; 表示为 http:&#x2F;&#x2F;ip:port&#x2F;工程路径&#x2F; \t映射到代码的 web 目录 \n\n5. 静态域动态包含5.1 Jsp 静态包含* &lt;%@ include file&#x3D;&quot; &quot;%&gt; \t静态包含格式 \n* 静态包含的特点\n  1. 静态包含  不会翻译  被包含的 jsp 页面\n  2. 静态包含其实是把被包含的 jsp 页面的代码拷贝到包含的位置执行输出。\n* &lt;%@include file&#x3D;&quot;footer.jsp&quot;%&gt;\n\n5.2 Jsp 动态包含* &lt;jsp:include page&#x3D;&quot;&quot;&gt;&lt;&#x2F;jsp：include&gt;\t\t动态包含 \n\n  1. page 属性是指定你要包含的 jsp 页面的路径 \n  2. 动态包含也可以像静态包含一样。把被包含的内容执行输出到包含位置 \n\n* 动态包含的特点\n\n  1. **动态包含会把包含的 jsp 页面也翻译成为 java 代码**\n  2. 动态包含底层代码使用如下代码去调用被包含的 jsp 页面执行输出。 JspRuntimeLibrary.include(request, response, &quot;&#x2F;include&#x2F;footer.jsp&quot;, out, false); \n  3. 动态包含，还可以传递参数\n\n&lt;jsp:include page&#x3D;&quot;&#x2F;include&#x2F;footer.jsp&quot;&gt;\n    &lt;jsp:param name&#x3D;&quot;username&quot; value&#x3D;&quot;bbj&quot;&#x2F;&gt;\n    &lt;jsp:param name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;\n&lt;&#x2F;jsp：include&gt;\n\n6. 页面注释和声明代码* 格式一、jsp注释\t&lt;%--- Content ---%&gt;\n* 格式二、html注释  &lt;!-- content --&gt;\n\n* 声明代码\n* &lt;%! %&gt; —— 定义成员内容\n* &lt;% %&gt; —— 定义service方法中的局部内容\n* &lt;%&#x3D; %&gt; —— 定义service方中的out对象的输入内容\n\n7. 九大内置对象7.1 概述在访问JSP后的，tomcat解析jsp后生成的.java文件中，在service()方法中，声明好的对象可在JSP中可以直接使用\n7.2 分类\n\n\n对象\n\n\n\n\napplication对象\nServletContext\n\n\nsession对象\nHttpSession\n\n\nrequest对象\nHttpServletRequest\n\n\npageCotext对象\nPageCotext (页面域)\n\n\nout对象\nJspWriter\n\n\nresponse对象\nHttpServletResponse\n\n\nconfig对象\nServletConfig\n\n\npage对象\nthis，页面对象\n\n\nexception对象\nThrowable\n\n\n8. 四大域对象8.1 四大域对象存取范围* pageContext (PageContextImpl类) \t当前 jsp 页面范围内有效 \n* request (HttpServletRequest类)     一次请求内有效 \n* session (HttpSession类)            一个会话范围内有效（打开浏览器访问服务器，直到关闭浏览器） \n* application (ServletContext类)     整个 web 工程范围内都有效（只要 web 工程不停止，数据都在）\n\n8.2 域对象可以像 Map存取数据的对象* 四个域对象功能一样。不同的是它们对数据的存取范围。 \n* 虽然四个域对象都可以存取数据。在使用上它们是有优先顺序的。 \n* 四个域在使用的时候，优先顺序分别是，他们从小到大的范围的顺序。\n  pageContext &#x3D;&#x3D;&gt;&gt;&gt; request &#x3D;&#x3D;&gt;&gt;&gt; session &#x3D;&#x3D;&gt;&gt;&gt; application\n\n\n9. 常用标签9.1 请求转发\n &lt;jsp:forward page=”    “&gt;&lt;/jsp: forward&gt;是请求转发标签，它的功能就是请求转发 page 属性设置请求转发的路径\n &lt;jsp:forward page=”b.jsp”&gt;&lt;/jsp: forward&gt;\n\n","slug":"27-Jsp","date":"2021-09-13T15:04:32.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"大黄"},{"id":"36fd07d1ed0a51bb3b4e77f831ab30e9","title":"Http 基础知识","content":"1. WEB回顾1.1 Web开发中的常见概念B&#x2F;S 系统和C&#x2F;S 系统\n\n\tBrower&#x2F;Server：浏览器 服务器 系统 ----- 网站\n    更新维护成本低，所有计算都在服务端，导致服务器计算压力较大，网络负荷较重\n\n\tClient&#x2F;Server：客户端 服务器 系统 ----- QQ、飞秋、大型游戏  \n    减轻服务器负担，大量计算充分利用客户端计算机资源，更新维护成本高\n\n* web应用服务器 —— 供向外部发布web资源的服务器软件\n\n* web资源 —— 存在于web应用服务器可供外界访问的资源就是web资源\n\n  例如：存在于web应用服务器内部的Html、Css、js、图片、视频等\n\n* 资源分类：\n\n  静态资源：指web页面中供人们浏览的数据始终是不变。比如：HTML、CSS、\tJS、图片、多媒体。\n\n  动态资源：指web页面中供人们浏览的数据是由程序产生的，不同时间点访问\tweb页面看到的内容各不相同。比如：JSP&#x2F;Servlet、ASP、PHP\n\n  javaWEB领域：动态资源认为通过java代码去动态生成html\n\n1.2 网络通信三要素* IP地址\n\n  * 网络中设备的标识，也可以用主机名识别，但ip地址唯一，主机名不唯一；\n\n* 端口号\n\n  * 用于标识进程的逻辑地址，是不同进程的标识；\n\n* 传输协议\n\n  * 也即通信的规则，常见的协议由 UDP 协议 和 TCP协议；\n  * TCP协议：安全协议，三次握手，速度稍慢\n  * UDP协议：不安全协议，速度快\n\n\n1.3 常用的web应用服务器* weblogic：oracle公司的大型收费web服务器 支持全部javaEE规范\n\n* websphere：IBM公司的大型收费web服务器 支持全部的javaEE规范\n\n* Tomcat：Apache开源组织下的 开源免费的中小型的web应用服务器 支持 javaEE 中的 servlet 和 jsp规范\n\n2. Tomcat介绍2.1 文件目录剖析\n* bin: 脚本目录\n       启动脚本：startup.bat\n       停止脚本：shutdown.bat\n\t\t\t\n* conf: 配置文件目录 (config &#x2F;configuration)\n\t\t核心配置文件：server.xml\n\t\t用户权限配置文件：tomcat-users.xml\n\t\t所有web项目默认配置文件：web.xml\n\t\t\t\n* lib:  依赖库，tomcat和web项目中需要使用的jar包\n\n* logs: 日志文件.\n\t\tlocalhost_access_log.*.txt tomcat记录用户访问信息，星*表示时间。\n\t\t例如：localhost_access_log.2016-02-28.txt\n\t\n* temp: 临时文件目录，文件夹内内容可以任意删除。\n\n* webapps: 默认情况下发布WEB项目所存放的目录。\n\n* work: tomcat处理JSP的工作目录。\n\n2.2 启动失败原因分析* 如果没有配置JAVA_HOME环境变量，在双击“startup.bat”文件运行tomcat\t\t时，将一闪立即关闭。且必须配\n\n  置正确，及JAVA_HOME指向JDK的安装目录\n\n* 端口冲突：java.net.BindException: Address already in use: JVM_Bind &lt;null&gt;:8080\n\n  修改Tomcat&#x2F;conf&#x2F;server.xml\n\n\n\n2.3 WEB目录 \n\n注意：WEB-INF目录是受保护的，外界不能直接访问\n3. Http协议3.1 什么是http协议* 协议是指双方，或多方，相互约定好，大家都需要遵守的规则，叫协议。 \n* 而HTTP 协议是指，客户端和服务器之间通信时，发送的数据，需要遵守的规则。 HTTP 协议中的数据又叫 **报文**。\n* 且HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。目前www主流的是HTTP&#x2F;1.0\n\n3.2 http协议主要特点* 支持客户&#x2F;服务器模式。\n\n* 简单快速：客户向服务器请求服务时，只需传送请求方法和路径，由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。\n\n* 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。\n\n* 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n\n* 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。\n\n4. 请求的HTTP协议详解4.1 Get请求4.1.1 请求行* 请求的方式 GET\n* 请求的资源路径[+?+请求参数] \n* 请求的协议的版本号 HTTP&#x2F;1.1 \n\n4.1.2 请求头key : value 组成 不同的键值对，表示不同的含义。\n\n4.1.3 请求体就是发送给服务器的数据\n\n\n4.2 Post请求4.2.1 请求行* 请求的方式 POST\n* 请求的资源路径[+?+请求参数] \n* 请求的协议的版本号 HTTP&#x2F;1.1 \n\n4.2.2 请求头key : value 组成 不同的键值对，表示不同的含义。\n\n空行\n4.2.3 请求体就是发送给服务器的数据\n\n请求内容\n\n4.3 常用请求头* Accept: 表示客户端可以接收的数据类型 \n* Accpet-Languege: 表示客户端可以接收的语言类型 \n* User-Agent: 表示客户端浏览器的信息 \n* Host： 表示请求时的服务器 ip 和端口号\n\n4.4 get 与 post请求有哪些\n\n\nGET 请求有：\nPOST 请求有：\n\n\n\nform 标签 method=get\nform 标签 method=post\n\n\n在浏览器地址栏中输入地址后敲回车\n\n\n\niframe 引入 html 页面\n\n\n\na 标签\n\n\n\nlink 标签引入 css\n\n\n\nScript 标签引入 js 文件\n\n\n\nimg 标签引入图片\n\n\n\n5. 响应的HTTP协议详解5.1 响应5.1.1 响应行* 响应的协议和版本号 \n* 响应状态码\n* 响应状态描述符\n\n5.1.2 响应头key : value 不同的响应头，有其不同含义\n\n空行\n5.1.3 响应体就是回传给客户端的数据\n\n\n5.2 常用响应码说明1. 在接收和解释请求消息后，服务器返回一个HTTP响应消息。\n2. HTTP响应也是由三个部分组成，分别是：&lt;span Style&#x3D;&quot;color:red;&quot;&gt;状态行、消息报头、响应正文&lt;&#x2F;span&gt;\n\n* 状态行格式如下：\n  HTTP-Version Status-Code Reason-Phrase CRLF\n  其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。\n\n\n\na）状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：\n\n    1xx：指示信息--表示请求已接收，继续处理\n    2xx：成功--表示请求已被成功接收、理解、接受\n    3xx：重定向--要完成请求必须进行更进一步的操作\n    4xx：客户端错误--请求有语法错误或请求无法实现\n    5xx：服务器端错误--服务器未能实现合法的请求\n\n\n\n\nb）常见状态代码、状态描述、说明：\n200 OK                                  表示客户端请求成功\n302                                        表示请求重定向\n404 Not Found                      表示请求资源不存在，eg：输入了错误的URL\n500 Internal Server Error      表示服务器已经收到请求，但是服务器发生不可预期的错误\n400                                       客户端请求有语法错误，不能被服务器所理解\n401 Unauthorized                 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用\n403 Forbidden                      服务器收到请求，但是拒绝提供服务\n503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常\n* 响应报头后述\n\n* 响应正文就是服务器返回的资源的内容 \n\n\n\n5.3 MIME类型说明* MIME 是 HTTP 协议中数据类型。 MIME 的英文全称是&quot;Multipurpose Internet Mail Extensions&quot; 多功能 Internet 邮件扩充服务。\n\n* MIME 类型的格式是“大类型&#x2F;小 类型”，并与某一种文件的扩展名相对应。\n\n\n\n\n文件\nMIME 类型\n\n\n\n超文本标记语言文本\n.html , .htm                          text/html\n\n\n普通文本\n.txt                                  text/plain\n\n\nRTF 文本\nrtf                                  application/rtf\n\n\nGIF 图形\ngif                                  image/gif\n\n\nJPEG 图形\n.jpeg,.jpg                             image/jpeg au\n\n\n声音文件\n.au                            audio/basic\n\n\nMIDI 音乐文件\nmid,.midi                            audio/midi,audio/x-midi RealAudio\n\n\n音乐文件\n.ra, .ram                             audio/x-pn-realaudio\n\n\nMPEG 文件\nmpg,.mpeg                               video/mpeg\n\n\nAVI 文件\n.avi                                 video/x-msvideo\n\n\nGZIP 文件\n.gz                               application/x-gzip\n\n\nTAR 文件\n.tar                                 application/x-tar\n\n\n6. 谷歌查看 HTTP 协议\n","slug":"26-Http","date":"2021-09-13T15:04:32.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"大黄"},{"id":"ed74ba118184352b8cd4d1ed4148e31c","title":"JDBC 返回自增，批处理","content":"0.0！等待录入！","slug":"25-JDBC返回自增，批处理","date":"2021-09-13T15:02:32.000Z","categories_index":"JDBC","tags_index":"JDBC","author_index":"大黄"},{"id":"55745060491eb4938fdbbffa36e92659","title":"JDBC 事务，工具类，行级锁","content":"一、JDBC事务机制\nJdbc中的事务是自动提交的。\n只要执行任意一条DML语句，则自动提交一次，这是JDBC的默认事务提交行为。但是实际业务中，很多情况是 需要N条DML语句联合才能完成的，必须保证他们同时成功或者同事失败。\nconn表示一个连接，与数据库的连接，不为空表示还连接着，为空就表示没有连接，就不需要释放资源 stmt，rs，ps与之一样。\n开启事务，提交，catch里写rollback并判断conn不等于nul1rollback的意义在于当还有连接，如果上面的联合语句有些地方有问题，可以进行回滚\n开启事务：conn.setAutoCommit(false);提交事务：conn.commit();回滚事务：conn.rollback();设置回滚点：Savepoint sp = conn.getSavepoint();回滚到回滚点：conn.rollback(sp)；\n\n*两个人转账\n\t  &#x2F;&#x2F;开启事务\n      conn.setAutoCommit(false);\n      \n      &#x2F;&#x2F;转账\n\t  String sql &#x3D; &quot;update deposit set balance &#x3D;? where id &#x3D;?&quot;;\n\t  &#x2F;&#x2F;111的\n\t  ps.setString(1, balance);\n      ps.setString(2, id);\n      int count &#x3D; ps.executeUpdate();\n      &#x2F;&#x2F;222的\n      ps.setString(1, balance2);\n      ps.setString(2, id2);\n      count +&#x3D; ps.executeUpdate();\n      \n      &#x2F;&#x2F;进行查询（发现数据改变，变为更新的值，而数据库中的数据并未改变，因为还事务开启未提交）\n      ps2 &#x3D; conn.prepareStatement(&quot;select * from deposit&quot;);\n            ResultSet rs &#x3D; ps2.executeQuery();\n            while (rs.next())&#123;\n                String id3 &#x3D; rs.getString(1);\n                String balance3 &#x3D; rs.getString(2);\n                System.out.println(id3+&quot;:&quot;+balance3);\n            &#125;\n            \n      &#x2F;&#x2F;若没有问题，此时提交，则数据库中数据进行更新同步\n      \n      &#x2F;&#x2F;若还没提交这里有一个异常，比如空指针异常\n      String s&#x3D;null;\n      s.toString();\n      &#x2F;&#x2F;因为异常，所以会进入到catch()中执行语句\n      \n      &#x2F;&#x2F;首先再次查询一下数据（发现数据和上次查到的一样，所以我们要进行数据回滚）\n      try &#123;\n      ps3 &#x3D; conn.prepareStatement(&quot;select * from deposit&quot;);\n      ResultSet rs &#x3D; ps3.executeQuery();\n      while (rs.next())&#123;\n      String id4 &#x3D; rs.getString(1);\n      String balance4 &#x3D; rs.getString(2);\n      System.out.println(id4+&quot;:&quot;+balance4);\n      &#125;\n      &#125;catch (Exception es)&#123;\n      es.printStackTrace();\n      &#125;\n            \n      &#x2F;&#x2F;回滚\n      if (conn !&#x3D; null) &#123;\n      try &#123;\n      conn.rollback();\n      &#125; catch (SQLException ex) &#123;\n      ex.printStackTrace();\n      &#125;\n      &#125;\n      \n      &#x2F;&#x2F;再次查询（数据更新取消，回到原来的数值）\n            try &#123;\n                ps4 &#x3D; conn.prepareStatement(&quot;select * from deposit&quot;);\n                ResultSet rs &#x3D; ps4.executeQuery();\n                while (rs.next())&#123;\n                    String id5 &#x3D; rs.getString(1);\n                    String balance5 &#x3D; rs.getString(2);\n                    System.out.println(id5+&quot;:&quot;+balance5);\n                &#125;\n            &#125;catch (Exception es)&#123;\n                es.printStackTrace();\n            &#125;\n      \n      \n\n二、JDBC工具类的制作package DBUtil;\nimport java.sql.*;\n\n&#x2F;* 工具类中的构造方法都是私有的，不是必须是私有，只是模仿（模仿sun公司）\n\t\n   因为工具类的方法都是静态的，不需要new对象，直接采用类名调用\n   \n   为了防止别人new对象，所以私有化\n\t\n*&#x2F;\n\npublic class DBUtil &#123;\n\n\t&#x2F;&#x2F;构造方法\n    private DBUtil()&#123;&#125;\n\n\t&#x2F;&#x2F;以静态代码块的方式生成注册驱动的功能，因为类的加载会调用静态代码块，并且只执行一次\n    static &#123;\n        try &#123;\n            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n\t&#x2F;&#x2F;获取数据库连接，\n    public static Connection getConnection() throws Exception&#123;\n\t\treturn  DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db_sql&quot;,&quot;root&quot;,&quot;hhhh&quot;);\n    &#125;\n\t\n    &#x2F;&#x2F;封装关闭资源的方法，因为在jdbc增删改时，用不到rs对象，所以用方法重载，又写了一个此方法\n    public static void close(Connection conn, Statement ps, ResultSet rs)&#123;\n\n        if (rs!&#x3D;null)&#123;\n            try &#123;\n                rs.close();\n            &#125; catch (SQLException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        if (ps!&#x3D;null)&#123;\n            try &#123;\n                ps.close();\n            &#125; catch (SQLException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        if (conn!&#x3D;null)&#123;\n            try &#123;\n                conn.close();\n            &#125; catch (SQLException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n    public static void close(Connection conn, Statement ps)&#123;\n\n        if (ps!&#x3D;null)&#123;\n            try &#123;\n                ps.close();\n            &#125; catch (SQLException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        if (conn!&#x3D;null)&#123;\n            try &#123;\n                conn.close();\n            &#125; catch (SQLException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n\n    &#125;\n&#125;\n\n\n三、行级锁* 使用需要开启事务\n\n1、for update叫排它锁，是一种行级锁，一旦用户对某个行施加了行级加锁，则该用户可以查询也可以更新被加锁的数据行，其它用户只能查询但不能更新被加锁的数据行．如果其它用户想更新该表中的数据行，则也必须对该表施加行级锁．即使多个用户对一个表均使用了共享更新，但也不允许两个事务同时对一个表进行更新，真正对表进行更新时，是以独占方式锁表，一直到提交或复原该事务为止。行锁永远是独占方式锁。\n只有当出现如下之一的条件，便释放共享更新锁：\n（1）、执行提交（COMMIT）语句；\n（2）、退出数据库（LOG　OFF）\n（3）、程序停止运行。\n\nSelect …for update语句是我们经常使用手工加锁语句。通常情况下，select语句是不会对数据加锁，妨碍影响其他的DML和DDL操作。同时，在多版本一致读机制的支持下，select语句也不会被其他类型语句所阻碍。\n\n2、 借助for update子句，我们可以在应用程序的层面手工实现数据加锁保护操作\n\n什么时候需要使用for update？就是那些需要业务层面数据独占时，可以考虑使用for update。场景上，比如火车票订票，在屏幕上显示邮票，而真正进行出票时，需要重新确定一下这个数据没有被其他客户端修改。所以，在这个确认过程中，可以使用for update。\n\n3、顺便说一下乐观锁和悲观锁\n\n悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。\n\n乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。\n\n4、一般遇到高并发会有多服务器部署，这时候就要用到分布式锁\n    \n【此内容来自】https:&#x2F;&#x2F;www.cnblogs.com&#x2F;h-c-g&#x2F;p&#x2F;10234477.html\n\n四、封装JDBCTools配置文件：src/jdbc.properties\n#key&#x3D;value\ndriverClassName&#x3D;com.mysql.jdbc.Driver\nurl&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test\nusername&#x3D;root\npassword&#x3D;123456\ninitialSize&#x3D;5\nmaxActive&#x3D;10\nmaxWait&#x3D;1000\n\nJDBCTools工具类：\npackage com.atguigu.util;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Properties;\nimport javax.sql.DataSource;\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\n\n&#x2F;*\n * 获取连接或释放连接的工具类\n *&#x2F;\npublic class JDBCTools &#123;\n\t&#x2F;&#x2F; 1、数据源,即连接池\n\tprivate static DataSource dataSource;\n\t\n\t&#x2F;&#x2F; 2、ThreadLocal对象\n\tprivate static ThreadLocal&lt;Connection&gt; threadLocal &#x3D; new ThreadLocal&lt;&gt;();\n\n\tstatic &#123;\n\t\ttry &#123;\n\t\t\t&#x2F;&#x2F;1、读取druip.properties文件\n\t\t\tProperties pro &#x3D; new Properties();\n\t\t\tpro.load(JDBCTools2.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));\n\t\t\t\n\t\t\t&#x2F;&#x2F;2、创建线程池\n\t\t\tdataSource &#x3D; DruidDataSourceFactory.createDataSource(pro);\n\t\t&#125; catch (Exception e) &#123;\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;**\n\t * 获取连接的方法\n\t * \n\t * @return\n\t * @throws SQLException\n\t *&#x2F;\n\tpublic static Connection getConnection() &#123;\n\t\t&#x2F;&#x2F; 从当前线程中获取连接\n\t\tConnection connection &#x3D; threadLocal.get();\n\t\tif (connection &#x3D;&#x3D; null) &#123;\n\t\t\t&#x2F;&#x2F; 从连接池中获取一个连接\n\t\t\ttry &#123;\n\t\t\t\tconnection &#x3D; dataSource.getConnection();\n\t\t\t\t&#x2F;&#x2F; 将连接与当前线程绑定\n\t\t\t\tthreadLocal.set(connection);\n\t\t\t&#125; catch (SQLException e) &#123;\n\t\t\t\te.printStackTrace();\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn connection;\n\t&#125;\n\n\t&#x2F;**\n\t * 释放连接的方法\n\t * \n\t * @param connection\n\t *&#x2F;\n\tpublic static void releaseConnection() &#123;\n\t\t&#x2F;&#x2F; 获取当前线程中的连接\n\t\tConnection connection &#x3D; threadLocal.get();\n\t\tif (connection !&#x3D; null) &#123;\n\t\t\ttry &#123;\n\t\t\t\tconnection.close();\n\t\t\t&#125; catch (SQLException e) &#123;\n\t\t\t\te.printStackTrace();\n\t\t\t&#125;finally&#123;\n\t\t\t\t&#x2F;&#x2F; 将已经关闭的连接从当前线程中移除\n\t\t\t\tthreadLocal.remove();\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n其中ThreadLocal的介绍如下：\nJDK 1.2的版本中就提供java.lang.ThreadLocal，为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。通常用来在在多线程中管理共享数据库连接、Session等\nThreadLocal用于保存某个线程共享变量，原因是在Java中，每一个线程对象中都有一个ThreadLocalMap&lt;ThreadLocal, Object&gt;，其key就是一个ThreadLocal，而Object即为该线程的共享变量。而这个map是通过ThreadLocal的set和get方法操作的。对于同一个static ThreadLocal，不同线程只能从中get，set，remove自己的变量，而不会影响其他线程的变量。\n1、ThreadLocal.get: 获取ThreadLocal中当前线程共享变量的值。\n2、ThreadLocal.set: 设置ThreadLocal中当前线程共享变量的值。\n3、ThreadLocal.remove: 移除ThreadLocal中当前线程共享变量的值。\n\n五、封装BasicDAOImpl&#x2F;&#x2F;1.获取泛型父类\nType genType &#x3D; getClass().getGenericSuperclass();\n&#x2F;&#x2F;2.获取实际传入的泛型参数类型\nType[] typeParams &#x3D; ((ParameterizedType) genType).getActualTypeArguments();\nClass entityClass &#x3D; (Class)typeParams[0];\n\nField field &#x3D; entityClass.getDeclaredField(colName);\nfield.setAccessible(true);\nfield.set(instance, rs.getObject(i));\n\npackage com.atguigu.test08.dao;\n\nimport java.lang.reflect.Field;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\n\nimport com.atguigu.util.JDBCTools;\n\npublic class BasicDAOImpl &#123;\n\t&#x2F;*\n\t * 通用的增、删、改的方法\n\t *&#x2F;\n\tprotected int update(String sql,Object... args) throws SQLException&#123;\n\t\t&#x2F;&#x2F;1、获取链接对象\n\t\tConnection conn &#x3D; JDBCTools.getConnection();\n\t\t\n\t\t&#x2F;&#x2F;2、编写sql，用形参传入的方式代替\n\t\t\n\t\t&#x2F;&#x2F;3、获取Statement或PreparedStatement对象\n\t\tPreparedStatement pst &#x3D; conn.prepareStatement(sql);\n\t\t\n\t\t&#x2F;&#x2F;设置？的值\n\t\t&#x2F;&#x2F;因为不知道sql中是否有?，以及？设置为什么值，通过形参来传入\n\t\t&#x2F;&#x2F;Object... args可变形参，可以传入0~n个值\n\t\t&#x2F;&#x2F;如果没有传入，说明没有？需要设置\n\t\t&#x2F;&#x2F;如果传入了n个值，那么说明sql中有n个？需要设置\n\t\tif(args!&#x3D;null  &amp;&amp; args.length&gt;0)&#123;\n\t\t\tfor (int i &#x3D; 0; i &lt; args.length; i++) &#123;\n\t\t\t\t&#x2F;&#x2F;数组的下标从0开始，pst的？的序号是从1开始，所以这里用i+1\n\t\t\t\tpst.setObject(i+1, args[i]);\n\t\t\t&#125;\n\t\t&#125;\n\t\t\n\t\t&#x2F;&#x2F;4、执行sql\n\t\tint len &#x3D; pst.executeUpdate();\n\t\t&#x2F;&#x2F;5、关闭\t\t\n\t\tpst.close();\n\t\t&#x2F;&#x2F;这里不关闭conn，因为它在同一个事务的其他地方还要使用\n\t\treturn len;\n\t&#125;\n\t\n\t&#x2F;*\n\t * 通用查询多个Javabean对象的方法\n\t *&#x2F;\n\tprotected &lt;T&gt; ArrayList&lt;T&gt; getList(Class&lt;T&gt; clazz,String sql,Object... args) throws Exception&#123;\n\t\t&#x2F;&#x2F;1、获取链接对象\n\t\tConnection conn &#x3D; JDBCTools.getConnection();\n\t\t&#x2F;&#x2F;2、编写sql，由形参传入\n\t\t\n\t\t&#x2F;&#x2F;3、获取PreparedStatement对象\n\t\tPreparedStatement pst &#x3D; conn.prepareStatement(sql);\n\t\t\n\t\t&#x2F;&#x2F;4、设置？，由形参传入\n\t\tif(args!&#x3D;null  &amp;&amp; args.length&gt;0)&#123;\n\t\t\tfor (int i &#x3D; 0; i &lt; args.length; i++) &#123;\n\t\t\t\t&#x2F;&#x2F;数组的下标从0开始，pst的？的序号是从1开始，所以这里用i+1\n\t\t\t\tpst.setObject(i+1, args[i]);\n\t\t\t&#125;\n\t\t&#125;\n\t\t\n\t\t&#x2F;&#x2F;5、执行sql\n\t\tResultSet rs &#x3D; pst.executeQuery();\n\t\t&#x2F;*\n\t\t * 如何把ResultSet结果集中的数据变成一个一个的Javabean对象，放到ArrayList对象，并且返回\n\t\t *&#x2F;\n\t\tArrayList&lt;T&gt; list &#x3D; new ArrayList&lt;&gt;();\n\t\t&#x2F;*\n\t\t * 要从ResultSet结果集中获取一共有几行，决定要创建几个对象\n\t\t * 要从ResultSet结果集中获取一共有几列，决定要为几个属性赋值\n\t\t * ResultSet结果集对象中，有一个方法ResultSetMetaData getMetaData()获取结果集的元数据\n\t\t * 元数据就是描述结果集中的数据的数据，例如：列数，列名称等\n\t\t *&#x2F;\n\t\tResultSetMetaData metaData &#x3D; rs.getMetaData();\n\t\tint count &#x3D; metaData.getColumnCount();&#x2F;&#x2F;获取列数\n\t\t\n\t\twhile(rs.next())&#123;&#x2F;&#x2F;循环一次代表一行，就要创建一个Javabean对象\n\t\t\t&#x2F;&#x2F;(1)创建一个Javabean对象\n\t\t\tT t  &#x3D; clazz.newInstance();&#x2F;&#x2F;这个方法有要求，要求Javabean这个类要有无参构造\n\t\t\t\n\t\t\t&#x2F;&#x2F;(2)设置对象的属性值\n\t\t\t&#x2F;*\n\t\t\t * 反射操作属性的步骤：\n\t\t\t * ①获取Class对象，现在有了\n\t\t\t * ②获取属性对象Field\n\t\t\t * \t\tField f &#x3D; clazz.getDeclaredField(&quot;属性名&quot;);\n\t\t\t * ③创建Javabean对象，已经创建\n\t\t\t * ④设置属性的可访问性  setAccessible(true)\n\t\t\t * ⑤设置属性的值\n\t\t\t *&#x2F;\n\t\t\tfor (int i &#x3D; 0; i &lt; count; i++) &#123;&#x2F;&#x2F;一共要为count个属性赋值\n&#x2F;&#x2F;\t\t\t\tField f &#x3D; clazz.getDeclaredField(&quot;属性名&quot;);\n\t\t\t\tString fieldName &#x3D; metaData.getColumnLabel(i+1);&#x2F;&#x2F;获取第几列的字段名\n\t\t\t\tField f &#x3D; clazz.getDeclaredField(fieldName);\n\t\t\t\t\n\t\t\t\tf.setAccessible(true);\n\t\t\t\t\n\t\t\t\tf.set(t, rs.getObject(i+1));&#x2F;&#x2F;rs.getObject(i+1)获取第几列的值\n\t\t\t&#125;\n\t\t\t\n\t\t\t&#x2F;&#x2F;(3)把Javabean对象放到list中\n\t\t\tlist.add(t);\n\t\t&#125;\n\t\tpst.close();\n\t\trs.close();\n\t\t&#x2F;&#x2F;这里不关闭conn，因为它在同一个事务的其他地方还要使用\n\t\treturn list;\n\t&#125;\n\n\tprotected &lt;T&gt; T getBean(Class&lt;T&gt; clazz,String sql,Object... args) throws Exception&#123;\n\t\treturn getList(clazz,sql,args).get(0);\n\t&#125;\n&#125;\n\n\n","slug":"24-JDBC事务、工具类、行级锁","date":"2021-09-13T15:01:32.000Z","categories_index":"JDBC","tags_index":"JDBC","author_index":"大黄"},{"id":"bb5bc50a09711181a6e48f61d586b1e3","title":"JDBC 连接池及项目结构","content":"1、三层架构UI(表现层): 主要是指与用户交互的界面。用于接收用户输入的数据和显示处理后用户需要的数据。\nBLL(业务逻辑层): UI层和DAL层之间的桥梁。实现业务逻辑。业务逻辑具体包含：验证、计算、业务规则等等。\nDAL(数据访问层): 与数据库打交道。主要实现对数据的增、删、改、查。将存储在数据库中的数据提交给业务层，同时将业务层处理的数据保存到数据库。（当然这些操作都是基于UI层的。用户的需求反映给界面（UI），UI反映给BLL，BLL反映给DAL，DAL进行数据的操作，操作后再一一返回，直到将用户所需数据反馈给用户）\nEntity(实体层)：它不属于三层中的任何一层，但是它是必不可少的一层。\n三层架构与MVC的区别：MVC（模型Model-视图View-控制器Controller）是一种架构模式，可以用它来创建在域对象和UI表示层对象之间的区 分。\n2、为什么使用三层？使用三层架构的目的：解耦！！！|||||   层次清晰，分工明确，每层之间耦合度低——提高了效率，适应需求变化，可维护性高，可扩展性高   ||||\n同样拿上面饭店的例子来讲：\n（1）服务员（UI层）请假——另找服务员；厨师（BLL层）辞职——招聘另一个厨师；采购员（DAL）辞职——招聘另一个采购员； （2）顾客反映：\n\n1、你们店服务态度不好——服务员的问题。开除服务员；\n2、你们店菜里有虫子——厨师的问题。换厨师；\n\n任何一层发生变化都不会影响到另外一层！！！\n3、标准的项目结构\nweb层                                      web/servlet/controller         \n\nservice层（业务逻辑层）         service Service                 接口包 \n​                                                service.impl Service           接口实现类 \n\ndao层    （数据持久层）        dao Dao                         接口包\n                                                                                   dao.impl Dao                   接口实现类\n\n\npojo层   （实体层）              pojo/entity/domain/bean    JavaBean 类 \n\n测试包                                test/junit \n\n工具类                                utils\n\n\n4、连接池4.1、连接池简介1.概念\n其实就是一个容器（集合），存储数据库连接的容器\n当容器初始化好后，容器被创建，容器中会申请一些连接对象，当用户访问数据库时，从容器中获取连接对象，用户访问完后，会将连接对象归还给容器。\n\n2.好处\n节约资源\n用户访问高效\n\n3.实现\n实现接口：javax.sql.DataSource\n\n方法：\n1）获取连接：getConnection()\n2）归还连接：close()\n​        如果连接对象是从连接池中获取，那么close()方法不再是关闭连接，而是归还连接\n\n\n4.连接池技术\nc3p0\nDBCP：它与Druid非常像，都是properties作为配置文件，然后加载配置文件\nDruid：阿里巴巴提供，被认为世界最好的数据库连接池技术之一\n\n4.2、C3P0的使用（不用）1.步骤\n导入jar包（两个包）\n1）c3p0-0.9.5.5.jar        2）mchange-commons-java-0.2.19.jar\n\n定义配置文件\n1）名称：c3p0.properties 或者 c3p0.xml\n2）路径 ：直接放在src目录下即可\n\n创建核心对象\n数据库连接池对象，new ComboPooledDataSource();\n\n获取连接\ngetConnection()\n* 获取连接\n&#x2F;*1.导入jar包*&#x2F;\n&#x2F;*2.创建数据库连接池对象*&#x2F;\nComboPooledDataSource dataSource &#x3D; new ComboPooledDataSource();\n&#x2F;*3.获取连接对象*&#x2F;\nConnection conn &#x3D; dataSource.getConnection();\n\n2.配置文件&lt;!-- 自定义的c3p0-config.xml --&gt;\n&lt;c3p0-config&gt;\n    &lt;default-config&gt;\n        &lt;property name&#x3D;&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;jdbcUrl&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;xscj&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;user&quot;&gt;root&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;password&quot;&gt;hhhh&lt;&#x2F;property&gt;\n\n        &lt;!--初始化申请连接数量--&gt;\n        &lt;property name&#x3D;&quot;initialPoolSize&quot;&gt;10&lt;&#x2F;property&gt;\n        &lt;!--最大空闲时间，0表示永不丢弃--&gt;\n        &lt;property name&#x3D;&quot;maxIdleTime&quot;&gt;30&lt;&#x2F;property&gt;\n        &lt;!-- 连接超时时间, default: 0。如果是0，表示无限等待 --&gt;\n        &lt;property name&#x3D;&quot;checkoutTimeout&quot;&gt;3000&lt;&#x2F;property&gt;\n        &lt;!--连接池最大的连接数量--&gt;\n        &lt;property name&#x3D;&quot;maxPoolSize&quot;&gt;10&lt;&#x2F;property&gt;\n        &lt;!--连接池最小的连接数量--&gt;\n        &lt;property name&#x3D;&quot;minPoolSize&quot;&gt;2&lt;&#x2F;property&gt;\n    &lt;&#x2F;default-config&gt;\n\n    &lt;named-config name&#x3D;&quot;mySource&quot;&gt;\n        &lt;property name&#x3D;&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;jdbcUrl&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;xscj&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;user&quot;&gt;root&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;password&quot;&gt;hhhh&lt;&#x2F;property&gt;\n\n        &lt;property name&#x3D;&quot;initialPoolSize&quot;&gt;10&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;maxIdleTime&quot;&gt;30&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;maxPoolSize&quot;&gt;100&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;minPoolSize&quot;&gt;10&lt;&#x2F;property&gt;\n    &lt;&#x2F;named-config&gt;\n&lt;&#x2F;c3p0-config&gt;\n\n3.最大连接数测试&#x2F;**\n * @author Charon\n * @date 2020&#x2F;6&#x2F;22\n * @maxPoolSize 验证连接池最大连接数量\n **&#x2F;\npublic class c3p0Demo_02 &#123;\n\n    public static void main(String[] args) throws SQLException &#123;\n\n        &#x2F;*1.导入jar包*&#x2F;\n        &#x2F;*2.创建数据库连接池对象*&#x2F;\n        ComboPooledDataSource dataSource &#x3D; new ComboPooledDataSource();\n        &#x2F;*3.获取连接对象*&#x2F;\n        for (int i&#x3D;0; i&lt;10;i++)&#123;\n            Connection conn &#x3D; dataSource.getConnection();\n            &#x2F;*4.打印*&#x2F;\n            System.out.println(i+&quot;:&quot;+conn);\n        &#125;\n    &#125;\n\n&#125;\n\n4.归还方法及ComboPooledDataSource()是否传参&#x2F;**\n * @author Charon\n * @date 2020&#x2F;6&#x2F;22\n * @close() 验证连接池中 归还方法：close()\n *          不归还，因最大连接条数原因，只有10条结果\n *          归还后，发现有11条结果，且5和9的连接对象是同一个（这个调用时随机的，不一定和后面的哪一个一样）\n *          5：[wrapping: com.mysql.jdbc.Connection@4590c9c3]\n *          9：[wrapping: com.mysql.jdbc.Connection@4590c9c3]\n * @ new ComboPooledDataSource(); 括号内不传参数表示使用xml中的默认参数，传值表示使用的是xml中相应名字的参数\n **&#x2F;\npublic class c3p0Demo_03 &#123;\n\n    @Test\n    public void test_Close() throws SQLException &#123;\n\n        &#x2F;*1.获取数据库连接池对象*&#x2F;\n        DataSource dataSource &#x3D; new ComboPooledDataSource();\n        &#x2F;*2.获取连接 因为归还了一个，所以说可以有11次*&#x2F;\n        for (int i&#x3D;0; i&lt;&#x3D;10; i++)&#123;\n            Connection conn &#x3D; dataSource.getConnection();\n        &#x2F;*3.打印*&#x2F;\n            System.out.println(i+&quot;:&quot;+conn);\n        &#x2F;*4.归还连接*&#x2F;\n            if (i&#x3D;&#x3D;5)&#123;\n                conn.close();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n4.3、DBCP连接池（不用）\nDBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：\nCommons-dbcp.jar：连接池的实现\nCommons-pool.jar：连接池实现的依赖库\n\n\nTomcat 的连接池正是采用该连接池来实现的。该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。\n\n\n它与Druid非常像，都是properties作为配置文件，然后加载配置文件\n\n加载配置的方法也相同\n\n然后创建DataSource ，使用的是 BasicDataSourceFactory.creatDataSource();\n\n\n4.4、Druid的使用1.步骤\n导入jar包\ndruid-1.1.22.jar\n\n定义配置文件\n1）形式：是properties形式的\n2）名称：可以叫任何名字 \n3）路径 ：可以放在任意的目录下\n4）不会自动加载了，需要手动加载\n\n获取数据库连接池对象\n通过工厂来获取，DruidDataSourceFactory\n\n获取连接\ngetConnection()\n\n关闭资源\nclose();（德鲁伊中关闭资源并不是真的关闭，而是将连接的状态设置为休眠，当有人再次申请时，可能会激活他（也可能申请到其他的））\n\n\n2.详细配置参数\n\n\n配置\n缺省\n说明\n\n\n\nname\n\n配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。   如果没有配置，将会生成一个名字，格式是：”DataSource-” +   System.identityHashCode(this)\n\n\nurl\n\n连接数据库的url，不同数据库不一样。例如：mysql :   jdbc:mysql://10.20.153.104:3306/druid2      oracle :   jdbc:oracle:thin:@10.20.149.85:1521:ocnauto\n\n\nusername\n\n连接数据库的用户名\n\n\npassword\n\n连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter\n\n\ndriverClassName\n\n根据url自动识别   这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)\n\n\ninitialSize\n0\n初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时\n\n\nmaxActive\n8\n最大连接池数量\n\n\nmaxIdle\n8\n已经不再使用，配置了也没效果\n\n\nminIdle\n\n最小连接池数量\n\n\nmaxWait\n\n获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。\n\n\npoolPreparedStatements\nfalse\n是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。\n\n\nmaxOpenPreparedStatements\n-1\n要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100\n\n\nvalidationQuery\n\n用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。\n\n\ntestOnBorrow\ntrue\n申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n\n\ntestOnReturn\nfalse\n归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能\n\n\ntestWhileIdle\nfalse\n建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n\n\ntimeBetweenEvictionRunsMillis\n\n有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n\n\nnumTestsPerEvictionRun\n\n不再使用，一个DruidDataSource只支持一个EvictionRun\n\n\nminEvictableIdleTimeMillis\n\n\n\n\nconnectionInitSqls\n\n物理连接初始化的时候执行的sql\n\n\nexceptionSorter\n\n根据dbType自动识别   当数据库抛出一些不可恢复的异常时，抛弃连接\n\n\nfilters\n\n属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：   监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall\n\n\nproxyFilters\n\n类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系\n\n\n3.连接操作@Test\npublic void test_connection() throws Exception &#123;\n\n    &#x2F;*1.导入jar包*&#x2F;\n    &#x2F;*2.定义配置文件 druid.properties*&#x2F;\n    &#x2F;*3.加载配置文件*&#x2F;\n    InputStream is &#x3D; druidDemo_01.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);\n    Properties pro &#x3D; new Properties();\n    pro.load(is);\n\n    &#x2F;*4.获取数据库连接池对象*&#x2F;\n    DataSource ds &#x3D; DruidDataSourceFactory.createDataSource(pro);\n    &#x2F;*5.获取连接*&#x2F;\n    Connection conn &#x3D; ds.getConnection();\n    System.out.println(conn);\n\n&#125;\n\n4.Durid 工具类&#x2F;**\n * @author Charon\n * @date 2020&#x2F;6&#x2F;23\n * druid 连接池工具类\n **&#x2F;\npublic class DruidUtil &#123;\n\n    private static DataSource ds;\n\n    public DruidUtil()&#123;&#125;\n\n    static &#123;\n\n        try &#123;\n            &#x2F;*1.导包，写配置文件*&#x2F;\n            &#x2F;*2.加载配置文件*&#x2F;\n            InputStream is &#x3D; DruidUtil.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);\n            Properties pro &#x3D; new Properties();\n            pro.load(is);\n\n            &#x2F;*3.获取数据库连接池对象*&#x2F;\n            ds &#x3D; DruidDataSourceFactory.createDataSource(pro);\n\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n\n    &#125;\n\n\n    &#x2F;**\n     *获取连接\n     *&#x2F;\n    public static Connection getConnection() throws SQLException &#123;\n        return ds.getConnection();\n    &#125;\n\n    &#x2F;**\n     * 关闭资源\n     * *&#x2F;\n\n    &#x2F;*获取ds对象（jdbcTemplate中使用）*&#x2F;\n    public static DataSource getDataSource()&#123;\n        return ds;\n    &#125;\n&#125;\n\n4.5、JdbcTemplate入门1.概述\nJDBCTemplate就是Spring对JDBC的封装,通俗点说就是Spring对jdbc的封装的模板。\n使用spring的注入功能，可以把DataSource注册到JdbcTemplate之中,\n相比较于传统的JDBC,大大简化了数据库的操作。\n\n\n2.步骤\n导入jar包（5个包）\nspring-tx-5.1.10.RELEASE.jar        spring-core-5.1.10.RELEASE.jar\nspring-jdbc-5.1.10.RELEASE.jar   spring-beans-5.1.10.RELEASE.jar\ncommons-logging-1.2.jar\n\n定义配置文件\n\n获取JdbcTemplate对象\nJdbcTemplate template = new JdbcTemplate(ds);\n\n常用方法\n\nupdate()                        \n返回的是一个int值，影响的行数， 用于执行INSERT、UPDATE、DELETE等DML语句。        \n\nqueryForMap()            \n将查询结果封装为map集合，列名作为key，值作为value\n\n\n​         注意：查询单个对象，这个方法查询的结果集长度为  1\n\nqueryForList()       \n查询多个对象，返回一个List对象，List对象存储是Map对象\n注意：将每一条记录封装为一个map集合，再讲map集合封装到List集合中\n\nqueryForObject( sql , 聚合函数类型的class文件)      \n查询单个对象,将结果封装为对象，返回单个实体类对象\n注意：一般用于聚合函数的查询\nString sql &#x3D; &quot;select count(学号) from xs_kc&quot;;\nLong aLong &#x3D; template.queryForObject(sql, Long.class);\nquery( sql , RowMapper )                         \n查询多个对象，返回的是一个List对象，List对象存储是实体类（javaBean对象）\n注意：query的参数RowMapper\n​                一般我们使用的是BeanPropertyRowMapper实现类，可以完成数据到javabean的自动封装\nList&lt;xskc&gt; list &#x3D; template.query(sql,new BeanPropertyRowMapper&lt;xskc&gt;(xskc.class));\n\n\n\n3.操作&#x2F;**\n * @author Charon\n * @date 2020&#x2F;6&#x2F;23\n *\n * JDBCTemplate 入门\n **&#x2F;\npublic class JDBCTemplate_01 &#123;\n\n    public static void main(String[] args) &#123;\n\n        &#x2F;*1.导入jar包（5个）*&#x2F;\n        &#x2F;*2.创建Template对象*&#x2F;\n        JdbcTemplate template &#x3D; new JdbcTemplate(DruidUtil.getDataSource());\n        &#x2F;*3.调用方法*&#x2F;\n        String sql &#x3D; &quot;update xs_kc set 学分&#x3D;? where 学号&#x3D;?&quot;;\n        int count &#x3D; template.update(sql, 5, &quot;081260&quot;);\n        System.out.println(count);\n\n\n    &#125;\n&#125;\n\n4.6、DBUtilscommons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。\n其中QueryRunner类封装了SQL的执行，是线程安全的。\n（1）可以实现增、删、改、查、批处理、\n（2）考虑了事务处理需要共用Connection。\n（3）该类最主要的就是简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。\n（1）更新\npublic int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。\n……\n（2）插入\npublic  T insert(Connection conn,String sql,ResultSetHandler rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值\n….\n（3）批处理\npublic int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句\npublic  T insertBatch(Connection conn,String sql,ResultSetHandler rsh,Object[][] params)throws SQLException：只支持INSERT语句\n…..\n（4）使用QueryRunner类实现查询\npublic Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。\n….\nResultSetHandler接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet  rs)该方法的返回值将作为QueryRunner类的query()方法的返回值。\n该接口有如下实现类可以使用：\n\nBeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。\nBeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。\nScalarHandler：查询单个值对象（聚合函数）\nMapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。\nMapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List\nColumnListHandler：将结果集中某一列的数据存放到List中。\nKeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。\nArrayHandler：把结果集中的第一行数据转成对象数组。\nArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。\n\n","slug":"23-三层架构、项目结构、连接池","date":"2021-09-13T14:58:32.000Z","categories_index":"JDBC","tags_index":"JDBC","author_index":"大黄"},{"id":"43229a92952aad915ea9d7e4fe26c570","title":"JDBC 基础总结","content":"一、JDBC的本质1、JDBC是什么？Java Database  Connectuvity（java语言数据库）\n使用java语言操作数据库\n2、JDBC的本质是什么？\nJDBC是SUN公司指定的一套接口(interface)：java.sql.*; (这个软件包下有很多接口)\n\n接口都有调用者和实现者\n面向接口调用，面向接口写实现类，这都属于面向接口编程\n\n为什么要面向接口编程？\n解耦合：降低程序的耦合性，提高程序的扩展力\n多态机制就是非常非典型的：面向抽象编程（不要面向程序编程，耦合性大，牵一发而动全身）\n即建议：\nAnimal   a &#x3D;   new Cat();\nAnimal   a &#x3D;   new  Dog();\n\n不建议：\nCat  a&#x3D;new Cat();\nDog a&#x3D;new  Dog();\nSUN公司制定这样一套接口？\n因为每一个数据库的底层实现原理不一样。\nOracle，MySql，MS Sqlserver数据库都有自己独特的的实现原理。\n于是各个厂遵循了JDBC规范，制定了可以访问自己数据库的API，被称之为驱动！\n\n\n\n3、JDBC创建步骤（背会）第一步：注册驱动（作用：告诉Java程序，即将要连接的是哪个品牌的数据库）\n第二步：获取连接（表示JVM的进程和数据库进程之间的通道打开了，这属于进程之间的通信，重量级的，使用完之后一定要关闭通道。）\n第三步：执行SQL语句并处理结果（DQL DML….）(编写sql，获取数据库操作对象，执行sql，处理结果)（大部分时候只有执行的是select语句的时候，才有处理查询结果集。）\n第四步：释放资源（使用完资源之后一定要关闭资源。Java和数据库属于进程间的通信，开启之后一定要关闭。）\n4、两种思想\n面向接口编程的思想\n\nORM思想(object relational mapping)\n\n一个数据表对应一个java类\n表中的一条记录对应java类的一个对象\n表中的一个字段对应java类的一个属性\n\n\n\n二、步骤详解1、注册驱动1.1、第一种方式（不常用）\npublic interface Driver每个驱动程序类必须实现的接口(接口的实现 — 多态)当加载一个Driver类时，它应该创建一个自己的实例，并用DriverManager注册它\ncom.mysql.jdbc.Driver是Driver接口的实现类该类就在 mysql-connector-java-5.0.8-bin.jar中。\npublic class DriverManager extends Object用于管理一组JDBC驱动程序的基本服务\nregisterDriver(Driver driver)DriverManager的方法，使用 DriverManager注册给定的驱动程序。\n\n代码实现\njava.sql.Driver driver &#x3D; new com.mysql.jdbc.Driver();\nDriverManager.registerDriver(driver);\n\n1.2、第二种方式（最常用）\nClass.forName可以把一个类加载到JVM中，加载的时候,会 执行其中的 静态初始化块，完成其初始化的相关工作静态代码块在类加载时执行，并且只执行一次\n\n在 com.mysql.jdbc.Drive中，有这样的一段静态代码块\nstatic &#123;\n    try &#123;\n       java.sql.DriverManager.registerDriver(new Driver());\n    &#125; catch (SQLException E) &#123;\n       throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);\n    &#125;\n  &#125;\n所以可以用class.forName 加载此代码块，调用 java.sql.DriverManager.registerDriver(new Driver())\n\n\n*代码实现\nClass.forName(&quot;com.mysql.jdbc.Driver&quot;);\n\n*常用的原因\n以上方法不需要返回值，参数是一个字符串，以后可以写到 xxx.properties 文件中\n\n2、获取连接\npublic interface Connection  extends Wrapper, AutoCloseable与特定数据库的连接（会话）。 执行SQL语句并在连接的上下文中返回结果\n\npublic static Connection getConnection(String url,String user,String password)尝试建立与给定数据库URL的连接。 DriverManager尝试从一组已注册的JDBC驱动程序中选择适当的驱动程序。| 使用的时候需要导包，而且必须在程序结束的时候将其关闭 |\n\n代码实现\nString url &#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;testdb?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&quot;;\nString user &#x3D; &quot;wx&quot;;\nString password &#x3D; &quot;091599&quot;;\nConnection conn &#x3D; DriverManager.getConnection(url,user,password);\nSystem.out.println(conn&#x3D;&#x3D;null?&quot;连接失败&quot;:&quot;连接成功&quot;);    \n关于 url \n概念：url是网络中的某个资源的绝对路径（统一资源定位符）\n包括：协议，ip，port(端口)，资源名\n\n\n\n\n\n上述的通信协议是什么，有什么用\n通信协议就是通信之前就提前定好的数据传送格式。数据包具体怎么传数据，格式是提前定好的\n\n\n3、执行SQL语句并处理结果3.1、编写SQL语句3.2、获取数据库操作对象\n第一种（存在sql注入）\n创建Statement对象\n方法：Statement createStatement()  throws SQLException(Connection里的方法，用conn调用)创建之后，可以执行SQL语句，完成对数据库的增删改查。\n代码实现Statement stmt = conn.createStatement();\n\n\n第二种（解决sql注入）\n创建PreparedStatement对象\n代码实现PreparedStatement pstmt = conn.prepareStatement(String s[“sql语句”]) \n\n\n\n3.3、执行SQL语句增删改执行用 executeUpdate查询自行用 executeQuery\n执行DML 语句的方法\n\n*步骤\n1、int executeUpdate(String sql)  throws SQLException  \n(Statement的方法，返回 int类型的 值)\n    \n2、此方法 不执行 DQL 语句 ，专门执行DML语句的（insert delete update）\n或者不返回任何内容，如DDL的SQL语句\n\n3、返回的值是  “影响数据库中的记录条数”\n\n4、注意：java 中的 sql语句不能分号结尾\n\t\n*代码实现\nint count &#x3D; stmt.executeUpdate(sql);\n\n*执行 DQL 语句的方法\n    \n1.ResultSet executeQuery​(String sql) throws SQLException\n\t  执行给定的SQL语句，返回一个  ResultSet（结果集）对象。\n\t  \n2.参数 sql - 要发送到数据库的SQL语句，通常为静态 &#123;SQL SELECT语句&#125;\n\n3.4、处理查询结果集*步骤\n1.public interface ResultSet extends Wrapper, AutoCloseable\n表示数据库结果集的数据表，通常通过 &#123;执行查询&#125; 数据库的语句生成。\n    \n2.boolean next() 将光标从当前位置向前移动一行\n比较像 iterator 的 hasNext 下一行有数据的情况下，返回true否则false\n    \n3.所以为了减少代码的重复\n用while循环改进，能一次读出来全部信息\n    \n4，String getString​(int columnIndex) throws SQLException\n检索此 ResultSet对象的当前行中指定列的值为Java编程语言中的 String 。 \n参数：columnIndex - 第一列是1，第二列是2\n    \n5.为了代码的健壮性，getString的参数一般不写数字（列的索引），因为如果改变了数据库中列的顺序\n查询的结果就不对应了，不方便观察\n直接写SQL语句中想要查询的对应的列名，如果sql语句中用as改变列名，那这里应写改变后的列名\n\n代码实现\nrs &#x3D; stmt.executeQuery(sql);\n    while (rs.next()) &#123;\n    String 学号 &#x3D; rs.getString(&quot;学号&quot;);\n    String 课程号 &#x3D; rs.getString(&quot;课程号&quot;);\n    String 成绩 &#x3D; rs.getString(&quot;成绩&quot;);\n    String 学分 &#x3D; rs.getString(&quot;学分&quot;);\n    System.out.println(学号 + &quot;|&quot; + 课程号 + &quot;|&quot; + 成绩 + &quot;|&quot; + 学分);\n    &#125;\n\n4、释放资源\n为了保证资源一定释放，在finally语句中关闭资源\n并且要遵循从小到大，依次关闭\n分别对其 try..catch..\n\n三、用户登录实现（存在sql注入）*编程思路\n\t1.需求：\n\t  模拟用户登录功能实现\n\t\n\t2.业务描述:\n\t  程序运行的时候，提供一个输入的入口（scanner），可以让用户输入用户名和密码\n\t  用户输入用户名和密码后提交信息，Java程序收集到用户信息\n\t  java连接数据库验证数据信息是否合法\n\t  合法：登陆成功  不合法：登陆失败\n\t  \n\t3.数据的准备：\n\t  在实际开发中，表的设计会使用专业的建模工具，例如：PowerDesigner\n\t  使用其进行设计\n\t  \n*关于 sql注入 的问题\n\t  1.输用户名：fdsa\n        输入密码：fdsa&#39; or &#39;1&#39;&#x3D;&#39;1\n        登录结果：成功\n        这条信息并不是我们数据库中的信息，但还是登陆成功了，这种现象叫做 sql注入（安全隐患）\n        \n      2.导致 sql注入 的根本原因是什么？\n        用具输入的信息中有 sql关键字，并且这些关键字参与了sql语句的编译过程\n        导致sql语句的原本意思被扭曲，进而达到sql注入\n        \n      3.经过调试可知，上述用户名密码输入后，查询语句变为：\n        select * from user where userName&#x3D;&#39;fdsa&#39; and userPwd&#x3D;&#39;fdsa&#39; or &#39;1&#39;&#x3D;&#39;1&#39;\n        分析可知，无论 or 前面的用户名是什么，后面的 1&#x3D;1 都一直成立，\n\npackage JDBCTest03;\n\nimport java.sql.*;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class test01_userlogin &#123;\n\n    public static void main(String[] args) &#123;\n\n        &#x2F;&#x2F;1.初始化登录页面\n        Map&lt;String,String&gt; userloginInfo &#x3D; initUI();\n\n        &#x2F;&#x2F;2.验证登录信息\n        boolean loginSuccess &#x3D; login(userloginInfo);\n        System.out.println(loginSuccess ? &quot;登陆成功&quot; : &quot;登录失败&quot; );\n\t&#125;\n    &#x2F;*\n     * 用户登录\n     * @param userloginInfo 用户登陆成功\n     * @return false表示失败，true表示成功\n     * *&#x2F;\n    private static boolean login(Map&lt;String, String&gt; userloginInfo) &#123;\n\n        boolean loginSuccess &#x3D; false;\n\n        Connection conn &#x3D;null;\n        Statement stmt &#x3D; null;\n        ResultSet rs &#x3D; null;\n\n        try &#123;\n\n            &#x2F;&#x2F;1.注册驱动\n            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);\n            &#x2F;&#x2F;2.获取连接\n            conn &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db_sql&quot;,&quot;root&quot;,&quot;123&quot;);\n            &#x2F;&#x2F;3.获取数据库操作对象\n            stmt &#x3D; conn.createStatement();\n            &#x2F;&#x2F;4.执行sql语句\n            String sql &#x3D; &quot;select * from user where userName&#x3D;&#39;&quot;+userloginInfo.get(&quot;userName&quot;)+ &quot;&#39; \n            \t\t      and userPwd&#x3D;&#39;&quot;+userloginInfo.get(&quot;userPwd&quot;)+&quot;&#39;&quot;;\n            rs &#x3D; stmt.executeQuery(sql);\n            &#x2F;&#x2F;5.处理查询结果集\n            if(rs.next())&#123;\n            \tloginSuccess &#x3D; true;\n            &#125;\n        &#125;catch (SQLException e)&#123;\n            e.printStackTrace();\n        &#125;catch (ClassNotFoundException e)&#123;\n            e.printStackTrace();\n        &#125; finally&#123;\n\n\n            &#x2F;&#x2F;6.关闭资源\n            try &#123;\n                   if(rs !&#x3D; null)&#123;\n                   \t\trs.close();\n                   &#125;\n            &#125;catch (SQLException e)&#123;\n                e.printStackTrace();\n            &#125;\n            try &#123;\n                   if(stmt !&#x3D; null)&#123;\n                   \t\tstmt.close();\n                   &#125;\n            &#125;catch (SQLException e)&#123;\n                e.printStackTrace();\n            &#125;\n            try &#123;\n                   if(conn !&#x3D; null)&#123;\n                   \t\tconn.close();\n                   &#125;\n            &#125;catch (SQLException e)&#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n\n        return loginSuccess;\n    &#125;\n\n    private static Map&lt;String, String&gt; initUI() &#123;\n        \n        Scanner sc &#x3D; new Scanner(System.in);\n        \n        System.out.print(&quot;请输入用户名：&quot;);\n        String userName &#x3D; sc.nextLine();\n        \n        System.out.print(&quot;请输入密码：&quot;);\n        String userPwd &#x3D; sc.nextLine();\n        \n        Map&lt;String,String&gt; userloginInfo &#x3D; new HashMap&lt;String,String&gt;();\n        userloginInfo.put(&quot;userName&quot;,username);\n        userloginInfo.put(&quot;userPwd&quot;,userPwd);\n        \n        return userloginInfo;\n    &#125;\n&#125;\n\n\n四、解决SQL注入*解决措施\n    1.只要用户提供的信息，不参与sql语句编译过程，就可以解决了\n\n    2.即使用户提供的信息中建有关键字，但没有参与编译，，就不起作用\n\n    3.要想用户信息不参与SQL语句的编译，那么必须使用java.sql.PreparedStatement\n\n    4.PreparedStatement继承了Statement\n      是属于预编译的数据库操作对象\n    \n*重要\n    5.preparedStatement原理是：预先对Sql语句的框架进行编译，然后再给sql传值\n\n    \n*分析：\n\t1.String sql &#x3D; &quot;select * from user where userName&#x3D;? and userPwd&#x3D;?&quot;;\n      先加载数据库sql语句的框架，其中一个 ? 代表一个占位符，一个问号 将来要接受一个 “值”\n       注意：占位符不能使用单引号括起来\n        \n    2.数据执行到 ps &#x3D; conn.prepareStatement(sql); \n      会把数据库 sql语句的框子 传给DBMS ，然后DBMS进行sql语句的预先编译\n          \n    3.给占位符 ? 传值 ，第一个问号 下标是1，第二个问号 下标是2.jdbc中所有下标从1开始\n          ps.setString(1,userName);   ps.setString(2,userPwd);\n\n\n正确完整登录案例\n\npackage JDBCTest03;\n\nimport java.sql.*;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class test02_Prepare &#123;\n\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;1.初始化登路界面(返回用户信息，map接收)\n        Map&lt;String , String&gt; userLoginInfo &#x3D; initUI();\n        &#x2F;&#x2F;2.验证用户登录信息(创建方法，传入参数，提供验证，返回true或false)\n        boolean loginSuccess &#x3D; login(userLoginInfo);\n        System.out.println(loginSuccess ? &quot;登陆成功&quot;:&quot;登陆失败&quot;);\n    &#125;\n\n    private static boolean login(Map&lt;String, String&gt; userLoginInfo) &#123;\n\n        String userName &#x3D; userLoginInfo.get(&quot;userName&quot;);\n        String userPwd &#x3D; userLoginInfo.get(&quot;userPwd&quot;);\n\n        boolean loginSuccess &#x3D; false;\n\n        Connection conn &#x3D; null;\n        PreparedStatement ps &#x3D; null;\n        ResultSet rs &#x3D; null;\n\n        &#x2F;&#x2F;JDBC六\n        try &#123;\n            &#x2F;&#x2F;1.注册驱动\n            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);\n            &#x2F;&#x2F;2.获取连接\n            conn &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db_sql&quot;,&quot;root&quot;,&quot;hhhh&quot;);\n            &#x2F;&#x2F;3.获取预编译数据库操作对象\n            String sql &#x3D; &quot;select * from user where userName&#x3D;? and userPwd&#x3D;?&quot;;\n            ps &#x3D; conn.prepareStatement(sql);\n            ps.setString(1,userName);\n            ps.setString(2,userPwd);\n            &#x2F;&#x2F;4.执行sql语句\n            rs &#x3D; ps.executeQuery();\n            &#x2F;&#x2F;5.处理是查询结果集\n            if(rs.next())&#123;\n                loginSuccess &#x3D; true;\n            &#125;\n        &#125;catch (SQLException e)&#123;\n            e.printStackTrace();\n        &#125;catch (ClassNotFoundException e)&#123;\n            e.printStackTrace();\n        &#125;finally&#123;\n            &#x2F;&#x2F;6.关闭资源\n            try &#123;\n                if(rs !&#x3D; null)&#123;\n                    rs.close();\n                &#125;\n            &#125;catch (SQLException e)&#123;\n                e.printStackTrace();\n            &#125;\n            try &#123;\n                if(ps !&#x3D; null)&#123;\n                    ps.close();\n                &#125;\n            &#125;catch (SQLException e)&#123;\n                e.printStackTrace();\n            &#125;\n            try &#123;\n                if(conn !&#x3D; null)&#123;\n                    conn.close();\n                &#125;\n            &#125;catch (SQLException e)&#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        return loginSuccess;\n    &#125;\n\n    private static Map&lt;String, String&gt; initUI() &#123;\n        &#x2F;&#x2F;提供用户输入口\n        Scanner sc &#x3D; new Scanner(System.in);\n\n        System.out.print(&quot;请输入用户名：&quot;);\n        String userName &#x3D; sc.nextLine();\n\n        System.out.print(&quot;请输入密码：&quot;);\n        String userPwd &#x3D; sc.nextLine();\n        &#x2F;&#x2F;接收数据\n        Map&lt;String,String&gt; userLoginInfo &#x3D; new HashMap&lt;String, String&gt;();\n        userLoginInfo.put(&quot;userName&quot;,userName);\n        userLoginInfo.put(&quot;userPwd&quot;,userPwd);\n\n        &#x2F;&#x2F;返回给用户登录信息的 Map集合\n        return userLoginInfo;\n    &#125;\n&#125;\n\n\n五、Stmt与PStmt比较\nStatement 存在sql注入问题，preparedStatement解决了sql注入问题\nStatement 编译一次运行一次，preparedStatement编译一次可以运行 n 次，PreparedStatement的效率更高\nPreparedStatement会在编译阶段做安全检查，因为setString要求后面的字符串是String类型，不给引号就报错，但是Statement并不会，所以：99%的情况下选用PreparedStatement，但是也有个别情况适用Statement\n什么情况需要Statementne？\n业务方面要求必须支持sql注入\n凡是业务要求需要进行sql语句拼接的，必须使用。比如升序降序，如果用preparedStatement传值的话，会给desc/asc 自动加单引号，这样就不符合sql语句规则了，所以，此时需要Statement\n\n\n做拼接的时候，如下：String sql = “select * from xs_kc order by 学号 “+s;  \n\n","slug":"22-JDBC总结","date":"2021-09-13T14:57:32.000Z","categories_index":"JDBC","tags_index":"JDBC","author_index":"大黄"},{"id":"a725910a1add8e5328c32e2fb97b8db8","title":"Mysql 索引视图备份","content":"一、索引1、什么是索引？索引就相当于一-本书的目录，通过目录可以快速的找到对应的资源.\n2、查询表的两种方式第一种方式:全表扫描\n第二种方式:根据索引检索(效率很高)\n3、索引为何能提高检索效率?其实最根本的原理是缩小了扫描的范围.\n索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中的对象，也需要数据库不断的维护。是有维护成本的。\n比如，表中的数据经常被修改，这样就不适合添加索引，因为数据一旦修改， 索引需要重新排序，进行维护。|\n4、创建，删除索引对象?创建索引对象\ncreate index 索引名称 on 表名(字段名)；\n删除索引对象\ndrop index 索引名称 on 表名；\n查看sq1语句的执行计划:（看type的类型，all是全局扫描）\nexplain select ename,sal from emp where sal = 5000;\n5、何时给字段添加索引?\n数据量庞大（根据客户的需求，根据线上的环境）\n该字段很少DML操作（因为字段进行修改，索引也需要维护）\n该字段经常出现在where字句中（经常根据那个字段查询）\n\n6、注意（自动添加）主键和具有unique约束的字段自动会添加索引。\n根据主键查询效率较高。尽量根据主键检索。        \n7、索引的分类单一索引：给单个字段添加索引\n复合索引：给多个字段联合起来加一个索引\n主键索引：主键上会自动添加索引\n唯一索引：有unique约束的字段上会自动添加索引\n8、索引什么时候失效select ename from emp where eame  like ‘%A%’；\n模糊查询的时候，第一个通配符使用的是%，这个时候索引是失效的\n9、索引简单实现原理缺\n二、视图1、什么是视图?站在不同的角度去看到数据。(同 一张表的数据，通过不同的角度去看待)。\n2、创建，删除视图?创建\ncreate view myview as select empno, ename from emp;\n删除\ndrop view myview;\n注意:只有DQL语句才 能以视图对象的方式创建出来.\n3、对视图进行操作会影响到原表数据\n 通过视图影响原表数据的， 不是直接操作的原表\n可以对视图进行CRUD操作。\n面向视图操作?\n三、数据库的备份和还原1、备份操作导出整个库\nmysqldump -u用户名 -p密码 要备份的数据库 &gt; 保存的路径\nmysqldump  要备份的数据库 &gt; D:\\sql\\a.sql -root -p123\n\n导出一个表\nmysqldump 数据库中的表&gt;D:\\sql\\a.sql -root -p123\n\n2、还原操作登录数据库  |  创建数据库  |  使用数据库  |  执行文件（source 文件路径）\n\n3、相关程序进行备份还原进去就看得到，百度百度\n\n","slug":"21-MySql索引视图备份","date":"2021-09-13T14:56:32.000Z","categories_index":"MySql","tags_index":"MySql","author_index":"大黄"},{"id":"0aff3f9d6ddb049036e17692cfc8cc4a","title":"Mysql 约束范式","content":"一、约束（Constraint）1、主要内容1. 非空约束\n2. 自增约束\n3. 主键约束\n4. 唯一键约束\n5. 默认值约束\n6. 外键约束\n7. 检查约束\n\n2.、查看某个表的约束SELECT * FROM information_schema.table_constraints WHERE table_name &#x3D; &#39;表名称&#39;;\n或\nSHOW CREATE TABLE 表名;\n\n3.、查看某个表的索引SHOW INDEX FROM 表名称;\n\n4、主键约束：primary key主键分为单列主键和复合主键：\n\n主键的特点：（1）唯一并且非空（2）一个表只能有一个主键约束（3）主键约束名就叫做PRIMARY（4）创建主键会自动创建对应的索引，同样删除主键对应的索引也会删除。\n（1）如何在建表时指定主键约束\ncreate table [数据名.]表名(\n\t字段名1 数据类型  primary key ,\n\t....\n);\n或\ncreate table [数据名.]表名(\n\t字段名1 数据类型,\n\t....,\n    primary key(字段名1)\n);\n或\ncreate table [数据名.]表名(\n    字段名1 数据类型,\n    字段名2 数据类型,\n\t....,\n    primary key(复合主键字段列表)#如果是复合主键，那么就需要在所有字段列表后面使用这种形式指定，不能在字段后面直接加primary key\n);\n\n（2）如何在建表后指定主键约束\nalter table 表名称 add primary key (主键字段列表);\n\n（3）如何删除主键约束\nalter table 表名称 drop primary key;\n\n5、唯一键约束：unique key（1）唯一键约束特点\n\n唯一键约束列允许为null。\n\n同一个表可以有多个唯一约束。\n\n唯一约束可以是某一个列的值唯一，也可以多个列组合值的唯一。\n\nMySQL会给唯一约束的列上默认创建一个唯一索引。\n\n\n\n删除唯一键只能通过删除对应索引的方式删除，删除时需要指定唯一键索引名\n\n（2）如何在建表时指定唯一键约束\ncreate table [数据名.]表名(\n\t字段名1 数据类型  primary key ,\n\t字段名2 数据类型 unique key,\n\t....\n);\n\ncreate table [数据名.]表名(\n    字段名1 数据类型  primary key ,\n    字段名2 数据类型,\n    字段名3 数据类型,\n\t....,\n    unique key(复合唯一字段列表)#如果是复合唯一键，那么就需要在所有字段列表后面使用这种形式指定，不能在字段后面直接加unique key\n);\n\n（3）如何在建表后增加唯一键约束\nalter table 表名称 add [constraint 约束名] unique [key] (字段名列表);\n#如果没有指定约束名，(字段名列表)中只有一个字段的，默认是该字段名，如果是多个字段的默认是字段名列表的第1个字段名。也可以通过show index from 表名;来查看\n\n（4）如何删除唯一键约束\nALTER TABLE 表名称 DROP INDEX 唯一性约束名;\n#注意：如果忘记名称，可以通过“show index from 表名称;”查看\n\n6、外键约束：foreign key（1）外键特点\n\n外键约束是保证一个或两个表之间的参照完整性,外键是构建于一个表的两个字段或是两个表的两个字段之间的参照关系。\n\n在创建外键约束时，如果不给外键约束名称，默认名不是列名，而是自动产生一个外键名（例如 student_ibfk_1;），也可以指定外键约束名。\n\n当创建外键约束时，系统默认会在所在的列上建立对应的普通索引。但是索引名是列名，不是外键的约束名。\n\n删除外键时，关于外键列上的普通索引需要单独删除。\n\n\n（2）要求\n\n在从表上建立外键，而且主表要先存在。\n\n一个表可以建立多个外键约束\n\n从表的外键列，在主表中引用的只能是键列（主键，唯一键，外键），推荐引用主表的主键。\n\n从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样\n\n\n（3）约束关系：约束是针对双方的\n\n添加了外键约束后，主表的修改和删除数据受约束\n\n添加了外键约束后，从表的添加和修改数据受约束\n\n在从表上建立外键，要求主表必须存在\n\n删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除\n\n\n（4）5个约束等级\n\nCascade方式：在父表上update/delete记录时，同步update/delete掉子表的匹配记录 \n\nSet null方式：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列是否设置了不允许为null  \n\nNo action方式：如果子表中有匹配的记录,则不允许对父表对应候选键进行update/delete操作  \n\nRestrict方式：同no action, 都是立即检查外键约束\n\nSet default方式（在可视化工具SQLyog中可能显示空白）：父表有变更时,子表将外键列设置成一个默认的值，但Innodb不能识别\n\n\n如果没有指定等级，就相当于Restrict方式\n（5）如何在建表时指定外键约束\ncreate table [数据名.]从表名(\n\t字段名1 数据类型  primary key ,\n\t字段名2 数据类型 [unique key],\n\t....,\n    [constraint 外键约束名] foreign key (从表字段) references 主表名(主表字段) [on update 外键约束等级][on delete 外键约束等级[\n    #外键只能在所有字段列表后面单独指定\n    #如果要自己命名外键约束名，建议 主表名_从表名_关联字段名_fk\n);\n\ncreate table [数据名.]表名(\n    字段名1 数据类型,\n    字段名2 数据类型,\n\t....,\n    primary key(复合主键字段列表),#如果是复合主键，那么就需要在所有字段列表后面使用这种形式指定，不能在字段后面直接加primary key\n    unique key(复合唯一字段列表),#如果是复合唯一键，那么就需要在所有字段列表后面使用这种形式指定，不能在字段后面直接加unique key\n    foreign key (从表字段) references 主表名(主表字段) [on update 外键约束等级][on delete 外键约束等级[\n    #外键只能在所有字段列表后面单独指定\n);\n\n（6）如何在建表后指定外键约束\nalter table 从表名称 add [constraint 外键约束名] foreign key (从表字段名) references 主表名(主表被参照字段名) [on update xx][on delete xx];\n\n（7）如何删除外键约束\nALTER TABLE 表名称 DROP FOREIGN KEY 外键约束名;\n#查看约束名 SELECT * FROM information_schema.table_constraints WHERE table_name &#x3D; &#39;表名称&#39;;\n#删除外键约束不会删除对应的索引，如果需要删除索引，需要用ALTER TABLE 表名称 DROP INDEX 索引名;\n#查看索引名 show index from 表名称;\n\n7、非空约束：not nullNOT NULL 非空约束，规定某个字段不能为空\n（1）如何在建表时给某个字段指定非空约束\ncreate table [数据名.]表名(\n\t字段名1 数据类型  primary key ,\n\t字段名2 数据类型 [unique key] [not null],\n\t....,\n    foreign key (从表字段) references 主表名(主表字段) [on update 外键约束等级][on delete 外键约束等级[\n    #外键只能在所有字段列表后面单独指定\n);\n\ncreate table [数据名.]表名(\n    字段名1 数据类型 [not null],\n    字段名2 数据类型 [not null],\n\t....,\n    primary key(复合主键字段列表),#如果是复合主键，那么就需要在所有字段列表后面使用这种形式指定，不能在字段后面直接加primary key\n    unique key(复合唯一字段列表),#如果是复合唯一键，那么就需要在所有字段列表后面使用这种形式指定，不能在字段后面直接加unique key\n    foreign key (从表字段) references 主表名(主表字段) [on update 外键约束等级][on delete 外键约束等级[\n    #外键只能在所有字段列表后面单独指定\n);\n\n（2）如何在建表后指定某个字段非空\nALTER TABLE 表名称 MODIFY 字段名 数据类型 NOT NULL [default 默认值];\n#如果该字段原来设置了默认值约束，要跟着一起再写一遍，否则默认值约束会丢失\n\n（3）如何在建表后取消某个字段非空\nALTER TABLE 表名称 MODIFY 字段名 数据类型 [default 默认值];\n#如果该字段原来设置了默认值约束，要跟着一起再写一遍，否则默认值约束会丢失\n\n8、默认值约束：default（1）如何在建表时给某个字段指定默认约束\ncreate table [数据名.]表名(\n\t字段名1 数据类型  primary key ,\n\t字段名2 数据类型 [unique key] [not null] [default 默认值],\n\t....,\n    foreign key (从表字段) references 主表名(主表字段) [on update 外键约束等级][on delete 外键约束等级[\n    #外键只能在所有字段列表后面单独指定\n);\n\ncreate table [数据名.]表名(\n    字段名1 数据类型 [not null] [default 默认值],\n    字段名2 数据类型 [not null] [default 默认值],\n\t....,\n    primary key(复合主键字段列表),#如果是复合主键，那么就需要在所有字段列表后面使用这种形式指定，不能在字段后面直接加primary key\n    unique key(复合唯一字段列表),#如果是复合唯一键，那么就需要在所有字段列表后面使用这种形式指定，不能在字段后面直接加unique key\n    foreign key (从表字段) references 主表名(主表字段) [on update 外键约束等级][on delete 外键约束等级[\n    #外键只能在所有字段列表后面单独指定\n);\n\n（2）如何在建表后指定某个字段的默认值约束\nALTER TABLE 表名称 MODIFY 字段名 数据类型  [default 默认值] [NOT NULL];\n#如果该字段原来设置了非空约束，要跟着一起再写一遍，否则非空约束会丢失\n\n（3）如何在建表后取消某个字段的默认值约束\nALTER TABLE 表名称 MODIFY 字段名 数据类型 [NOT NULL];\n#如果该字段原来设置了非空约束，要跟着一起再写一遍，否则非空约束会丢失\n\n9、检查约束：check检查约束，mysql暂不支持\ncreate table stu(\n\tsid int primary key,\n\tsname varchar(20),\n\tgender char check (&#39;男&#39;or&#39;女&#39;)\n);\ninsert into stu values(1,&#39;张三&#39;,&#39;男&#39;);\ninsert into stu values(2,&#39;李四&#39;,&#39;妖&#39;);\n\n使用枚举类型解决如上问题：\ncreate table stu(\n\tsid int primary key,\n\tsname varchar(20),\n\tgender enum (&#39;男&#39;,&#39;女&#39;)\n);\n\n10、自增约束：auto_increment（1）关于自增长auto_increment：\n\n一个表最多只能有一个自增长列\n自增长列必须是键列（主键列，唯一键列，外键列），并且要求非空。\n自增列必须是整数类型\nInnoDB表的自动增长列可以手动插入，但是插入的值如果是空或者0，则实际插入的将是自动增长后的值。\n\n（2）如何在建表时指定自增长列\ncreate table [数据名.]表名(\n\t字段名1 数据类型  primary key auto_increment,\n\t字段名2 数据类型 [unique key] [not null] [default 默认值],\n\t....\n);\n\n或\ncreate table [数据名.]表名(\n\t字段名1 数据类型  primary key ,\n\t字段名2 数据类型 [unique key  not null] auto_increment,\n\t....\n);\n\n（3）如何在建表后指定自增长列\nalter table [数据名.]表名 modify 自增字段名 数据类型 auto_increment;\n\n（4）如何删除自增约束\nalter table [数据名.]表名 modify 自增字段名 数据类型;\n\n11、DML(v2.0)1、如果某列有自增约束，怎么添加该字段的值\n添加数据时，对于自增列\ninsert into [数据库名.]表名称 values(值列表)；#在值列表中，对应自增列可以赋值为null和0\n\ninsert into [数据库名.]表名称(部分字段列表) values(值列表)；#自增列在(部分字段列表)中不写就可以\n\n2、如果某列有默认值约束，怎么添加、修改该字段的值\n添加数据时，对于有默认值列\ninsert into [数据库名.]表名称 values(值列表)；#在值列表中，对应默认值列，如果想用默认值，用default\n\ninsert into [数据库名.]表名称(部分字段列表) values(值列表)；#对应默认值列，如果想用默认值，在(部分字段列表)中不写就可以\n\n修改数据\nupdate [数据库名.]表名称 set 字段名1 &#x3D; 值1, 字段名2 &#x3D; 值2 。。。 [where 条件]; #对应默认值列，如果想用默认值，写字段名 &#x3D; default就可以\n\n二、数据库的设计1、表间的关系\n一对一（了解）\n如：身份证和人\n分析：一个人只能有一个身份证，一个身份证只能对应一个人\n\n\n一对多（多对一）\n如：部门和员工\n分析：一个部门有很多员工，一个员工只能对应一个部门\n\n\n多对多\n如：学生和课程\n分析：一个学生可惜选修多门课程，一个课程也有很多学生\n\n\n\n2、实现方式\n一对一\n主键共享，其中一张表中的主键，既是主键又是外键，外键参考的是一对一的另外一张表的主键\n外键唯一：也可以在任意一方添加外键，然后让外键唯一，即添加约束-unique\n\n\n一对多（多对一）\n实现：在多的一方建立外键，指向一的一方的主键\n\n\n多对多\n多对多关系实现需要借助第三张中间表\n中间表至少含有两个字段，这两个字段作为第三张表的外键，分别指向两个表的主键\n\n\n\n3、数据库三大设计范式\n概念：设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。\n\n目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。\n\n主要学习：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）\n\n基础知识：\n\n码：表中可以唯一确定一个元组的某个属性（或者属性组），如果这样的码有不止一个，那么大家都叫候选码，我们从候选码中挑一个出来做老大，它就叫主码。\n元组：表中的一行就是一个元组\n非主属性：与上面相反，没有在任何候选码中出现过，这个属性就是非主属性。\n外码：一个属性（或属性组），它不是码，但是它别的表的码，它就是外码。\n\n\n\n4、第一范式（1NF）\n概念：数据库表的每一列都是不可分割的原子数据项\n\n范例：\n学号\t姓名\t系名\t\t 系主任 课程名\t分数\n10010\thh\t经济\t\t张三丰\t数学\t    100\n10010\thh\t经济\t\t张三丰\t计算机\t    98\n10010\thh\t经济\t\t张三丰\t英语\t     99\n10011\tgg\t法律\t\t任我行\t法理\t     58\n10011\tgg\t法律\t\t任我行\t法律社会    35\n10012\tff\t法律\t\t任我行\t法理\t     12\n10012\tff\t法律\t\t任我行\t英语 \t     38\n\t\t    计算机系   殷天正\t\t\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n存在问题：\n1.存在非常严重的冗余(重复): 姓名，系名，系主任\n2.数据添加问题：如果现实中添加了一个新的系，殷天正为系主任，但是因为没有招生，所以没有学生\n\t\t\t 由上表可知，这在数据库中是无法添加的，数据不合法\n3.数据删除问题：如果现实中hh毕业了，那他的数据就可以删除了，但是随着他的删除，系名，系主任也被删除了\n\t\t\t 这显然也是不合法的\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n5、第二范式（2NF）\n概念：第二范式依赖第一范式，所以第二范式必须符合第一范式，然后 每个非主属性完全依赖于主键，而不是仅依赖于其中一部分属性（除主键外的每一列都必须和主键相关），而不能只和主键的某一部分相关（只可能发生在联合主键的情况下）\n\n解决了第一个问题，消除了严重的冗余\n\n图片来源：Spr Chan\n\n\n6、第三范式（3NF）\n概念：必须先满足第二范式，除开主键的其他列之间不能有传递依赖关系，目标是确保每列都和主键直接相关，而不是间接相关\n\n传递依赖：非主键列m既依赖于全部主键，又依赖于非主键列n的情况。\n\n解决了增加，删除的问题，因为遵循了三大范式，所以上述三个问题完全解决\n\n假设存在关系模式主键1: 课程编号; 列1: 教师名; 列2: 教师家庭地址。显然满足第一范式和第二范式，但是教师家庭地址传递依赖于教师名，所以不满足第三范式。\n\n\n三、事务1、概述 mysql中，事务其实是最小的不可分割的工作单元，事务能保证一个业务的完整性，是构成单一逻辑工作单元的操作集和\n比如我们的银行转账\n\na -&gt; -100\nupdate user set money&#x3D;money-100 where name&#x3D;&#39;a&#39;;\n\nb -&gt; +100\nupdate user set money&#x3D;money+100 where name&#x3D;&#39;b&#39;;\n\n实际的程序中，如果只有一条语句执行成功了，而另外一条没执行成功就会出现数据前后不一致\n\nupdate user set money&#x3D;money-100 where name&#x3D;&#39;a&#39;;\nupdate user set money&#x3D;money+100 where name&#x3D;&#39;b&#39;;\n\n事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行\n\n事务处理\n保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)到最初状态。\n\n2、事务四大特征（ACID）\n原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\n事务是最小的单位，不可以分割，同一事务中的 sql 语句必须保证同时成功或者同时失败\n一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。\n事务必须使得数据库从一个一致性状态转变到另一个一致性状态。比如银行转账，A账户转到B账户，不管转几次，A和B账户的总额不能变。\n隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。\n事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。\n持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n数据库数据存放到硬盘中，并有redo log 和 binlog 一起保证的。\n\n3、事务基本语句\n如果 不开启事务，mysql会自动提交事务的\n\n修改默认提交：set  autocommit = 0；（等于1代表自动提交，0为手动）set autocommit=false;（接下来都要手动提交） \nbegin；   |     start transaction；\n\n手动提交：commit；使已对数据库进行的所有修改成为永久性的\n\n手动回滚：rollback；回滚会结束用户的事务，并撤销正在进行的所有未提交的修改\n\n如何查看数据库的隔离级别（下方详解）\n\n如何修改隔离级别（下方详解）\n\n\n4、故障\n在事务的ACID特性中,C即一致性是事务的根本追求,而对数据一致性的破坏主要来自两个方面\n1.事务的并发执行\n2.事务故障或系统故障\n数据库系统是通过并发控制技术和日志恢复技术来避免这种情况发生的。\n\n并发控制技术保证了事务的隔离性,使数据库的一致性状态不会因为并发执行的操作被破坏。日志恢复技术保证了事务的原子性,使一致性状态不会因事务或系统故障被破坏。同时使已\n提交的对数据库的修改不会因系统崩溃而丢失,保证了事务的持久性。\n\n\n四、事务之隔离性1、概述数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。\n2、并发操作存在问题\n脏读：一个事务读取到另外一个事务没有提交的数据\n\n不可重复读（虚读）：在同一个事务中，两次读取到的数据不一样\n\n幻读：一个事务操做（DML）数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的的修改\n​           即：事务在插入已经检查过不存在的记录时，发现这些数据已经存在了\n\n\n3、四大隔离级别数据库事务的隔离性：数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。\n一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性（安全性）就越好, 但并发性越弱。\n数据库提供的 4 种事务隔离级别：\n\n\n\n隔离级别\n描述\n\n\n\nread-uncommitted\n允许A事务读取其他事务未提交和已提交的数据。会出现脏读、不可重复读、幻读问题\n\n\nread-committed\n只允许A事务读取其他事务已提交的数据。可以避免脏读，但仍然会出现不可重复读、幻读问题\n\n\nrepeatable-read\n确保事务可以多次从一个字段中读取相同的值。在这个事务持续期间，禁止其他事务对这个字段进行更新。可以避免脏读和不可重复读。但是幻读问题仍然存在。注意：mysql中使用了MVCC多版本控制技术，在这个级别也可以避免幻读。\n\n\nserializable\n确保事务可以从一个表中读取相同的行，相同的记录。在这个事务持续期间，禁止其他事务对该表执行插入、更新、删除操作。所有并发问题都可以避免，但性能十分低下。\n\n\n\nOracle 支持的 2 种事务隔离级别：READ-COMMITED, SERIALIZABLE。 Oracle 默认的事务隔离级别为: READ COMMITED 。\nMysql 支持 4 种事务隔离级别。 Mysql 默认的事务隔离级别为: REPEATABLE-READ。在mysql中REPEATABLE READ的隔离级别也可以避免幻读了。\n\n4、隔离级别的查看 | 设置\n查看隔离级别\nmysql 8.0\n——系统级别\nselect @@global.transaction_isolation;\n——会话级别\nselect @@transaction_isolation;\n\nmysql 5.x\n——系统级别\nselect @@global.tx_isolation;\n——会话级别\nselect @@tx_isolation;\n设置当前 mysql连接的隔离级别:  \n\n\nset tx_isolation &#x3D;&#39;repeatable-read&#39;;\n\n\n设置数据库系统的全局的隔离级别:\n\nset global tx_isolation &#x3D;&#39;read-committed&#39;;\n\n五、隔离级别范例create table user (\nid int primary key,\nname varchar(20),\nmoney int\n);\n\ninsert into user values(1,&#39;A&#39;,1000);\n\ninsert into user values(2,&#39;B&#39;,1000);\n\nselect * from user;\n\n-- 查询提交方式，1自动提交，0手动提交\nselect @@autocommit;\n\n-- 设置手动提交，也就是开启事务\nset @@autocommit&#x3D;0;\n-- 当然也可以使用 begin; 或者 start transaction;\n\n-- 此时a花了500块\nupdate  user  set money&#x3D;money-500 where id&#x3D;1; \n\n-- 换一个界面2查询，发现表中的值并未改变\n\n-- 此时进行回滚操作\nrollback;\n\n-- 在页面1查询发现表中的值并未改变\n\n-- 这是因开启事务，需要手动提交才会生效\nupdate  user  set money&#x3D;money-500 where id&#x3D;1; \ncommit;\n\n-- 再次两个页面查询发现，a的值改变了。\n\ninsert into user values(3,&#39;小明&#39;,1000);\ninsert into user values(4,&#39;淘宝店&#39;,1000);\n\n-- 查询数据库的隔离级别\nselect @tx_isolation;\nselect @@global.tx_isolation;\n\n-- 修改数据库的隔离级别\nset transaction isolation level read uncommitted; \n\n-- 小明淘宝买双鞋（500块），于是开启转账（事务）\nstart transaction;\nupdate user set money&#x3D;money-500 where name&#x3D;&#39;小明&#39;;\nupdate user set money&#x3D;money+500 where name&#x3D;&#39;淘宝店&#39;;\n\n-- 查询状况\nselect * from user;\n\n-- 小明给淘宝店打电话，让店主查账\n-- 店主在广州查账后发现到账了账目正确\n-- 给小明发货，然后晚上请女朋友吃饭\n-- 此时小明发现钱不够，就撤销了汇款（rollback;）\nrollback;\ncommit;\n\n-- 饭钱1500，付账发现钱不够了，这就属于账读\n\n——脏读：一个事务读到了另外一事务没有提交的数据，     ——就叫做脏读 实际开发是不允许的\n\n\n-- 读已经提交的\nset transaction isolation level read committed;\n\n-- 小张：银行的会计(开始统计报表)\nstart transaction;\nselect * from user;\nselect avg(money) from user;\n\n\n-- 小张去上厕所，并且在厕所抽烟\n\n-- 小王（用其他的电脑，开了一个户，添加一个数据）：\nstart transaction;\ninsert into user values(5,&#39;C&#39;,100);\ncommit;\n\n-- 小张回来，算钱的平均数(发现和之前不一样了)\nselect avg(money) from user;\n\n——虽然我只能读到已经提交的数据，但是还会出现问题，就是读取同一个表的数据，前后结果不一致。\n——不可重复读现象：read committed;\n\n\n-- 修改隔离级别\nset  global transaction isolation level repeatable read;\nselect @@global.tx_isolation;\n\n—— 张全蛋-成都-开户（两边同时开启事务）\nstart transaction;\ninsert into user values(7,&#39;f&#39;,1000);\ncommit;\n张全蛋这边还进行了 commit; 提交\n\n—— 王尼玛-北京-查询（用另外一个页面）\nstart transaction;\nselect * from user;\n\ninsert into user values(7,&#39;f&#39;,1000)\n&gt; 1062 - Duplicate entry &#39;7&#39; for key &#39;PRIMARY&#39;\n-- 王尼玛发现没有7，但是不能添加7，这种现象就叫  幻读\n\n\n-- 修改隔离级别\nset  global transaction isolation level serializable;\nselect @@global.tx_isolation;\n\n—— 张全蛋-成都\nstart transaction;\n\n—— 王尼玛-北京\nstart transaction;\ninsert into user values(8,&#39;i&#39;,1000);\n\n—— 张全蛋-成都\ninsert into user values(9,&#39;h&#39;,1000);\n插入语句卡着不能动了\n\n—— 王尼玛-北京\n输入了提交：commit；\n\n—— 张全蛋-成都  插入成功了\n\n——当user表被另一个事务操作时，其他事务里面的写操作，是不可以进行的。\n——进入排队状态（串行化），直到王尼玛那边事情结束，张全蛋这个写入操作才会执行  操作执行的前提是，等待没有超时的情况下\n\n\n\n\n\n\n\n\n\n\n\n做了一个实验 \ncreate table t (id number, mount number);\ninsert into t value(1,1);\n\n\n\n\nA\nB\n\n\n\n1\nbegin;\n\n\n\n2\nselect * from t;\n\n\n\n3\n\nbegin;\n\n\n4\n\nselect * from t;\n\n\n5\nupdate t set mount=mount+1 where id = 1;\n\n\n\n6\ncommit;\n\n\n\n7\n\nselect * from t where id = 1;\n\n\n8\n\nupdate t set mount=mount+2 where id = 1;\n\n\n9\n\ncommit;\n\n\n10\n\nselect * from t where id = 1;\n\n\n11\n\ncommit;\n\n\n12\nselect * from t where id = 1;\n\n\n\n13\ncommit;\n\n\n\nresult\n12步mount为2\n7步mount为1，10步mount为4\n\n\n这里事务B的两次结果容让人困惑，从mysql的隔离机制入手就不难理解了\n首先7步是为了解决不可重复读，尽管事务A已经修改并提交，但对于事务B不知情，4与7的查询结果应一致，这也是repeatable-read算法，查询时会去寻找事务开始时的snapshot。\n那为什么10步会查询为4呢？因为做了update操作，事务的起始点变化为8的位置，寻找到的那时的snapshot.\n同样12步只能寻找到事务A最后一次事务操作udpate的shpshot，获得值为2。\n\n六、DCL操作1、SQL分类回忆\nDDL DML DQL DCL\n\n2、概念\nDCL(Data Control Language)，即数据控制语言，用来定义数据库的访问权限和安全级别，及创建用户。\n主要包括创建用户、给用户授权、对用户撤销授权、查询用户授权和删除用户等。\n\n\n3、查询创建删除\n切换到 mysql 数据库：use mysql;\n\n查询用户：select *  from user;\n\n创建用户\n\ncreate user ‘用户名’@’localhost’  identified  by  ‘密码’;\n\n创建当前主机用户\ncreate user ‘123’@’localhost’  identified  by  ‘root’;\n\n创建远程可访问用户（用通配符 %）\ncreate user ‘123’@’ % ‘  identified  by  ‘root’;\n\n\n\n删除用户\n\ndrop user  ‘用户名’@‘主机名’;\ndrop user ‘123‘@’localhost’;\n\n\n\n4、用户密码问题\n修改用户名密码\nupdate user  set password = password(‘新密码’)  where  user = ‘用户名’;\nupdate user  set password = password(‘456’)  where  user = ‘123’;\nmysql 给出的简化方式：set password for ‘用户名’@‘主机名’ = password(‘新密码’);\n\n\nMySql 忘记root用户密码\ncmd —&gt; net stop mysql   停止mysql服务\n需要以管理员身份运行cmd\n使用无验证方式启动mysql服务：musqld –skip-grant-tables\n回车，光标卡着不动了，此时服务启动成功\n再打开一个新的cmd窗口 直接输入 mysql 回车就直接登录进去了\nuse mysql;\n修改密码：update user  set password = password(‘新密码’)  where  user = ‘root’;\n关闭两个窗口\n打开任务管理器，手动结束musqld.exe的进程\n启动mysql服务\n使用新密码登录\n\n\n\n5、权限的授予回收\n授予权限\ngrant  权限列表  on  数据库名.表名  to  ‘用户名‘@’主机名’;\ngrant  select  on db_school to  ‘123‘@’%’;\n给某个用户所有库的所有表的所有权限\ngrant  all  on  * . *   to  ‘用户名‘@’主机名’;\n\n\n查询权限\nshow grants  for  ‘用户名‘@’主机名’;\nshow grants  for  ‘123‘@’%’;\n\n\n撤销权限\nrevoke 权限列表  on 数据库名.表名  from  ‘用户名‘@’主机名’;\n\n\n\n","slug":"20-MySql约束范式","date":"2021-09-13T14:55:32.000Z","categories_index":"MySql","tags_index":"MySql","author_index":"大黄"},{"id":"68a57833ae44293764c3ebaf716fccf1","title":"Mysql 基础语句","content":"一、数据库的操作1、创建数据库普通创建\ncreate database db_sql；\n\n带字符集创建\ncreate database db_sql  character set utf8；\t\t\t\t\t\t\t\n\n2、查询数据库查看数据库字符编码\nshow variables like &#39;%character%&#39;\n\n查看所有数据库\nshow  databases;\n\n查看指定数据库\nshow create database db_sql；\n\n查看当前使用的数据库\nselect database();\n\n3、删除数据库drop database db_sql；\n\n4、使用数据库use 数据库名;\n\n\n\n二、表的操作1、新建表create table [数据名.]表名(\n\t字段名1 数据类型,\n\t字段名2 数据类型,\n\t....\n) charset utf8;\n\n2、查看表查看一个数据库的所有表\nshow  tables;\n\n如果要查询的不是当前数据库下所有表，那么我们可以指定数据库名\nshow tables from 数据库名;\n\n查看所有字段的设置值\ndescribe  表名;  &#x2F;&#x2F;  desc  表名;\n\n查看指定表的所有设置\nshow  create  table  表名；\n\n3、删除表drop table 表名;\n\n4、修改表结构1、增加一列alter table [数据库名.]表名称 add [column] 字段名 数据类型 [约束];\nalter table [数据库名.]表名称 add [column] 字段名 数据类型 first;\nalter table [数据库名.]表名称 add [column] 字段名 数据类型 after 另一个字段;\n\n2、修改一列# 修改列数据类型\nalter table [数据库名.]表名称 modify [column] 字段名 新数据类型 [约束];\n# 修改列名\nalter table [数据库名.]表名称 change [column] 旧字段名 新字段名 新数据类型 [约束];\n# 修改列的位置\nalter table [数据库名.]表名称 modify [column] 字段名 数据类型 first;\nalter table [数据库名.]表名称 modify [column] 字段名 数据类型 after 另一个字段;\n\nmodify： &#x2F;* 改的是内容，不能更改列名 *&#x2F;\nchange：&#x2F;* 啥都能改 *&#x2F; \n\n3、删除列alter table [数据库名.]表名称 drop [column] 字段名 [约束];\n\n4、修改表名称alter table 旧表名 rename 新表名;\nrename table 旧表名 to 新表名;\n\n5、修改字段默认值alter  table  表名  alter  字段  set  default  要设置的值;\n\n6、修表字符集alter  table  表名  alter  character  set  要设置的字符集;\n\n三、数据类型1、数值类型\n整型系列：xxxInt\n浮点型系列：float,double(或real)\n位类型：bit\n\n2、日期时间类型\ndate  \ntime\ndatetime\ntimestamp\nyear   184.92\n\n\n3、字符串类型\nchar , varchar , xxtext\nbinary , varbinary , xxblob\nenum , set\n\n\n四、缩写定义1、DBS\n数据库系统（Database System）\n整体数据的结构化是数据库的主要特征之一\n数据的共享性高，冗余度低，易扩充，数据的独立性高\n数据由DBMS统一管理和控制\n\n2、DBMS\n数据库管理系统（Database Manager System）\n是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库\n对数据库进行统一的管理和控制，以保证数据库的安全性和完整性\n大部分DBMS提供数据定义语言DDL（Data Definition Language）和数据操作语言DML（Data Manipulation Language）\n实现CRUD (增删改查) 操作\n\n3、RDBMS\n关系型数据库管理系统 （Relational Database Management System）\n将数据组织为相关的行和列的系统，而管理关系数据库的计算机软件就是关系数据库管理系统\n常用的数据库软件有MySql、Oracle、[SQL Server](https://baike.baidu.com/item/SQL Server)等\n详解：RDBMS 中的数据存储在被称为表（tables）的数据库对象中，表是相关的数据项的集合，它由列和行组成\n\n4、SQL分类1、DML\n数据操作语言（Data Manipulation Language）\n数据的插入，修改，删除 （insert | update | delete）\n\n2、DDL\n数据定义语言（Data Definition Language）\n牵涉到 表、视图，触发器，条件约束 和索引的定义，删除，修改 \n主要涉及到：create：创建     drop：删除    alter：修改  truncate：清空表中数据\n\n3、DQL\n数据查询语言 （Data Query Language）\nselect | from | where | group by | having | order by\n\n4、DCL\n数据控制语言（Data Control Language）\n\n是用来设置或更改数据库用户或角色权限的语句，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等\n\n牵涉到： grant：授权 | revoke： 收回权限 | COMMIT： 提交 | savepoint：保存点\nrollback：回滚 | set transaction：设置当前事务的特性，它对后面的事务没影响\n\n\n五、表中数据的操作1、插入数据insert into [数据库名.]表名称 values(值列表);\n#要求值列表的顺序、个数、类型，要与表格中的字段的顺序、个数、类型一一匹配\ninsert into [数据库名.]表名称(部分字段列表) values(值列表);\n\ninsert into [数据库名.]表名称 values(值列表1)，(值列表2)...;\n#要求列表的顺序、个数、类型，要与前面的(部分字段列表)的顺序、个数、类型一一匹配\ninsert into [数据库名.]表名称(部分字段列表) values(值列表1)，(值列表2)...;\n\n\n\n\n\n\n\n\n\n\n如果添加过主键自增（primary key  auto_increment）第一列在增加数据的时候，\n可以写为 0 或则  null 这样添加数据可以自增。从而可以添加全部数据。而不用特意规定那几列添加数据。\n2、修改数据更新单条\nupdate [数据库名.]表名称 set 字段名1 &#x3D; 值1, 字段名2 &#x3D; 值2 。。。 [where 条件];\n\n更新多条数据\n基本：update 表名称 set 列1名称&#x3D;新值1，列2名称&#x3D;新值2  where 更新条件;\n\n批量更新更新 某个字段 的某个字符\n基本：update 表名称 set 列名称&#x3D;replace(列名称,旧值,新值） where  条件;\n范例：mysql&gt; update xs set 性别&#x3D;replace( 性别,1,0 ) where 专业名&#x3D;&#39;计算机&#39;;\n\n\n\n\n\n\n\n\n\n\n如果没有加where条件，表示修改所有行，这个字段的值\n3、删除数据delete from [数据库名.]表名称 [where 条件];\n\n\n\n\n\n\n\n\n\n\n如果没有where条件，表示删除整张表的数据;\ntruncate [数据库名.]表名称;#删除整张表的数据，还可以使用这个语句，效率更高，但是它不能回滚\n\n删除语句的区别：\n\ndelete是 DML 语句，可以回滚；truncate和drop是 DDL 语句，操作完马上生效，不能回滚\n执行的速度上，drop&gt;truncate&gt;delete\n自增 id 列，delete 后 id 仍然从上次的数开始增加；例如删除id=3后，添加的自增id 从4开始。 但是使用truncate删除之后，id会恢复到初始值。\n对于由 外键 约束引用的表，不能用 truncate table 而应用不带 where 的 delete 语句。\n由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器\n\ndelete：\n删除 表内数据，一条一条的删除，配合事务，可以回滚(rollback)\n格式为：\ndelete from 表名 where 删除条件;\n\ntruncate：\n只能操作表，删除内容、释放空间但不删除表结构(实际是删除原来的表再重新建立结构一样的新表)\n格式为：\ntruncate table 表名;\n\ndrop\n删除表的结构，删除内容和定义，释放空间。\n删除之后，依赖于该表的存储过程&#x2F;函数将保留,但是变为 invalid 状态.\n格式为：\ndrop  table  表名;\n\n4、简单查询数据select * from [数据库名.]表名称; #查询整张表的所有数据\n\nselect 字段列表  from [数据库名.]表名称;  #查询部分列表\n\nselect * from [数据库名.]表名称 [where 条件];\n\nselect 字段列表  from [数据库名.]表名称 [where 条件];\n\n\n\n\n\n\n\n\n\n\n使用distinct可以对查询结果进行去重\n范例：select distinct name from user;\n5、单行函数6、分组(聚合)函数概述：分组函数作用于一组数据，并对一组数据返回一个值。\n类型：AVG() SUM() MAX() MIN() **COUNT() **\nSELECT AVG(salary), MAX(salary),MIN(salary), SUM(salary)\nFROM   employees\nWHERE  job_id LIKE &#39;%REP%&#39;;\n\n问题：用count(*)，count(1)谁好呢?\n其实，对于myisam引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。\nInnodb引擎的表用count(*)直接读行数，效率很低，因为innodb真的要去数一遍。\n7、group by释义：通过 需求的字段 把返回记录 分成多个组，这就是 group by 的字面含义。分完组后，然后用分组函数对每组中的不同字段（一或多条记录）作运算。\nSELECT name, COUNT(*) FROM   employee_tbl GROUP BY name;\n\n\n\n\n\n\n\n\n\n\n明确：WHERE一定放在FROM后面GROUP BY 前面\n8、having一般与 group by 联用\n释义：在select语句中使用having 子句来指定一组行或聚合的过滤条件。 having 子句通常与 group by子句一起使用，以根据指定的条件过滤分组。\nselect 专业名,count(*) from xs group by 专业名 having count(*)&gt;10;\n\n9、order by位置：一般写在最后\n降序：order by 根据谁排序 desc\n升序：order by 根据谁排序 asc \n范例：以cid升序、degree降序查询Score表的所有记录\n注意：不止以一个字段进行排序的，得到的结果首先完全遵循第一个字段排序，后面的排序在第一个字段基础上进行mysql&gt; select *from Score order by cid asc,degree desc;\n10、limitlimit a,b 分页查询\nlimit 开始的索引,每页查询条数 （不包含开始的索引）\n重要公式： 开始的索引 = （当前页码-1）* 每页显示的条数\n例如百度搜索任意东西，记录有很多，每页是10条，那第5页开始的索引是多少呢？第一页：0  第二页：10 第三页：20  第五页：（5-1）x 10=40\n11、七大子句顺序1、from：从哪些表中筛选\n2、on：关联多表查询时，去除笛卡尔积\n3、where：从表中筛选的条件\n4、group by：分组依据\n5、having：在统计结果中再次筛选\n6、order by：排序\n7、limit：分页\n必须按照（1）-（7）的顺序编写子句\n12、查询语句补充（也重要）-- where只能查询到表中存在的，group by分组后，会对相同组中的数据做运算，可以查询到表中不存在的\n-- 如果省略 group by子句，则having 子句的行为与where 子句类似\n-- where字句在分组前进行限定，而 having子句在分组后进行限定。\n\n\n-- IN 与 &#x3D; 的异同\n相同点：均在WHERE中使用作为筛选条件之一、均是等于的含义\n不同点：IN可以规定多个值，等于规定一个值\nin 与 &#x3D; 的转换\nselect * from Websites where name in (&#39;Google&#39;,&#39;菜鸟教程&#39;);\n可以转换成 &#x3D; 的表达：\nselect * from Websites where name&#x3D;&#39;Google&#39; or name&#x3D;&#39;菜鸟教程&#39;;\n\n\n-- between...and...\nbetween  a  and  b  (a到b之间，包含a和b)\n\n\n-- where 筛选子句\n释义：用于在初始表中筛选查询。它是一个约束声明，用于约束数据，在返回结果集之前起作用\nselect data(数据)  from  表名  where  条件; （操作符： &#x3D;&#x2F;!&#x3D;&#x2F;&gt;&#x2F;&lt;&#x2F;&gt;&#x3D;&#x2F;&lt;&#x3D;  区分大小写： binary）\n\n-- like 模糊查询\n释义: SQL的模式匹配允许你使用  “_” 匹配任何  单个字符 ，而  “%”  匹配  任意数目字符(包括 0 个字符) \n注意在你使用 SQL 的 like 模式时，你不能使用 &#x3D; 或 ！&#x3D;；而使用 like 或 not like比较操作符。\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n语法：select 字段 from 表名 where 字段名 like ...\n\n&#39;%a&#39;     &#x2F;&#x2F;以a结尾的数据\n&#39;a%&#39;     &#x2F;&#x2F;以a开头的数据\n&#39;%a%&#39;    &#x2F;&#x2F;含有a的数据\n&#39;_a_&#39;    &#x2F;&#x2F;三位且中间字母是a的\n&#39;_a&#39;     &#x2F;&#x2F;两位且结尾字母是a的\n&#39;a_&#39;     &#x2F;&#x2F;两位且开头字母是a的\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n扩展：查询内容包含通配符时,由于通配符的缘故，导致我们查询特殊字符 “%”、“_”、“[” 的语句无法正常实现，而把特殊字符用 “[ ]” 括起便可正常查询\n\n\n-- limit a,b 分页查询\nlimit 开始的索引,每页查询条数 （不包含开始的索引）\n-- 重要公式： 开始的索引 &#x3D; （当前页码-1）* 每页显示的条数\n   例如百度搜索任意东西，记录有很多，每页是10条，那第5页开始的索引是多少呢？\n   第一页：0  第二页：10 第三页：20  第五页：（5-1）x 10&#x3D;40\n                                            \n                                            \n-- case when ... then . else . end\n   select sc.CId,\n\t MAX(sc.score),MIN(sc.score),AVG(sc.score),COUNT(*) as 总计人数,\n\t sum(case when sc.score&gt;&#x3D;60 then 1 else 0 end)&#x2F;count(*) as 及格,\n\t sum(case when sc.score&gt;&#x3D;70 and sc.score&lt;80 then 1 else 0 end) &#x2F;count(*) as 中等,\n\t sum(case when sc.score&gt;&#x3D;80 and sc.score&lt;90 then 1 else 0 end) &#x2F;count(*) as良好,\n\t SUM(case when sc.score&gt;&#x3D;90 then 1 else 0 end)&#x2F;count(*) as 优秀\n\t from sc\n\t GROUP BY sc.cid\n \t order by COUNT(*) desc,sc.CId asc\n   分数在a和b之间 求和加一，否则加0\n\n六、关联查询1、笛卡尔积现象：当两张表进行连接查询的时候，没有任何条件进行限制，最终的查询结果条数是两张表记录条数的乘积\n\n怎么避免笛卡尔积现象？ \n当然是加条件进行过滤。\n\n思考：避免了笛卡尔积现象，会减少记录的匹配次数吗？\n不会，次数还是56次。只不过显示的是有效记录。\n\n\n2、union  操作符连接两个查询语句，把结果组合到一个结果集合中\nunion 语句：用于将不同表中相同列中查询的数据展示出来；（不包括重复数据）\nunion all 语句：用于将不同表中相同列中查询的数据展示出来；（包括重复数据，所有数据）\n使用形式如下：\nselect  列名称  from  表名称  union &#x2F; union all   select  列名称  from  表名称 order by 列名称；\n\n3、内连接：实现A∩Bselect 字段列表\nfrom A表 inner join B表\non 关联条件\nwhere 等其他子句;\n\n或\n\nselect 字段列表\nfrom A表 , B表\nwhere 关联条件 and 等其他子句;\n\n代码示例：\n#查询员工的姓名和他所在的部门的名称\n#员工的姓名在t_employee\n#部门的名称在t_department\nSELECT ename &quot;员工的姓名&quot;,dname &quot;部门名称&quot;\nFROM t_employee INNER JOIN t_department\nON t_employee.did &#x3D; t_department.did\n\nSELECT ename &quot;员工的姓名&quot;,dname &quot;部门名称&quot;\nFROM t_employee , t_department\nWHERE t_employee.did &#x3D; t_department.did\n\n#查询薪资高于20000的男员工的姓名和他所在的部门的名称\nSELECT ename &quot;员工的姓名&quot;,dname &quot;部门名称&quot;\nFROM t_employee INNER JOIN t_department\nON t_employee.did &#x3D; t_department.did\nWHERE salary&gt;20000 AND gender &#x3D; &#39;男&#39;\n\n4、左外连接#实现查询结果是A\nselect 字段列表\nfrom A表 left join B表\non 关联条件\nwhere 等其他子句;\n\n#实现A - A∩B\nselect 字段列表\nfrom A表 left join B表\non 关联条件\nwhere 从表关联字段 is null and 等其他子句;\n\n代码示例：\n#查询所有员工的姓名和他所在的部门的名称\nSELECT ename &quot;员工的姓名&quot;,dname &quot;部门名称&quot;\nFROM t_employee LEFT JOIN t_department\nON t_employee.did &#x3D; t_department.did\n\n\n#查询所有没有部门的员工\nSELECT ename &quot;员工的姓名&quot;,dname &quot;部门名称&quot;\nFROM t_employee LEFT JOIN t_department\nON t_employee.did &#x3D; t_department.did\nWHERE t_employee.did IS NULL\n\n5、右外连接#实现查询结果是B\nselect 字段列表\nfrom A表 right join B表\non 关联条件\nwhere 等其他子句;\n\n#实现B -  A∩B\nselect 字段列表\nfrom A表 right join B表\non 关联条件\nwhere 从表关联字段 is null and 等其他子句;\n\n代码示例：\n#查询所有部门，以及所有部门下的员工信息\nSELECT * \nFROM t_employee RIGHT JOIN t_department\nON t_employee.did &#x3D; t_department.did\n\n#查询那些没有员工属于它的部门\nSELECT * \nFROM t_employee RIGHT JOIN t_department\nON t_employee.did &#x3D; t_department.did\nWHERE t_employee.did IS NULL\n\n6、全连接full join（全员外连接）：获取 左右表 所有记录。                \nselect  字段  from 表1  full  join  表2  on   表1.字段=表2.字段;\n注意\nmysql 不支持 full join 用 左连接 union 右连接代替\n错误范例：select * from person full join card on person.carid=card.cid;\n​                  ERROR 1054 (42S22): Unknown column ‘person.carid’ in ‘on clause’\n7、用union代替全外连接#实现查询结果是A∪B\n#用左外的A，union 右外的B\nselect 字段列表\nfrom A表 left join B表\non 关联条件\nwhere 等其他子句\n\nunion \n\nselect 字段列表\nfrom A表 right join B表\non 关联条件\nwhere 等其他子句;\n\n\n\n#实现A∪B -  A∩B  或   (A -  A∩B) ∪ （B - A∩B）\n#使用左外的 (A -  A∩B)  union 右外的（B - A∩B）\nselect 字段列表\nfrom A表 left join B表\non 关联条件\nwhere 从表关联字段 is null and 等其他子句\n\nunion\n\nselect 字段列表\nfrom A表 right join B表\non 关联条件\nwhere 从表关联字段 is null and 等其他子句\n\n8、子查询1. where型①子查询是单值结果，那么可以对其使用（=，&gt;等比较运算符）\n②子查询是多值结果，那么可对其使用（【not】in(子查询结果)，或 &gt;all(子查询结果)，或&gt;=all(子查询结果)，&lt;all(子查询结果)，&lt;=all（子查询结果)，或 &gt;any(子查询结果)，或&gt;=any(子查询结果)，&lt;any(子查询结果)，&lt;=any（子查询结果)）\n查询全公司最高工资的员工信息\nselect * from 员工表 where 薪资 &#x3D; (select max(薪资) from 员工表);\n\nselect * from 员工表 where 薪资 &gt; all(select salary from 员工表  where 员工姓名 in(...));\n\n2. from型子查询的结果是多行多列的结果，类似于一张表格。\n必须给子查询取别名，即临时表名，表的别名不要加“”和空格。\n查询每个部门的编号，名称，平均工资\nselect 部门编号, 部门名称， 平均工资\nfrom 部门表 inner join (select 部门编号，avg(薪资) from 员工表  group by 部门编号) temp\non 部门表.部门编号 &#x3D; temp.部门编号\n\n3. exists型查询那些有员工的部门\nselect 部门编号, 部门名称 from 部门表\nwhere exists (select * from 员工表  where 部门表.部门编号 &#x3D; 员工表.部门编号);\n\n七、复制表1、select   into语句mysql 数据库是不支持 \n将查询出来的数据整理到一张新表中保存，表结构与查询结构一致。用于创建表的备份复件或者用于对记录进行存档。\n语法\nselect  *    into  新表名  from  旧表名；\n\nin  子句 （可用于向另一个数据库中拷贝表）\nselect  *  into  旧表名   in  其他数据库   from   旧表名;\n\n2、select  into  select语句为已经存在的表批量添加新数据\ninsert into (准备好的表) select *（或者取用自己想要的结构）from 表名 where 各种条件\n&#x2F;* 两者的主要区别为 *&#x2F;\nselect into from 要求目标表不存在，因为在插入时会自动创建；\ninsert into select from 要求目标表存在。\nselect into from：查询出来结果---&gt;复制一张同结构的空表---&gt;将数据拷贝进去。\ninsert into select from：指定一张想要插入数据的表格---&gt;对数据进行加工筛选---&gt;填入一张准备好的表格。\n\n&#x2F;* mysql数据库 不支持 select into from *&#x2F;\n错误实例:\nmysql&gt; select sname into Student1 from Student;\nERROR 1327 (42000): Undeclared variable: Student1\nmysql&gt; select * into Student1 from Student;\nERROR 1327 (42000): Undeclared variable: Student1\n&#x2F;* 替代方法 create table 目的地表名（select 需求列 from 源表名*&#x2F;\nmysql&gt; create table Student2(select sid,sname from Student);\nQuery OK, 9 rows affected (0.30 sec)\nRecords: 9  Duplicates: 0  Warnings: 0\n\n八、语句补充1、select   Top  语句TOP 子句用于规定要返回的  记录的数目。（从头开始多少条）\nselect  Top  条数  *  from  表；\n2、create   view   语句在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表,视图像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。\ncreate   view  视图名  as  select   列名  from  表名  （where  条件）&#x2F;可有可无&#x2F;\n\n— 范例\nmysql&gt; create view show_class as select class from Student;\nQuery OK, 0 rows affected (0.08 sec)\n\nmysql&gt; select * from show_class;\n+-------+\n| class |\n+-------+\n| 901   |\n| 902   |\n| 903   |\n| 904   |\n| 906   |\n\n4、is  null   /   is  not   null   语句查询  某列中  带有空值 / 不带有空值  的记录 \nselect   *    from  表   where  列  is null   &#x2F;   is not  nulll；","slug":"19-MySql基础语句","date":"2021-09-13T14:54:32.000Z","categories_index":"MySql","tags_index":"MySql","author_index":"大黄"},{"id":"89dcc30b71db0004bd54ff025b96bee1","title":"反射","content":"一、类加载– 概述：类在内存中的生命周期：加载–&gt;使用–&gt;卸载\n1、类的加载过程当程序主动使用某个类时，如果该类还未被加载到内存中，系统会通过加载、连接、初始化三个步骤来对该类进行初始化，如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载。\n类的加载又分为三个阶段：\n（1）加载：load\n就是指将类型的clas字节码数据读入内存\n（2）连接：link\n①验证：校验合法性等\n②准备：准备对应的内存（方法区），创建Class对象，为类变量赋默认值，为静态常量赋初始值。\n③解析：把字节码中的符号引用替换为对应的直接地址引用\n（3）初始化：initialize（类初始化）即执行类初始化方法，大多数情况下，类的加载就完成了类的初始化，有些情况下，会延迟类的初始化。\n\n2、类初始化1、哪些操作会导致类的初始化？\n（1）运行主方法所在的类，要先完成类初始化，再执行main方法\n（2）第一次使用某个类型就是在new它的对象，此时这个类没有初始化的话，先完成类初始化再做实例初始化\n（3）调用某个类的静态成员（类变量和类方法），此时这个类没有初始化的话，先完成类初始化\n（4）子类初始化时，发现它的父类还没有初始化的话，那么先初始化父类\n（5）通过反射操作某个类时，如果这个类没有初始化，也会导致该类先初始化\n\n\n\n\n\n\n\n\n\n类初始化执行的是()，该方法由（1）类变量的显式赋值代码（2）静态代码块中的代码构成\n2、哪些使用类的操作，但是不会导致类的初始化？\n（1）使用某个类的静态的常量（static  final）\n（2）通过子类调用父类的静态变量，静态方法，只会导致父类初始化，不会导致子类初始化，即只有声明静态成员的类才会初始化\n（3）用某个类型声明数组并创建数组对象时，不会导致这个类初始化\n3、类加载器很多开发人员都遇到过java.lang.ClassNotFoundException或java.lang.NoClassDefError，想要更好的解决这类问题，或者在一些特殊的应用场景，比如需要支持类的动态加载或需要对编译后的字节码文件进行加密解密操作，那么需要你自定义类加载器，因此了解类加载器及其类加载机制也就成了每一个Java开发人员的必备技能之一。\n1、类加载器分为：\n（1）引导类加载器（Bootstrap Classloader）又称为根类加载器\n它负责加载jre/rt.jar核心库\n它本身不是Java代码实现的，也不是ClassLoader的子类，获取它的对象时往往返回null\n\n（2）扩展类加载器（Extension ClassLoader）\n它负责加载jre/lib/ext扩展库\n它是ClassLoader的子类\n\n（3）应用程序类加载器（Application Classloader）\n它负责加载项目的classpath路径下的类\n\n它是ClassLoader的子类\n\n（4）自定义类加载器\n当你的程序需要加载“特定”目录下的类，可以自定义类加载器；\n当你的程序的字节码文件需要加密时，那么往往会提供一个自定义类加载器对其进行解码\n后面会见到的自定义类加载器：tomcat中\n\n2、Java系统类加载器的双亲委托模式\n简单描述：\n下一级的类加载器，如果接到任务时，会先搜索是否加载过，如果没有，会先把任务往上传，如果都没有加载过，一直到根加载器，如果根加载器在它负责的路径下没有找到，会往回传，如果一路回传到最后一级都没有找到，那么会报ClassNotFoundException或NoClassDefError，如果在某一级找到了，就直接返回Class对象。\n\n应用程序类加载器  把  扩展类加载器视为父加载器，\n扩展类加载器 把 引导类加载器视为父加载器。\n不是继承关系，是组合的方式实现的。\n\n\n二、Java反射机制1、概述\njava反射机制是在运行状态中，对任意一个类，都能够知道这个类的所有属性和方法，对任意一个对象，都能够调用他的任意一个方法和属性，这种动态获取信息以及动态调用对象的方法被称为 java语言的反射机制。\n要想解剖一个类，必须先要获取到该类的Class对象。而剖析一个类或用反射解决具体的问题就是使用相关API（1）java.lang.Class（2）java.lang.reflect.*。所以，Class对象是反射的根源。\n\n2、哪些类型可以获取class对象所有Java类型\n&#x2F;&#x2F;（1）基本数据类型和void\n例如：int.class\n\t void.class\n&#x2F;&#x2F;（2）类和接口\n例如：String.class\n\tComparable.class\n&#x2F;&#x2F;（3）枚举\n例如：ElementType.class\n&#x2F;&#x2F;（4）注解\n例如：Override.class\n&#x2F;&#x2F;（5）数组\n例如：int[].class\n\n三、获取Class对象的四种方式\n类型名.class：任何数据类型（包括基本数据类型）都有一个 “静态” 的class属性，要求编译期间已知类型。\n对象.getClass()：object类中的getClass方法，所有类都继承Object类。获取对象的运行时类型。\nClass.forName(类型全名称)：可以获取编译期间未知的类型\nClassLoader的类加载器对象.loadClass(类型全名称)：可以用系统类加载对象或自定义加载器对象加载指定路径下的类型\n\npublic class TestClass &#123;\n\t@Test\n\tpublic void test05() throws ClassNotFoundException&#123;\n\t\tClass c &#x3D; TestClass.class;\n\t\tClassLoader loader &#x3D; c.getClassLoader();\n\t\t\n\t\tClass c2 &#x3D; loader.loadClass(&quot;com.atguigu.test05.Employee&quot;);\n\t\tClass c3 &#x3D; Employee.class;\n\t\tSystem.out.println(c2 &#x3D;&#x3D; c3);\n\t&#125;\n\t\n\t@Test\n\tpublic void test03() throws ClassNotFoundException&#123;\n\t\tClass c2 &#x3D; String.class;\n\t\tClass c1 &#x3D; &quot;&quot;.getClass();\n\t\tClass c3 &#x3D; Class.forName(&quot;java.lang.String&quot;);\n\t\t\n\t\tSystem.out.println(c1 &#x3D;&#x3D; c2);\n\t\tSystem.out.println(c1 &#x3D;&#x3D; c3);\n\t&#125;\n&#125;\n\n注意：\n\n在运行期间，一个类只有一个Class对象产生\n\n四种方式中，最常用的是 第三种，通过Class类的静态方法获取\n第一种 需要导入类的包，依赖太强，不导包就会抛编译错误\n第二种 需要对象，对象都有了，没必要用反射了\n第三种 可以传入一个字符串，也可以从配置文件中获取等多种方法\n\n\n四、获取类型的详细信息可以获取：包、修饰符、类型名、父类（包括泛型父类）、父接口（包括泛型父接口）、成员（属性、构造器、方法）、注解（类上的、方法上的、属性上的）\n太多了，运用到什么查什么\n\n五、创建任意引用类型的对象1、两种方式：\n直接通过Class对象来实例化（要求必须有无参构造）\n通过获取构造器对象来进行实例化\n\n注意：不推荐使用Class类中的 newInstance() 方法，jdk9 后已经废弃。推荐使用 获取相关类的Class对象后，获取他的 Constructor对象(构造方法)，使用 Constructor类 中的 newInstance()方法\n2、方式一的步骤（1）获取该类型的Class对象（2）创建对象\n\t@Test\n\tpublic void test2()throws Exception&#123;\n\t\tClass&lt;?&gt; clazz &#x3D; Class.forName(&quot;com.atguigu.test.Student&quot;);\n\t\t&#x2F;&#x2F;Caused by: java.lang.NoSuchMethodException: com.atguigu.test.Student.&lt;init&gt;()\n\t\t&#x2F;&#x2F;即说明Student没有无参构造，就没有无参实例初始化方法&lt;init&gt;\n\t\tObject stu &#x3D; clazz.newInstance();\n\t\tSystem.out.println(stu);\n\t&#125;\n\t\n\t@Test\n\tpublic void test1() throws ClassNotFoundException, InstantiationException, IllegalAccessException&#123;\n&#x2F;&#x2F;\t\tAtGuigu obj &#x3D; new AtGuigu();&#x2F;&#x2F;编译期间无法创建\n\t\t\n\t\tClass&lt;?&gt; clazz &#x3D; Class.forName(&quot;com.atguigu.test.AtGuigu&quot;);\n\t\t&#x2F;&#x2F;clazz代表com.atguigu.test.AtGuigu类型\n\t\t&#x2F;&#x2F;clazz.newInstance()创建的就是AtGuigu的对象\n\t\tObject obj &#x3D; clazz.newInstance();\n\t\tSystem.out.println(obj);\n\t&#125;\n\n3、方式二的步骤：（1）获取该类型的Class对象（2）获取构造器对象（3）创建对象\n  先通过Class对象获取指定的Constructor对象，再通过Constructor对象的newInstance()方法来创建\n\n\n\n\n\n\n\n\n\n如果构造器的权限修饰符修饰的范围不可见，也可以调用setAccessible(true)\n示例代码：\npublic class TestNewInstance &#123;\n\t@Test\n\tpublic void test3()throws Exception&#123;\n\t\t&#x2F;&#x2F;(1)获取Class对象\n\t\tClass&lt;?&gt; clazz &#x3D; Class.forName(&quot;com.atguigu.test.Student&quot;);\n\t\t&#x2F;*\n\t\t * 获取Student类型中的有参构造\n\t\t * 如果构造器有多个，我们通常是根据形参【类型】列表来获取指定的一个构造器的\n\t\t * 例如：public Student(int id, String name) \n\t\t *&#x2F;\n\t\t&#x2F;&#x2F;(2)获取构造器对象\n\t\tConstructor&lt;?&gt; constructor &#x3D; clazz.getDeclaredConstructor(int.class,String.class);\n\t\t\n\t\t&#x2F;&#x2F;(3)创建实例对象\n\t\t&#x2F;&#x2F; T newInstance(Object... initargs)  这个Object...是在创建对象时，给有参构造的实参列表\n\t\tObject obj &#x3D; constructor.newInstance(2,&quot;张三&quot;);\n\t\tSystem.out.println(obj);\n\t&#125;\n&#125;\n\n六、通过反射获取构造方法1、获取多个构造方法public Constructor&lt;?&gt;[] getConstructors()：\n获取 所有的 构造方法，不包含私有的\n\npublic Constructor&lt;?&gt;[] getDeclaredConstructors()：\n获取 所有的 构造方法 ，包括私有的\n\n2、获取单个构造方法public Constructor&lt; T &gt; getConstructor(Class&lt;?&gt;... paramet)\n获取单个的构造方法， 不包含私有的\n\npublic Constructor&lt; T &gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)：\n获取单个的构造方法，包含私有的\n\n3、注意在使用第二种方法获取单个构造方法构建实例时，getConstructor()方法的参数为：**方法形参类型的class对象**\n* 示例\nstudent类中的一个构造方法：\npublic Student(String name, int age, String address) &#123;\n    this.name &#x3D; name;\n    this.age &#x3D; age;\n    this.address &#x3D; address;\n&#125;\n    \n获取次构造方法，创建实例：\nConstructor&lt;?&gt; cos3 &#x3D; c1.getConstructor(String.class,int.class,String.class);\nStudent obj2 &#x3D; (Student) cos3.newInstance(&quot;黄某人&quot;,22,&quot;新疆&quot;);   \n\n4、setAccessible(boolean flag)在获取私有的 构造犯法，成员变量，成员方法时，需要设置 使用java语言访问控制执行检查 的值为true\npublic void setAccessible(boolean flag)：将此反射对象的accessible标志设置为指示的布尔值。\n值为true表示反射对象应该在使用Java语言访问控制时   抑制检查。\n值为false表示反射对象应该在使用Java语言访问控制时  执行检查，并在类描述中指出变体。\npublic class ReflectDemo1 &#123;\n\n   public static void main(String[] args) throws Exception&#123;\n\n       Class&lt;?&gt; c1 &#x3D; Class.forName(&quot;ClassLoder.Student&quot;);\n\n       &#x2F;&#x2F; 获取私有的构造方法\n       Constructor&lt;?&gt; con5 &#x3D; c1.getDeclaredConstructor(String.class);\n       &#x2F;&#x2F;public void setAccessible(boolean flag)将此反射对象的accessible标志设置为指示的布尔值。\n       &#x2F;&#x2F;值为true表示反射对象应该在使用Java语言访问控制时抑制检查。\n       &#x2F;&#x2F;值为false表示反射对象应该在使用Java语言访问控制时执行检查，并在类描述中指出变体。\n       con5.setAccessible(true);\n       Object obj4 &#x3D; con5.newInstance(&quot;田兆鑫&quot;);\n       System.out.println(obj4);\n\n   &#125;\n&#125;\n\n七、通过反射获取成员变量1、获取多个成员变量public Field[] getFields()：\n获取所有的成员变量包含从父类继承过来的\n\npublic Field[] getDeclaredFields()：\t\n获取所有的成员变量 包含私有的 也包含从父类继承过来的成员变量\n\n2、获取单个成员变量public Field getField(String name) \n     \npublic Field getDeclaredField(String name) （需要setAccessible(true)）\n\n3、获取后可进行值的设置void set(Object obj, Object value) \n将指定的对象参数中由此 Field对象表示的字段设置为指定的新值。\n\n4、示例public static void main(String[] args) throws Exception &#123;\n\n        Class&lt;?&gt; c &#x3D; Class.forName(&quot;ClassLoder.Student&quot;);\n\n        &#x2F;&#x2F;public Field[] getFields()：\n        &#x2F;&#x2F;获取所有的成员变量包含从父类继承过来的\n        Field[] f1 &#x3D; c.getFields();\n        for (Field f : f1)&#123;\n            System.out.println(f);\n        &#125;\n        System.out.println(&quot;--------&quot;);\n\n        &#x2F;&#x2F;public Field[] getDeclaredFields()：\n        &#x2F;&#x2F;获取所有的成员变量 包含私有的 也包含从父类继承过来的成员变量\n        Field[] df1 &#x3D; c.getDeclaredFields();\n        for (Field df : df1)&#123;\n            System.out.println(df);\n        &#125;\n        System.out.println(&quot;--------&quot;);\n\n        &#x2F;&#x2F;public Field getField(String name) 获取单个成员变量\n        Field fiel &#x3D; c.getField(&quot;address&quot;);\n        System.out.println(fiel);\n        System.out.println(&quot;--------&quot;);\n\n        &#x2F;&#x2F;获取单个成员变量(包括私有)：\n        &#x2F;&#x2F;public Field getDeclaredField(String name)\n        Field fiel1 &#x3D; c.getDeclaredField(&quot;name&quot;);\n        System.out.println(fiel1);\n        System.out.println(&quot;--------&quot;);\n\n        Field fiel2 &#x3D; c.getField(&quot;address&quot;);\n        Constructor&lt;?&gt; con &#x3D; c.getConstructor();\n        Object o &#x3D; con.newInstance();\n        &#x2F;&#x2F;void set​(Object obj, Object value)\n        &#x2F;&#x2F; 将指定的对象参数中由此 Field对象表示的字段设置为指定的新值。\n        fiel2.set(o,&quot;北京&quot;);&#x2F;&#x2F;给对象o的成员变量fiel2(address)赋值为北京\n        System.out.println(o);\n        System.out.println(&quot;--------&quot;);\n\n\n        Field fiel3 &#x3D; c.getDeclaredField(&quot;name&quot;);\n        Constructor&lt;?&gt; con1&#x3D; c.getConstructor();\n        Object o1 &#x3D; con1.newInstance();\n\n        fiel3.setAccessible(true);\n\n        &#x2F;&#x2F;void set​(Object obj, Object value)\n        &#x2F;&#x2F; 将指定的对象参数中由此 Field对象表示的字段设置为指定的新值。\n        fiel3.set(o1,&quot;北京&quot;);&#x2F;&#x2F;给对象o的成员变量fiel2(address)赋值为北京\n        System.out.println(o1);\n    &#125;\n\n\n\n八、通过反射获取成员方法1、获取多个成员方法public Method[] getMethods()：\n获取所有的公共的成员方法不包含私有的，包含从父类继承过来的过来的公共方法\n\npublic Method[] getDeclaredMethods()：\n获取自己的所有成员方法 包含私有的\n\n2、获取单个成员方法参数1: 方法名称 参数2:方法行参类型的class 对象\n     \npublic Method getMethod(String name,Class&lt;?&gt;... parameterTypes)：\n获取单个的方法 不包含私有的\n\npublic Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)：\n获取单个方法包括私有的  （需要setAccessible(true)）\n\n3、获取方法后进行调用Object invoke(Object obj, Object... args) \n在具有指定参数的指定对象上调用此 方法对象表示的基础方法\n\n4、示例public static void main(String[] args) throws Exception &#123;\n\n        Class&lt;?&gt; c &#x3D; Class.forName(&quot;ClassLoder.Student&quot;);\n        &#x2F;&#x2F;Object o &#x3D; c.newInstance();\n        &#x2F;&#x2F;Class类中的newInstance()方法jdk9后已经过时，选择使用Constructor里的此方法\n        Constructor&lt;?&gt; con &#x3D; c.getConstructor();\n        Object o &#x3D; con.newInstance();\n\n        &#x2F;&#x2F;public Method[] getMethods()：\n        &#x2F;&#x2F;获取所有的公共的成员方法不包含私有的\n        &#x2F;&#x2F;包含从父类继承过来的过来的公共方法\n        Method[] met1 &#x3D; c.getMethods();\n        for (Method met : met1)&#123;\n            System.out.println(met);\n        &#125;\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n\n\n        &#x2F;&#x2F;public Method[] getDeclaredMethods()：\n        &#x2F;&#x2F;获取自己的所有成员方法 包含私有的\n        Method[] dmet1 &#x3D; c.getDeclaredMethods();\n        for (Method demt : dmet1)&#123;\n            System.out.println(demt);\n        &#125;\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n\n\n        &#x2F;&#x2F;参数1: 方法名称 参数2:方法行参的class 对象\n        &#x2F;&#x2F;public Method getMethod(String name,Class&lt;?&gt;... parameterTypes)：\n        &#x2F;&#x2F;获取单个的方法 不包含私有的\n        Method method1 &#x3D; c.getMethod(&quot;method1&quot;, String.class);\n        &#x2F;&#x2F;Object invoke​(Object obj, Object... args)\n        &#x2F;&#x2F;在具有指定参数的指定对象上调用此 方法对象表示的基础方法。\n        method1.invoke(o,&quot;黄任翔真帅！&quot;);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n\n\n        &#x2F;&#x2F;public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)：\n        &#x2F;&#x2F;获取单个方法包括私有的\n        Method function &#x3D; c.getDeclaredMethod(&quot;function&quot;);\n        function.setAccessible(true);\n        function.invoke(o);\n\n    &#125;\n\n九、获取泛型父类信息（可选）&#x2F;* Type：\n * （1）Class\n * （2）ParameterizedType   \n * \t\t例如：Father&lt;String,Integer&gt;\n * \t\t\tArrayList&lt;String&gt;\n * （3）TypeVariable\n * \t\t例如：T，U,E,K,V\n * （4）WildcardType\n * \t\t例如：\n * \t\tArrayList&lt;?&gt;\n * \t\tArrayList&lt;? super 下限&gt;\n * \t\tArrayList&lt;? extends 上限&gt;\n * （5）GenericArrayType\n * \t\t例如：T[]\n * \t\n *&#x2F;\npublic class TestGeneric &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t&#x2F;&#x2F;需求：在运行时，获取Son类型的泛型父类的泛型实参&lt;String,Integer&gt;\n\t\t\n\t\t&#x2F;&#x2F;（1）还是先获取Class对象\n\t\tClass clazz &#x3D; Son.class;&#x2F;&#x2F;四种形式任意一种都可以\n\t\t\n\t\t&#x2F;&#x2F;（2）获取泛型父类\n&#x2F;&#x2F;\t\tClass sc &#x3D; clazz.getSuperclass();\n&#x2F;&#x2F;\t\tSystem.out.println(sc);\n\t\t&#x2F;*\n\t\t * getSuperclass()只能得到父类名，无法得到父类的泛型实参列表\n\t\t *&#x2F;\n\t\tType type &#x3D; clazz.getGenericSuperclass();\n\t\t\n\t\t&#x2F;&#x2F; Father&lt;String,Integer&gt;属于ParameterizedType\n\t\tParameterizedType pt &#x3D; (ParameterizedType) type;\n\t\t\n\t\t&#x2F;&#x2F;（3）获取泛型父类的泛型实参列表\n\t\tType[] typeArray &#x3D; pt.getActualTypeArguments();\n\t\tfor (Type type2 : typeArray) &#123;\n\t\t\tSystem.out.println(type2);\n\t\t&#125;\n\t&#125;\n&#125;\n&#x2F;&#x2F;泛型形参：&lt;T,U&gt;\nclass Father&lt;T,U&gt;&#123;\n\t\n&#125;\n&#x2F;&#x2F;泛型实参：&lt;String,Integer&gt;\nclass Son extends Father&lt;String,Integer&gt;&#123;\n\t\n&#125;\n\n十、反射忽视泛型检查1、概念泛型仅在编译期有效（编译过后泛型擦除），而反射机制是针对运行期的，所以我们可以使用反射越过泛型检查\n具体通俗的来讲：\n若我们通过反射机制调用泛型，就会读取不到相应的类型，只会读取到 Object类型，这就是我们所谓的 泛型擦除机制\n2、示例定义一个 规定了内容类型 的 集合，通过反射可以添加 不同于 规定类型的 值\npublic static void main(String[] args) throws Exception &#123;\n\n        &#x2F;&#x2F; 规定 集合 内容类型为 Integer 类型（若正常添加，只能添加 Integer类型）\n        ArrayList&lt;Integer&gt; arr &#x3D; new ArrayList&lt;Integer&gt;();\n\n        &#x2F;&#x2F; public boolean add(E e)\n        arr.add(123);\n        arr.add(456);\n        arr.add(789);\n\n        &#x2F;&#x2F; 泛型，只在编译期有效，运行期就擦除了\n        &#x2F;&#x2F; 此时，通过反射获取 集合的 add方法时，可以看到，add方法的形参类型的class对象为 Object.class\n        Class&lt;? extends ArrayList&gt; c &#x3D; arr.getClass();\n        Method met &#x3D; c.getMethod(&quot;add&quot;, Object.class);\n       \n        &#x2F;&#x2F; 调用得到的方法发现，能够添加 String类型的值（综上，就是所谓的泛型擦除机制）\n        met.invoke(arr, &quot;abc&quot;);\n\n        System.out.println(arr);\n&#125;\n\n十一、运行配置文件指定内容1、概念\nProperties类可以将配置文件中的键值对读取出来。\n那么可以通过反射机制，将从配置文件中读取出来的值，赋给类中相应成员：\n如果想在一个测试类中 开始调用Student类中的方法，过会不调用Student了，开始调用Teacher类中的方法，然后再改，进行很多次，这样在测试类中写代码会很麻烦，所以就用到了运行配置文件指定内容，这样的话只需要修改配置文件中的路径名以及方法名就可以了\n\n2、配置文件ClassName&#x3D;ClassLoder.Phone\nMethodName&#x3D;music\n\n3、示例读取package ClassLoder;\n\npublic class Phone &#123;\n\n    public Phone() &#123;\n    &#125;\n\n    public void game() &#123;\n        System.out.println(&quot;正在运行游戏&quot;);\n    &#125;\n\n    public void music() &#123;\n        System.out.println(&quot;正在播放音乐&quot;);\n    &#125;\n\n    public void call() &#123;\n        System.out.println(&quot;正在进行通话&quot;);\n    &#125;\n&#125;\n\npublic static void main(String[] args) throws Exception &#123;\n\n        &#x2F;&#x2F;加载配置文件\n        &#x2F;&#x2F;基于目标类开发\n        Properties pro &#x3D; new Properties();\n        &#x2F;&#x2F;pro.load(new FileReader(&quot;.&#x2F;hrx.properties&quot;));\n        InputStream is &#x3D; TestDemo4.class.getClassLoader().getResourceAsStream(&quot;hrx.properties&quot;);\n        pro.load(is);\n\n        &#x2F;&#x2F;1.获取该类的字节码文件对象\n        Class&lt;?&gt; cn &#x3D; Class.forName(pro.getProperty(&quot;ClassName&quot;));\n\n        &#x2F;&#x2F;2.通过反射来创建目标类对象\n        Object o &#x3D; cn.getDeclaredConstructor().newInstance();\n\n        &#x2F;&#x2F;3.调用目标类中的方法执行\n        Method methodName &#x3D; cn.getMethod(pro.getProperty(&quot;MethodName&quot;));\n        methodName.invoke(o);\n\n    &#125;\n\n十二、JDK的动态代理\n\njdk的动态代理调用了Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 方法。\n通过该方法生成字节码，动态的创建了一个代理类，interfaces参数是该动态类所继承的所有接口，而继承InvocationHandler 接口的类则是实现在调用代理接口方法前后的具体逻辑\n\nnewProxyInstance方法执行了以下几种操作。\n1.生成一个实现了参数interfaces里所有接口且继承了Proxy的代理类的字节码，然后用参数里的classLoader加载这个代理类。\n2.使用代理类父类的构造函数 Proxy(InvocationHandler h)来创造一个代理类的实例，将我们自定义的InvocationHandler的子类传入。\n3.返回这个代理类实例\n\n1、什么是代理？\n代理：代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理\n动态代理：在程序运行过程中，产生这个对象，其实就是通过反射来生成一个代理。\n\n2、特点及作用\n字节码随用随创建，随用随加载\n在不修改源码的基础上对方法进行增强\n\n4、分类\n基于接口的动态代理 —— Proxy代理模式\n基于子类的动态代理 —— CGLib代理模式\n\n注意：JDK给我们提供的动态代理,只能对接口进行代理（即：Proxy代理模式）\n5、Proxy代理模式\n如何创建代理对象：调用Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 方法。\n参数：\nloader: 类加载器\ninterfaces: 接口对应的一个Class数组\nInvocationHandler: 这个其实就是要代理对象所做的事情的一个类的封装\n\n\n创建代理对象的前提：目标对象必须要有父接口，也就是说被代理类至少实现一个接口。\n\n\nnewProxyInstance方法执行了以下几种操作。1、生成一个实现了参数interfaces里所有接口且继承了Proxy的代理类的字节码，然后用参数里的classLoader加载这个代理类。2、使用代理类父类的构造函数 Proxy(InvocationHandler h)来创造一个代理类的实例，将我们自定义的InvocationHandler的子类传入。3、返回这个代理类实例\n而这个方法，最终会调用InvocationHandler接口的方法：InvocationHandler Object invoke(Object proxy,Method method,Object[] args)作用：执行被代理对象的任何接口方法都会经过该方法\n参数：proxy：代理对象的引用，method：当前执行的方法，args：当前执行方法所需的参数   返回值：和被代理对象方法有相同的返回值*\n\n6、两种代理模式区别\nProxy代理模式:产生的代理对象，其类型是目标接口的派生类类型对象代理对象只能调用接口中的方法(可以理解为：被代理对象的 兄弟对象)\nCGLib代理模式：产生的代理对象，是 被代理类的子类对象代理对象可以调用 被代理类 中 除了final修饰 的其它 所有方法(可以理解为：被代理对象的 子对象)\n\n","slug":"18-反射","date":"2021-09-13T14:53:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"c7c150790ff577b4efb11f92f9e10f6d","title":"Lambda 表达式","content":"一、函数式编程思想在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。编程中的函数，也有类似的概念，你调用我的时候，给我实参为形参赋值，然后通过运行方法体，给你返回一个结果。对于调用者来做，关注这个方法具备什么样的功能。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——强调做什么，而不是以什么形式做。\n\n面向对象的思想:\n\n做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.\n\n\n函数式编程思想:\n\n只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程\n\n\n\nJava8引入了Lambda表达式之后，Java也开始支持函数式编程。\nLambda表达式不是Java最早使用的，很多语言就支持Lambda表达式，例如：C++，C#，Python，Scala等。如果有Python或者Javascript的语言基础，对理解Lambda表达式有很大帮助，可以这么说lambda表达式其实就是实现SAM接口的语法糖，使得Java也算是支持函数式编程的语言。Lambda写的好可以极大的减少代码冗余，同时可读性也好过冗长的匿名内部类。\n\n\n\n\n\n\n\n\n\n备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部类的“语法糖”，但是二者在原理上是不同的。\n二、函数式接口lambda表达式其实就是实现SAM接口的语法糖，所谓SAM接口就是Single Abstract Method，即该接口中只有一个抽象方法需要实现，当然该接口可以包含其他非抽象方法。\n其实只要满足“SAM”特征的接口都可以称为函数式接口，都可以使用Lambda表达式，但是如果要更明确一点，最好在声明接口时，加上@FunctionalInterface。一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。\n之前学过的SAM接口中，标记了@FunctionalInterface的函数式接口的有：Runnable，Comparator，FileFilter。\nJava8在java.util.function新增了很多函数式接口：主要分为四大类，消费型、供给型、判断型、功能型。基本可以满足我们的开发需求。当然你也可以定义自己的函数式接口。\n1、自定义函数式接口只要确保接口中有且仅有一个抽象方法即可：\n修饰符 interface 接口名称 &#123;\n    public abstract 返回值类型 方法名称(可选参数信息);\n    &#x2F;&#x2F; 其他非抽象方法内容\n&#125;\n\n\n\n\n\n\n\n\n\n\n接口当中抽象方法的 public abstract 是可以省略的\n2、消费型接口消费型接口的抽象方法特点：有形参，但是返回值类型是void\n\n\n\n接口名\n抽象方法\n描述\n\n\n\nConsumer\nvoid accept(T t)\n接收一个对象用于完成功能\n\n\nBiConsumer&lt;T,U&gt;\nvoid accept(T t, U u)\n接收两个对象用于完成功能\n\n\nDoubleConsumer\nvoid accept(double value)\n接收一个double值\n\n\nIntConsumer\nvoid accept(int value)\n接收一个int值\n\n\nLongConsumer\nvoid accept(long value)\n接收一个long值\n\n\nObjDoubleConsumer\nvoid accept(T t, double value)\n接收一个对象和一个double值\n\n\nObjIntConsumer\nvoid accept(T t, int value)\n接收一个对象和一个int值\n\n\nObjLongConsumer\nvoid accept(T t, long value)\n接收一个对象和一个long值\n\n\n3、供给型接口这类接口的抽象方法特点：无参，但是无返回值\n\n\n\n接口名\n抽象方法\n描述\n\n\n\nSupplier\nT get()\n返回一个对象\n\n\nBooleanSupplier\nboolean getAsBoolean()\n返回一个boolean值\n\n\nDoubleSupplier\ndouble getAsDouble()\n返回一个double值\n\n\nIntSupplier\nint getAsInt()\n返回一个int值\n\n\nLongSupplier\nlong getAsLong()\n返回一个long值\n\n\n4、判断型接口这里接口的抽象方法特点：有参，但是返回值类型是boolean结果。\n\n\n\n接口名\n抽象方法\n描述\n\n\n\nPredicate\nboolean test(T t)\n接收一个对象\n\n\nBiPredicate&lt;T,U&gt;\nboolean test(T t, U u)\n接收两个对象\n\n\nDoublePredicate\nboolean test(double value)\n接收一个double值\n\n\nIntPredicate\nboolean test(int value)\n接收一个int值\n\n\nLongPredicate\nboolean test(long value)\n接收一个long值\n\n\n5、功能型接口这类接口的抽象方法特点：既有参数又有返回值\n\n\n\n接口名\n抽象方法\n描述\n\n\n\nFunction&lt;T,R&gt;\nR apply(T t)\n接收一个T类型对象，返回一个R类型对象结果\n\n\nUnaryOperator\nT apply(T t)\n接收一个T类型对象，返回一个T类型对象结果\n\n\nDoubleFunction\nR apply(double value)\n接收一个double值，返回一个R类型对象\n\n\nIntFunction\nR apply(int value)\n接收一个int值，返回一个R类型对象\n\n\nLongFunction\nR apply(long value)\n接收一个long值，返回一个R类型对象\n\n\nToDoubleFunction\ndouble applyAsDouble(T value)\n接收一个T类型对象，返回一个double\n\n\nToIntFunction\nint applyAsInt(T value)\n接收一个T类型对象，返回一个int\n\n\nToLongFunction\nlong applyAsLong(T value)\n接收一个T类型对象，返回一个long\n\n\nDoubleToIntFunction\nint applyAsInt(double value)\n接收一个double值，返回一个int结果\n\n\nDoubleToLongFunction\nlong applyAsLong(double value)\n接收一个double值，返回一个long结果\n\n\nIntToDoubleFunction\ndouble applyAsDouble(int value)\n接收一个int值，返回一个double结果\n\n\nIntToLongFunction\nlong applyAsLong(int value)\n接收一个int值，返回一个long结果\n\n\nLongToDoubleFunction\ndouble applyAsDouble(long value)\n接收一个long值，返回一个double结果\n\n\nLongToIntFunction\nint applyAsInt(long value)\n接收一个long值，返回一个int结果\n\n\nDoubleUnaryOperator\ndouble applyAsDouble(double operand)\n接收一个double值，返回一个double\n\n\nIntUnaryOperator\nint applyAsInt(int operand)\n接收一个int值，返回一个int结果\n\n\nLongUnaryOperator\nlong applyAsLong(long operand)\n接收一个long值，返回一个long结果\n\n\n\n\n\n\n\nBiFunction&lt;T,U,R&gt;\nR apply(T t, U u)\n接收一个T类型和一个U类型对象，返回一个R类型对象结果\n\n\nBinaryOperator\nT apply(T t, T u)\n接收两个T类型对象，返回一个T类型对象结果\n\n\nToDoubleBiFunction&lt;T,U&gt;\ndouble applyAsDouble(T t, U u)\n接收一个T类型和一个U类型对象，返回一个double\n\n\nToIntBiFunction&lt;T,U&gt;\nint applyAsInt(T t, U u)\n接收一个T类型和一个U类型对象，返回一个int\n\n\nToLongBiFunction&lt;T,U&gt;\nlong applyAsLong(T t, U u)\n接收一个T类型和一个U类型对象，返回一个long\n\n\nDoubleBinaryOperator\ndouble applyAsDouble(double left, double right)\n接收两个double值，返回一个double结果\n\n\nIntBinaryOperator\nint applyAsInt(int left, int right)\n接收两个int值，返回一个int结果\n\n\nLongBinaryOperator\nlong applyAsLong(long left, long right)\n接收两个long值，返回一个long结果\n\n\n三、Lambda表达式语法Lambda表达式是用来给 函数式接口 的变量或形参赋值用的。\n其实本质上，Lambda表达式是用于实现【函数式接口】的“抽象方法”\nLambda表达式语法格式\n(形参列表) -&gt; &#123;Lambda体&#125;\n\n说明：\n\n(形参列表)它就是你要赋值的函数式接口的抽象方法的(形参列表)，照抄\n{Lambda体}就是实现这个抽象方法的方法体\n-&gt;称为Lambda操作符（减号和大于号中间不能有空格，而且必须是英文状态下半角输入方式）\n\n优化：Lambda表达式可以精简\n\n当{Lambda体}中只有一句语句时，可以省略{}和{;}\n当{Lambda体}中只有一句语句时，并且这个语句还是一个return语句，那么return也可以省略，但是如果{;}没有省略的话，return是不能省略的\n(形参列表)的类型可以省略\n当(形参列表)的形参个数只有一个，那么可以把数据类型和()一起省略，但是形参名不能省略\n当(形参列表)是空参时，()不能省略\n\n四、方法引用与构造器引用Lambda表达式是可以简化函数式接口的变量与形参赋值的语法。而方法引用和构造器引用是为了简化Lambda表达式的。当Lambda表达式满足一些特殊的情况时，还可以再简化：\n（1）Lambda体只有一句语句，并且是通过调用一个对象的/类现有的方法来完成的\n例如：System.out对象，调用println()方法来完成Lambda体；Math类，调用random()静态方法来完成Lambda体\n（2）并且Lambda表达式的形参正好是给该方法的实参\n例如：t-&gt;System.out.println(t)； () -&gt; Math.random() 都是无参\n1、方法引用方法引用的语法格式：\n（1）实例对象名::实例方法        \n（2）类名::静态方法\n（3）类名::实例方法\n说明：\n\n::  称为方法引用操作符（两个 : 中间不能有空格，而且必须英文状态下半角输入）\nLambda表达式的形参列表，全部在Lambda体中使用上了，要么是作为调用方法的对象，要么是作为方法的实参。\n在整个Lambda体中没有额外的数据。\n\n2、构造器引用（1）当Lambda表达式是创建一个对象，并且满足Lambda表达式形参，正好是给创建这个对象的构造器的实参列表。\n（2）  当Lambda表达式是创建一个数组对象，并且满足Lambda表达式形参，正好是给创建这个数组对象的长度\n构造器引用的语法格式：\n\n类名::new\n数组类型名::new\n\n五、StreamAPIJava8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 Stream API。\nStream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。\nStream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。\nStream是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。“集合讲的是数据，负责存储数据，Stream流讲的是计算，负责处理数据！”\n1、注意①Stream 自己不会存储元素。\n②Stream 不会改变源对象。每次处理都会返回一个持有结果的新Stream。\n③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。\n2、Stream 的操作三个步骤1- 创建 Stream：通过一个数据源（如：集合、数组），获取一个流\n2- 中间操作：中间操作是个操作链，对数据源的数据进行n次处理，但是在终结操作前，并不会真正执行。\n3- 终止操作：一旦执行终止操作，就执行中间操作链，最终产生结果并结束Stream。\n\n3、创建Stream1、创建 Stream方式一：通过集合Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：\n\npublic default Stream stream() : 返回一个顺序流\n\npublic default Stream parallelStream() : 返回一个并行流\n\n\n2、创建 Stream方式二：通过数组Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：\n\npublic static  Stream stream(T[] array): 返回一个流\n\n重载形式，能够处理对应基本类型的数组：\n\npublic static IntStream stream(int[] array)：返回一个整型数据流\npublic static LongStream stream(long[] array)：返回一个长整型数据流\npublic static DoubleStream stream(double[] array)：返回一个浮点型数据流\n\n3、创建 Stream方式三：通过Stream的of()可以调用Stream类静态方法 of(), 通过显示值创建一个流。它可以接收任意数量的参数。\n\npublic static Stream of(T… values) : 返回一个顺序流\n\n4、创建 Stream方式四：创建无限流可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。\n\npublic static Stream iterate(final T seed, final UnaryOperator f):返回一个无限流\npublic static Stream generate(Supplier s) ：返回一个无限流\n\npackage com.atguigu.test06;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.junit.Test;\n\npublic class Test07StreamCreate &#123;\n\t@Test\n\tpublic void test06()&#123;\n\t\t&#x2F;*\n\t\t * Stream&lt;T&gt; iterate(T seed, UnaryOperator&lt;T&gt; f)  \n\t\t * UnaryOperator接口，SAM接口，抽象方法：\n\t\t * \n\t\t * UnaryOperator&lt;T&gt; extends Function&lt;T,T&gt;\n\t\t * \t\tT apply(T t)\n\t\t *&#x2F;\n\t\tStream&lt;Integer&gt; stream &#x3D; Stream.iterate(1, num -&gt; num+&#x3D;2);\n&#x2F;&#x2F;\t\tstream &#x3D; stream.limit(10);\n\t\tstream.forEach(System.out::println);\n\t&#125;\n\t\n\t@Test\n\tpublic void test05()&#123;\n\t\tStream&lt;Double&gt; stream &#x3D; Stream.generate(Math::random);\n\t\tstream.forEach(System.out::println);\n\t&#125;\n\t\n\t@Test\n\tpublic void test04()&#123;\n\t\tStream&lt;Integer&gt; stream &#x3D; Stream.of(1,2,3,4,5);\n\t\tstream.forEach(System.out::println);\n\t&#125;\n\t\n\t@Test\n\tpublic void test03()&#123;\n\t\tString[] arr &#x3D; &#123;&quot;hello&quot;,&quot;world&quot;&#125;;\n\t\tStream&lt;String&gt; stream &#x3D; Arrays.stream(arr);\n\t&#125;\n\t\n\t@Test\n\tpublic void test02()&#123;\n\t\tint[] arr &#x3D; &#123;1,2,3,4,5&#125;;\n\t\tIntStream stream &#x3D; Arrays.stream(arr);\n\t&#125;\n\t\n\t@Test\n\tpublic void test01()&#123;\n\t\tList&lt;Integer&gt; list &#x3D; Arrays.asList(1,2,3,4,5);\n\t\t\n\t\t&#x2F;&#x2F;JDK1.8中，Collection系列集合增加了方法\n\t\tStream&lt;Integer&gt; stream &#x3D; list.stream();\n\t&#125;\n&#125;\n\n4、中间操作多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。\n\n\n\n方  法\n描  述\n\n\n\nfilter(Predicate p)\n接收 Lambda ， 从流中排除某些元素\n\n\ndistinct()\n筛选，通过流所生成元素的equals() 去除重复元素\n\n\nlimit(long maxSize)\n截断流，使其元素不超过给定数量\n\n\nskip(long n)\n跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补\n\n\npeek(Consumer action)\n接收Lambda，对流中的每个数据执行Lambda体操作\n\n\nsorted()\n产生一个新流，其中按自然顺序排序\n\n\nsorted(Comparator com)\n产生一个新流，其中按比较器顺序排序\n\n\nmap(Function f)\n接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。\n\n\nmapToDouble(ToDoubleFunction f)\n接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。\n\n\nmapToInt(ToIntFunction f)\n接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。\n\n\nmapToLong(ToLongFunction f)\n接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。\n\n\nflatMap(Function f)\n接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流\n\n\n5、终结操作终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void。流进行了终止操作后，不能再次使用。\n\n\n\n方法\n描述\n\n\n\nboolean allMatch(Predicate p)\n检查是否匹配所有元素\n\n\nboolean anyMatch(Predicate p)\n检查是否至少匹配一个元素\n\n\nboolean noneMatch(Predicate  p)\n检查是否没有匹配所有元素\n\n\nOptional findFirst()\n返回第一个元素\n\n\nOptional findAny()\n返回当前流中的任意元素\n\n\nlong count()\n返回流中元素总数\n\n\nOptional max(Comparator c)\n返回流中最大值\n\n\nOptional min(Comparator c)\n返回流中最小值\n\n\nvoid forEach(Consumer c)\n迭代\n\n\nT reduce(T iden, BinaryOperator b)\n可以将流中元素反复结合起来，得到一个值。返回 T\n\n\nU reduce(BinaryOperator b)\n可以将流中元素反复结合起来，得到一个值。返回 Optional\n\n\nR collect(Collector c)\n将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法\n\n\nCollector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例。\n","slug":"17-Lambda","date":"2021-09-13T14:52:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"b85a5ed5aa29024c7191b1325f9b4bb8","title":"网络编程","content":"一、实现通信需解决的两个问题\n1.如何准确地定位网络上一台或多台主机；定位主机上的特定的应用\n2.找到主机后如何可靠高效地进行数据传输\n\n二、网络通信的两个要素\n对应问题一：IP和端口号\n对应问题二：提供网络通信协议：TCP/IP参考模型（应用层、传输层、网络层、物理+数据链路层）\n\n三、通信要素一：IP和端口号1、IP的理解\n\nIP:唯一的标识 Internet 上的计算机（通信实体）\n\n\n\n在Java中使用InetAddress类代表IP\n\n\n\nIP分类：IPv4 和 IPv6 ; 万维网 和 局域网\n\n\n\n域名:   www.baidu.com   www.mi.com  www.sina.com  www.jd.com\n\n\n   域名解析：域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS)负责将域名转化成IP地址，这样才能和主机建立连接。 ——-域名解析\n\n本地回路地址：127.0.0.1 对应着：localhost\n\n\n\n2、InetAddress类此类的一个对象就代表着一个具体的IP地址\n2.1 实例化getByName(String host) 、 getLocalHost()\n2.2 常用方法getHostName() / getHostAddress()\n2.3 端口号：正在计算机上运行的进程。\n要求：不同的进程不同的端口号\n范围：被规定为一个 16 位的整数 0~65535。\n\n端口号与IP地址的组合得出一个网络套接字：Socket\n四、通信要素二：网络通信协议1、分型模型\n2、TCP和UDP的区别\n3、TCP三次握手和四次挥手\n\n五、UDP代码示例代码示例：\n\n&#x2F;&#x2F;发送端\n@Test\npublic void sender() throws IOException &#123;\n\n    DatagramSocket socket &#x3D; new DatagramSocket();\n\n\n\n    String str &#x3D; &quot;我是UDP方式发送的导弹&quot;;\n    byte[] data &#x3D; str.getBytes();\n    InetAddress inet &#x3D; InetAddress.getLocalHost();\n    DatagramPacket packet &#x3D; new DatagramPacket(data,0,data.length,inet,9090);\n\n    socket.send(packet);\n\n    socket.close();\n\n&#125;\n&#x2F;&#x2F;接收端\n@Test\npublic void receiver() throws IOException &#123;\n\n    DatagramSocket socket &#x3D; new DatagramSocket(9090);\n\n    byte[] buffer &#x3D; new byte[100];\n    DatagramPacket packet &#x3D; new DatagramPacket(buffer,0,buffer.length);\n\n    socket.receive(packet);\n\n    System.out.println(new String(packet.getData(),0,packet.getLength()));\n\n    socket.close();\n&#125;\n\n六、TCP代码示例代码示例1：客户端发送信息给服务端，服务端将数据显示在控制台上\n&#x2F;&#x2F;客户端\n    @Test\n    public void client()  &#123;\n        Socket socket &#x3D; null;\n        OutputStream os &#x3D; null;\n        try &#123;\n            &#x2F;&#x2F;1.创建Socket对象，指明服务器端的ip和端口号\n            InetAddress inet &#x3D; InetAddress.getByName(&quot;192.168.14.100&quot;);\n            socket &#x3D; new Socket(inet,8899);\n            &#x2F;&#x2F;2.获取一个输出流，用于输出数据\n            os &#x3D; socket.getOutputStream();\n            &#x2F;&#x2F;3.写出数据的操作\n            os.write(&quot;你好，我是客户端mm&quot;.getBytes());\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            &#x2F;&#x2F;4.资源的关闭\n            if(os !&#x3D; null)&#123;\n                try &#123;\n                    os.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n\n            &#125;\n            if(socket !&#x3D; null)&#123;\n                try &#123;\n                    socket.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n\n            &#125;\n        &#125;\n\n\n\n    &#125;\n    &#x2F;&#x2F;服务端\n    @Test\n    public void server()  &#123;\n\n        ServerSocket ss &#x3D; null;\n        Socket socket &#x3D; null;\n        InputStream is &#x3D; null;\n        ByteArrayOutputStream baos &#x3D; null;\n        try &#123;\n            &#x2F;&#x2F;1.创建服务器端的ServerSocket，指明自己的端口号\n            ss &#x3D; new ServerSocket(8899);\n            &#x2F;&#x2F;2.调用accept()表示接收来自于客户端的socket\n            socket &#x3D; ss.accept();\n            &#x2F;&#x2F;3.获取输入流\n            is &#x3D; socket.getInputStream();\n\n            &#x2F;&#x2F;不建议这样写，可能会乱码\n&#x2F;&#x2F;        byte[] buffer &#x3D; new byte[1024];\n&#x2F;&#x2F;        int len;\n&#x2F;&#x2F;        while((len &#x3D; is.read(buffer)) !&#x3D; -1)&#123;\n&#x2F;&#x2F;            String str &#x3D; new String(buffer,0,len);\n&#x2F;&#x2F;            System.out.print(str);\n&#x2F;&#x2F;        &#125;\n            &#x2F;&#x2F;4.读取输入流中的数据\n            baos &#x3D; new ByteArrayOutputStream();\n            byte[] buffer &#x3D; new byte[5];\n            int len;\n            while((len &#x3D; is.read(buffer)) !&#x3D; -1)&#123;\n                baos.write(buffer,0,len);\n            &#125;\n\n            System.out.println(baos.toString());\n\n            System.out.println(&quot;收到了来自于：&quot; + socket.getInetAddress().getHostAddress() + &quot;的数据&quot;);\n\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            if(baos !&#x3D; null)&#123;\n                &#x2F;&#x2F;5.关闭资源\n                try &#123;\n                    baos.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if(is !&#x3D; null)&#123;\n                try &#123;\n                    is.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if(socket !&#x3D; null)&#123;\n                try &#123;\n                    socket.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if(ss !&#x3D; null)&#123;\n                try &#123;\n                    ss.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n\n        &#125;\n\n    &#125;\n\n代码示例2：客户端发送文件给服务端，服务端将文件保存在本地。\n&#x2F;*\n这里涉及到的异常，应该使用try-catch-finally处理\n *&#x2F;\n@Test\npublic void client() throws IOException &#123;\n    &#x2F;&#x2F;1.\n    Socket socket &#x3D; new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;),9090);\n    &#x2F;&#x2F;2.\n    OutputStream os &#x3D; socket.getOutputStream();\n    &#x2F;&#x2F;3.\n    FileInputStream fis &#x3D; new FileInputStream(new File(&quot;beauty.jpg&quot;));\n    &#x2F;&#x2F;4.\n    byte[] buffer &#x3D; new byte[1024];\n    int len;\n    while((len &#x3D; fis.read(buffer)) !&#x3D; -1)&#123;\n        os.write(buffer,0,len);\n    &#125;\n    &#x2F;&#x2F;5.\n    fis.close();\n    os.close();\n    socket.close();\n&#125;\n\n&#x2F;*\n这里涉及到的异常，应该使用try-catch-finally处理\n *&#x2F;\n@Test\npublic void server() throws IOException &#123;\n    &#x2F;&#x2F;1.\n    ServerSocket ss &#x3D; new ServerSocket(9090);\n    &#x2F;&#x2F;2.\n    Socket socket &#x3D; ss.accept();\n    &#x2F;&#x2F;3.\n    InputStream is &#x3D; socket.getInputStream();\n    &#x2F;&#x2F;4.\n    FileOutputStream fos &#x3D; new FileOutputStream(new File(&quot;beauty1.jpg&quot;));\n    &#x2F;&#x2F;5.\n    byte[] buffer &#x3D; new byte[1024];\n    int len;\n    while((len &#x3D; is.read(buffer)) !&#x3D; -1)&#123;\n        fos.write(buffer,0,len);\n    &#125;\n    &#x2F;&#x2F;6.\n    fos.close();\n    is.close();\n    socket.close();\n    ss.close();\n\n&#125;\n\n代码示例3：从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。并关闭相应的连接。\n\n&#x2F;*\n    这里涉及到的异常，应该使用try-catch-finally处理\n     *&#x2F;\n@Test\npublic void client() throws IOException &#123;\n    &#x2F;&#x2F;1.\n    Socket socket &#x3D; new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;),9090);\n    &#x2F;&#x2F;2.\n    OutputStream os &#x3D; socket.getOutputStream();\n    &#x2F;&#x2F;3.\n    FileInputStream fis &#x3D; new FileInputStream(new File(&quot;beauty.jpg&quot;));\n    &#x2F;&#x2F;4.\n    byte[] buffer &#x3D; new byte[1024];\n    int len;\n    while((len &#x3D; fis.read(buffer)) !&#x3D; -1)&#123;\n        os.write(buffer,0,len);\n    &#125;\n    &#x2F;&#x2F;关闭数据的输出\n    socket.shutdownOutput();\n\n    &#x2F;&#x2F;5.接收来自于服务器端的数据，并显示到控制台上\n    InputStream is &#x3D; socket.getInputStream();\n    ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream();\n    byte[] bufferr &#x3D; new byte[20];\n    int len1;\n    while((len1 &#x3D; is.read(buffer)) !&#x3D; -1)&#123;\n        baos.write(buffer,0,len1);\n    &#125;\n\n    System.out.println(baos.toString());\n\n    &#x2F;&#x2F;6.\n    fis.close();\n    os.close();\n    socket.close();\n    baos.close();\n&#125;\n\n&#x2F;*\n这里涉及到的异常，应该使用try-catch-finally处理\n *&#x2F;\n@Test\npublic void server() throws IOException &#123;\n    &#x2F;&#x2F;1.\n    ServerSocket ss &#x3D; new ServerSocket(9090);\n    &#x2F;&#x2F;2.\n    Socket socket &#x3D; ss.accept();\n    &#x2F;&#x2F;3.\n    InputStream is &#x3D; socket.getInputStream();\n    &#x2F;&#x2F;4.\n    FileOutputStream fos &#x3D; new FileOutputStream(new File(&quot;beauty2.jpg&quot;));\n    &#x2F;&#x2F;5.\n    byte[] buffer &#x3D; new byte[1024];\n    int len;\n    while((len &#x3D; is.read(buffer)) !&#x3D; -1)&#123;\n        fos.write(buffer,0,len);\n    &#125;\n\n    System.out.println(&quot;图片传输完成&quot;);\n\n    &#x2F;&#x2F;6.服务器端给予客户端反馈\n    OutputStream os &#x3D; socket.getOutputStream();\n    os.write(&quot;你好，美女，照片我已收到，非常漂亮！&quot;.getBytes());\n\n    &#x2F;&#x2F;7.\n    fos.close();\n    is.close();\n    socket.close();\n    ss.close();\n    os.close();\n\n&#125;\n\n","slug":"16-网络编程","date":"2021-09-13T14:51:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"ed728f6a9d3e4347d3410adc7305d745","title":"多线程","content":"一、多任务我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？为什么操作系统上可以同时运行多个程序而用户感觉不出来？\n这是因为无论是单CPU还是多CPU，操作系统都营造出了可以同时运行多个程序的假象。实际的过程操作系统对进程的调度以及CPU的快速上下文切换实现的：每个进程执行一会就先停下来，然后CPU切换到下个被操作系统调度到的进程上使之运行。因为切换的很快，使得用户认为操作系统一直在服务自己的程序。\n\n并发：多个任务”同时“执行。\n并行：多个任务同时执行。\n\n它们虽然都说是”多个进程同时运行”，但是它们的”同时”不是一个概念。并行的”同时”是同一时刻可以多个进程在运行，是真实的同时运行；而并发所说的”同时”，是经过CPU上下文快速切换，使得看上去多个进程同时都在运行的现象，是一种OS欺骗用户的现象。\n单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。而在多核 CPU 系统中，则可以将多个任务分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核越多，并行处理的程序越多，能大大的提高电脑运行的效率。\n实际上，当程序中写下多进程或多线程代码实现多任务时，只是告诉操作系统有多个任务需要同时执行。而这多个任务最终是有多个CPU分别并行执行，还是由一个CPU来切换并发执行，都是由操作系统的调度器决定的。也就是说，并行与否程序员无法控制，只能让操作系统决定。\n二、进程和线程1、进程\n进程是正在运行的程序\n是系统资源分配和调用的单位\n每一个进程都有他的内存空间和资源\n一个应用程序可以有多个进程\n\n2、线程\n线程就是独立的执行路径，一个进程至少有一个线程\n\n在程序运行时，即使没有自己创建线程，后台也会有多个线程（例如主线程，gc线程）\n\n在一个进程中如果开辟了多个线程，线程的运行由调度器安排调度，调度器与操作系统紧密联系，先后顺序不能人为是干预的\n\n对同一份资源操作，会存在资源抢夺的问题，需要加入并发控制\n\n线程会带来额外的开销，如cpu调度时间，并发控制开销\n\n每个线程都在自己工作内存中交互，内存控制不当会造成数据不一致\n\n\n注意：启动一个线程时，其实不止一个线程开启，因为main方法也开启了一个线程\n简而言之：一个程序运行后至少有一个进程，一个进程中也至少包含一个线程 。\n三、线程调度1、两种模型\n分时调度模型\n所有线程轮流使用cpu使用权，平均分配每个线程占用cpu的时间片\n\n抢占式调度模型\n优先让优先级高的使用cpu，如果线程优先级相同，那么随机选择一个，优先级高的线程获取cpu的时间片相对多一些\n\n\n2、 随机性若 计算机只有一个cpu，那么cpu在某一时刻只能执行一条指令，线程只有抢到cpu时间片，才能执行命令\n所以 多线程执行具有随机性（抢到使用权是随机的）\n3、有关线程优先级的方法方法在 Thread类中\n\npublic final int getPriority() 返回此线程的优先级\n\npublic final void setPriority() 更改线程优先级\n\n异常IllegalArgumentException - 如果优先级不在 MIN_PRIORITY到 MAX_PRIORITY范围内。SecurityException - 如果当前线程不能修改此线程。\n\n优先级的取值范围MIN_PRIORITY：最小值是1     MAX-PRIORITY：最大值是10        NORM_PRIORITY：默认线程是5\n\n线程的优先级高，只是获取cpu时间片的几率大，并不是每一次都一定会按照级别顺序获取\n\n\n四、部分问题\njvm的启动是多线程还是单线程\n\n多线程的，至少启动两个线程（主线程，垃圾回收线程）\n垃圾回收线程不可能在程序执行完才启动，否则我们的程序很容易 内存溢出\n\n\n调用 start方法后的线程状态\n\n调用 start方法，线程进入就绪状态，此时线程对象 仅有执行资格，没有执行权\n当就绪的线程抢到 执行权时（进入运行状态），方可调用 run方法，run方法执行完毕后，线程死亡，不能复生\n在没有执行完时，也可以调用stop方法来结束线程，强制死亡\n若在运行时 调用了 sleep / wait 方法，也会进入阻塞状态，此时释放执行资格和执行权。\n等 sleep / wait状态结束时，或者嗲用notifyall方法，该线程被唤醒，又进入就绪状态\n\n\n线程的随机性的原因\n\n实际上的多线程，是由多核（多个cpu）决定的\n而我们的电脑只有一个cpu（一个时间只能干一件事），同一时刻，cpu只能执行一个程序，多线程的程序其实是由cpu高速切换造成的\n\n\n什么时候使用多线程\n\n多个对象对同一有限资源进行操作时\n\n使用多线程是为了 提高解决问题的效率\n\n\n\n\n五、线程的使用概述：在Java中我们可以使用，Thread类和Runnable接口来创建一个线程\n1、Thread类概述：Java使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。\n– 通过继承Thread类，开启线程的流程：\n\n定义Thread类的子类，并重写 run() 方法，该 run() 方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。\n创建Thread子类的实例，即创建了线程对象。\n调用线程对象的start()方法来启动该线程。\n\n– Thread类中的构造方法：\n\npublic Thread() :分配一个新的线程对象。\npublic Thread(String name) :分配一个指定名字的新的线程对象。\npublic Thread(Runnable target) :分配一个带有指定目标新的线程对象。\npublic Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。\n\n– 例子，继承Thread类\npublic class MyThread  extends Thread&#123;\n\n    public MyThread() &#123;\n    &#125;\n\n    &#x2F;&#x2F;定义指定线程名称的构造方法\n    public MyThread(String name) &#123;\n        super(name);&#x2F;&#x2F;引用父类的构造方法\n    &#125;\n\n    @Override\n    public void run() &#123;\n        for (int i &#x3D; 1; i &lt; 21; i++) &#123;\n            System.out.println(getName()+&quot;:&quot;+i);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;创建自定义线程对象\n        MyThread myThread1 &#x3D; new MyThread(&quot;hh&quot;);\n        MyThread myThread2 &#x3D; new MyThread(&quot;gg&quot;);\n        myThread1.start();\n        myThread2.start();\n        &#x2F;&#x2F;结果：交替执行（start方法启动了线程）\n    &#125;\n&#125;\n\n– 常见方法:\n\npublic String getName() :获取当前线程名称。\npublic void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。\npublic void run() :此线程要执行的任务在此处定义代码。\npublic static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。\npublic static Thread currentThread() :返回对当前正在执行的线程对象的引用。\n\n2、Runnable接口– 使用步骤:\n\n定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。\n创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正 的线程对象。\n调用线程对象的start()方法来启动线程。\n\npublic class MyRunnable implements Runnable&#123;\n    @Override  \n    public void run() &#123;\n        for (int i &#x3D; 0; i &lt; 20; i++) &#123;\n            System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);         \n        &#125;       \n    &#125;    \n&#125;\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;创建自定义类对象  线程任务对象\n        MyRunnable mr &#x3D; new MyRunnable();\n        &#x2F;&#x2F;创建线程对象\n        Thread t &#x3D; new Thread(mr, &quot;小强&quot;);\n        t.start();\n        for (int i &#x3D; 0; i &lt; 20; i++) &#123;\n            System.out.println(&quot;旺财 &quot; + i);\n        &#125;\n    &#125;\n&#125;\n\n通过实现Runnable接口，使得该类有了多线程类的特征，run()方法是多线程程序的一个执行目标。所有的多线程代码都在run方法里面，Thread类实际上也是实现了Runnable接口的类。\n在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。\n实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。\n3、Thread和Runnable的区别如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。 实现Runnable接口比继承Thread类所具有的优势：\n\n适合多个相同的程序代码的线程去共享同一个资源，把线程和程序代码，数据有限分离，较好地体现了面向对象的思想。\n可以避免java中的单继承的局限性，实现接口，可以允许有其他父类。\n增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。\n线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。\n在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。\n实现Runnable，不能用 getName直接获取线程名，需要用Thread类中的currentThread获取当前线程，在使用 getName获取线程名\n\n4、start()和run()的区别\n调用start方法开启了线程，而run方法只是普通方法的调用，还是在一条线程中顺序执行\n\nstart()方法释义：     * 用start方法来启动线程，真正实现了多线程运行，这时无需等待 run()方法体代码执行完毕而直接继续执行下面的代码。\n\n\n * 通过调用 Thread类的 start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法 run()称为 线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。\n\n * start() 方法执行，将自动调用 run()方法，这是由 jvm内存机制规定的\n\n\nrun() 方法释义：\n\n * run() 方法只是 Thread类 的一个普通方法，程序中只有主线程这一个线程，其程序路径还是一条，还是要顺序执行，还是要等待\n    run() 方法执行完毕后才能执行其他代码\n\n * 把需要并行的代码放到 run() 方法里，调用 start方法即可启动线程，抢到cpu时间片，就会运行run方法，以及run方法内部的代码\n\n * 为什么 重写 run() 方法？\n    因为 run()方法是用来封装线程执行代码的\n\n六、线程控制1、线程休眠\nstatic void sleep(long millis)  是当前正在执行的线程停留(暂停执行) 指定的毫秒数\n\nsleep时间到达后，线程再次进入就绪状态\n\n每一个对象都有一个锁，sleep不会释放锁\n\nsleep可以模拟网络延迟，计时器等\n\nInterruptedException：如果任何线程中断了当前线程，当抛出此异常，抛出后，中断异常的状态被清除\n\n\n2、线程礼让\nstatic void yield()：使当前正在执行的线程向另外一个线程交出运行权，静态方法。\n\n礼让线程，使当前正在执行的线程暂停，但不阻塞，从运行状态变为就绪状态，使cpu重新调度\n\n但是 调度不一定成功，要看 cpu心情。\n\n\n3、线程强制执行\nvoid join()：等待线程死亡（待此线程执行完成，在执行其他线程，其他线程阻塞）\n\njoin 合并线程，可以想象成 插队\n\n\n4、守护线程\nvoid setDaemon(Boolean isDaemon)：标识该线程为守护线程或用户线程，这一方法在线程启动前调用\ntrue为Daemon模式，false为User模式。\n注意：守护线程必须在start之前设置，否则会报错。\n\n线程分为 用户线程和守护线程，守护线程也被称为 — “服务线程”\n\n用户线程：Java虚拟机在它所有非守护线程已经离开后自动离开。\n\n守护线程：守护线程用来服务用户线程，如果没有用户线程在运行，那就没有可服务对象，也就没有理由继续执行下去。\n\n当只剩下守护线程时，虚拟机就会退出（没有可服务对象，没必要继续执行）\n\n如果在守护线程中产生了新的线程，那么将不用设置Daemon属性，他们都是守护线程，用户线程同样\n\n\n5、停止线程\n不推荐使用，JDK 中的stop()、destroy()方法【已经废弃】\n推荐线程自己停下来\n建议使用一个标志位进行终止变量当flag=false，则终止线程运行\n\npublic class stopThread implements Runnable &#123;\n\n    private boolean flag &#x3D; true;\n\n    @Override\n    public void run() &#123;\n        while (flag)&#123;\n            System.out.println(Thread.currentThread().getName());\n        &#125;\n    &#125;\n\n\tpublic void stop()&#123;\n   \t\t this.flag&#x3D;false;\n\t&#125;\n&#125;\n\n七、线程生命周期\n八、线程安全1、卖票案例代码public class sellTickets implements Runnable &#123;\n\n    private int tickets &#x3D; 100;\n    \n    @Override\n    public void run() &#123;\n\n        while (true) &#123;\n            if (tickets &gt; 0) &#123;\n                try &#123;\n                    Thread.sleep(100);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                System.out.println(Thread.currentThread().getName() + &quot;:&quot; + tickets + &quot;张票&quot;);\n                tickets --;\n            &#125;\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n\n        sellTickets st &#x3D; new sellTickets();\n\n        Thread t1&#x3D;new Thread(st,&quot;窗口1&quot;);\n        Thread t2&#x3D;new Thread(st,&quot;窗口2&quot;);\n        Thread t3&#x3D;new Thread(st,&quot;窗口3&quot;);\n\n        t1.start();\n        t2.start();\n        t3.start();\n\n    &#125;\n&#125;\n\n2、出现问题\n出售一张票时，虽然出票时间短暂，但是存在问题\n\n相同的票出现了多次（结果中，一号窗口买了第100号票，二号窗口也卖出了第100号）\n\n会出现 负数的票（加上 票号判断，tickets &gt; 0后，问题解决）\n\n\n3、问题原因\n线程的随机性\n线程访问的延迟\n\n4、线程安全问题的表现\n当一个线程对象在执行run()方法的某一操作时，其他线程也进来了，并发访问了临界资源，破坏了原子操作，造成数据不一致\n这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。\n线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步， 否则的话就可能影响线程安全。\n\n5、数据安全问题\n判断多线程程序是否有 数据安全问题的标准1、是否为多线程环境2、是否有共享数据3、是否有多条语句操作共享数据\n如何解决多线程安全问题把多条语句曹作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可（同步代码块/同步方法）具体就是给哪个原子操作加锁，使整个操作同步，不让其他线程对象破坏，保证数据的一致性\n\n九、线程同步–  概述：为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。 那么怎么去使用呢？有三种方式完成同步操作：\n\n同步代码块。\n同步方法。\n锁机制\n\n– 同步的前提\n\n至少要有两个线程\n\n同一个锁\n\n\n– 同步的好处\n\n提高了安全性，解决了多线程数据安全问题\n\n– 同步的弊端\n\n效率较低，当线程很多时，每个线程都会去判断同步上的锁，十分耗费资源，无形中降低运行效率\n\n1、同步代码块– 概述：同步代码块： synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。 格式:\nsynchronized(同步锁)&#123;\n     需要同步操作的代码\n&#125;\n\n\n任意对象称之为同步监视器，推荐使用共享资源作为同步监视器\n非静态方法内的同步代码块，使用this对象锁\n静态方法内的同步底阿妈快，锁用 类名.class\n\n同步监视器执行过程：\n\n第一个线程访问，锁定同步监视器，自行其中代码\n\n第二个线程访问，发现同步监视器被锁定，无法访问\n\n第一个线程访问完毕，解锁同步监视器\n\n第二个线程访问，发现同步监视器没有锁，然后锁定并访问\n\n\n– 同步锁:\n\n对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁。\n锁对象可以是任意类型，多个线程对象要使用同一把锁。 \n注意：在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。 使用同步代码块解决代码：\n\npublic class Ticket implements Runnable &#123;\n    private int ticket &#x3D; 100;\n\n    @Override\n    public void run() &#123;\n        while (ticket &gt; 0) &#123;\n            System.out.println(Thread.currentThread().getName() + &quot;开始售票&quot;);\n            try &#123;\n                Thread.sleep(100);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n            synchronized (this) &#123;\n                if (ticket &gt; 0) ticket--;\n                System.out.println(Thread.currentThread().getName() + &quot;售票完成,还剩&quot; + ticket + &quot;张票&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n2、同步方法– 概述：同步方法就是使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。\n– 格式：\npublic synchronized void method()&#123;\n    可能会产生线程安全问题的代码\n&#125;\n\n– 同步方法使用的锁\n\n同步方法使用的是 this对象锁，静态同步方法的锁是(类名.class)\n同步方法使用 双重判断完成，效率低，多宜采用同步代码块完成单例的延迟加载\n\npublic class Ticket implements Runnable&#123;\n    private int ticket &#x3D; 100;   \n    &#x2F;*\n     * 执行卖票操作   \n     *&#x2F;  \n    @Override \n    public void run() &#123;        \n    &#x2F;&#x2F;每个窗口卖票的操作             \n    &#x2F;&#x2F;窗口 永远开启             \n        while(ticket &gt; 0)&#123;        \n            sellTicket();            \n        &#125;        \n    &#125;\n\n        &#x2F;*   \n         * 锁对象 是 谁调用这个方法 就是谁     \n         *   隐含 锁对象 就是  this    \n         *            \n         *&#x2F;\n\n    public synchronized void sellTicket()&#123;\n        if(ticket&gt;0)&#123;&#x2F;&#x2F;有票 可以卖   \n          &#x2F;&#x2F;出票操作\n          &#x2F;&#x2F;使用sleep模拟一下出票时间 \n            try &#123;              \n                Thread.sleep(100);\n            &#125; catch (InterruptedException e) &#123;\n                  e.printStackTrace();\n            &#125;\n        &#125;\n            &#x2F;&#x2F;获取当前线程对象的名字 \n        String name &#x3D; Thread.currentThread().getName();\n        System.out.println(name+&quot;正在卖:&quot;+ticket‐‐);\n   &#125;\n&#125;\n\n3、代码块与方法的比较synchronized代码块 要比 synchronized方法灵活，因为一个方法中可能只有一部分代码需要同步，如果同步整个方法会影响执行效率，而是用代码块就避免了这个问题\n4、Lock锁– 概述：java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作。同步代码块/同步方法具有的功能Lock都有，除此之外更强大，更体现面向对象。《Lock锁目前只做了解，详细使用在后续的JUC课程里会介绍》\n– Lock锁也称同步锁，加锁与释放锁方法，如下：\n\npublic void lock() :加同步锁。\npublic void unlock() :释放同步锁。\n\npublic class Ticket implements Runnable&#123;\n    private int ticket &#x3D; 100;    \n    Lock lock &#x3D; new ReentrantLock();   \n    @Override        \n    public void run() &#123;        \n        &#x2F;&#x2F;每个窗口卖票的操作             \n        &#x2F;&#x2F;窗口 永远开启             \n        while(ticket &gt; 0)&#123;        \n            lock.lock();                \n            if(ticket&gt;0)&#123;&#x2F;&#x2F;有票 可以卖            \n                &#x2F;&#x2F;出票操作                 \n                &#x2F;&#x2F;使用sleep模拟一下出票时间                 \n                try &#123;                \n                    Thread.sleep(50);                    \n                &#125; catch (InterruptedException e) &#123;                \n                &#x2F;&#x2F; TODO Auto‐generated catch block                    \n                    e.printStackTrace();                    \n                &#125;                \n                &#x2F;&#x2F;获取当前线程对象的名字                 \n                String name &#x3D; Thread.currentThread().getName();               \n                System.out.println(name+&quot;正在卖:&quot;+ticket‐‐);                    \n            &#125;            \n            lock.unlock();            \n        &#125;        \n    &#125;    \n&#125;\n\n十、死锁1、概念\n每个线程都不会释放自己拥有的锁的标记，却阻塞在另外的线程所拥有的的锁标记的对象锁池中，就造成了死锁现象\n\n2、产生原因\n一个进程因请求资源而阻塞时，对已获得的资源保持不放\n\n例如：a锁中要使用b锁，在b锁中要使用a锁，而他们都不想让，最终导致了死锁\n\n系统资源不足，进程的运行顺序不合适，资源分配不当\n\n\n3、产生死锁的四个必要条件\n互斥条件: 一个资源每次只能被一个线程使用\n请求保持条件: 一个进程因请求资源而阻塞时.对以获得的资源保持不放\n不剥夺条件: 线程已获得的资源,在未使用完之前,不能强行剥夺\n循环等待条件: 若干线程之间形成一种头尾相接的循环等待资源关系（1等2的资源，2等1的资源）\n\n注意：如果所有线程以固定顺序来获得锁，那么在程序中就不会出现 锁顺序 死锁问题。\n4、破坏死锁发生的条件\n一次性申请所有资源\n申请资源而得不到时，主动释放占有的资源\n靠按申请顺序预防，先申请资源序号小的，在申请大的，线性申请\n\n十一、线程状态\nTimed Waiting（计时等待）\nBLOCKED(阻塞)\nWaiting（无限等待）\n其他状态\n\n十二、等待唤醒机制1、概念这是多个线程间的一种协作机制。谈到线程我们经常想到的是线程间的竞争（race），比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。\n就是在一个线程进行了规定操作后，就进入等待状态（**wait()）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（notify()**）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。\nwait/notify 就是线程间的一种协作机制。\n2、等待唤醒中的方法\nwait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个特别的动作，也即是“通知（notify）”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中\nnotify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。\nnotifyAll：则释放所通知对象的 wait set 上的全部线程。\n\n总结如下：\n\n如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；\n否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态\n\n3、wait和notify方法要注意的\nwait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。\nwait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。\nwait方法与notify方法必须要在同步代码块或者是同步方法中使用。因为：必须要通过锁对象调用这2个方法。\n\n4、其它问题\n为什么wait()，notify()，notifyAll()都定义在Object 类中？A：这些方法存在于同步中。B：使用这些方法时必须要标识所属的同步的锁。C：锁可以是任意对象，所以任意对象调用的方法一定定义 Object 类中。D：wait() 让线程等待 notify() 唤醒线程 notifyAll() 唤醒线程池中的所有线程 。 这些方法需要在同步方法内（锁内，需要锁对象）使用。\nwait() 和 sleep()的区别A：对时间指定而言   wait()：可以不指定时间。   sleep()：必须指定时间。B：对执行权和锁而言   wait()：释放 cpu 执行权(资格也没了)，释放锁。存储于线程池   sleep()：释放 cpu 执行权，不释放锁(会自动醒)。\n\n十三、Lock&amp;Condition接口（了解）1. 概念\n   * JDK1.5 以后将同步和锁封装成了对象。并将操作锁的隐式方式定义到了对象中，将隐式动作编程了显示动作。对多线程中的内部细节进行了升级改良。\n   * 它的出现替代了同步代码块或者同步函数。将同步的隐式锁操作编程了显示锁操作。同时更为灵活。可以一个锁上加上多组监视器。\n\n2. Lock接口\n\n   * 提供了获得锁 释放锁的方法\n     1 void lock()：获得锁\n     2 void unlock()：释放锁【注意：通常需要定义在finally代码块中】\n     \n   * lock锁不能直接实例化，这里采用他的实现类 ReentrantLock来实现\n     构造方法 ReentrantLock()。\n     \n   * java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。\n     锁提供了对共享资源的独占访问,每次只能有一个线程对Lock对象加锁,线程开始访问共享资源之前应先获得Lock对象\n\n3. Lock与synchronized对比\n\n   * Lock是显示锁(手动开启和关闭,别忘记关闭锁)\n     synchronized是隐式锁,出了作用域自动释放\n     \n   * Lock只有代码块锁,synchronized有代码块锁和方法锁\n   \n   * 使用lock锁,JVM将花费较少的时间来调度线程,性能更好,并且具有更好的扩展性(提供更多的子类)\n   \n   * 优先使用顺序：Lock &gt; 同步代码块 &gt; 同步方法\n\n4. Condition \n\n   * Lock 接口替代了 synchronized \n   \n     Condition 替代了 Object 类中监视器方法 wait，notify，notifyAll。\n     \n   * JDK1.5后 将监视器方法单独封装成了 Condition 对象。而且一个锁上可以组合多组监视器对象\n   \n     实现了多生产者多消费者时，本方只唤醒对方中一个的操作，提高效率。\n     \n   * await()睡眠; signal(), signalAll()唤醒;将这些监视器方法单独进行封装，变成了Condition 监视器对象。\n     可以任意锁进行组合。使用为一般是生产者是被消费者唤醒，消费者是被生产者唤醒。\n\n\n\n十四、生产者消费者问题假设仓库中只能存放一件产品,生产者将生产出来的产品放入仓库,消费者将仓库产品取走消费\n如果仓库中没有产品,则生产者将产品放入仓库,否则停止生产并等待,直到仓库中的产品被消费者取走为止\n如果仓库中放有产品,则消费者可以将产品取走消费,否则停止消费并等待,直到仓库中再次放入产品为止\n这是一个线程同步问题,生产者和消费者共享一个资源,并且生产者和消费者之间相互依赖,互为条件\n\n对于生产者,没有生产产品之前,要通知消费者等待,而生产了产品之后,又要马上通知消费者消费\n对于消费者,在消费之后,要通知生产者已经结束消费,需要生产新的产品以供消费\n在生产者消费者问题上,仅有synchronized是不够的\nsynchronized可阻止并发更新同一个共享资源,实现了同步\nsynchronized不能用来实现不同线程之间消息传递(通信)\n\n\n\n十五、常用方法总结1. 停止线程 \n    A：通过控制循环 \n    B：interrupt()方法 stop 已过时，被 interrupt 取代\n\n2. 守护线程 后台线程 \n   你只要把一个线程设置为守护线程，那么主方法线程结束，不管什么情况，守护线程就结束.\n   举例：坦克大战 A：setDaemon(boolean flag)\n   \n3. join：加入线程,把执行权抢夺,自己执行完毕,其他的线程才可能有机会执行.\n\n4. yield()：让本线程暂停执行,把执行权给其他线程. \n\n5. setPriority(int num)：设置线程优先级 \n   getPrinrity()：获取线程优先级 线程的级别:1 - 10  默认级别为 5.\n\n","slug":"15-多线程","date":"2021-09-13T14:50:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"76d4babd3007758066655a1fc80352b9","title":"IO流（下）","content":"一、字符流当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。\n字符流与字节流的区别：字符流虽然以字节流为基础创建的，但是字节流可以支持声音，视频，图片，文本等所有文件类型，而字符流只支持文本文件。\n二、编码与乱码\n编码: 字符 (能看懂的) –&gt; 字节 (看不懂的)\n\n解码: 字节 (看不懂的) –&gt; 字符 (能看懂的)\n\n字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。\n\n编码表:生活中文字和计算机中二进制的对应规则。\n\n字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。\n\n乱码：编码与解码不一致，导致的乱码问题，每一种编码格式都有自己独特的编码，如果编码与解码不一致，势必会导致乱码，例如用Unicode编码，用gbk解码，就会字符与码值不匹配，从而导致乱码。\n\nASCII字符集\n\nASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。\n基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。\n\n\nISO-8859-1字符集\n\n拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。\nISO-8859-1使用单字节编码，兼容ASCII编码。\n\n\nGBxxx字符集\n\nGB就是国标的意思，是为了显示中文而设计的一套字符集。\nGB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。\nGBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。\nGB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。\n\n\nUnicode字符集\n\nUnicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。\n它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。\nUTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：\n128个US-ASCII字符，只需一个字节编码。\n拉丁文等字符，需要二个字节编码。\n大部分常用字（含中文），使用三个字节编码。\n其他极少使用的Unicode辅助字符，使用四字节编码。\n\n\n\n\n\n三、字符输入流1、字符输入流，输出流\njava.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。\n\npublic void close() ：关闭此流并释放与此流相关联的任何系统资源。\npublic int read()： 从输入流读取一个字符。\npublic int read(char[] cbuf)： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。\n\n\njava.io.Writer抽象类是表示用于写入字符流的所有类的超类，将指定的字符信息写入到目的地。它定义了字节输出流的基本共性功能方法。\n\nvoid write(int c) 写入单个字符。\nvoid write(char[] cbuf)写入字符数组。\nabstract void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。\nvoid write(String str)写入字符串。\nvoid write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。\nvoid flush()刷新该流的缓冲。\nvoid close() 关闭此流，但要先刷新它。\n\n注意：close（）方法默认调用了flush（）方法，但是flush（）方法只刷新缓冲区，而close（）还会关闭IO流\n\n\n2、FileReader类java.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。\n\nFileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。\nFileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称。\n\n3、FileWriter类\nFileWriter(File file)： 创建一个新的 FileWriter，给定要读取的File对象。\nFileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。\n\n4、关闭和刷新因为内置缓冲区的原因，如果不关闭输出流，无法写入字符到文件中。但是关闭的流对象，是无法继续写入数据的。如果我们既想写入数据，又想继续使用流，就需要flush 方法了。\n\nflush ：刷新缓冲区，流对象可以继续使用。\nclose:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。\n\n四、缓冲流1、概述高效读写的缓冲流，转换编码的转换流，持久化存储对象的序列化流等等，这些流的功能更为强大\n缓冲流,也叫高效流，是对4个基本的FileXxx 流的增强，所以也是4个流，按照数据类型分类：\n\n字节缓冲流：BufferedInputStream，BufferedOutputStream\n字符缓冲流：BufferedReader，BufferedWriter\n\n缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。\n2、字节缓冲流\npublic BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。\npublic BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。\n\n&#x2F;&#x2F; 创建字节缓冲输入流\nBufferedInputStream bis &#x3D; new BufferedInputStream(new FileInputStream(&quot;bis.txt&quot;));\n&#x2F;&#x2F; 创建字节缓冲输出流\nBufferedOutputStream bos &#x3D; new BufferedOutputStream(new FileOutputStream(&quot;bos.txt&quot;));\n\n缓冲流读写方法与基本流是一致的，但是缓冲流的执行效率要比基本流高效。\n3、字符缓冲流字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。\n\nBufferedReader：public String readLine(): 读一行文字。\nBufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。\n\n五、转换流1、概述转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。\n2、InputStreamReader转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。\n\nInputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。\nInputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。\n\n3、OutputStreamWriter转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。\n\nOutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。\nOutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。\n\n4、解码需回到转换流\nFileReader和FileWriter是InputStreamReader和OutputStreamWriter的直接子类方便书写\n如果需要进行字符编码，解码问题，还需要回到InputStreamReader和OutputStreamWriter\n\n六、序列化和反序列化1、概述Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。\n反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。\n\ntransient     关键字：被修饰的成员，在 不会被序列化。所以当我们用序列化流去存储后，在读取时，所得到的结果 和 我们读取未赋值的成员的结果一样，不能修饰方法。\n2、ObjectOutputStreamjava.io.ObjectOutputStream 类，将Java对象的原始数据类型写入到文件,实现对象的持久存储。\npublic ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。\nFileOutputStream fileOut &#x3D; new FileOutputStream(&quot;employee.txt&quot;);\nObjectOutputStream out &#x3D; new ObjectOutputStream(fileOut);\n\n3、序列化实现一个对象要想序列化，必须满足两个条件:\n\n该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。\n该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。\n\n调用writeObject方法，序列化写入数据。\n4、ObjectInputStreamObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。\n\npublic ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。\npublic final Object readObject () : 读取一个对象。\n\n5、反序列化注意事项对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下：\n\n该类的序列版本号与从流中读取的类描述符的版本号不匹配\n该类包含未知数据类型\n该类没有可访问的无参数构造方法\n\nSerializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。\n七、打印流1、概述平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。\n打印流分为：字节流打印流 与 字符打印流\n通过这两个流，我们可以向所关联的文件 或 或控制台 打印数据\n打印流只有输出流，没有输入流\n2、PrintStream（字节打印流）\n概述：\n\nPrintStream 为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。\n异常情况仅设置可通过 checkError 方法测试的内部标志。\n另外，为了自动刷新，可以创建一个 PrintStream；\n\n这意味着可在写入 byte 数组之后自动调用 flush 方法，可调用其中一个 println 方法，或写入一个换行符或字节 (‘\\n’)。、\nPrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。\n\n在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。\n\n\n\n构造方法：\n\nPrintStream(String fileName)\n创建具有指定文件名称的新打印流\n\nPrintStream(String fileName, String csn)\n创建具有指定文件名称和字符集的新打印流\n\n\n\n\n3、标准输入输出流标准输入输出流：System类中的两个成员变量。\n标准输入流(public static final InputStream in)：通常，此流对应于键盘输入或者由主机环境或用户指定的另一个输入源。\n​          InputStream is = System.in;\n标准输出流(public static final PrintStream out)：通常，此流对应于显示器输出或者由主机环境或用户指定的另一个输出目标。\n​          PrintStream ps = System.out;\nSystem.out，本质是PrintStream类\n4、PrintWriter类（字符打印流）\n概述：\n\n向文本输出流打印对象的格式化表示形式。\n此类实现在 PrintStream 中的所有 print 方法。\n它不包含用于写入原始字节的方法，对于这些字节，程序应该使用未编码的字节流进行写入。\n与 PrintStream 类不同，如果启用了自动刷新，则只有在调用 println、printf 或 format 的其中一个方法时才可能完成此操作，而不是每当正好输出换行符时才完成。\n这些方法使用平台自有的行分隔符概念，而不是换行符。\n\n\n构造方法：\n\nPrintWriter(String fileName)\n创建具有指定文件名称且不带自动行刷新的新 PrintWriter\n\nPrintWriter(String fileName, String csn)\n创建具有指定文件名称和字符集且不带自动行刷新的新 PrintWriter\n\nPrintWriter(Writer out, boolean autoFlush)\n创建带自动行刷新的新 PrintWriter\n\n\n\n\n虽然打印流没有输入流，但不意味着不能复制文件（借用BufferedReader）\n八、属性集（Properties）1、概述java.util.Properties 继承于Hashtable ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，System.getProperties 方法就是返回一个Properties对象。\n2、Properties类\npublic Properties() :创建一个空的属性列表。\npublic void load(InputStream inStream)： 从字节输入流中读取键值对。\npublic Set&lt;String&gt; stringPropertyNames() ：所有键的名称的集合。\ngetProperty(String key)：用指定的键在此属性列表中搜索属性若搜索不到，则null\nvoid list(PrintStream out)：将属性列表输出到指定的输出流\nvoid list(PrintWriter out)：将属性列表输出到指定的输出流\n\n参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式:\nfilename&#x3D;a.txt\nlength&#x3D;209385038\nlocation&#x3D;D:\\a.txt\n\n加载代码演示：\npublic class ProDemo2 &#123;\n    public static void main(String[] args) throws FileNotFoundException &#123;\n        &#x2F;&#x2F; 创建属性集对象\n        Properties pro &#x3D; new Properties();\n        &#x2F;&#x2F; 加载文本中信息到属性集\n        pro.load(new FileInputStream(&quot;read.txt&quot;));\n        &#x2F;&#x2F; 遍历集合并打印\n        Set&lt;String&gt; strings &#x3D; pro.stringPropertyNames();\n        for (String key : strings ) &#123;\n              System.out.println(key+&quot; -- &quot;+pro.getProperty(key));\n        &#125;\n     &#125;\n&#125;\n输出结果：\nfilename -- a.txt\nlength -- 209385038\nlocation -- D:\\a.txt\n\n\n\n\n\n\n\n\n\n\n小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。\n","slug":"14-IO流（下）","date":"2021-09-13T14:49:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"4e865ee4768f3582deb20f72187b6c6b","title":"IO流（上）","content":"一、File类1、概述\nFile类的一个对象，代表一个文件或一个文件目录(俗称：文件夹)\n\nFile类声明在java.io包下\n\nFile类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，\n并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。\n\n后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的”终点”\n\n\n2、构造方法\npublic File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。\n\npublic File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的 File实例。\n\npublic File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File实例。\n\n一个File对象代表硬盘中实际存放的一个文件夹或者目录\n\n无论该路径下是否存在文件或者目录，都不影响File对象的创建\n\n\n3、路径的使用\n绝对路径：从盘符开始的路径，这是一个完整的路径\n相对路径：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用\n\npublic static void main(String[] args) &#123;\n        File file&#x3D;new File(&quot;D:\\\\Idea\\\\workspace\\\\Project\\\\src&quot;);\n        System.out.println(file.getAbsolutePath());\n        File file1&#x3D;new File(&quot;src&quot;);\n        System.out.println(file1.getAbsolutePath());\n    &#125;\n\n4、路径分隔符windows和DOS系统默认使用“\\”来表示\nUNIX和URL使用“/”来表示\n5、常用方法5.1 获取功能\npublic String getName() ：返回由此File表示的文件或目录的名称。\npublic String getPath() ：将此File转换为路径名字符串。\npublic String getAbsolutePath() ：返回此File的绝对路径名字符串。\npublic File getAbsoluteFile()：返回此File对应的绝对路径文件。\npublic String getParent()：返回此File对应的父文件夹路径。\npublic File getParentFile()：返回此File对应的父文件夹对象。\npublic long length() ：返回由此File表示的文件的大小，单位是字节。\n\n5.2 判断\npublic boolean exists() ：此File表示的文件或目录是否实际存在。\npublic boolean isDirectory() ：此File表示的是否为目录。\npublic boolean isFile() ：此File表示的是否为文件。\n\n5.3 操作文件（夹）\npublic boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。\npublic boolean delete() ：删除由此File表示的文件或目录。\npublic boolean mkdir() ：创建由此File表示的目录。\npublic boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。\n\n5.4 文件夹遍历\npublic String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。\npublic File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。\n\nFile file2&#x3D;new File(&quot;c:&#x2F;&quot;);\nFile[] files &#x3D; file2.listFiles();\nfor (File file3 : files) &#123;\n    System.out.println(file3.getName());\n&#125;\n\n结果：\nIntel\nProgram Files\nProgram Files (x86)\nProgramData\ntemp\nUsers\nWindows\n\n二、IO流1、概述数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为输入input 和输出output ，即流向内存是输入流，流出内存的输出流。\nJava中I/O操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输出也叫做作写入数据。\n\n2、IO分类根据数据的流向分为：输入流和输出流。\n\n输入流 ：把数据从其他设备上读取到内存中的流。\n输出流 ：把数据从内存 中写入到其他设备上的流。\n\n根据数据的类型分为：字节流和字符流。\n\n字节流 ：以字节为单位，读写数据的流。\n字符流 ：以字符为单位，读写数据的流。\n\n\n\n蓝色框框的格外需要注意\n三、字节流1、概述一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。\n2、字节输出流java.io.OutputStream抽象类是表示字节输出流的所有类的超类，将指定的字节信息写入到目的地。它定义了字节输出流的基本共性功能方法。\n\npublic void close() ：关闭此输出流并释放与此流相关联的任何系统资源。\npublic void flush() ：刷新此输出流并强制任何缓冲的输出字节被写入。\npublic void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。\npublic void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。\npublic abstract void write(int b) ：将指定的字节输出流。\n\n注意：当完成流的操作时，必须调用 close() 方法，释放系统资源。\n3、FileOutputStreamOutputStream有很多子类，其中java.io.FileOutputStream类是最常见的文件输出流，用于将数据写入到文件。\n\npublic FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。\npublic FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。\npublic FileOutputStream(File file, boolean append)： 创建文件输出流以写入由指定的 File对象表示的文件。\npublic FileOutputStream(String name, boolean append)： 创建文件输出流以指定的名称写入文件。\n\nappend参数是一个boolean类型：\n\nfalse:如果文件不存在，会创建这个文件；如果文件存在，写入数据时会清除之前的数据。\ntrue:如果文件不存在，会创建这个文件；如果文件存在，写入数据时会追加。\n\n数据追加操作\n\n4、换行\n回车符：\\r    和    换行符：\\n\n回车符：回到一行的开头（return）。\n换行符：下一行（newline）。\n\n\n系统中的换行：\nWindows系统里，每行结尾是 回车+换行 ，即\\r\\n；\nUnix系统里，每行结尾只有 换行 ，即\\n；\nMac系统里，每行结尾是 回车 ，即\\r。从 Mac OS X开始与Linux统一。\n\n\n\n5、字节输入流java.io.InputStream抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。\n\npublic void close() ：关闭此输入流并释放与此流相关联的任何系统资源。\npublic abstract int read()： 从输入流读取数据的下一个字节。\npublic int read(byte[] b)： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。\n\n注意：当完成流的操作时，必须调用 close() 方法，释放系统资源。\n6、FileInputStreamInputStream有很多子类，其中java.io.FileInputStream类是最常见的文件输入流，用于从文件里读取数据。\n\nFileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。\nFileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。\npublic int read(int r)： 这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。      \npublic int  read(byte[] r) ：  这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。      \npublic int  available()：  返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值  \n\n当创建一个输入流对象时，必须传入一个文件路径。如果路径对应的文件不存在，则会抛出FileNotFoundException 。\npublic class FileInputStreamConstructor throws IOException&#123;\n    public static void main(String[] args) &#123;\n            &#x2F;&#x2F; 使用File对象创建流对象\n        File file &#x3D; new File(&quot;a.txt&quot;);\n        FileInputStream fis1 &#x3D; new FileInputStream(file);\n\n        &#x2F;&#x2F; 使用文件名称创建流对象\n        FileInputStream fis2 &#x3D; new FileInputStream(&quot;b.txt&quot;);\n    &#125;\n&#125;\n\nread方法每次只读取一个字节的数据，并将返回值提升为int类型。读取到文件末尾时，返回-1,表示文件读取结束。\nFile file &#x3D; new File(&quot;a.txt&quot;);\nFileInputStream fis &#x3D; new FileInputStream(file);\n&#x2F;*\n调用 read 方法一个字节一个字节的读取数据\nSystem.out.println(fis.read());\nSystem.out.println(fis.read());\n*&#x2F;\n\n&#x2F;*\n使用while循环，不断读取数据\nint data &#x3D; fis.read();\nwhile (data !&#x3D; -1) &#123;\n     System.out.println(data);\n     data &#x3D; fis.read();\n&#125;\n*&#x2F;\n\n&#x2F;*\n使用do...while循环，不断读取数据\nint data;\ndo &#123;\n    data &#x3D; fis.read();\n    System.out.println(data);\n&#125; while (data !&#x3D; -1);\n*&#x2F;\n\n&#x2F;*\n使用死循环，不断读取数据\nwhile (true) &#123;\n    int data &#x3D; fis.read();\n    if (data &#x3D;&#x3D; -1) &#123;\n        break;\n    &#125;\n    System.out.println(data);\n&#125;\n*&#x2F;\n\nread方法还可以传入byte类型的数组参数，用来规定读取的字节长度。\nFile file &#x3D; new File(&quot;a.txt&quot;);\nFileInputStream fis &#x3D; new FileInputStream(file);\n\n&#x2F;&#x2F; 创建一个指定长度的字节数组，用来存储数据\nbyte[] bs &#x3D; new byte[2];\n\nwhile (true) &#123;\n    &#x2F;&#x2F; 读取到的数据会被写入到 byte 数组里\n    &#x2F;&#x2F; read方法的返回值表示读取的字节长度\n    int len &#x3D; fis.read(bs);\n    if (len &#x3D;&#x3D; -1) &#123;\n        break;\n    &#125;\n    &#x2F;&#x2F; 这种写法有问题，有可能出现数据重复的情况\n    &#x2F;&#x2F; System.out.println(new String(bs));\n    System.out.println(new String(bs, 0, len));\n&#125;\nfis.close();\n\n注意：使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。\n7、字节流正规写法public class ReadAndWrite &#123;\n\n    public static void main(String[] args) &#123;\n\n        FileInputStream fis &#x3D; null;\n        FileOutputStream fos &#x3D; null;\n        try &#123;\n            fis &#x3D; new FileInputStream(&quot;Study_test\\\\src\\\\hh.txt&quot;);\n            fos &#x3D; new FileOutputStream(&quot;Study_test\\\\src\\\\文本.txt&quot;);\n\n            int f;\n            while ((f &#x3D; fis.read()) !&#x3D; -1) &#123;\n                fos.write(f);\n            &#125;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            if (fos !&#x3D; null &amp;&amp; fis !&#x3D; null) &#123;\n                try &#123;\n                    fos.close();\n                    fis.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n","slug":"13-IO流（上）","date":"2021-09-13T14:48:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"88ccd4775101a2a1232ec4d83ea6f5c4","title":"集合（下）","content":"一、Collections\n\n\n要点\n\n\n\n工具类，随机排序方法shuffle，，反转元素方法reverse以及升序排序方法sort\n\n\ncollection：单列集合的父接口\n\ncollections：他是集合操作的一种 工具类，类中的方法全部是静态的，可以进行查找，排序等操作\n\nCollections类的常用方法\n    * public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)：将指定的列表按升序排序\n    * public static void reverse(List&lt;?&gt; list)：反转指定列表中元素的顺序\n    * public static void shuffle(List&lt;?&gt; list)：使用默认的随机源随机排列指定的列表（随机排列，洗牌）\n\n二、Map1、map简介\n一次添加一对元素，是双列集合\n其实map中存储的就是键值对\nmap集合必须保证键的唯一性\n\n2、map常用方法\nV put(K key,V value)：添加元素put方法中，若键第一次添加，则进行添加，若不是第一次添加，则对原有元素进行修改\nV remove(Object key)：根据键删除键值对元素\nvoid clear()：清空map集合内所有键值对\nboolean containsKey(Object key)：判断集合是否包含指定的键\nboolean containsValue(Object value)：判断集合是否包含指定的值\nboolean isEmpty()：判断集合是否为空\nint size()：集合的长度，也就是集合中键值对的个数\n\n3、map获取功能\nV get(Objectkey)：根据键获取值\nSet keySet()：获取所有键的集合\nCollection values()：获取所有值的集合\nSet&lt;Map.Entry&lt;K,V&gt; &gt; entrySet()：获取所有键值对对象的集合\n\n4、map两种遍历操作常用第二种，还有只获取值的方法，不过只获取值没意义\n\n获取所有 键的集合 使用 KeySet方法增强for遍历键的集合，得到每一个键随后使用map的 get方法，以键找值\n获取所有 键值对对象集合 使用entrySet方法遍历键值对对象集合，得到每一个对象使用 getKey和getValue 得到每个对象的键和值\n\n5、map的常用子类子类中的方法和map中的差不多\n\nHashTable: 内部结构是哈希表，是同步的，不允许 Null 作为建，null 作为值， \nProperties：用来存储键值对型配置文件的信息，可以和 IO 技术相结合。 \nHashMap：内部构造是哈希表，不是同步的。允许 null 键，null 为 null \nTreeMap：内部构造是二叉树，不是同步的，可以对 map 集合进行排序\n\n三、HashMap源码分析\n\n\n\n\n\n\n\n\n引用：https://blog.csdn.net/qq_31903733/article/details/95075601\n1、整体介绍HashMap实现Map接口，用于存储key-value结构，能够根据其key快速查找其value。底层实现为采用一个table数组的hash表，数组中的每一项为一个链表结构。对于每个key，先计算其hash值，然后根据hash值计算其在table数组中的位置，若该位置没有元素，则直接将其放置在该位置，否则，则出现hash冲突，需要遍历查看其所在bucket是否已经有该key了（通过hash和key进行比较），若有了直接替换该key对应的value，否则在链表头部插入。\n需要注意的是如果一个桶中元素大于某个阈值，在JDK8中会将其右链表转换为红黑树。而且对于哈希表（table数组）太满时（大于负载因子），需要对其进行再散列，负载因子默认为0.75，如果表中超过了75%的位置已经填入了元素，那么这个表就会用双倍的桶数自动进行再散列。\n2、源码解析1. 成员变量主要有以下几个成员变量\n&#x2F;*静态常量*&#x2F;\n&#x2F;&#x2F;初始容量：16\nstatic final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16\n&#x2F;&#x2F;负载因子：0.75\nstatic final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;\n&#x2F;&#x2F;链表转换为红黑树的阈值：大于8\nstatic final int TREEIFY_THRESHOLD &#x3D; 8;\n&#x2F;&#x2F;红黑数转换为链表的阈值：小于6\nstatic final int UNTREEIFY_THRESHOLD &#x3D; 6;\n\n&#x2F;*成员变量*&#x2F;\n&#x2F;&#x2F;哈希表数组\ntransient Node&lt;K,V&gt;[] table;\n&#x2F;&#x2F;存储HashMap中的key-value对\ntransient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;\n&#x2F;&#x2F;元素实际个数\ntransient int size;\n&#x2F;&#x2F;是否重新散列的阈值\nint threshold;\n&#x2F;&#x2F;负载因子\nfinal float loadFactor;\n123456789101112131415161718192021\n\n2. 存储结构主要存储结构为Node&lt;K,V&gt;\n的结点，用于表示链表结构。\n\n还有用于表示红黑树结构的\nTreeNode&lt;K,V&gt;\n\n\n3. 构造函数\n\n可以看到，构造函数里并没有对table数组初始化，JDK8的初始化是放在第一次添加的时候进行的。\n4. put方法这是HashMap里的最核心的方法了。\npublic V put(K key, V value) &#123;\n    return putVal(hash(key), key, value, false, true);\n&#125;\n123\n\n首先计算key的hash值，然后调用putValue方法。计算hash值的代码如下\nstatic final int hash(Object key) &#123;\n    int h;\n    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n&#125;\n1234\n\n5、hash函数这里有个问题：为什么这样不是直接计算hashCode呢，还要与高16位做异或运算？\n这里的hash函数相当于是一个打扰函数，最终是减少碰撞。因为我们是要根据hash值来计算其在table数组中的位置，也就是后面的tab[i = (n - 1) &amp; hash]，这里(n-1) &amp; hash\n相当于取模运算，但比取模更高效，因为table的长度始终是2的n次方(初始容量16，后面扩容时也始终&lt;&lt;1)，所以其低位相当于全是1，高位全是0，最终&amp;运算只保留hash的低位。所以在table容量较小时，如n-1为15(1111)，hash和其相与后真正参与运算的也就是低4位，高位都为0了，这样可能会增加碰撞。所以在计算hash函数中将其和右移16位的值（高位16位变成0，低16位为之前的高16位）进行异或，由于右移始终为0，所以异或后原来的高位保持不变（原来是1的还是1，0的为0），低位变成低位与高位的异或，这样增加了低位的随机性，混合了高位和低位，高位的信息也被保留在低位中了。\n\n6、putVal方法\n上述有几处需要注意的地方：\n\n1 首先是判断table是否为空，即初次添加，是则调用resize()函数进行初始化\n2 当没有发生碰撞时，即tab[(n-1) &amp; hash]位置为null，直接添加元素\n3 如果发生碰撞，则首先判断该位置的hash以及key是否相等，如相等则记录下来（后续直接替换）\n4 判断该位置结点是否是红黑树结构，是的话就执行红黑树的插入方法\n5 遍历找是否有和待插入元素相等的key，找到则替换，没有的话则直接在尾部插入（JDK8以前是在头部插入），插入后如果发现其大于转换为红黑树的阈值，则将其转换为红黑树结构\n\n7、resize方法\n\n8. get方法public V get(Object key) &#123;\n    Node&lt;K,V&gt; e;\n    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;\n&#125;\n1234\n\n其调用的是getNode方法，根据key的hash和key找到该值。\n\n9. remove方法也是和get方法相似，根据key的hash值找到对应位置，然后分情况删除。\n3、HashMap总结\n底层实现：数组+链表+红黑树，允许key为null\n负载因子的默认值是0.75：初始值大了，可减少哈希表的再散列(扩容的次数)，但同时会导致散列冲突的可能性变大。初始值小了，可以减小散列冲突的可能性，但同时扩容的次数可能就会变多。\n初始容量的默认值是16：初始容量过大，遍历时速度就会受影响，初始容量过小，散列表再散列(扩容的次数)可能就变得多\nHashMap在计算hash值并不是直接根据key的hashCode，而是将其和高16位进行异或，增加其随机性。\n并不是桶子上有8位元素的时候它就能变成红黑树，它得同时满足我们的散列表容量大于64才行.\n\n4、线程安全的HashMap由于HashMap是线程不安全的,即多个线程可以同时put、get等，这在多线程环境下会出现问题，所以java又提供了线程安全的HashMap。\n1. Hashtable与HashMap存储结构基本相同，底层实现是数组+链表，其是线程安全的，实现方式是对整个Hashtable加锁（基本在所有操纵Hashtable的方法上都加了sysynchronized进行同步，所以同一时间只允许一个线程操作），且不允许key和value为null，但是其实现效率较低，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。Hashtable默认初始容量为11，扩容方式为原始容量x2 + 1.\n2. ConcurrentHashMap与Hashtable一样都是用来实现线程安全的HashMap，但是却比Hashtable效率高很多。主要是因为其采用了锁分段的机制，将数据分段存储，每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，所以可以供多个线程同时访问，而不是像Hashtable那样锁住整个表，同一时刻只能有一个线程访问。\nConcurrentHashMap从JDK1.5开始随java.util.concurrent包一起引入JDK中，主要为了解决HashMap线程不安全和Hashtable效率不高的问题。\n3、补充：JDK8和7实现差异\nJDK7中使用的是分段锁机制，即将整个table分成多个Segment，对每个Segment加锁，即有一个Segment数组，每一个Segment都是一个单独的哈希表。在执行put操作时首先根据hash算法定位到元素属于哪个Segment，然后对该Segment加锁即可\nJDK8对其进行了优化，底层采用和Node数组+链表+红黑树（和HashMap类似），并发控制使用Synchronized和CAS来操作，其与HashMap更接近。\n\n","slug":"12-集合（下）","date":"2021-09-13T14:47:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"42c17c71eb42c16b2fd355c959a76eb9","title":"集合（上）","content":"一、为什么使用集合为什么我们不采用数组存对象呢？\n\n因为数组长度是固定，而我们很多时候对对象的个数是 不确定的。\n所以，我们产生了集合框架，它是用于存储对象的。\n\n二、集合和数组的区别\n集合长度是可变的，集合中不能存储基本数据类型值，只能存储对象(引用数据类型)。 \n数组的长度是固定的，可以存储对象，也可以存储基本数据类型。\n\n数组只能存储同一种类型，集合可以存储不同类型（但一般来说，集合也只存储同一类型）\n\n什么时候用哪个? 长度不固定，用集合。 长度固定，可以集合，可用数组。\n\n\n三、集合的体系结构\n---------| Collection 单例集合的根接口\n------------| List  如果是实现了List接口的集合类， 具备的特点：有序，重复。\n----------------| ArraryList  底层 是使用了Object数组实现的，特点： 查询速度快，增删慢。\n----------------| LinkedList 底层是使用了链表数据结构实现 的， 特点： 查询速度慢，增删快。\n----------------| Vector Vector的实现与ArrayList是一致，但是是线程安全 的，操作效率低。 jdk1.0的时候出现的\n------------| Set  如果是实现了Set接口的集合类，具备的特点：无序，不可重复。\n----------------| HashSet  底层是使用了一个哈希表支持的， 特点：存取速度快。\n----------------| TreeSet  底层实现为二叉树，元素有序（从小到大）\n---------| Map 双链集合的根接口\n---------------| HashMap  接口实现类，没有同步，线程不安全\n---------------| LinkedHashMap  双向链表和哈希表实现\n---------------| TreeMap  红黑树对所有的key进行排序\n\n四、泛型1、基本和引用数据类型区别\n基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接答存储在栈上。\n而引用专数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的属引用指向堆中对象的地址。\n在数据做为参数传递的时候，基本数据类型是值传递，而引用数据类型是引用传递（地址传递）。\n\n2、泛型的概念\njdk1.5出现的安全机制，解决类型安全的问题，只能用于编译时期，提高安全性\n\n3、泛型的好处\n将运行时期的问题 classCastExceptoin 转到了编译时期。 \n避免了强制转换的麻烦。\n\n4、泛型类的定义格式1. 泛型类,在类上自定义泛型，实在创建对象实现确定,没指定为object类型\n   格式:修饰符    class     类名&lt;T t&gt; &#123; &#125;\n   范例: public     class     Generic&lt;T&gt;&#123; &#125;\n   此处T可以随便写为任意标识，常见的如T、E、 K、V等形式的参数常用于表示泛型\n\n2. 自定义方法泛型 格式： \n   修饰符 &lt;T&gt; 返回类型 方法名（T 参数） &#123; &#125;\n   范例: public static &lt;T&gt; void println(T t) &#123; &#125;\n         public static &lt;E&gt; E call(E e) &#123; &#125;\n\n3. 泛型接口,在实现接口是指定类型，没指定为object\n   interface CallBack&lt;T&gt; &#123; &#125;\n\n5、类型通配符   为了表示各种泛型List的父类，可以使用类型通配符\n\n类型通配符: &lt;?&gt;\nList&lt;?&gt;:     表示元素类型未知的List,它的元素可以匹配任何的类型\n这种带通配符的List仅表示它是各种泛型List的父类，     并不能把元素添加到其中\n\n   如果说我们不希望List&lt;?&gt;是任何泛型List的父类，只希望它代表某一类泛型List的父类,可以使用\n\n类型通配符的上限\n类型通配符 上限: &lt;? extends类型&gt;\nList&lt;? extends      Number&gt;:  它表示的类型是Number或者其子类型\n\n\n类型通配符下限\n类型通配符下限: &lt;?super 类型&gt;\nList&lt;? super      Number&gt;:  它表示的类型是Number或者其父类型五、collection集合\n\n\n\n1、注意collection集合不能直接实现，使用更为具体的子接口实现。牢记各种方法\n2、collection集合概述\ncollection集合是==单例集合的顶层接口==，他表示一组对象，这些对象也称为collection的元素\nJDK不提供此接口直接的实现，他提供更为具体的子接口的实现（Set 和 List）\n\n3、创建collection对象\n多态的方式\n使用具体的实现类\n\n4、collection接口的方法1. 添加\n   * Boolean  add(E e): 成功返回true，失败false\n   * Boolean  addAll(): 在集合中添加另外一个集合\n2. 删除\n   * Boolean  remove(object obj): 删除一个对象，会改变集合的长度\n   * Boolean  remove(Collection con): 删除一个集合，还有两个集合中相同的元素\n   * void  clear(): 删除所有 \n3. 判断\n   * Boolean  contains(object obj): 在集合中是否包含指定的对象\n   * Boolean  containsAll(Collection con): 在集合中是否包含另一个集合\n   * Boolean  isEmpty(): 判断集合是否为空\n4. 获取\n   * int  size():  得到集合的尺寸大小    数组：length   字符串：length();\n   * Iterator iterator()：取出元素的方式。迭代器。\n   - E next():  返回迭代中的下一个元素\n   * boolean hasNext():  如果迭代具有更多元素，则返回true\n   * 迭代器将容器的取出方式和容器的数据结构相分离，降低了耦合性\n5. 集合转数组\n   * Obiect[] toArray():  把集合转换为对象\n\n六、List集合1、注意list集合，有序，可重复，通过索引进行查询，数组查询速度快，增删慢，链表查询慢，增删快   \n2、List集合的特点\n有序（存入和取出的顺序一致）\n元素都有索引（角标）\n存储元素可以重复（set集合不可）\n规律：凡是有索引的容器，都有增删改查的方法。\n\n3、List集合的方法\nvoid add(int index,E element)： 在此集合指定位置添加元素\n\nObject remove(index):删除指定的元素—-获取并删除\n\nObject set(index,element):在指定位置改变元素，并返回被替换掉的元素。\n\nObject get(index): 获取指定的元素\n\nint indexOf(object ):返回对象所在的位置 \nString s &#x3D; &quot;dd&quot;;\nint i &#x3D; list.indexOf(s);\nSystem.out.println(i);\nListIterator：拥有了对元素进行增删改查的方法——-&gt;list 特有的！\n\n\n4、常见数据结构\n数组查询数据通过索引定位，查询任意数据耗时相同，查询速率高删除数据时，要将原始数据删除，同时后面每个数据前移，删除效率低添加数据时，添加位置后的数据每个要后移，再添加元素，添加效率极低\n链表链表是一种查询慢，增删快的模型（对比 数组 而言）每次查询都要重头开始查询\n\n5、List 接口的子类\nVector: 内部是数组数据结构，是线程安全的。增删查询都很慢！（基本不用） \nArrayList: 内部是数组数据结构，是不同步的，代替了 vector.，查询的速度快内存原理： 在 arrayList 集合中，是一种线性表，每个对象存储都是有序的，用角标确定对象所存储的位置查询时，直接通过角标进行查询，速度会很快但是如果要进行增添、修改、删除操作的 话，就要影响后面角标的对象，大部分对象都要移动，直接影响运行效率。 \nLinkedList: 内部是链表结构，有很多自己特有的方法，查询慢，增删快，线程不安全\n\n6、List集合子类特点\nArrayList：底层数据结构是数组，查询快，增删慢，线程不安全，效率高，可以存储重复元素\nLinkedList:：底层数据结构是双链表，查询慢，增删快，线程不安全，效率高，可以存储重复元素，（包括null ）\n\n七、Set集合1、Set集合概述和特点Set集合没有特有方法，他的方法都来自Collection。\n2、Set集合特点\n不包含重复元素的集合\n没有带索引的方法， 所以不能使用普通for循环遍历\n\n3、哈希值\n哈希值: 是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值\nObject类中有一一个方法可以获取对象的哈希值\npublic int hashCode():返回对象的哈希码值\n\n4、对象的哈希值特点\n同一个对象多次调用hashCode()方法返回的哈希值 是相同的\n默认情况下、不同对象的哈希值是不同的。而重写hashCode()方法, 可以实现让不同对象的哈希值相同\n\n5、HashSet集合特点\n底层数据结构是 哈希表 ， 元素无序且唯一，可以存储 null元素；\n唯一性是靠所存储元素类型是否重写hashCode()和equals()方法来保证的，如果没有重写这两个方法，则无法保证元素的唯一性。\n对集合的迭代顺序不作任何保证， 也就是说不保证存储和取出的元素顺序一致\n没有带索引的方法， 所以不能使用普通for循环遍历\n线程不安全\n\n6、HashSet的底层实现具体实现唯一性的比较过程：存储元素首先会使用hash()算法函数生成一个int类型hashCode散列值，然后已经的所存储的元素的hashCode值比较，如果hashCode不相等，则所存储的两个对象一定不相等，此时存储当前的新的hashCode值处的元素对象；如果hashCode相等，存储元素的对象还是不一定相等，此时会调用equals()方法判断两个对象的内容是否相等，如果内容相等，那么就是同一个对象，无需存储；如果比较的内容不相等，那么就是不同的对象，就该存储了，此时就要采用哈希的解决地址冲突算法，在当前hashCode值处类似一个新的链表， 在同一个hashCode值的后面存储存储不同的对象，这样就保证了元素的唯一性。\nSet的实现类的集合对象中不能够有重复元素，HashSet也一样他是使用了一种标识来确定元素的不重复，HashSet用一种算法来保证HashSet中的元素是不重复的， HashSet采用哈希算法，底层用数组存储数据。默认初始化容量16，加载因子0.75。\nObject类中的hashCode()的方法是所有子类都会继承这个方法，这个方法会用Hash算法算出一个Hash（哈希）码值返回，HashSet会用Hash码值去和数组长度取模， 模（这个模就是对象要存放在数组中的位置）相同时才会判断数组中的元素和要加入的对象的内容是否相同，如果不同才会添加进去。\nHash算法是一种散列算法。\nSet hs&#x3D;new HashSet();\nhs.add(o);\n\n* o.hashCode();\n\n  o%当前总容量 (0–15)\n\n* 是否发生冲突\n\n  * 不发生冲突  -------------  直接存放\n\n  * 发生冲突  ------------  o1.equals(o2)\n\n    假（不相等)  -------------  找一个空位添加\n\n    是（相等）-------------  不添加\n\n覆盖hashCode()方法的原则：\n1、一定要让那些我们认为相同的对象返回相同的hashCode值\n2、尽量让那些我们认为不同的对象返回不同的hashCode值，否则，就会增加冲突的概率。\n3、尽量的让hashCode值散列开（两值用异或运算可使结果的范围更广）\nHashSet 的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成，我们应该为保存到HashSet中的对象覆盖hashCode()和equals()，因为再将对象加入到HashSet中时，会首先调用hashCode方法计算出对象的hash值，接着根据此hash值调用HashMap中的hash方法，得到的值&amp; (length-1)得到该对象在hashMap的transient Entry[] table中的保存位置的索引，接着找到数组中该索引位置保存的对象，并调用equals方法比较这两个对象是否相等，如果相等则不添加，注意：所以要存入HashSet的集合对象中的自定义类必须覆盖hashCode(),equals()两个方法，才能保证集合中元素不重复。在覆盖equals()和hashCode()方法时， 要使相同对象的hashCode()方法返回相同值，覆盖equals()方法再判断其内容。为了保证效率，所以在覆盖hashCode()方法时， 也要尽量使不同对象尽量返回不同的Hash码值。\n如果数组中的元素和要加入的对象的hashCode()返回了相同的Hash值（相同对象）,才会用equals()方法来判断两个对象的内容是否相同。\n7、LinkedHashSet\n哈希表和链表实现的Set接口, 具有可预测的迭代次序\n由链表保证元素有序， 也就是说元素的存储和取出顺序是一致的\n由哈希表保证元素唯一， 也就是说没有重复的元素\n\n8、TreeSet集合特点\n底层数据结构采用二叉树来实现，元素唯一且已经排好序\n\n唯一性同样需要重写hashCode和equals()方法，二叉树结构保证了元素的有序性\n\n构造方法不同，分为自然排序（无参构造）和比较器排序（有参构造）\n\nTreeSet(): 根据其元素的自然排序进行排序\n\nTreeSet(Comparator comparator) :根据指定的比较器进行排序\n对Comparetor.compare(o1, o2)方法的返回值，\n返回0说明两个对象相同，不需要存储\n\n\n\n比较器排需要在TreeSet初始化是时候传入一个实现Comparator接口的比较器对象，或者采用匿名内部类的方式new一个Comparator对象，重写里面的compare()方法；\n\n没有带索引的方法， 所以不能使用普通for循环遍历\n\n\n八、集合的使用技巧1、同步和非同步\n明确具体集合名称的所属后缀，后缀是list和set的，属于list和set体系，通常为非同步。\n后缀不是所属接口名的，一般是同步的，如vector\n\n2、集合的数据结构\n前缀是数据结构，后缀是所属体系\n例如：ArrayList，Array明确是数组结构，查询快\narray：数组，查询快，有角标。 \nlink：链表，增删快，就要想到 add get remove+first last 的方法。\nhash：哈希表，唯一性，就要想到 hashcode 和 equals \ntree：排序，二叉树，就要想到 comparable 和 comparator \n通常这些常用的是线程不安全的。\n\n3、需要唯一嘛\n元素需要唯一：Set\n需要制定顺序：TreeSet\n不需要指定顺序：HashSet\n想要存储顺序一致的：LinkedList\n\n\n元素不需要唯一：List\n需要频繁增删改：LinkedList\n不需要：ArrayList\n\n\n\n","slug":"11-集合（上）","date":"2021-09-13T14:46:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"5a74204f11299c4fc6660b81cabe549b","title":"异常处理","content":"一、概述在使用计算机语言进行项目开发的过程中，即使程序员把代码写得尽善尽美，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避免的，比如：客户输入数据的格式，读取文件是否存在，网络是否始终保持通畅等等。\n异常的出现就是为了记录程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止的情况。在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。\n异常出现的目的是为了保证程序的健壮性。代码出现问题时，曝出异常，程序员解决这些异常以后再继续向下执行。如果不抛出异常，程序就会在错误的基础上继续执行，这样更加危险。\n二、异常体系\n\nError:严重错误Error，无法通过处理的错误，只能事先避免，例如常见的StackOverFlowError和OutOfMemoryError。\nException:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是需要处理的。\n\nThrowable中的常用方法：\n\npublic void printStackTrace():打印异常的详细信息。\n包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。\n\npublic String getMessage():获取发生异常的原因。\n提示给用户的时候,就提示错误原因。\n\npublic String toString():获取异常的类型和异常描述信息(不用)。\n\n\n三、异常分类根据在编译时期还是运行时期去检查异常?\n\n编译时期异常:  checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)\n运行时期异常:  runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数组索引越界异常)\n\n四、异常处理1、规避：只适用于RuntimeException，通过大量的条件判断语句，避免出现异常。\n2、try …  catch …\ntry...catch：\ntry&#123;\n   &#x2F;&#x2F; 有可能出现异常的代码\n&#125;catch(异常类型 异常变量名) &#123;\n  &#x2F;&#x2F; 发生异常以后执行的代码\n&#125;\n\n\n一个try可以有多个catch语句\n如果多个catch语句它的代码一样，可以使用 | 连接\n如果多个catch语句的异常类型有父子类继承关系，父类的异常捕获要在子类的后面\n在catch语句里，通常会调用异常对象printStackTrace()方法，打印异常调用堆栈\n在catch语句里，还可以再抛出一个新的异常(原因之前的错误类型可能不能很好的描述异常的情况，此时可以考虑定义一个新的异常类来描述错误)\n\n3、使用  throw  关键字抛出一个异常\n\nthrow 后面的对象，必须要继承自 Throwable\n\n一般情况下，如果使用了 throw 抛出了一个异常，就需要在方法的声明使用 throws 声明这个异常。\n\n如果代码里抛出的是 RuntimeException类型的异常，方法声明里可以不使用 throws 来声明异常\n\n父类的方法如果抛出了异常，子类在重写这个方法的时候\n\n如果没有使用super调用父类的方法，子类可以不用管父类抛出异常\n\n如果使用super调用了父类的方法，子类必须要处理父类的异常\n可以直接使用throws抛出一个和父类方法相同的异常\n也可以使用try…catch语句，解决父类的异常\n\n\n\n父类的方法里没有抛出异常，子类在重写父类方法时，也不能抛出编译时异常\n\n\n五、finally代码块1、概述因为异常会引发程序跳转，导致有些语句执行不到。\n但是如果有一些特定的代码无论异常是否发生，都需要执行，就可以讲这些代码写入到finally代码块里。（保证这段代码一定会被执行）\n2、finally 语法try&#123;\n  &#x2F;&#x2F; 程序代码\n&#125;catch(异常类型1 异常的变量名1)&#123;\n  &#x2F;&#x2F; 程序代码\n&#125;catch(异常类型2 异常的变量名2)&#123;\n  &#x2F;&#x2F; 程序代码\n&#125;finally&#123;\n  &#x2F;&#x2F; 程序代码\n&#125;\n\n3、注意\nfinally不能单独使用。\n\n一个方法可以有多个return语句，但是通常情况都只会执行一个return语句。\nreturn语句表示一个方法的结束，但是当方法里有finally语句时，finally语句里的return一定会执行，可能会覆盖之前的return语句结果\n\n\n六、自定义异常1、概述在有些情况下，Java内置的错误类型可能不能够很精确的描述我们的遇到的异常类型，此时就可以考虑自定义异常。\n2、如何自定义异常分为两大类，编译时异常和运行时异常。我们在开发中，也可以根据我们的业务逻辑，选择继承的异常类型。\n\n自定义编译时异常：自定义异常类需要继承自Exception类。\n自定义运行时异常：自定义异常类需要继承自RuntimeException类。\n根据自己的业务需求，还可以继承Exception或者RuntimeException的子类。\n\n","slug":"10-异常处理","date":"2021-09-13T14:45:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"2d669717a3bf1c4b448259cbc4c2654a","title":"常用的类（下）","content":"一、Arrays类1、概述Arrays类包含用于操作数组的各种方法，是操作属猪的工具类\n2、常用方法toString():将数组变成字符串\nint[] arr &#x3D; &#123;1, 2, 3&#125;;\nString x &#x3D; java.util.Arrays.toString(arr);\nSystem.out.pritnln(x);\n\nbinarySearch:二分查找\n\ncopyOf:从一个数组里赋值指定长度的数据\n\ncopyOfRange:从一个数组里赋值指定范围的数据\n\nequals:比较两个数组里的数据是否相等\n\nfill:使用指定的数据对数组进行填充\n\nsort:用来对数组里数据进行排序。如果是数字或者字符数组，会按照快速排序进行升序排序；如果是对象，这个对象必须要实现一个Compareable接口，并且实现compareTo方法\n\ntoString:用来将数组变成&quot;[元素1,元素2,....]&quot;格式的字符串。如果是一个对象类型的数组，会调用这个对象的toString方法，如果这个对象没有重写toString方法，默认会打印对象的类型以及hashCode.\n\ndeepToString:将多维数组转换成为字符串\n\nList&lt;String&gt; list &#x3D; Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);\n该方法是将数组转化成List集合的方法。\n注意：\n（1）该方法适用于对象型数据的数组（String、Integer...）\n（2）该方法不建议使用于基本数据类型的数组（byte,short,int,long,float,double,boolean）\n（3）该方法将数组与List列表链接起来：当更新其一个时，另一个自动更新\n（4）不支持add()、remove()、clear()等方法\n    \n【2.Arrays.asList()是个坑】\n用此方法得到的List的长度是不可改变的，\n当你向这个List添加或删除一个元素时（例如 list.add(&quot;d&quot;);）程序就会抛出异常（java.lang.UnsupportedOperationException）。 \n\n3、数组转集合可以对数组中的元素通过集合中的方法进行操作，只要不影响其长度，可以使用集合中的任意方法\n4、集合转数组为了限制集合中的元素操作，他只有一个length属性可以进行操作\n5、注意无论是集合转数组还是数组转集合，长度是 不可以改变的，不能对其进行增删操作\n\n增强for循环和普通for循环的区别循环多次的时候，普通for可以对其循环条件进行控制，而增强for不能\n什么时候用map？当问题中存在着映射关系时，首先考虑数组和map当映射关系中有一方是有序编号时，可以考虑数组，反之，就不用考虑了\n\n二、Date类1、构造方法\npublic Date()：创建一个当前时间的日期对象。\npublic Date(long date)：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。\n\n2、常用方法\npublic long getTime() ：把日期对象转换成对应的时间毫秒值。\npublic boolean after(Date when)：判断是否在when时间之后。\npublic boolean before(Date when)：判断是否在when时间之前。\npublic int compareTo(Date anotherDate)：判断时间和指定时间的大小关系。\n\n三、DateFormat类1、概述是一个抽象类，通常情况下使用SimpleDateFormat类来进行日期格式化\n\n格式化：按照指定的格式，从Date对象转换为String对象。\n解析：按照指定的格式，从String对象转换为Date对象。\n\n2、构造方法DateFormat是一个抽象类，不能直接创建对象，通常我们会选择创建一个**SimpleDateFormat**类型的对象。\npublic SimpleDateFormat(String pattern)：通常会传入一个格式化字符串参数。\nSimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-mm-dd HH:MM:SS&quot;);\n\n参数pattern是一个字符串，代表日期时间的自定义格式。\n3、常见方法\npublic String format(Date date)：将Date对象格式化为字符串。\npublic Date parse(String source)：将字符串解析为Date对象。\n\nyyyy     四位数年\nMM       两位数的月\ndd       在月里日期\nDD       在年里的天数\nHH       小时\nmm       分钟\nss       秒\n\n&#x2F;&#x2F; 创建一个 SimpleDateFormat 对象\nSimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-mm-dd HH:MM:SS&quot;);\n&#x2F;&#x2F; 创建一个 Date 对象\nDate date &#x3D; new Date();\n\n&#x2F;&#x2F; 将当前时间以指定的格式转换成为字符串\nString str1 &#x3D; sdf.format(date);\nSystem.out.println(str1);  &#x2F;&#x2F; 2020-03-15 11:22:35\n\n&#x2F;&#x2F; 按照格式创建一个字符串对象\nString dateStr &#x3D; &quot;2008-08-08 12:34:45&quot;;\n\n&#x2F;&#x2F; 将字符串加载成为一个 Date 对象\nDate newDate &#x3D; sdf.parse(dateStr);\n\n四、Calendar类1、概述java.util.Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。\n2、构造方法Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象。\n\npublic static Calendar getInstance()：使用默认时区和语言环境获得一个日历。\n\n3、 常见方法Calendar类里通常使用两个方法:\n\npublic int get(int field)：获取指定字段（年月日等）的值。\npublic void set(int filed, int vale)：给指定的字段设置值。\n\n4、Calendar里的字段Calendar类中提供很多成员常量，代表给定的日历字段：\n\n\n\n字段值\n含义\n\n\n\nYEAR\n年\n\n\nMONTH\n月（从0开始，可以+1使用）\n\n\nDAY_OF_MONTH\n月中的天（几号）\n\n\nHOUR\n时（12小时制）\n\n\nHOUR_OF_DAY\n时（24小时制）\n\n\nMINUTE\n分\n\n\nSECOND\n秒\n\n\nDAY_OF_WEEK\n周中的天（周几，周日为1，可以-1使用）\n\n\n五、其他日期类1、概述JDK8里还提供了LocalDate类，LocalTime类,以及LocalDateTime类来分别用来表示日期，时间以及日期和时间。\n这三个类的构造方法都是私有的，不要直接创建对象，都是通过静态方法now来获取到当前的日期和时间\n2、DateTimeFormatter\n用来将日期和字符串之间相互转换\n获取实例对象\n不允许调用构造方法直接创建实例对象\n只能调用 ofPattern 等静态方法，返回一个实例对象\n\n\n日期转换成为字符串，调用  format 方法\n把字符串加载成为日期，不是调用 DateTimeFormatter的parse方法，因为获取到结果是一个父接口，无法获取到日期时间等数据。分别使用 LocalDate / LocalTime / LocalDateTime 的 parse静态方法，将字符串和formatter传入，实现加载。\n\npublic class FormatDemo &#123;\n    public static void main(String[] args) throws ParseException &#123;\n        Date date &#x3D; new Date();\n\n        SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy年MM月dd日 HH点mm分ss秒&quot;);\n\n        &#x2F;&#x2F; 把 Date 类型的对象转换成为指定格式的字符串\n        String dateStr &#x3D; sdf.format(date);\n        System.out.println(dateStr);\n\n        String str &#x3D; &quot;2012-03-12 12:34:12&quot;;\n        SimpleDateFormat sdf2 &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n        Date date1 &#x3D; sdf2.parse(str);\n        System.out.println(date1.getYear());\n\n        DateTimeFormatter formatter &#x3D; DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);\n\n        &#x2F;&#x2F; 将日期变成字符串\n        LocalDate now &#x3D; LocalDate.now();\n        System.out.println(formatter.format(now));\n\n\n        String str1 &#x3D; &quot;2021-04-17&quot;;\n&#x2F;&#x2F;        LocalDate time &#x3D; (LocalDate) formatter.parse(str1);\n&#x2F;&#x2F;        System.out.println(time.getYear());\n        LocalDate d &#x3D; LocalDate.parse(str1, formatter);\n        System.out.println(d.getYear());\n\n        LocalTime time &#x3D; LocalTime.parse(&quot;12:34:56&quot;, DateTimeFormatter.ofPattern(&quot;HH:mm:ss&quot;));\n        System.out.println(time.getHour());\n\n        LocalDateTime ldt &#x3D; LocalDateTime.parse(&quot;2021年04月17日 15:09:20&quot;, DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH:mm:ss&quot;));\n        System.out.println(ldt.getYear());\n    &#125;\n&#125;\n\n六、String类1、概述String（字符串）在 Java中属于对象，Java提供了String类来创建和操作字符串。\nString的值是不可变的，所以导致每次对String的操作都会生成String对象\nString str &#x3D; &quot;hello&quot;;\nstr &#x3D; &quot;hello&quot;+&quot;world&quot;;\n上述world需要开辟一个堆内存\n相加时再开辟一个内存空间存储相加的值\n最后把str指向上一个开辟的空间（这个时候“hello”的对象已经丢弃了）\n\n上述开辟了三次内存空间，如果这种操作放到循环中，会造成内存极大浪费，引入StringBuffer与StringBuild处理这种问题\n\n2、字符串的特点\n字符串不可变, 它们的值在创健后不能被更改\n虽然 String的值是不可变的,但是它们可以被共享\n字符串效果上相当于字符数组( char[]).但是底层原理是字节数组( byte[])\n\n3、String 构造方法\n\n\n方法名\n说明\n\n\n\npublic String()\n创建一个空白字符审对象，不含有任何内容\n\n\npublic String(char[] chs)\n根据字符数组的内容，来创建字符串对象\n\n\npublic String(byte[] bys)\n根据字节数组的内容，来创建字符串对象\n\n\nString s= “abc” ;\n直接赋值的方式创建字符串对象，内容就是abc\n\n\n4、字符串比较使用==做比较\n\n基本类型:  比较的是数据值是否相同\n引用类型:  比较的是地址值是否相同\n\n字符串是对象，它比较内容是否相同，需要equals()\n\npublic boolean equals(Object a): 将此字符串与指定对象进行比较。\n由于我们比较的是字符串对象，所以参数直接传递一个字符串\n\n5、Split方法public String[] split(String regex)将此字符串拆分为给定的字符数组 \n例如，字符串”boo:and:foo”使用以下表达式得到以下结果：\n\nregex = : \n{ “boo”, “and”, “foo” } \n\nregex = o \n{ “b”, “”, “:and:f” } \n\n\n七、StringBuilder类当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder类。这两个类的对象能被多次修改，并且不产生新的未使用对象\nStringBuffer 和 StringBuilder的区别在于，StringBuilder的方法不是线程安全的（不能同步访问）但是 StringBulider速度较快，所以一般情况下建议使用 StirngBuilder类。然而在程序要求线程安全的情况下，必须使用StirngBuffer类\n\n\n\n序号\n方法描述\n\n\n\n1\npublic StringBuffer append(String s) 将指定的字符串追加到此字符序列。\n\n\n2\npublic StringBuffer reverse()  将此字符序列用其反转形式取代。\n\n\n3\npublic delete(int start, int end) 移除此序列的子字符串中的字符。\n\n\n4\npublic insert(int offset, int i) 将 int 参数的字符串表示形式插入此序列中。\n\n\n5\nreplace(int start, int end, String str) 使用给定 String 中的字符替换此序列的子字符串中的字符。\n\n\n下面的列表里的方法和 String 类的方法类似：\n\n\n\n序号\n方法描述\n\n\n\n1\nchar charAt(int index) 返回此序列中指定索引处的 char 值。\n\n\n2\nint indexOf(String str) 返回第一次出现的指定子字符串在该字符串中的索引。\n\n\n3\nint indexOf(String str, int fromIndex) 从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。\n\n\n4\nint lastIndexOf(String str) 返回最右边出现的指定子字符串在此字符串中的索引。\n\n\n5\nint length()  返回长度（字符数）。\n\n\n6\nvoid setCharAt(int index, char ch) 将给定索引处的字符设置为 ch。\n\n\n7\nvoid setLength(int newLength) 设置字符序列的长度。\n\n\n8\nString substring(int start) 返回一个新的 String，它包含此字符序列当前所包含的字符子序列。\n\n\n9\nString substring(int start, int end) 返回一个新的 String，它包含此序列当前所包含的字符子序列。\n\n\n10\nString toString() 返回此序列中数据的字符串表示形式。\n\n\n注意\n都可以直接赋为空值 String s = null；StringBuffer s1 = null;  StringBuilder s3 = null;\n小结\n（1）如果要操作少量的数据用 String；\n（2）多线程操作字符串缓冲区下操作大量数据 StringBuffer；\n（3）单线程操作字符串缓冲区下操作大量数据 StringBuilder\n","slug":"09-常用的类（下）","date":"2021-09-13T14:43:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"c660642989e58d8f24bf7e09ddf846f0","title":"常用的类（中）","content":"一、Math类1、特点提供了操作数学元素的方法，都是静态的\n2、常用方法int abs(int a)：返回整数的绝对值\n\nint max(int a, int b)：返回两个整数的最大值 \n\ndouble random()：返回一个伪随机值(0--1 之间) \n\ndouble sqrt(double a)：返回一个数的平方根 \n\ndouble ceil()：返回大于参数的最小整数\n\ndouble floor()：返回小于参数的最大整数 \n\ndouble round()：返回四舍五入的值。 \n\ndouble pow(a,b)：a 的 b 次方\n\n二、Scanner类1、概念接收键盘输入数据的类\n2、常用APIdelimiter()：返回此 Scanner 当前正在用于匹配分隔符的 Pattern\n\nhasNext()：判断扫描器中当前扫描位置后是否还存在下一段。（原APIDoc的注释很扯淡）\n\nhasNextLine()：如果在此扫描器的输入中存在另一行，则返回 true\n\nnext()：查找并返回来自此扫描器的下一个完整标记\n\nnextLine()：此扫描器执行当前行，并返回跳过的输入信息\n\n3、next() 与 nextLine() 区别next():\n    1、一定要读取到有效字符后才可以结束输入。\n    2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。\n    3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。    \n    \n注意：next() 不能得到带有空格的字符串。\n\nnextLine()：\n    1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。\n    2、可以获得空白。\n\n三、System类1、特点不能实例化对象，提供的方法都是静态的。\n2、获取本地系统信息系统属性信息：程序在运行时获取到Jvm以及所在操作系统的一些固有信息，获取了这些信息，能为后面的程序运行提供数据\npublic static void main(String[] args) &#123;\n\n    Properties pros &#x3D; System.getProperties();\n    \n    Set&lt;String&gt; names &#x3D; pros.stringPropertyNames();\n    \n    for (String name : names) &#123;\n        System.out.println(name+&quot;:&quot;+pros.getProperty(name));\n    &#125;\n\n&#125;\n\n结果：java.runtime.name:Java(TM) SE Runtime Environment\n     sun.boot.library.path:D:\\Myeclipse\\jdk1.8\\jre\\bin\n     java.vm.version:25.241-b07\n     java.vm.vendor:Oracle Corporation\n     ...\n         \n获取系统换行符：String s &#x3D; System.getProperty(&quot;line.separator&quot;);\n              System.out.println(&quot;hh&quot;+s+&quot;kk&quot;);\n\n3、常用方法* static long currentTimeMillis()：获取当前时间，以毫秒为单位。 \n\n* static void exit(int status) ：退出当前程序。 \n\n* static void gc()：调用垃圾回收器。 \n\n* static Properties getProperties()：获取当前系统属性 \n\n* static String getProperty(String key)：根据关键字获取系统属性名称 \n\n* static String setProperty(String key, String value)：设置属性的键和值。\n\n四、Properties类1、特点：properties集合类中储存的都是 string 类型的键和值，最好是用他自己的存储和取出方法来完成元素的操作\n主要用于读取 java中的配置文件\n2、常用方法：Properties getProperty(String key):返回指定的属性 \n\nObject setProperty(String key,String value):设置属性的键和值 \n\nvoid load(InputStream inStream) :加载输入流 \n\nSet&lt;String&gt; stringPropertyNames() ：返回属性键的集合。\n\n五、Runtime类1、使用单例模式没有构造方法摘要，说明该类不可以创建对象，又发现还有非静态的方法，说明该类应该提供静态的返回该类对象的方法，\n而且只有一个，说明 runtime 类使用了单例设计模式。\n2、打开记事本exec 方法返回的是一个进程，可以通过该方法启动一个程序\npublic static void main(String[] args) &#123;\n\tRuntime runtime &#x3D; Runtime.getRuntime();\n\n\ttry &#123;\n   \t\truntime.exec(&quot;notepad.exe&quot;);\n\t&#125; catch (IOException e) &#123;\n    \te.printStackTrace();\n\t&#125;\n&#125;\n\n","slug":"08-常用的类（中）","date":"2021-09-13T14:42:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"01fd53219624f0d973c128a92b2b96c5","title":"常用的类（上）","content":"一、单例设计模式1.1 概述单例模式，是一种常用的软件设计模式，在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中应用该模式的类一个类只有一个实例，即一个类只有一个对象实例。例如，windows操作系统里的回收站。\n单例设计模式分为饿汉式（立即加载型）和懒汉式（延迟加载型）。由于懒汉式有线程安全问题，又衍生出了线程安全版的懒汉式以及DLC双检查锁（最佳实现方式）的懒汉式\n1.2 做法\n将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。\n在该类内部产生一个唯一的实例化对象，并且将其封装为private static final类型。\n定义一个静态方法返回这个唯一对象。\n\n1.3 饿汉式1.3.1 概述立即加载就是使用类的时候已经将对象创建完毕\n不管以后会不会使用到该实例化对象，先创建了再说。很着急的样子，故又被称为“饿汉模式”，常见的实现办法就是直接new实例化。\npublic class Singleton &#123;\n\n    &#x2F;&#x2F; 将自身实例化对象设置为一个属性，并用static修饰\n    private static final Singleton instance &#x3D; new Singleton();\n\n    &#x2F;&#x2F; 构造方法私有化\n    private Singleton() &#123;&#125;\n\n    &#x2F;&#x2F; 静态方法返回该实例\n    public static Singleton getInstance() &#123;\n        return instance;\n    &#125;\n&#125;\n\n1.3.2 特点优点：实现起来简单，没有多线程同步问题。\n缺点：当类SingletonTest被加载的时候，会初始化static的instance，静态变量被创建并分配内存空间，从这以后，这个static的instance对象便一直占着这段内存（即便你还没有用到这个实例），当类被卸载时，静态变量被摧毁，并释放所占有的内存，因此在某些特定条件下会耗费内存。\n1.4 懒汉式1.4.1 概述延迟加载就是调用get()方法时实例才被创建（先不急着实例化出对象，等要用的时候才给你创建出来。不着急，故又称为“懒汉模式”），常见的实现方法就是在get方法中进行new实例化。\npublic class Singleton &#123;\n\n    &#x2F;&#x2F; 将自身实例化对象设置为一个属性，并用static修饰\n    private static Singleton instance;\n\n    &#x2F;&#x2F; 构造方法私有化\n    private Singleton() &#123;&#125;\n\n    &#x2F;&#x2F; 静态方法返回该实例\n    public static Singleton getInstance() &#123;\n        if(instance &#x3D;&#x3D; null) &#123;\n            instance &#x3D; new Singleton();\n        &#125;\n        return instance;\n    &#125;\n&#125;\n\n1.4.2 特点优点：实现起来比较简单，当类SingletonTest被加载的时候，静态变量static的instance未被创建并分配内存空间，当getInstance方法第一次被调用时，初始化instance变量，并分配内存，因此在某些特定条件下会节约了内存。\n缺点：在多线程环境中，这种实现方法是完全错误的，根本不能保证单例的状态\n二、枚举类2.1 概述枚举是一个被命名的整型常数的集合，用于声明一组带标识符的常数。枚举在曰常生活中很常见，例如一个人的性别只能是“男”或者“女”，一周的星期只能是 7 天中的一个等。类似这种当一个变量有几种固定可能的取值时，就可以将它定义为枚举类型。\n在 JDK 1.5 之前没有枚举类型，那时候一般用接口常量来替代。而使用 Java 枚举类型 enum 可以更贴近地表示这种常量。\n2.2  枚举类的实现2.2.1 JDK 1.5 之前public class Test &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(Season.SPRING);\n    &#125;\n&#125;\n\nclass Season &#123;\n    private Season() &#123;\n    &#125;\n    public static final Season SPRING &#x3D; new Season();\n    public static final Season SUMMER &#x3D; new Season();\n    public static final Season AUTUMN &#x3D; new Season();\n    public static final Season WINTER &#x3D; new Season();\n&#125;\n\n2.2.2 Enum的使用enum 枚举类类名 &#123;\n    对象1,对象2,对象3;\n&#125;\n\npublic enum Season&#123;\n    &#x2F;&#x2F; SPRING(),SUMMER(),AUTUMN(),WINTER();  调用构造函数，创建了四个对象，小括号可以省略\n\n    SPRINT,SUMMER,AUTUMN,WINTER;  &#x2F;&#x2F; 创建了四个对象\n    &#x2F;&#x2F; private Season()&#123;&#125; 构造方法可以不写，默认就有一个空参数构造方法\n&#125;\n\npublic enum WeekDay &#123;\n    &#x2F;&#x2F; 创建的实例对象时，必须要调用构造方法传入 name 参数\n    MON(&quot;周一&quot;), TUE(&quot;周二&quot;), WED(&quot;周三&quot;), THU(&quot;周四&quot;), FRI(&quot;周五&quot;), SAT(&quot;周六&quot;), SUN(&quot;周日&quot;);\n\n    private String name;\n    WeekDay(String name) &#123;  &#x2F;&#x2F; 还能自定义构造方法\n        this.name &#x3D; name;\n    &#125;\n\n    &#x2F;&#x2F; 像正常的类一样，可以使用 getter&#x2F;setter 方法\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n&#125;\n\n2.3 枚举类的特点\n所有的枚举都继承自java.lang.Enum类，由于Java 不支持多继承，所以枚举对象不能再继承其他类（但是可以实现接口）。\n枚举类的所有实例对象都必须放在第一行展示（逗号隔开），并且默认都是以public static final修饰的常量，所以变量名通常都全大写。\n在创建实例对象时，不需使用new 关键字，也不需使用小括号显式调用构造器\n使用enum定义非抽象的枚举类默认使用final修饰，不可以被继承。\n枚举类的构造器只能是私有的，不允许在外部创建对象。\n\n2.4  Enum中的方法\n\n\n\n方法名称\n描述\n\n\n\nvalues()\n以数组形式返回枚举类型的所有成员\n\n\nvalueOf()\n将普通字符串转换为枚举实例\n\n\ncompareTo()\n比较两个枚举成员在定义时的顺序\n\n\nordinal()\n获取枚举成员的索引位置\n\n\ntoString()\n返回对象名（常用♥）\n\n\nname()\n获取对象名（不常用）\n\n\n三、包装类3.1 概述在 Java 的设计中提倡一种思想，即一切皆对象。但是从数据类型的划分中，我们知道 Java 中的数据类型分为基本数据类型和引用数据类型，但是基本数据类型怎么能够称为对象呢？于是 Java 为每种基本数据类型分别设计了对应的类，称之为包装类（Wrapper Classes），也有地方称为外覆类或数据类型类。\n3.2 关系\n\n\n序号\n基本数据类型\n包装类\n\n\n\n1\nbyte\nByte\n\n\n2\nshort\nShort\n\n\n3\nint\nInteger\n\n\n4\nlong\nLong\n\n\n5\nchar\nCharacter\n\n\n6\nfloat\nFloat\n\n\n7\ndouble\nDouble\n\n\n8\nboolean\nBoolean\n\n\n从上表中我们可以看出，除了 Integer 和 Character 定义的名称与基本数据类型定义的名称相差较大外，其它的 6 种类型的名称都是很好掌握的。\n3.3 装箱和拆箱\n装箱：从基本类型转换为对应的包装类对象。\n拆箱：从包装类对象转换为对应的基本类型。\n\nint a &#x3D; 10;\n\n&#x2F;&#x2F; 装箱:使用构造方法 或者 valueOf 方法将基本数据类型a包装成为包装类型\nInteger i1 &#x3D; new Integer(a);\nInteger i2 &#x3D; Integer.valueOf(a);\n\n&#x2F;&#x2F; 拆箱:将包装类型转换成为基本数据类型\nint b &#x3D; i1.intValue();\n\n\n自动装箱拆箱:由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：\n\nInteger i &#x3D; 4; &#x2F;&#x2F;自动装箱。相当于Integer i &#x3D; Integer.valueOf(4);\ni &#x3D; i + 5; &#x2F;&#x2F;等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;\n&#x2F;&#x2F;加法运算完成后，再次装箱，把基本数值转成对象。\n\n3.4 包装类的应用3.4.1 int 和 Integer 的相互转换public class Demo &#123;\n    public static void main(String[] args) &#123;\n        int m &#x3D; 500;\n        Integer obj &#x3D; new Integer(m);  &#x2F;&#x2F; 手动装箱\n        int n &#x3D; obj.intValue();  &#x2F;&#x2F; 手动拆箱\n        System.out.println(&quot;n &#x3D; &quot; + n);\n       \n        Integer obj1 &#x3D; new Integer(500);\n        System.out.println(&quot;obj等价于obj1的返回结果为&quot; + obj.equals(obj1));\n    &#125;\n&#125;\n\n3.4.2 将字符串转换为数值类型① new Integer(String str);\n② Integer 类（String 转 int 型）parsenInt（）\nint parseInt(String s); s 为要转换的字符串。\n\n注意：使用以上两种方法时，字符串中的数据必须由数字组成，否则转换时会出现程序错误。\n3.4.3 将整数转换为字符串\nInteger 类有一个静态的 toString() 方法，可以将整数转换为字符串。例如：\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        int m &#x3D; 500;\n        String s &#x3D; Integer.toString(m);\n        System.out.println(&quot;s &#x3D; &quot; + s);\n    &#125;\n&#125;\n\n使用+将基本数据类型和字符串拼接，例如String x = 1 + &quot;&quot;;得到的结果x就是个字符串。\n调用String类的valueOf方法，例如String x = String.valueOf(1);得到的结果是一个字符串。\n","slug":"07-常用的类（上）","date":"2021-09-13T14:41:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"5a1c4f03caf8f9ffac125f63d3a94727","title":"面向对象（下）","content":"一、内部类1.成员内部类1.1  概念在成员位置定义的类（定义在另一个类的内部，最普通的内部类），称之为成员内部类\n1.2  成员内部类特点:\n不能使用 static关键字，但是可以使用static final关键字定义常量。\n成员内部类 可以无条件的访问外部类的 成员属性 和 成员方法 （包括private成员）\n注意：当成员内部类拥有和外部类同名的成员变量或方法时，默认访问的是 成员内部类 的\n如过要访问外部类 同名成员，可以下述方式访问：      \n外部类.this.外部成员变量\n外部类.this.外部成员方法\n\n\n可以使用final修饰内部类，表示不能被继承。\n编译以后也会有自己独立的字节码文件，只不过文件名是Outer$Inner.class\n外部函数的static成员里，不允许访问成员内部类。\n由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰\n\n1.3  创建成员内部类的对象前提是存在外部类的对象，然后通过外部类对象创建内部类对象\n\n第一种（Outter外，Inner内部类 类举例）\nOutter outter = new Outter;\nOutter.Inner inner = outter.new Inner();\n\n第二种，在内部类中给出 获取内部类实例化的方法（getInnerInstance(){return new Inner();}）\n\n\n2.局部内部类2.1  概述局部内部类是定义在一个方法或者一个作用域里面的类，他和成员内部类的区别在于 \n局部内部类的访问 仅限于 方法内 或者 该作用域内。\n2.2  语法格式[修饰符] class 外部类&#123;\n    [修饰符] 返回值类型  方法名([形参列表])&#123;\n            [final&#x2F;abstract] class 内部类&#123;\n        &#125;\n    &#125;    \n&#125;\n\n2.3  局部内部类特点\n局部内部类 可随意访问 外部类的成员变量和方法，即使是私有的；\n 局部内部类像是方法里面的一个局部变量，前面不能有权限修饰符！\n在外部类中不能创建内部类的实例；\n创建内部类的实例只能在包含他的方法中；\n\n\n局部内部类里不能使用static声明变量！\n局部内部类中能访问外部类的静态成员。\n如果这个局部内部类所在的方法是静态方法，它无法访问访问外部类的非静态成员。\n内部类和外部类有同名变量和方法时，需要通过Outer.this方式来访问外部类成员变量或方法\n局部内部类可以访问外部函数的局部变量，但是这个局部变量必须要被final修饰。JDK8以后，如果局部变量被局部内部类使用了，会自动在前面加final.\n\n2.4  为什么要加finalpublic class TestInner&#123;\n    public static void main(String[] args) &#123;\n        A obj &#x3D; Outer.method();\n        &#x2F;&#x2F;因为如果c不是final的，那么method方法执行完，method的栈空间就释放了，那么c也就消失了\n        obj.a();&#x2F;&#x2F;这里打印c就没有中可取了，所以把c声明为常量，存储在方法区中\n    &#125;\n&#125;\n\ninterface A&#123;\n    void a();\n&#125;\nclass Outer&#123;\n    public static A method()&#123;\n        final int c &#x3D; 3;\n        class Sub implements A&#123;\n            @Override\n            public void a() &#123;\n                System.out.println(&quot;method.c &#x3D; &quot; + c);\n            &#125;\n        &#125;\n        return new Sub();\n    &#125;\n&#125;\n\n3.匿名内部类1.  概念匿名内部类就是 局部内部类的简化写法\n2.  格式new 类名或接口名()&#123;\n\t重写方法\n&#125;;\n\n3.  注意\n根据格式看，所谓的匿名内部类，就是 实现了父类 或者 实现了父接口 的 子类匿名对象\n\n在匿名内部类中的this，代表的是 该匿名内部类 这个对象\n\n一个匿名内部类 最好对应一种 抽象方法的实现，可以使功能更加单一化，修改时不易出错\n\n匿名内部类没有类名，所以匿名内部类是唯一一种没有构造器的类，所以适用范围十分有限，大部分用于接口回调\n匿名内部类在编译的时候由系统自动起名为 Outter$1.class\n\n一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写\n\n\n4.静态内部类1.  定义静态内部类也是定义在 另一个类里面的类，只不过前面多了一个关键字 static\n静态内部类是不需要依赖于 外部类的，与类的静态成员有点类似，不能使用外部类的非静态成员方法\n在没有外部类的对象情况下，可以创建静态内部类的对象，外部类的费static成员必须依附于具体的对象\n2.  静态内部类特点:\n使用static关键字修饰。\n在静态内部类里，可以使用static关键字定义静态成员。\n只能访问外部的静态成员，不能访问外部的非静态成员。\n外部类可以直接通过静态内部类名.静态成员名访问静态内部类的静态成员。\n\n二、代码块1.概述\n普通代码块：就是类里方法体代码。\n构造代码块：类里直接使用 { } 编写的代码。\n静态代码块：在构造代码块前添加static关键字。\n同步代码块：使用synchronize关键字包裹起来的代码块，用于多线程。\n\n2.静态代码块2.1 语法结构【修饰符】 class 类名&#123;\n    static&#123;\n        静态代码块语句;\n    &#125;\n&#125;\n\n2.2 特点\n使用static关键字修饰，写在类里，方法外，用来对类进行初始化。\n一个类里可以有多个静态代码块，但是通常情况下只会定义一个。\n随着类加载而执行，只执行一次，只要类加载就会执行，所以执行的优先级很高。\n一般情况下,如果有些代码必须在项目启动的时候就执行的时候,就需要使用静态代码块\n\n3.构造代码块3.1 语法结构:&#123;\n    &#x2F;&#x2F;代码块里的内容\n&#125;\n\n3.2 特点\n对象一建立就会执行构造代码块，构造代码块先于构造方法执行，用来给对象进行初始化。\n每创建一个对象都会调用一次构造代码块。\n构造代码块是给所有对象统一初始化，构造函数是给各自对应的对象初始化。\n如果每个实例对象都需要统一的初始化，可以考虑将这部分代码写入到构造代码块里。\n\n三、初始化1.类的初始化当我们 用new关键字创建一个对象时，其实就是调用了这个对象的无参构造方法进行了初始化\n无参构造方法可以隐藏，由JVM自动添加，构造方法能保证类的初始化\n2.成员初始化Java 会尽量保证每个变量在使用前都会获得初始化。\n\n编译器默认指定的字段初始化，基本数据类型的初始化\n\n\n\n类型\n初始值\n\n\n\nboolean\nfalse\n\n\nchar\n/u0000\n\n\nbyte\n(byte)0\n\n\nshort\n(short)0\n\n\nint\n0\n\n\nlong\n0L\n\n\nfloat\n0.0f\n\n\ndouble\n0.0d\n\n\n引用类型\nnull\n\n\n\n指定数值初始化\n\n指定数值后，初始化值，就不是默认初始化值了，而是指定数值，基本类型和引用类型也一样\n\n\n3.构造器初始化可以利用构造器对某些方法和动作进行初始化，确定初始值（完成对象初始化）。\npublic class Test&#123;\n\n\tint i;\n\tpublic Test()&#123;\n\t\ti&#x3D;11;\n\t&#125;\n\n&#125;\n\n4.实例对象的初始化4.1 使用一个类来实例化对象的几种方式:\n最常见的方式，使用关键字new来创建一个实例对象。\n使用反射，调用Class或者java.lang.reflect.Constructor对象的newInstance()方法。\n调用对象的clone()方法。\n调用java.io.ObjectInputStream类的getOjbect()方法序列化。\n\n4.2 对象加载\n先给成员变量设置默认值。\n调用构造方法里 super 的构造方法。\n给成员变量赋值和执行构造代码块。\n执行构造方法里其他的代码。\n\n5.初始化顺序\n初始化顺序：父类的静态变量–&gt;父类的静态代码块–&gt;子类的静态变量–&gt;子类的静态代码快–&gt;父类的非静态变量(父类的非静态代码块)–&gt;父类的构造函数–&gt;子类的非静态变量（子类的非静态代码块）–&gt;子类的构造函数\n值得注意的是：父类的非静态变量(父类的非静态代码块)是同一级的，看哪个部分写在类的最前面谁就先被执行，子类的非静态变量（子类的非静态代码块）也是一样。\n\n","slug":"06-面向对象（下）","date":"2021-09-13T14:38:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"6a12650511ac8438957ec15fcbb76cbc","title":"面向对象（中）","content":"一、封装1.1    概述\n面向对象编程语言是对客观世界的模拟，客观世界里实例变量都是隐藏在对象内部的，外界无法直接操作和修改。\n封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。\n\n1.2    原则\n将类的某些信息隐藏在类内部，不允许外部程序直接访问\n通过该类提供的方法来实现对隐藏信息的操作和访问\n成员变量private，提供对应的  get / set  方法\n\n1.3    好处\n通过方法来控制成员量的操作，提高了代码的安全性\n\n把代码用方法进行封装，提高了代码的复用性\n\n\n二、继承2.1    概述\n继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。\n\n猫狗类都可以称为子类，也叫派生类；多个类抽取出来的这个动物类称为父类、超类（superclass）或者基类。\n\n继承描述的是事物之间的所属关系，父类更通用，子类更具体。\n\nextends 用在 class 或 interface声明中，用于指示所声明的类或接口是其名称后跟有 extends关键字的类或接口的子类\n\n子类继承父类的所有 public 和 protected 变量和方法。 \n\n子类可以重写父类的任何非 final 方法。\n\n一个类只能扩展一个其他类。\n\n\n2.2    好处子类继承父类，就使得子类对象具有与父类相同的属性，可以调用父类相同的行为。\n\n提高代码的复用性。\n提高代码的扩展性。\n类与类之间产生了关系，是学习多态的前提。\n\n2.3    注意事项\nJava中类只支持单继承， 不支持多继承\nJava中类支持多层继承\n\n2.4    常见写法class Animal &#123;\n    private String name;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n\n    Animal(String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n&#125;\n\nclass Dog extends Animal &#123;\n    Dog(String name) &#123;\n        super(name);\n    &#125;\n&#125;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        Dog dog &#x3D; new Dog(&quot;jerry&quot;);\n    &#125;\n&#125;\n\n2.5    继承中变量的访问特点2.5.1    成员变量不重名\n子类局部范围找\n子类成员范围找\n父类成员范围找\n如果都没有就报错(不考虑父亲的父亲.)（保持疑问）\n\n2.5.2    成员变量重名同不重名，但重名时，访问不了父类的成员变量\nclass Fu &#123;\n    &#x2F;&#x2F; Fu中的成员变量。\n    int num &#x3D; 3;\n&#125;\n\nclass Zi extends Fu &#123;\n    &#x2F;&#x2F; Zi中的成员变量\n    int num &#x3D; 4;\n    public void show() &#123;\n        &#x2F;&#x2F; 访问的num到底是子类还是父类？\n        System.out.println(&quot;num &#x3D; &quot; + num);\n    &#125;\n&#125;\nclass ExtendsDemo03 &#123;\n    public static void main(String[] args) &#123;\n          &#x2F;&#x2F; 创建子类对象\n        Zi z &#x3D; new Zi(); \n          &#x2F;&#x2F; 调用子类中的show方法\n        z.show(); \n    &#125;\n&#125;\n演示结果：\nnum &#x3D; 4\n\n子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用  super 关键字，修饰父类成员变量，类似于之前学过的  this 。\nclass Zi extends Fu &#123;\n    &#x2F;&#x2F; Zi中的成员变量\n    int num &#x3D; 6;\n    public void show() &#123;\n        &#x2F;&#x2F;访问父类中的num\n        System.out.println(&quot;Fu num&#x3D;&quot; + super.num);\n        &#x2F;&#x2F;访问子类中的num\n        System.out.println(&quot;Zi num&#x3D;&quot; + this.num);\n    &#125;\n&#125;\n演示结果：\nFu num &#x3D; 5\nZi num &#x3D; 6\n\n小贴士：\n\nFu 类中的成员变量是非私有的，子类中可以直接访问。\n若Fu 类中的成员变量私有了，子类是不能直接访问的。\n通常编码时，遵循封装的原则，使用private修饰成员变量。可以在父类中提供公共的getXxx方法和setXxx方法。\n\n2.6    继承中方法访问特点2.6.1    构造方法\n子类中所有的构造方法默认都会访问父类中无参的构造方法。\n因为子类会继承父类中的数据，可能使用父类数据。所以，子类初始化之前，一定要先完成父类的初始化\n每一个子类构造方法的第一 条语句默认都是: super()\n即便在子类的构造方法里没有手动使用super调用父类构造函数，子类也是会自动调用父类的空参数构造函数\n\n\n如果父类中没有无参构造方法，只有带参构造方法，该怎么办呢?\n通过使用super关键字 去显示的调用父类的带参构造方法\n在父类中自 己提供一个无参构造方法\n子类中也不要无参构造方法\n\n\n\n2.6.2    成员方法不重名会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。\n2.6.3    成员方法重名（重写）就是重写，直接覆盖。\n方法的覆盖重写特点：创建的是子类对象，则优先用子类方法。\n注意事项：\n\n必须保证父子类之间方法的名称相同，参数列表也相同。 @Override：写在方法前面，用来检测是不是有效的正确覆盖重写。这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。\n子类方法的返回值类型必须【小于等于】父类方法的返回值类型（小于其实就是是它的子类）。\n子类方法的权限必须【大于等于】父类方法的权限修饰符。 小扩展提示：public &gt; protected &gt; 缺省 &gt; private 备注：缺省不是汉字缺省，而是什么都不写，留空。\n\n三、static3.1    概述static 关键字可以应用于内部类（在另一个类中定义的类）、方法或字段（类的成员变量）。通常，static 关键字意味着应用它的实体在声明该实体的类的任何特定实例外部可用。static（内部）类可以被其他类实例化和引用（即使它是顶级类）static 字段（类的成员变量）在类的所有实例中只存在一次\n3.2    static修饰的特点\n被类的所有对象共享这也是我们判断是否使用静态关键字的条件\n静态修饰的优先于对象存在，所以可以直接被类名调用当然，也可以通过对象名调用，推荐使用类名调用\n\n3.3    static访问特点\n非静态的成员方法• 能访问静态的成员变量\n• 能访问非静态的成员变量\n• 能访问静态的成员方法\n• 能访问非静态的成员方法\n\n\n静态的成员方法• 能访问静态的成员变量\n• 能访问静态的成员方法\n总结成一句话就是：**静态成员方法只能访问静态成员**\n\n\n\n\n四、final1、可以用来修饰：类、方法、变量\n2、具体的：final 用来修饰一个类、此类不能被其他类所继承。\n\n     比如：String类、System类、StringBuffer类\n\n\n\n3、final 用来修饰方法：表明此方法不可以被重写\n\n        比如：Object类中getClass();\n\n\n\n4、 final 用来修饰变量：此时的”变量”就称为是一个常量\n\nfinal修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化\n\nfinal修饰局部变量：\n尤其是使用final修饰形参时，表明此形参是一个常量。\n当我们调用此方法时，给常量形参赋一个实参。\n一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。\n\n      static final 用来修饰属性：全局常量\n\n\n\n5、一个类不能同时是 abstract 又是 final。abstract 意味着必须扩展类，final 意味着不能扩展类\n五、抽象类abstract修饰类：抽象类\n\n 此类**不能实例化**\n\n\n 抽象类中一定有构造器（默认也会有无参构造），便于子类实例化时调用（涉及：子类对象实例化的全过程）\n\n\n 开发中，都会提供抽象类的子类，**让子类对象实例化**，完成相关的操作 ---&gt;抽象的**使用前提：继承性**\n\n\n\nabstract修饰方法：抽象方法\n\n    抽象方法只方法的声明，**没方法体**\n\n\n    包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。\n\n\n   若子类重写了父类中的所的抽象方法后，此子类方可实例化\n\n\n     若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰\n\n\n\n注意点：\n\n1.abstract不能用来修饰：属性、构造器等结构\n2.abstract不能用来修饰私方法、静态方法、final的方法、final的类\n抽象类可以有构造器、静态方法。构造器能被子类继承并完成初始化，但不会创建抽象类的实例对象。静态方法的好处是不实例化就可由子类类名直接调用\n\n六、接口1.接口使用interface来定义\n2.Java中，接口和类是并列的两个结构\n3.如何定义接口：定义接口中的成员\n4.JDK7及以前：只能定义全局常量和抽象方法\n\n        全局常量：public static final的.但是书写时，可以省略不写\n\n\n        抽象方法：public abstract的\n\n\n\n5.JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法\n   JDK9以后可以定义私有方法\n6.接口中不能定义构造器的！意味着接口不可以实例化\n7.Java开发中，接口通过让类去实现**(implements)**的方式来使用.\n\n如果实现类覆盖了接口中的所抽象方法，则此实现类就可以实例化\n如果实现类没覆盖接口中所的抽象方法，则此实现类仍为一个抽象类\n\n8.Java类可以实现多个接口   —&gt;弥补了Java单继承性的局限性\n\n格式：class AA extends BB implements CC,DD,EE\n\n9.接口与接口之间可以继承，而且可以多继承\n\n接口的具体使用，体现多态性\n接口，实际上可以看做是一种规范\n\n10.知识点\n接口中定义的静态方法，只能通过接口来调用。\n\n通过实现类的对象，可以调用接口中的默认方法。\n如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法\n\n如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法\n那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。–&gt;类优先原则\n\n如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，\n那么在实现类没重写此方法的情况下，报错。–&gt;接口冲突。\n这就需要我们必须在实现类中重写此方法\n\n如何在子类(或实现类)的方法中调用父类、接口中被重写的方法\npublic void myMethod()&#123;\n    method3();&#x2F;&#x2F;调用自己定义的重写的方法\n    super.method3();&#x2F;&#x2F;调用的是父类中声明的\n    &#x2F;&#x2F;调用接口中的默认方法\n    CompareA.super.method3();\n    CompareB.super.method3();\n&#125;\n\n七、多态1.多态： 就是指同一事物，具有多个不同表现形式。\n2.前提\n\n继承或者实现【二选一】\n方法的重写【意义体现：不重写，无意义】\n父类引用指向子类对象【格式体现】\n\n3.大大的提高了代码的灵活性，便于代码后期的扩展\n4.成员方法，编译看左边，运行看右边\n5.成员变量，等号左边是谁，优先用谁\n八、引用类型转换1.向上转型多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。当父类引用指向一个子类对象时，便是向上转型。\n使用格式：\n父类类型  变量名 &#x3D; new 子类类型();\n如：Animal a &#x3D; new Cat();\n\n2.向下转型父类类型向子类类型向下转换的过程，这个过程是强制的。一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。\n使用格式：\n子类类型 变量名 &#x3D; (子类类型) 父类变量名;\n如:Cat c &#x3D;(Cat) a; \n\n3.类型转换的意义调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。\n4.转型的异常为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验，格式如下：\n变量名 instanceof 数据类型 \n如果变量属于该数据类型，返回true。\n如果变量不属于该数据类型，返回false。\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 向上转型  \n        Animal a &#x3D; new Cat();  \n        a.eat();               &#x2F;&#x2F; 调用的是 Cat 的 eat\n\n        &#x2F;&#x2F; 向下转型  \n        if (a instanceof Cat)&#123;\n            Cat c &#x3D; (Cat)a;       \n            c.catchMouse();        &#x2F;&#x2F; 调用的是 Cat 的 catchMouse\n        &#125; else if (a instanceof Dog)&#123;\n            Dog d &#x3D; (Dog)a;       \n            d.watchHouse();       &#x2F;&#x2F; 调用的是 Dog 的 watchHouse\n        &#125;\n    &#125;  \n&#125;\n\n","slug":"05-面向对象（中）","date":"2021-09-13T14:37:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"0959816aacb592f211c0dd883a8ef3db","title":"面向对象（上）","content":"一、概述\nJava语言是面向对象的程序设计语言，而面向对象思想（Object Oriented Programming）是一种程序设计思想。\n\n这里的对象泛指现实中的一切事物，而每种事物都具有自己的属性和行为\n\n而面向对象编程就是参照现实中的事物，将其属性和行为抽象出来，描述成计算机事件的思想\n\n面向对象有以下特征：\n比较符合人们的思考习惯\n可以将复杂的逻辑简单化，易维护，易复用，易扩展\n具有封装，继承，多态的特性，可以设计出低耦合的系统，使之更加灵活\n性能比面向过程低\n\n面向对象的编程语言主要有：C++，Java，C# 等\n\n\n二、类和对象2.1    什么是类类：是一类具有相同特性的事物的抽象描述，是一组相关属性和行为的集合\n2.2    什么是对象对象：是一类事物的具体体现，对象是类的一个实例，必然具有该类事物的属性和行为\n2.3    定义类public class className&#123;\n\t&#x2F;&#x2F; 成员变量\n\t&#x2F;&#x2F; 方法\n&#125;\n\n\n一般，类的命名遵循大驼峰原则，每个首字母都要大写\n成员变量，和以前定义变量的方法一样，不过成员变量在类中方法外\n方法，有构造方法，各个成员方法，功能更加丰富，也更加灵活\n\n2.4    定义对象在Java中，万事万物都是对象，虽然一切可以看做对象，但是我们操纵的却是一个对象的    引用（reference） 也就是，我们有一个对象引用，但是不一定需要对象与之关联，如下：\nPerson p;\n\n这里创建的只是 引用，而并非对象，但是若想使用这个引用时，会返回异常，高数我们需要一个 对象 来进行关联。安全的做法是，在创建引用的同时吧对象赋给他。\nPerson p &#x3D; new Person();\n\n直接打印对象名和数组名都是显示“类型@对象的hashCode值”所以说类、数组都是引用数据类型，引用数据类型的变量中存储的是对象的地址，或者说指向堆中对象的首地址。\n那么像“Student@4e25154f”是对象的地址吗？不是，因为Java是对程序员隐藏内存地址的，不暴露内存地址信息，所以打印对象时不直接显示内存地址，而是JVM提取了对象描述信息给你现在，默认提取的是对象的运行时类型@代表对象唯一编码的hashCode值。\n2.5    属性和方法\n属性，也被称为字段，属性可以是任意类型的对象，可以是基本数据类型，也可以是引用数据类型；\n方法，表示的是  做某些事情的方式，方法其实就是函数\n方法的基本组成包括：权限修饰符，返回值类型，方法名，参数，方法体\n\n2.6    构造方法\n是一种特殊的方法，也被称为构造函数，构造器。\n在JAVA中，通过这种方法确保每个对象都被初始化。\n构造方法只能在对象的创建时期调用一次。\n没有返回值类型，他的名称要和类名保持一致，并且构造方法可以有多个。**(可以重载，不可以重写)**\n没有参数的称为 默认构造方法，如果没有定义其它构造方法，那JVM 会自动生成一个构造方法但是若手动定义了任何一个构造方法，JVM都不会再提供默认构造方法，必须手动指定。\n\npublic class Test&#123;\n\t\n\tint a;\n\tint b;\n\n\tpublic Test()&#123;\n\t\t&#x2F;&#x2F;无参构造、默认构造\n\t&#125;\n\t\n\tpublic Test(int a,int b)&#123;\n\t\t&#x2F;&#x2F; 满参构造\n\t&#125;\n&#125;\n\n2.8    成员和局部变量的区别\n\n\n区别\n成员变量\n局部变量\n\n\n\n类中位置不同\n类中方法外\n方法内或者方法声明上\n\n\n内存中位置不同\n堆内存\n栈内存\n\n\n生命周期不同\n随着对象的存在而存在，随着对象的消失而消失\n随着方法的调用而存在，随着方法的调用完毕而消失\n\n\n初始化值不同\n有默认的初始化值（默认的值在下方的成员初始化中）一种情况例外:被 final 修饰的成员变量也必须显式地赋值\n没有默认的初始化值\n\n\n作用域不同\n整个类中\n方法中\n\n\n成员变量如果被 ==static== 修饰，那么这个成员变量是属于这个类的（不会再存储到堆中，会和类一起到方法区中），如果没有，则是属于==实例==的\n2.9    对象的销毁Java 虚拟机进行管理和销毁\n2.10    作用域作用域定义了其内部定义的变量名的可见性和生命周期。作用域通常有 { } 的位置来决定\n三、重载和重写3.1    方法重载方法名相同，参数列表不同。构造函数，也是重载的一种\n每个重载方法都有独一无二的参数列表，其中包括参数的类型，顺序，数量等，满足一种因素就构成了重载。\n重载的条件：\n\n方法名必须相同\n参数列表必须不同（个数不同，类型不同，参数类型排列顺序不同）\n方法的返回值类型可以相同也可以不同\n仅仅返回值类型不足矣成为方法的重载\n重载发生在编译时，因为编译器可以根据参数类型选择使用哪个方法\n\n3.2    方法重写重写描述的是  父类和子类  之间；而重载是同一类中。\n方法的声明： 权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型&#123;\n\n\t\t\t\t&#x2F;&#x2F;方法体\n\n\t\t   &#125;\n\n约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法\n① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同\n② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符\n\n     特殊情况：子类**不能重写**父类中声明为**private权限的方法**\n\n\n\n③ 返回值类型：\n\n     父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void\n\n\n     父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是**A类或A类的子类**\n\n\n     父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是**相同的基本数据类型**(必须也是double)\n\n\n\n④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）\n\n   子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写，要么都声明为static的（不是重写)。\n\n四、this 和 superthis：代表本类对象的引用\nsuper：代表父类存储空间的标识（可以理解为父类对象引用）\n\n\n\n关键字\nthis\nsuper\n\n\n\n调用方式\n调用本类中的属性，构造函数，方法\n调用父类中的属性，构造函数，方法\n\n\n调用位置\n构造函数第一行，其他自行指定\n构造函数第一行，其他自行指定\n\n\n调用次数\n一个构造函数只能调用一次\n一个构造函数只能调用一次\n\n\n\n\n\n关键字\n访问成员变量\n访问构造方法\n访问成员方法\n\n\n\nthis\nthis.成员变量\nthis(…)\nthis.成员方法(…)\n\n\nsuper\nsuper.成员变量\nsuper(…)\nsuper.成员方法(…)\n\n\n五、访问控制权限\n\n\n\n同一类中\n同一包中（子类与无关类）\n不同包中的子类\n不同包中的无关类\n\n\n\npublic\n可以\n可以\n可以\n可以\n\n\nprotected\n可以\n可以\n可以\n不可以\n\n\n默认（friendly/default/没有）\n可以\n可以\n不可以\n不可以\n\n\nprivate\n可以\n不可以\n不可以\n不可以\n\n\npublic：用于类，需要别人调用的方法，构造方法\nprotected：通常用于继承，只想让子类使用\n缺省（默认）：包内使用\nprivate：用于成员变量，实现封装\n\nprivate是一个权限修饰符，代表最小权限，可以修饰实例变量和实例方法。\n被private修饰后的实例变量和实例方法，只在本类中才能访问。\n父类中的成员，无论是公有(public)还是私有(private)，均会被子类继承（private被继承有歧义）。\n子类虽会继承父类私有(private)的成员，但子类不能对继承的私有成员直接进行访问，可通过继承的公有方法进行访问\n\n","slug":"04-面向对象（上）","date":"2021-09-13T14:36:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"e16187d7a3c490f96b788338bdd79d24","title":"数组","content":"一、容器\n如果使用很多个变量来逐一保存数据，这样操作起来会非常的不便。把这80个数据想象成为80个鸡蛋，如果让你一个个的操作这些鸡蛋，你会非常的慌乱，此时我们可以使用一个篮子，将所有的鸡蛋(数据)全部存储到一个容器中，统一操作。 \n\n装鸡蛋用到的篮子我们可以称之为容器，容器里的一个个的鸡蛋数据，我们可以称之为元素。\n\nJava里的容器有很多种实现方式，数组是其中最基本也最重要的一种\n\n\n二、数组1.数组的特点\n他是一种数据结构(容器)，用来存储同一种类型数据的集合\n\n数组是有大小的，而且数组的大小确定后不允许改变\n\n数组里的元素是有序的，可以通过索引获取和修改数据，索引从0开始\n\n创建数组时会在内存中开辟一整块连续的空间，数组名指向这块内存的首地址。\n\n如果数组里的数据没有设置值，那么会有一个默认的值，\n整数（byte,short,in）默认0，long：0L\n浮点数   float：0.0F    double：0.0\n布尔默认false\n字符默认，0或  ‘ \\u0000 ’ （表现为空）\n引用类型，0默认null\n\n在 java中，允许长度为0的数组，长度为 0 的数组与null并不完全相同\n\n\n2.初始化（一维）\n动态初始化：创建数组时，不指定元素后续通过（下标，角标，索引）来给数组里的数据赋值。元素类型[]   数组名 = new   元素类型[元素个数或者数组长度] ;示例：int[] arr = new int[3]\n\n\n静态初始化：创建数组时，就给元素赋值。\n元素类型[] 数组名 = new 元素类型[]{元素1，元素2，元素3……};\n示例：int[] arr = new int[] {1,2,3,};    int[] arr = {1,2,3,4}\n\n注意：大括号直接赋值的方式只能写在一行，不能分开来写！\n\n注意：数组在创建时就已经指定好了长度，在代码里使用 length 属性来获取数组的长度。\n\n注意：当明确数组元素时，建议使用第二种方式\n\n\n3.数组遇到的问题\n数组索引越界异常：ArrayIndexOutOfBoundsException（程序运行的时候发生)）\n访问到了数组的最后一个元素后，你还在继续访问,此时就会出现此问题。\n\n空指针异常：NullPointerException（程序运行的时候发生）\n一个引用变量已经不再指向对内存的地址。这个时候，还在使用这个引用。\n\n\n4.遍历方法\n普通for循环\n\nfor each循环（增强for循环）\n\nwhile循环\n\n注意：for each循环语句的循环变量将会遍历数组中的每个元素，而不是下标值\n如果不希望遍历整个集合，或者在循环内部需要使用下标值时，用普通for循环\n\n\n5.选择排序\n\n\n\n\n\n\n\n\n从索引为0的元素开始与其他元素(自己除外)依次比较，每次比较完，最小值出现在最左边\npublic static void main(String[] args) &#123;\n     int[] arr &#x3D;&#123;12,22,53,65,45,32&#125;;\n     for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;\n         for (int j &#x3D; i+1; j &lt; arr.length; j++) &#123;\n             if (arr[i]&gt;arr[j]) &#123;\n                 int temp &#x3D; arr[i];\n                 arr[i]&#x3D;arr[j];\n                 arr[j]&#x3D;temp;\n             &#125;\n         &#125;\n     &#125;\n     System.out.println(Arrays.toString(arr));\n&#125;\n\n\n\n6.冒泡排序\n\n\n\n\n\n\n\n\n相邻的元素，两两相比，大的后移。每次比较完后，最大值出现在右边\npublic static void main(String[] args) &#123;\n  int[] arr &#x3D;&#123;12,22,53,65,45,32&#125;;\n  for (int i &#x3D; 0; i &lt; arr.length-1; i++) &#123;\n      for (int j &#x3D; 0; j &lt; arr.length-1-i; j++) &#123;\n          if (arr[j]&gt;arr[j+1])&#123;\n             int temp &#x3D; arr[j];\n             arr[j] &#x3D; arr[j+1];\n             arr[j+1] &#x3D; temp;\n          &#125;\n      &#125;\n  &#125;\n  System.out.println(Arrays.toString(arr));\n&#125;\n\n\n\n7.折半（二分）查找\n\n\n\n\n\n\n\n\n需要 有序数组\n三、基本和引用类型1.概述\n在 java 中只有值传递，引用传递的时候，传递的是地址值。\n基本数据类型传递过去后，形参改变对实参没有影响。引用类型传递过去后，形参改变直接影响实参 \n\n2.分类\n基本数据类型,基本数据类型只有8种，可按照如下分类\n整数类型：long、int、short、byte浮点类型：float、double字符类型：char布尔类型：boolean\n\n引用数据类型大致包括：\n类、 接口类型、 数组类型、 枚举类型、 注解类型、 字符串型\n简单来说，所有的非基本数据类型都是引用数据类型。\n\n\n3.形参实参public static void main(String[] args) &#123;\n    System.out.println(&quot;---基本数据类型---&quot;);\n    int a&#x3D;10;\n    System.out.println(&quot;形参改变前，实参：&quot;+a);\n    change(a);\n    System.out.println(&quot;作为形参改变后，实参：&quot;+a);\n\n    System.out.println(&quot;---引用数据类型---&quot;);\n    int[] arr&#x3D;&#123;1,2,3&#125;;\n    System.out.println(&quot;形参改变前，实参：&quot;+arr[2]);\n    change2(arr);\n    System.out.println(&quot;作为形参改变后，实参：&quot;+arr[2]);\n&#125;\n\nprivate static void change2(int[] arr) &#123;\n    arr[2] &#x3D; 100;\n    System.out.println(&quot;方法中，当a作为形参且改变后：&quot;+arr[2]);\n&#125;\n\nprivate static void change(int a) &#123;\n    a&#x3D;20;\n    System.out.println(&quot;方法中，当a作为形参且改变后：&quot;+a);\n&#125;\n\n\n四、数组内存图1.内存概述内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。其作用是用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。只要计算机在运行中，CPU就会把需要运算的数据调到内存中进行运算，当运算完成后CPU再将结果传送出来。我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。\nJava虚拟机要运行程序，必须要对内存进行空间的分配和管理。\n2.java虚拟机的内存划分为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。\n\n\n\n\n\n区域名称\n作用\n\n\n\n程序计数器\n程序计数器是CPU中的寄存器，它包含每一个线程下一条要执行的指令的地址\n\n\n虚拟机栈\n用于存储正在执行的每个Java方法的局部变量表等。局部变量表存放了编译期可知长度的各种基本数据类型、对象引用，方法执行完，自动释放。\n\n\n本地方法栈\n当程序中调用了native的本地方法时，本地方法执行期间的内存区域。在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。\n\n\n方法区\n存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。\n\n\n堆内存\n存储对象（包括数组对象），new来创建的，都存储在堆内存。\n\n\n3.数组在内存中的存储\n\n\n\n\n\n\n\n\n\n思考：打印arr为什么是[I@5f150435，它是数组的地址吗？\n答：它不是数组的地址。\n问？不是说arr中存储的是数组对象的首地址吗？\n答：arr中存储的是数组的首地址，但是因为数组是引用数据类型，打印arr时，会自动调用arr数组对象的toString()方法，默认该方法实现的是对象类型名@该对象的hashCode()值的十六进制值。\n问？对象的hashCode值是否就是对象内存地址？\n答：不一定，因为这个和不同品牌的JVM产品的具体实现有关。例如：Oracle的OpenJDK中给出了5种实现，其中有一种是直接返回对象的内存地址，但是OpenJDK默认没有选择这种方式。\n五、二维数组1. 第一种格式\n\n   int[][] arr &#x3D; new int[3] [2]; \n\n   定义了名称为 arr 的二维数组 二维数组中有 3 个一维数组 \n\n   每一个一维数组中有 2 个元素 一维数组的名称分别为 arr[0], arr[1], arr[2] \n\n   给第一个一维数组 1 脚标位赋值为 78 \n\n   写法是：arr[0] [1] &#x3D; 78;\n\n2. 第二种格式\n\n   int[][] arr &#x3D; new int[3] []; \n\n   二维数组中有 3 个一维数组 \n\n   每个一维数组都是默认初始化值 null----引用类型的初始化值为 Null \n\n   可以对这个三个一维数组分别进行初始化 \n\n   arr[0] &#x3D; new int[3]; arr[1] &#x3D; new int[1]; arr[2] &#x3D; new int[2];\n\n3. 第三种格式\n\n   int[][] arr &#x3D; &#123;&#123;3,8,2&#125;,&#123;2,7&#125;,&#123;9,0,1,6&#125;&#125;; \n\n   定义一个名称为 arr 的二维数组 \n\n   二维数组中的有三个一维数组 \n\n   一个一维数组中具体元素也都已初始化 \n\n   第一个一维数组 arr[0] &#x3D; &#123;3,8,2&#125;; \n\n   第二个一维数组 arr[1] &#x3D; &#123;2,7&#125;; \n\n   第三个一维数组 arr[2] &#x3D; &#123;9,0,1,6&#125;; \n\n   第三个一维数组的长度表示方式：arr[2].length;\n   \n   \n 4. 遍历格式\n \n \tpublic static void main(String[] args) &#123; \n \t\n \t\tint[][] arr &#x3D; &#123;&#123;60,12,23&#125;,&#123;0,50,69&#125;,&#123;98,120&#125;,&#123;111,222,333&#125;&#125;;\n \t\t\n \t\tfor(int x &#x3D; 0;x&lt;arr.length;x++)&#123; \n \t\t\n \t\t\tfor(int y &#x3D; 0;y&lt;arr[x].length;y++)&#123; \n \t\t\t\n \t\t\t\tSystem.out.println(arr[x][y]+&quot; &quot;);\n\t\t\t&#125; \n\t\t\t\n\t\t\tSystem.out.println(); \n\t\t&#125;\n\n六、可变参数1. int add(T... a)：该函数可以添加多个同种类型的数据，相当于函数的参数是数组形式。 \n\n2. int add(T a,T... a1)：在传参数是，除了第一个为 a，其他全部都是属于可变参数。\n\n注意：可变参数必须放在其他参数的最后边。 传入的实参必须是根据形参的同种类型的参数","slug":"03-数组","date":"2021-09-13T14:35:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"7689509bc540e79b176cff8111263e2f","title":"流程控制语句","content":"一、顺序结构顺序结构就是从上到下逐行执行，中间没有任何跳转和判断。\npublic static void main(String[] args)&#123;\n    System.out.println(&quot;&quot;);\n    System.out.println(&quot;&quot;);\n    System.out.println(&quot;&quot;);\n    System.out.println(&quot;&quot;);\n&#125;\n\n\n\n二、分支结构2.1    if 语句if(条件表达式)&#123;  &#x2F;&#x2F; 条件表达式必须是一个布尔类型的值\n      语句体;\n&#125;\n\n执行流程\n    \n    首先判断条件表达式，看其结果是true还是false\n    \n    如果是true就执行语句体\n    \n    如果是false就不执行\n\n2.2    if … else … 语句if(关系表达式) &#123; \n      语句体1;\n&#125;else &#123;\n      语句体2;\n&#125;\n\n执行流程\n\n\t首先判断关系表达式看其结果是true还是false\n\n    如果是true就执行语句体1\n\n    如果是false就执行语句体2\n\n2.3    if … else if … else … 语句if (判断条件1) &#123;\n      执行语句1;\n&#125; else if (判断条件2) &#123;\n      执行语句2;\n&#125;\n...\n&#125;else if (判断条件n) &#123;\n     执行语句n;\n&#125; else &#123;\n      执行语句n+1;\n&#125;\n\n执行流程\n    \n\t首先判断关系表达式1看其结果是true还是false\n\n    如果是true就执行语句体1，然后结束当前多分支\n\n    如果是false就继续判断关系表达式2看其结果是true还是false\n\n    如果是true就执行语句体2，然后结束当前多分支\n\n    如果是false就继续判断关系表达式…看其结果是true还是false\n\n    …\n\n    如果没有任何关系表达式为true，就执行语句体n+1，然后结束当前多分支。\n\n2.4    switch … case … 语句switch(表达式)&#123;\n    case 常量值1:\n     语句块1;\n        【break;】\n    case 常量值2:\n        语句块2;\n        【break;】   \n    。。。\n   【default:\n        语句块n+1;\n        【break;】\n     】\n&#125;\n\n执行过程\n（1）入口\n\t\n\t当switch(表达式)的值与case后面的某个常量值匹配，就从这个case进入；\n\t\n\t当switch(表达式)的值与case后面的所有常量值都不匹配，寻找default分支进入;不管\tdefault在哪里\n\n（2）一旦从“入口”进入switch，就会顺序往下执行，直到遇到“出口”，即可能发生贯穿\n\n（3）出口\n\n\t自然出口：遇到了switch的结束&#125;\n\n\t中断出口：遇到了break等\n        \n（4）在switch语句中，如果case的后面不写break，将出现穿透现象，\n    也就是一旦匹配成功，不会在判断下一个case的值，直接向后运行，\n    直到遇到break或者整个switch语句结束，switch语句执行终止。\n\n\n\n三、循环结构3.1    while循环while (循环条件语句①) &#123;\n    循环体语句②；\n&#125;\n\n执行流程\n\n第一步：执行循环条件语句①，看循环条件语句的值是true，还是false；\n       如果是true，执行第二步；\n       如果是false，循环语句中止，循环不再执行。\n第二步：执行循环体语句②；\n第三步：循环体语句执行完后，重新从第一步开始再执行一遍\n\n3.1.2    while循环语句扩展格式初始化语句①；\nwhile (循环条件语句②) &#123;\n    循环体语句③；\n    迭代语句④；\n&#125;\n\n执行流程\n第一步：执行初始化语句①，完成循环变量的初始化；\n第二步：执行循环条件语句②，看循环条件语句的值是true，还是false；\n\t   如果是true，执行第三步；\n\t   如果是false，循环语句中止，循环不再执行。\n第三步：执行循环体语句③\n第四步：执行迭代语句④，针对循环变量重新赋值\n第五步：根据循环变量的新值，重新从第二步开始再执行一遍\n\n案例：遍历1-100之间的偶数\nint num &#x3D; 2;\nwhile(num&lt;&#x3D;100)&#123;\n    System.out.println(num);\n    num+&#x3D;2;\n&#125;\n\n3.2    do … while … 循环do &#123;\n    循环体语句①；\n&#125; while (循环条件语句②)；\n\n执行流程\n第一步：执行循环体语句①；\n第二步：执行循环条件语句②，看循环条件语句的值是true，还是false；\n\t   如果是true，执行第三步；\n\t   如果是false，循环语句终止，循环不再执行。\n第三步：循环条件语句执行完后，重新从第一步开始再执行一遍\n    \n    \n注意：\n（1）while(循环条件)中循环条件必须是boolean类型\n\n（2）do&#123;&#125;while();最后有一个分号\n\n（3）do...while结构的循环体语句是至少会执行一次，这个和for和while是不一样的\n\n3.2.1    do … while … 循环语句扩展格式初始化语句①\ndo &#123;\n    循环体语句②；\n    迭代语句③；\n&#125; while (循环条件语句④)；\n\n执行流程\n第一步：执行初始化语句①，完成循环变量的初始化；\n第二步：执行循环体语句②；\n第三步：执行迭代语句③，针对循环变量重新赋值；\n第四步：执行循环条件语句④，看循环条件语句的值是true，还是false；\n\t   如果是true，根据循环变量的新值，重新从第二步开始再执行一遍；\n\t   如果是false，循环语句中止，循环不再执行\n\npublic static void main(String[] args)&#123;\n    &#x2F;&#x2F;随机生成一个100以内的整数\n    &#x2F;*\n        Math.random() &#x3D;&#x3D;&gt; [0,1)的小数\n        Math.random()* 100 &#x3D;&#x3D;&gt; [0,100)的小数\n        (int)(Math.random()* 100) &#x3D;&#x3D;&gt; [0,100)的整数\n        *&#x2F;\n    int num &#x3D; (int)(Math.random()* 100);\n    &#x2F;&#x2F;System.out.println(num);\n\n    &#x2F;&#x2F;声明一个变量，用来存储猜的次数\n    int count &#x3D; 0;\n\n    java.util.Scanner input &#x3D; new java.util.Scanner(System.in);\n    int guess;&#x2F;&#x2F;提升作用域\n    do&#123;\n        System.out.print(&quot;请输入100以内的整数：&quot;);\n        guess &#x3D; input.nextInt();\n\n        &#x2F;&#x2F;输入一次，就表示猜了一次\n        count++;\n\n        if(guess &gt; num)&#123;\n            System.out.println(&quot;大了&quot;);\n        &#125;else if(guess &lt; num)&#123;\n            System.out.println(&quot;小了&quot;);\n        &#125;\n    &#125;while(num !&#x3D; guess);\n\n    System.out.println(&quot;一共猜了：&quot; + count+&quot;次&quot;);\n\n&#125;\n\n3.3    for 循环for(初始化语句①; 循环条件语句②; 迭代语句④)&#123;\n    循环体语句③\n&#125;\nfor(;;)&#123;\n    循环体语句块；&#x2F;&#x2F;如果循环体中没有跳出循环体的语句，那么就是死循环\n&#125;\n\n注意：\n\n（1）for(;;)中的两个；是不能多也不能少\n\n（2）循环条件必须是boolean类型\n\n（3）如果循环条件语句②省略的话，就默认为循环条件成立\n\n执行流程：\n\n第一步：执行初始化语句①，完成循环变量的初始化；\n第二步：执行循环条件语句②，看循环条件语句的值是true，还是false；\n如果是true，执行第三步；\n如果是false，循环语句中止，循环不再执行。\n第三步：执行循环体语句③\n第四步：执行迭代语句④，针对循环变量重新赋值\n第五步：根据循环变量的新值，重新从第二步开始再执行一遍\n\n3.3.1    for … each … 循环for ( 变量类型  变量名 : 数组名 ) &#123;\n    \n    需要执行的循环语句;\n \n&#125;\n\n\n\n\n\n\n\n\n\n\n不使用下标变量就可以顺序地遍历整个数组\n3.4    嵌套循环所谓嵌套循环，是指一个循环的循环体是另一个循环。\n比如for循环里面还有一个for循环，就是嵌套循环。\n总共的循环次数&#x3D;外循环次数*内循环次数。\n当然可以是三种循环任意互相嵌套。\n\nfor(初始化语句①; 循环条件语句②; 迭代语句⑦) &#123;\n    for(初始化语句③; 循环条件语句④; 迭代语句⑥) &#123;\n          循环体语句⑤;\n    &#125;\n&#125;\n\n案例1：打印倒三角形\n🐟 🐟 🐟 🐟 🐟 \n 🐟 🐟 🐟 🐟 \n  🐟 🐟 🐟 \n   🐟 🐟 \n    🐟 \npublic class Test07 &#123;\n\tpublic static void main(String[] args)&#123;\n\t\tfor(int i&#x3D;1; i&lt;&#x3D;5; i++)&#123;&#x2F;&#x2F;控制行数\n\t\t\t&#x2F;*\n\t\t\t每一行有三件事：\n\t\t\t（1）打印n个空格\n\t\t\t（2）打印m个&quot; *&quot;\n\t\t\t（3）换行\n\t\t\t*&#x2F;\n\t\t\t&#x2F;&#x2F;（1）打印n个空格\n\t\t\t&#x2F;*\n\t\t\t第1行：0个，当i&#x3D;1, j应该让它第一次循环都不满足\tj&lt;i\n\t\t\t第2行：1个，当i&#x3D;2, j运行1次，j&#x3D;1\n\t\t\t第3行：2个，当i&#x3D;3, j运行2次，j&#x3D;1,2\n\t\t\t第4行：3个，当i&#x3D;4, j运行3次，j&#x3D;1,2,3\n\t\t\t第5行：4个，当i&#x3D;5, j运行4次，j&#x3D;1,2,3,4\n\t\t\t*&#x2F;\n\t\t\tfor(int j&#x3D;1; j&lt;i; j++)&#123;\n\t\t\t\tSystem.out.print(&quot; &quot;);\n\t\t\t&#125;\n\t\t\t&#x2F;&#x2F;（2）打印m个&quot; *&quot;\n\t\t\t&#x2F;*\n\t\t\t第1行：5个，当i&#x3D;1,j运行5次，j&#x3D;1,2,3,4,5\t\tj&lt;&#x3D;6-i\n\t\t\t第2行：4个，当i&#x3D;2,j运行4次，j&#x3D;1,2,3,4\n\t\t\t第3行：3个，当i&#x3D;3,j运行3次，j&#x3D;1,2,3\n\t\t\t第4行：2个，当i&#x3D;4,j运行2次，j&#x3D;1,2\n\t\t\t第5行：1个，当i&#x3D;5,j运行1次，j&#x3D;1\n\t\t\t*&#x2F;\n\t\t\tfor(int j&#x3D;1; j&lt;&#x3D;6-i; j++)&#123;\n\t\t\t\tSystem.out.print(&quot; *&quot;);\n\t\t\t&#125;\n\t\t\t\n\t\t\t&#x2F;&#x2F;（3）换行\n\t\t\tSystem.out.println();\n\t\t&#125;\n\t&#125;\n&#125;\n\n案例2：打印『X』对称图形，效果如图所示：\n        🐅*****🐅\n        *🐅***🐅*\n        **🐅*🐅**\n        ***🐅***\n        **🐅*🐅**\n        *🐅***🐅*\n        🐅*****🐅\n    \npublic class Test08 &#123;\n\tpublic static void main(String[] args)&#123;\n\t\tfor(int i&#x3D;1; i&lt;&#x3D;7; i++)&#123;&#x2F;&#x2F;控制行数\n\t\t\t&#x2F;&#x2F;(1)打印该行的*或o\n\t\t\t&#x2F;*\n\t\t\t发现O+*的总个数是7个\n\t\t\t当i&#x3D;1, 当j&#x3D;1和j&#x3D;7的时候是O，其余的是* \n\t\t\t当i&#x3D;2, 当j&#x3D;2和j&#x3D;6的时候是O，其余的是* \n\t\t\t当i&#x3D;3, 当j&#x3D;3和j&#x3D;5的时候是O，其余的是* \n\t\t\t当i&#x3D;4, 当j&#x3D;4的时候是O，其余的是* \n\t\t\t当i&#x3D;5, 当j&#x3D;5和j&#x3D;3的时候是O，其余的是* \n\t\t\t当i&#x3D;6, 当j&#x3D;6和j&#x3D;2的时候是O，其余的是* \n\t\t\t当i&#x3D;7, 当j&#x3D;7和j&#x3D;1的时候是O，其余的是* \n\t\t\t*&#x2F;\n\t\t\tfor(int j&#x3D;1; j&lt;&#x3D;7; j++)&#123;\n\t\t\t\tif(i&#x3D;&#x3D;j || i&#x3D;&#x3D;8-j)&#123;\n\t\t\t\t\tSystem.out.print(&quot;O&quot;);\n\t\t\t\t&#125;else&#123;\n\t\t\t\t\tSystem.out.print(&quot;*&quot;);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\t\n\t\t\t&#x2F;&#x2F;(2)每一行的最后一件事是换行\n\t\t\tSystem.out.println();\n\t\t&#125;\n\t&#125;\n&#125;\n\n3.5    循环语句的区别\n从循环次数角度分析 \ndo…while循环至少执行一次循环体语句\nfor和while循环先循环条件语句是否成立，然后决定是否执行循环体，至少执行零次循环体语句\n\n\n从循环变量的生命周期角度分析\nfor循环的循环变量在for()中声明的，在循环语句结束后，不可以被访问；\nwhile和do…while循环的循环变量因为在外面声明的，所以while和do…while结束后可以被继续使用的；\n\n\n如何选择\n遍历有明显的循环次数（范围）的需求，选择for循环\n遍历没有明显的循环次数（范围）的需求，循环while循环\n如果循环体语句块至少执行一次，可以考虑使用do…while循环\n本质上：三种循环之间是可以互相转换的，都能实现循环的功能\n\n\n三种循环结构都具有四要素：\n循环变量的初始化表达式\n循环条件\n循环变量的修改的迭代表达式\n循环体语句块\n\n\n\n3.6    关键字：break使用场景：终止switch 或者 当前循环\n\n在选择结构switch语句中\n\n在循环语句中\n\n离开使用场景的存在是没有意义的\n\nbreak用于，跳出所在的当前整个循环，到外层代码继续执行。\n不管是哪种循环，一旦在循环体中遇到break，系统将完全结束循环，开始执行循环之后的代码。 \nbreak不仅可以结束其所在的循环，还可结束其外层循环。此时需要在break后紧跟一个标签，这个标签用于标识一个外层循环。\nJava中的标签就是一个紧跟着英文冒号（:）的标识符。且它必须放在循环语句之前才有作用。\npublic class BreakTest\n&#123;\n　　public static void main(String[] args)&#123;\n　　　　&#x2F;&#x2F; 外层循环，outer作为标识符\n　　　　outer:\n　　　　for (int i &#x3D; 0 ; i &lt; 5 ; i++ )&#123;\n　　　　　　&#x2F;&#x2F; 内层循环\n　　　　　　for (int j &#x3D; 0; j &lt; 3 ; j++ )&#123;\n　　　　　　　　System.out.println(&quot;i的值为:&quot; + i + &quot; j的值为:&quot; + j);\n　　　　　　　　if (j &#x3D;&#x3D; 1)&#123;\n　　　　　　　　　　&#x2F;&#x2F; 跳出outer标签所标识的循环。\n　　　　　　　　　　　break outer;\n　　　　　　　　&#125;\n　　　　　　&#125;\n　　　　&#125;\n　　&#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n案例：从键盘输入一个大于1的自然数，判断它是否是素数 提示：素数是指大于1的自然数中，除了1和它本身以外不能再有其他因数的自然数，即某个素数n，在[2,n-1]范围内没有其他自然数可以把n整除\nclass Test07BreakExer1&#123;\n    public static void main(String[] args)&#123;\n        java.util.Scanner input &#x3D; new java.util.Scanner(System.in);\n\n        int num;\n        while(true)&#123;\n            &#x2F;&#x2F;true是常量，常量是编译期间就可以确定的值\n            System.out.print(&quot;请输入一个大于1的自然数：&quot;);\n            num &#x3D; input.nextInt();\n\n            if(num&gt;1)&#123;\n                break;\n            &#125;\n        &#125;\n        System.out.println(&quot;num &#x3D; &quot; + num);\n\n        boolean flag &#x3D; true;&#x2F;&#x2F;假设num是素数\n\n        &#x2F;&#x2F;判断它是否是素数\n        for(int i&#x3D;2; i&lt;num; i++)&#123;\n            if(num % i &#x3D;&#x3D;0)&#123;&#x2F;&#x2F;num被某个i整除了，num就不是素数\n                System.out.println(num + &quot;不是素数&quot;);\n                flag &#x3D; false;\n                break;&#x2F;&#x2F;找到其中一个可以把num整除的数，就可以结束了，因为num已经可以判定不是素数了\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F;只有把[2,num-1]之间的所有数都检查过了，才能下定结论，num是素数\n        if(flag)&#123;\n            System.out.println(num + &quot;是素数&quot;);\n        &#125;\n\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n案例：从键盘输入不断输入整数，输入0表示结束，统计一共有几个正数、负数。\npublic static void main(String[] args) &#123;\n    java.util.Scanner input &#x3D; new java.util.Scanner(System.in);\n\n    int positive &#x3D; 0;\n    int negative &#x3D; 0;\n    while(true)&#123;\n        System.out.print(&quot;请输入整数（0）结束：&quot;);\n        int num &#x3D; input.nextInt();\n        if(num&#x3D;&#x3D;0)&#123;\n            break;\n        &#125;else if(num&gt;0)&#123;\n            positive++;\n        &#125;else&#123;\n            negative++;\n        &#125;\n    &#125;\n    System.out.println(&quot;正数：&quot; + positive + &quot;，负数：&quot; + negative);\n&#125;\n\n3.7    关键字：continue执行continue操作，跳出本次循环，从下一个迭代继续运行循环，内层循环执行完毕，外层代码继续运行。\ncontinue结束的是本次循环，将接着开始下一次循环。\n3.8    returnreturn关键字并不是专门用于跳出循环的，return的功能是结束一个方法。 一旦在循环体内执行到一个return语句，return语句将会\n结束该方法，循环自然也随之结束。\n四、综合案例","slug":"02-流程控制语句","date":"2021-09-13T14:34:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"7f9eaea51aac5991b1ad0d8e6f097110","title":"基础知识","content":"一、终端命令（Windows）\n\n\n命令\n说明\n\n\n\n盘符名称：\n盘符切换，d: 表示切换到d盘\n\n\ndir\n查看当前路径下的内容\n\n\ncd\n查看当前路径\n\n\ncd  目录\n进入单级目录\n\n\ncd  ..\n回退到上一-级目录\n\n\ncd\\\n回退到盘符目录\n\n\ncls\n清屏\n\n\nexit\n退出命令提示符窗口\n\n\n\n\n\n命令\n说明\n\n\n\ncalc\n启动计算器\n\n\nappwiz.cpl\n程序和功能\n\n\ncleanmgr\n打开磁盘清理工具\n\n\ncontrol\n控制面板\n\n\ndevmgmt.msc\n设备管理器\n\n\nexplorer\n资源管理器\n\n\ngpedit.msc\n组策略\n\n\nmspaint\n画图\n\n\nnotpad\n记事本\n\n\nregedit.exe\n注册表\n\n\nstikyNot\n便签\n\n\nwrite\n写字板\n\n\n二、注释分类• 单行注释格式：//信息\n• 多行注释格式：/信息/    \n• 文档注释格式：/*信息/\n三、八大数据类型\n\n\n简单类型\nboolean\nbyte\nchar\nshort\nInt\nlong\nfloat\ndouble\n\n\n\n二进制位数\n1\n8\n16\n16\n32\n64\n32\n64\n\n\n封装器类\nBoolean\nByte\nCharacter\nShort\nInteger\nLong\nFloat\nDouble\n\n\n对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。如：\n例如：基本类型byte 二进制位数：Byte.SIZE 最小值：Byte.MIN_VALUE 最大值：Byte.MAX_VALUE\n\nbyte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。\n\nshort：16位，最大数据存储量是65536，数据范围是-32768~32767之间。\n\nint：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。\n\nlong：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。\n\nfloat：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。\n\ndouble：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。\n\nboolean：只有true和false两个取值。\n\nchar：16位，存储Unicode码，用单引号赋值。\n\n* jvm 内存空间\n\n  （1）. Heap 堆空间：分配对象 new Student（）\n\n  （2）. Stack 栈空间：临时变量 Student stu\n\n  （3）. Code 代码区 ：类的定义，静态资源 Student.class\n  \n* eg：Student stu &#x3D; new Student（）； &#x2F;&#x2F;new 在内存的堆空间创建对象\n\n  stu.study(); &#x2F;&#x2F;把对象的地址赋给stu引用变量\n\n  上例实现步骤：\n  \n  a.JVM加载Student.class 到Code区\n\n  b.new Student()在堆空间分配空间并创建一个Student实例；\n  \n  c.将此实例的地址赋值给引用stu， 栈空间；\n\n\n\n四、三大引用数据类型\n类 Class    接口 Interface    数组 Array\n\n八种基本类型在java中都有对应的 封装类型，也就是 引用类型：\n整数类型 Byte、Short、Integer、Long浮点数类型 Float、Double字符型 Character布尔类型 Boolean\n\n\n五、数据转换简单类型数据间的转换,有两种方式: 自动转换 和 强制转换, 通常发生在表达式中或方法的参数传递时.\n\n自动转换\n具体地讲,当一个较”小”数据与一个较”大”的数据一起运算时,系统将自动将”小”数据转换成”大”数据,再进行运算\n这里我们所说的”大”与”小”,并不是指占用字节的多少,而是指表示值的范围的大小\n这些类型由”小”到”大”分别为 (byte，short，char)–int–long–float—double\na 如果低级类型为char型，向高级类型（整型）转换时，会转换为对应ASCII码值\nb 对于byte,short,char三种类型而言，他们是平级的，因此不能相互自动转换，可以使用强制类型转换\n\n\n强制类型转换\n将”大”数据转换为”小”数据时，使用强制类型转换\n格式： 用圆括号括起来目标类型，置于变量前例如： int n=(int)3.14159/2;\n这种转换肯定可能会导致溢出或精度的下降\n\n\n六、标识符1. 标识符是用户编程时使用的名字，用于给类、方法、变量、常量等命名。\n\n2. Java中标识符的组成规则：\n   \n   由字母、数字、下划线“_”、美元符号“$”组成，第一个字符不能是数字\n   \n   不能使用java中的关键字作为标识符\n   \n   标识符对大小写敏感（区分大小写）\n\n3. Java中标识符的命名约定：\n\n   * 小驼峰式命名：变量名、方法名\n   \n     首字母小写，从第二个单词开始每个单词的首字母大写\n   \n   * 大驼峰式命名：类名\n   \n     每个单词的首字母都大写\n     \n4. 标识符的命名最好可以做到见名知意\n\n七、进制（了解）7.1    计算机中，数字共有四种不同进制的表示方式\n\n\n十进制\n二进制\n八进制\n十六进制\n\n\n\n0\n0\n0\n0\n\n\n1\n1\n1\n1\n\n\n2\n10\n2\n2\n\n\n3\n11\n3\n3\n\n\n4\n100\n4\n4\n\n\n5\n101\n5\n5\n\n\n6\n110\n6\n6\n\n\n7\n111\n7\n7\n\n\n8\n1000\n10\n8\n\n\n9\n1001\n11\n9\n\n\n10\n1010\n12\na或A\n\n\n11\n1011\n13\nb或B\n\n\n12\n1100\n14\nc或C\n\n\n13\n1101\n15\nd或D\n\n\n14\n1110\n16\ne或E\n\n\n15\n1111\n17\nf或F\n\n\n16\n10000\n20\n10\n\n\n7.2    代码中不同进制的表示方式\n十进制：默认就是十进制\nSystem.out.println(10);\n二进制：0b或0B开头\nSystem.out.println(0B10);\n八进制：0开头\nSystem.out.println(010);\n十六进制：0x或0X开头\nSystem.out.println(0X10);\n\n7.3    进制转换\n十进制转二进制、八进制和十六进制\n二进制、八进制和十六进制 转换成为 十进制\n二进制、八进制和十六进制相互转换\n\n\n7.4    计算机存储单位\n位（bit）：是数据存储的最小单位，也就是二进制。二进制数系统中，每个0或1就是一个位，叫做bit（比特）\n\n字节（Byte）：是计算机信息技术用于计量存储容量的一种计量单位，也是是计算机的基本存储单位，一字节等于八位。\n\n转换关系：\n\n8 bit = 1 Byte\n1024 Byte = 1 KB\n1024 KB = 1 MB\n1024 MB = 1 GB\n1024 GB = 1 TB\n\n\n\n7.5    数据二进制表示\n原码\n反码\n补码\n\n八、运算符8.1    运算符和表达式运算符：对常量或者变量进行操作的符号\n表达式：用运算符把常量或者变量连接起来符合java语法的式子就可以称为表达式。\n例如：int c = a + b;    +是运算符   a+b 是表达式\n8.2    算术运算符\n\n\n算术运算符\n符号解释\n\n\n\n+\n加法运算，字符串连接运算，正号\n\n\n-\n减法运算，负号\n\n\n*\n乘法运算\n\n\n/\n除法运算，整数/整数结果还是整数\n\n\n%\n求余运算，余数的符号只看被除数\n\n\n++ 、 --\n自增自减运算\n\n\n\n注意：\n/和%的区别：两个数据做除法，/取结果的商，%取结果的余数。\n整数操作只能得到整数，要想得到小数，必须有浮点数参与运算\n\nchar类型参与算术运算，使用的是计算机底层对应的十进制数值。需要我们记住三个字符对应的数值：‘a’ – 97 a-z是连续的，所以’b’对应的数值是98，’c’是99，依次递加‘A’ – 65 A-Z是连续的，所以’B’对应的数值是66，’C’是67，依次递加‘0’ – 48 0-9是连续的，所以’1’对应的数值是49，’2’是50，依次递加\n\n\n当“+”操作中出现 字符串 时，这个”+”是字符串连接符，而不是算术运算。\n“itheima”+ 666; // 输出：itheima666\n\n自增自减运算符\n符号  作用  说明++     自增  变量的值加1–       自减  变量的值减1\n\n注意事项：自加自减运算\n++ 运算，变量自己的值加1。反之，-- 运算，变量自己的值减少1，用法与++ 一致。\n先自增运算符: ++在前，先自加，后赋值，例如, ++a;\n后自增运算符: ++在后，先赋值，后自加，例如, a++;\n\n\n8.3    赋值运算符\n\n\n赋值运算符\n符号解释\n\n\n\n=\n将符号右边的值，赋值给左边的变量\n\n\n+=\n将符号**左边的值和右边的值进行相加操作，最后将结果赋值给左边的变量**\n\n\n-=\n将符号**左边的值和右边的值进行相减操作，最后将结果赋值给左边的变量**\n\n\n*=\n将符号**左边的值和右边的值进行相乘操作，最后将结果赋值给左边的变量**\n\n\n/=\n将符号**左边的值和右边的值进行相除操作，最后将结果赋值给左边的变量**\n\n\n%=\n将符号**左边的值和右边的值进行取余操作，最后将结果赋值给左边的变量**\n\n\n* 赋值运算符的作用是将一个表达式的值赋给左边，左边必须是可修改的，不能是常量        \n\n8.4    关系运算符\n\n\n关系运算符\n符号解释\n\n\n\n&lt;\n比较符号左边的数据是否小于右边的数据，如果小于结果是true。\n\n\n&gt;\n比较符号左边的数据是否大于右边的数据，如果大于结果是true。\n\n\n&lt;=\n比较符号左边的数据是否小于或者等于右边的数据，如果大于结果是false。\n\n\n&gt;=\n比较符号左边的数据是否大于或者等于右边的数据，如果小于结果是false。\n\n\n==\n比较符号两边数据是否相等，相等结果是true。\n\n\n！=\n不等于符号 ，如果符号两边的数据不相等，结果是true。\n\n\n* 注意事项：\n     关系运算符的结果都是boolean类型，要么是true，要么是false。\n     千万不要把“&#x3D;&#x3D;”误写成“&#x3D;”，&quot;&#x3D;&#x3D;&quot;是判断是否相等的关系，&quot;&#x3D;&quot;是赋值。\n\n8.4    逻辑运算符\n\n\n逻辑运算符\n符号解释\n运算规则\n\n\n\n&amp;\n逻辑与,逻辑且\n只有所有的运算数都是true,结果才是true,只要有一个是false,结果就是false\n\n\n|\n逻辑或\n只有所有的运算数都是false,结果才是flase,只要有一个是true,结果就是true\n\n\n^\n逻辑异或\n相同为false，不同为true\n\n\n!\n逻辑非\n非false则true，非true则false\n\n\n&amp;&amp;\n双与，短路与\n左边为false，则右边就不看\n\n\n||\n双或，短路或\n左边为true，则右边就不看\n\n\n* 用来连接两个布尔类型结果的运算符（!除外），以判断程序中的表达式是否成立，判断的结果是 true 或 false。\n\n* 短路逻辑运算符\n     符号   作用    说明\n     &amp;&amp;    短路作用和&amp;相同，但是有短路效果\n     ||    短路或  作用和|相同，但是有短路效果\n     \n     在逻辑与运算中，只要有一个表达式的值为false，那么结果就可以判定为false了，没有必要将所有表达式的值都计算出来，\n     短路与操作就有这样的效果，可以提高效率。\n     同理在逻辑或运算中，一旦发现值为true，右边的表达式将不再参与运算\n     \n     逻辑与&amp;，无论左边真假，右边都要执行。\n     短路与&amp;&amp;，如果左边为真，右边执行；如果左边为假，右边不执行。\n     逻辑或|，无论左边真假，右边都要执行。\n     短路或||，如果左边为假，右边执行；如果左边为真，右边不执行。\n\n8.5    三元运算符\n运算符格式关系表达式 ? 表达式1 : 表达式2;\n解释：问号前面的位置是判断的条件，判断结果为boolean型，为true时调用表达式1，为false时调用表达式2。 其逻辑为：如果条件表达式成立或者满足则执行表达式1，否则执行第二个。\n\n\n\n8.6    位运算符\n\n\n位运算符\n运算规则\n\n\n\n&amp;\n按位与，同为1则为1,否则为0\n\n\n|\n按位或，只要有一个为1则为1,否则为0\n\n\n~\n按位取反，将操作数的每个位（包括符号位）全部取反\n\n\n^\n按位异或,相同时返回0，不同时返回1\n\n\n&lt;&lt;\n左移运算符\n\n\n&gt;&gt;\n右移运算符\n\n\n&gt;&gt;&gt;\n无符号右移运算符\n\n\n位运算是将数字转换成为二进制然后再进行运算，它的运算过程都是基于补码的。\n\n思考：如何区分&amp;,|,^是逻辑运算符还是位运算符？\n\n如果操作数是boolean类型，就是逻辑运算符，如果操作数是整数，那么就位运算符。\n\n8.6.1    左移：&lt;&lt;运算规则：左移几位就相当于乘以2的几次方\n注意：当左移的位数n超过该数据类型的总位数时，相当于左移（n-总位数）位\n8.6.2    右移：&gt;&gt;快速运算：类似于除以2的n次，如果不能整除，向下取整\n8.6.3    无符号右移：&gt;&gt;&gt;运算规则：往右移动后，左边空出来的位直接补0，不看符号位\n正数：和右移一样\n负数：右边移出去几位，左边补几个0，结果变为正数\n8.6.4    按位与：&amp;运算规则：对应位都是1才为1\n             1 &amp; 1 结果为1\n \n             1 &amp; 0 结果为0\n\n​                 0 &amp; 1 结果为0\n​                 0 &amp; 0 结果为0\n8.6.5    按位或：|运算规则：对应位只要有1即为1\n 1 | 1 结果为1\n 1 | 0 结果为1\n 0 | 1 结果为1\n 0 &amp; 0 结果为0\n8.6.6    按位异或：^ 运算规则：对应位一个为1一个为0，才为1\n 1 ^ 1 结果为0\n 1 ^ 0 结果为1\n 0 ^ 1 结果为1\n 0 ^ 0 结果为0\n8.6.7    按位取反运算规则：~0就是1\n ~1就是0\n8.7    运算符优先级\n\n\n优先级\n运算符\n\n\n\n1\n()\n\n\n2\n!、+、-、~、++、–\n\n\n3\n、/、%\n\n\n4\n+、-\n\n\n5\n«、»、&gt;&gt;&gt;\n\n\n6\n&lt;、&lt;=、&gt;、&gt;=、instanceof\n\n\n7\n==、!=\n\n\n8\n&amp;\n\n\n9\n^\n\n\n10\n|\n\n\n11\n&amp;&amp;\n\n\n12\n||\n\n\n13\n=、+=、-=、=、/=、&amp;=、|=、^=、~=、«=、»=、&gt;&gt;&gt;=\n\n\n要求:\n\n表达式不要太复杂\n对于比较复杂的表达式，要求使用()来提升运算符的优先级。\n一般而言，单目运算符优先级较高，赋值运算符优先级较低。\n算术运算符优先级较高，关系和逻辑运算符优先级较低。\n\n九、高级输出语句9.1    转义字符的使用\n\n\n转义字符\n作用\n\n\n\n\\t\n表示一个制表符(tab键)\n\n\n\\n\n表示换行\n\n\n\\r\n表示回车\n\n\n\\ ‘\n表示一个单引号\n\n\n\\ “\n表示一个双引号\n\n\n\\\n表示一个\\\n\n\n9.2    格式化输出使用System.out.printf方法传入占位符还能实现格式化输出。常见的格式化占位符如下:\n\n\n\n占位符\n含义\n示例\n输出结果\n\n\n\n%d\n表示整数(byte,short,int,long类型)\nSystem.out.printf(“我今年%d岁了”,18);\n我今年18岁了\n\n\n%nd\n如果整数不够n位，前面使用空格补齐\nSystem.out.printf(“我是第%3d号选手”,8);\n我是第 8号选手\n\n\n%0nd\n如果整数不够n位，前面使用0补齐\nSystem.out.printf(“我是第%03d号选手”,8);\n我是第008号选手\n\n\n%-nd\n如果整数不够n位，后面使用空格补齐\nSystem.out.printf(“我是第%-3d号选手”,8);\n我是第8 号选手\n\n\n%.nf\n表示浮点数四舍五入保留到小数点后n位\nSystem.out.printf(“您卡上的余额是%.2f元”,34.5678);\n您卡上的余额是34.57元\n\n\n%c\n表示单个字符\nSystem.out.printf(“我的幸运字母是%c”,’s’);\n我的幸运字母是s\n\n\n%s\n表示字符串\nSystem.out.printf(“我的名字是是%s”,”张三”);\n我的名字是张三\n\n\n%%\n表示%\nSystem.out.printf(“我的名字是是%%d”);\n我的名字是%d\n\n\n十、几个关键字10.1    class类\nclass 关键字用来声明新的 Java 类，该类是相关变量和/或方法的集合。\n类是面向对象的程序设计方法的基本构造单位。\n类通常代表某种实际实体，如几何形状或人。类是对象的模板。每个对象都是类的一个实例.\n\n10.2    native 本地native 关键字可以应用于方法，以指示该方法是用 Java 以外的语言实现的可以将native方法比作Java程序同Ｃ程序的接口，其实现步骤：１、在Java中声明native()方法，然后编译；２、用javah产生一个.h文件；３、写一个.cpp文件实现native导出方法，其中需要包含第二步产生的.h文件（注意其中又包含了JDK带的jni.h文件）；４、将第三步的.cpp文件编译成动态链接库文件；５、在Java中用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问了。 \n10.3    synchronized\nsynchronized 关键字可以应用于方法或语句块，并为一次只应由一个线程执行的关键代码段提供保护。 \nsynchronized 关键字可防止代码的关键代码段一次被多个线程执行。 \n如果应用于静态方法，那么，当该方法一次由一个线程执行时，整个类将被锁定。 \n如果应用于实例方法，那么，当该方法一次由一个线程访问时，该实例将被锁定。 \n如果应用于对象或数组，当关联的代码块一次由一个线程执行时，对象或数组将被锁定。\n\n10.4    static、abstract、final、implements在面向对象详细介绍\n","slug":"01-基础知识","date":"2021-09-13T14:33:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"}]