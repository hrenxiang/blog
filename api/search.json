[{"id":"8eb5da915bb87dd80146b401007f8494","title":"iterm的使用","content":"一、安装zsh一定先执行zsh --version检查是否已安装zsh。\n返回类似zsh 5.7.1的内容说明可以跳过zsh直接安装iTerm2。\n1、macOSmacOS最新系统已经内置zsh，所以你很可能不需要执行这一步操作。\n安装Homebrew可以访问：https://brew.idayer.com/ ，教你如何飞速安装Homebrew。\nbrew install zsh\n\n设置为默认：\nchsh -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;zsh\n\n更多平台安装方法请浏览 Installing-ZSH 。\n二、安装iTerm21、下载iTerm2是macOS平台上终端的替代方案，功能也更强大，目前支持macOS 10.14及更高版本。\n你可以直接从官网下载iTerm2。\n2、把iTerm2设为默认iTerm2 -&gt; Make ITerm2 Default Term\n三、安装oh-my-zsh1、选择其中一种脚本安装curl（这种即可）：\nsh -c &quot;$(curl -fsSL https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;tools&#x2F;install.sh)&quot;\n\nwget：\nexport REMOTE&#x3D;https:&#x2F;&#x2F;gitee.com&#x2F;imirror&#x2F;ohmyzsh.git\nsh -c &quot;$(wget -O- https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;tools&#x2F;install.sh)&quot;\n\nfetch：\nexport REMOTE&#x3D;https:&#x2F;&#x2F;gitee.com&#x2F;imirror&#x2F;ohmyzsh.git\nsh -c &quot;$(fetch -o - https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;tools&#x2F;install.sh)&quot;\n\n四、配置主题官方收集了一些主题（不再收录新主题），你可以访问 主题&amp;&amp;截图 页面查看并选取。\n这里以Dracula为例说明。\n1、下载主题文件git clone https:&#x2F;&#x2F;github.com&#x2F;dracula&#x2F;zsh.git ~&#x2F;Downloads\n\n在下载中将压缩包解压\n移动主题文件 dracula.zsh-theme 到 ~/.oh-my-zsh/themes/ 下\n然后移动压缩包中 lib 文件夹中的文件到 ~/.oh-my-zsh/thems/lib （没有 lib 就创建）\n2、编辑~/.zshrc文件# 启用相关主题\nZSH_THEME&#x3D;&quot;dracula&quot;\n\n# 添加 bash中的环境变量到 ~&#x2F;.zshrc 中\nsource ~&#x2F;.bash_profile\n\n# 保存退出\nwq\n\n# 在外面重新加载 配置文件\nsource ~&#x2F;.zshrc\n\n# 主题介绍请访问 https:&#x2F;&#x2F;github.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;wiki&#x2F;Themes （dracula不在这里）\n\n3、安装字体大部分主题都用到了 Powerline Fonts  ，我们可以直接安装 Powerline Fonts 中的全部字体\n将字体安装包下载到一个文件夹内\ngit clone https:&#x2F;&#x2F;github.com&#x2F;powerline&#x2F;fonts.git  ~&#x2F;iterm2&#x2F;fonts\n\n进入文件夹\ncd ~&#x2F;iterm2&#x2F;fonts\n\n安装字体\n.&#x2F;install.sh\n\n安装完成后，字体文件可以保存，也可以删除\n4、选择字体然后打开iTerm -&gt; Preferences -&gt; Profiles -&gt; Text -&gt; Change Font，选择Meslo LG S Regular for Powerline （只要是 poweline 的任意一种就可以）。\n重新打开iTerm2就能看到效果。\n5、其他主题设置如果没有找到满意的主题，可以试下 更多主题 。\n你也可以试下random，不用纠结选择哪个主题：\nZSH_THEME&#x3D;&quot;random&quot;\n\n指定参与随机的主题：\nZSH_THEME_RANDOM_CANDIDATES&#x3D;(\n  &quot;robbyrussell&quot;\n  &quot;agnoster&quot;\n)\n\n也可以排除主题：\nZSH_THEME_RANDOM_IGNORED&#x3D;(pygmalion tjkirch_mod)\n\n\n\n五、功能增强1、zsh-autosuggestions命令自动补全功能。\n1、克隆代码到$ZSH_CUSTOM/plugins（默认位于~/.oh-my-zsh/custom/plugins）\ngit clone https:&#x2F;&#x2F;gitee.com&#x2F;imirror&#x2F;zsh-autosuggestions.git $&#123;ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom&#125;&#x2F;plugins&#x2F;zsh-autosuggestions\n\n最后执行source ~/.zshrc生效。\n2、在Oh My Zsh配置启用插件\n打开~/.zshrc，找到plugins，追加zsh-autosuggestions。\ngit为默认配置。\nplugins&#x3D;(git zsh-autosuggestions)\n\n如果有看不到自动补全的内容，确保以下两个颜色不是相近的：\niTerm &gt; Preferences &gt; Profiles &gt; Colors &gt; ANSI Colors &gt; Bright &gt; Black\niTerm &gt; Preferences &gt; Profiles &gt; Colors &gt; Basic Colors &gt; Background\n\n2、zsh-syntax-highlighting语法高亮。\n1、克隆代码到$ZSH_CUSTOM/plugins（默认位于~/.oh-my-zsh/custom/plugins）\ngit clone https:&#x2F;&#x2F;gitee.com&#x2F;imirror&#x2F;zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom&#125;&#x2F;plugins&#x2F;zsh-syntax-highlighting\n\n2、在Oh My Zsh配置启用插件\n打开~/.zshrc，找到plugins，追加zsh-autosuggestions。\ngit为默认配置。\nplugins&#x3D;(git zsh-autosuggestions zsh-syntax-highlighting)\n\n最后执行source ~/.zshrc生效。\n六、番外篇1、iTerm2一键ssh连接远程服务器配置1、编写一个文件，内容如下，把对应的中文改成你的服务器相关内容就行，这里我将其编写为txt文本文件，放到用户目录下的 .zsh 文件夹下 (  ~/.zsh/aliyun.txt  )\n#!&#x2F;usr&#x2F;bin&#x2F;expect -f\n  set user 用户名\n  set host ip地址\n  set password 密码\n  set timeout -1\n  \n  spawn ssh $user@$host\n  expect &quot;*assword:*&quot;\n  send &quot;$password\\r&quot;\n  interact\n  expect eof\n\n2、打开iTerm2，打开设置(Preferences)，点击Profiles，点左下角+\n3、以后在终端界面直接点击即可连接到服务器\n\n2、一些功能和快捷键\n鼠标选中即复制\n\ncommand + d 垂直分屏\n\ncommand + shift + d 水平分屏\n\ncommand + shift + h 打开剪切板(复制历史)\n\ncommand + ; 命令自动完成\n\ncommand + shift + ; 查看历史命令\n\ncommand + option + b 按键回放(输入命令回放, 通过时间线)\n\ncommand+方向键: 切换tab。\n\ncommand+enter: 全屏模式。\n\ncommand+f: 搜索，支持正则表达式。\n\ncommand+[ 或 command +]: 在最近使用的分屏直接切换。\n\ncommand+t: 打开新标签。\n\ncommand+w: 关闭新标签。\n\ncommand+;: 自动补全历史命令。\n\ncommand+r: 清除屏幕，相当与clear.\n\ncommand+p/n: 上一条/下一条命令，相当于方向键上和下。\n\nctrl+r: 搜索命令历史。\n\n\n1、光标快速切换到行尾行首\n   ctrl+a 行首\n   ctrl+e 行尾\n2、删除至行尾\n   ctrl+k\n3、使用alias命令查看一些命令的简写","slug":"iterm的使用","date":"2021-09-13T14:32:32.000Z","categories_index":"Mac相关","tags_index":"Mac终端","author_index":"大黄"},{"id":"97e5d14896602922a9c354542d00c374","title":"HomeBrew 基本使用","content":"1、搜索包brew search mysql\n\n\n\n2、安装包brew install mysql\n\n\n\n3、查看包信息注意：比如查看目前的版本，依赖，安装后注意事项等\nbrew info mysql\n\n\n\n4、卸载包brew uninstall wget\n\n\n\n5、显示已安装的包brew list\n\n\n\n6、查看brew的帮助brew –help\n\n\n\n7、更新注意：这会更新 Homebrew 自己\nbrew update\n\n\n\n8、检查过时注意：（是否有新版本），这会列出所有安装的包里，哪些可以升级\nbrew outdated\nbrew outdated mysql\n\n\n\n9、升级所有可以升级的软件brew upgrade\nbrew upgrade mysql\n\n\n\n10、清理不需要的版本极其安装包缓存brew cleanup\nbrew cleanup mysql\n\n\n\n11、brew 查看源配置在目录中可以通过git remote get-url origin来查看当前的源的URL。\ngit -C &quot;$(brew --repo)&quot; remote get-url origin\ngit -C &quot;$(brew --repo homebrew&#x2F;core)&quot; remote get-url origin \ngit -C &quot;$(brew --repo homebrew&#x2F;cask)&quot; remote get-url origin \n\n\n\n12、brew 修改国内源清华源\n# 替换brew.git\ncd &quot;$(brew --repo)&quot;\ngit remote set-url origin https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;git&#x2F;homebrew&#x2F;brew.git\n\n# 替换homebrew-core.git\ncd &quot;$(brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core&quot;\ngit remote set-url origin https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;git&#x2F;homebrew&#x2F;homebrew-core.git\n\n# 刷新源\nbrew update\n\n阿里云\n# 替换brew.git\ncd &quot;$(brew --repo)&quot;\ngit remote set-url origin https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;homebrew&#x2F;brew.git\n\n# 替换homebrew-core.git\ncd &quot;$(brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core&quot;\ngit remote set-url origin https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;homebrew&#x2F;homebrew-core.git\n\n# 刷新源\nbrew update\n\n腾讯源\n替换brew.git:\ncd &quot;$(brew --repo)&quot;\ngit remote set-url origin https:&#x2F;&#x2F;mirrors.cloud.tencent.com&#x2F;homebrew&#x2F;brew.git\n\n替换homebrew-core.git:\ncd &quot;$(brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core&quot;\ngit remote set-url origin https:&#x2F;&#x2F;mirrors.cloud.tencent.com&#x2F;homebrew&#x2F;homebrew-core.git\n\n# 刷新源\nbrew update\n\n默认值，可以通过以下三个命令设置为默认值，最后需要更新\ngit -C &quot;$(brew --repo)&quot; remote set-url origin &#39;https:&#x2F;&#x2F;github.com&#x2F;Homebrew&#x2F;brew.git&#39;\n\ngit -C &quot;$(brew --repo homebrew&#x2F;core)&quot; remote set-url origin &#39;https:&#x2F;&#x2F;github.com&#x2F;Homebrew&#x2F;homebrew-core.git&#39;\n\ngit -C &quot;$(brew --repo homebrew&#x2F;cask)&quot; remote set-url origin &#39;https:&#x2F;&#x2F;github.com&#x2F;Homebrew&#x2F;homebrew-cask.git&#39;\n\nbrew update\n\n\n\n13、安装 homebrew&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;ineo6&#x2F;homebrew-install&#x2F;install)&quot;\n\n该脚本用了中科大镜像加速访问，仅修改仓库地址部分，不会产生安全隐患。 关于中科大所提供的 Homebrew 镜像服务 https://lug.ustc.edu.cn/wiki/mirrors/help/brew.git\n注：注意这里的速度，几百kib/s或几m/s才是正常的。若只有几kib/s，通常为无效的安装方法，一般加载了百分之几十后就会报错。\n然后还需设置环境变量，具体操作步骤如下，一定要仔细阅读。\n\n在终端执行命令echo $SHELL获得终端类型：\n\n/bin/zsh =&gt; zsh =&gt; .zprofile\n/bin/bash =&gt; bash =&gt; .bash_profile\n\n\n如果看到的是/bin/zsh\necho &#39;eval &quot;$(&#x2F;opt&#x2F;homebrew&#x2F;bin&#x2F;brew shellenv)&quot;&#39; &gt;&gt; ~&#x2F;.zprofile\neval &quot;$(&#x2F;opt&#x2F;homebrew&#x2F;bin&#x2F;brew shellenv)&quot;\n\n如果看到的是/bin/bash\necho &#39;eval &quot;$(&#x2F;opt&#x2F;homebrew&#x2F;bin&#x2F;brew shellenv)&quot;&#39; &gt;&gt; ~&#x2F;.bash_profile\neval &quot;$(&#x2F;opt&#x2F;homebrew&#x2F;bin&#x2F;brew shellenv)&quot;\n\n\n\n\n\n\n\n\n\n\n从macOS Catalina(10.15.x) 版开始，Mac使用zsh作为默认Shell。\n14、homebrew 组成\n\n\n组成\n功能\n\n\n\nHomebrew\n源代码仓库\n\n\nhomebrew-core\nHomebrew 核心源\n\n\nhomebrew-cask\n提供macos应用和大型二进制文件的安装\n\n\nhomebrew-bottles\n预编译二进制软件包\n\n\n15、删除 homebrew&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;ineo6&#x2F;homebrew-install&#x2F;uninstall)&quot;\n\n\n\n16、下载可视化界面官网：https://www.cakebrew.com/\ngithub：https://github.com/brunophilipe/Cakebrew/releases\n","slug":"HomeBrew基本使用","date":"2021-09-13T14:30:32.000Z","categories_index":"Mac相关","tags_index":"Mac终端","author_index":"大黄"},{"id":"28f9cbb3f87fb083ac5744977081fb5c","title":"你好\thexo","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"你好 hexo !","date":"2021-09-13T14:28:32.000Z","categories_index":"","tags_index":"Mac终端","author_index":"大黄"},{"id":"88ccd4775101a2a1232ec4d83ea6f5c4","title":"集合（下）","content":"一、Collections\n\n\n要点\n\n\n\n工具类，随机排序方法shuffle，，反转元素方法reverse以及升序排序方法sort\n\n\ncollection：单列集合的父接口\n\ncollections：他是集合操作的一种 工具类，类中的方法全部是静态的，可以进行查找，排序等操作\n\nCollections类的常用方法\n    * public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)：将指定的列表按升序排序\n    * public static void reverse(List&lt;?&gt; list)：反转指定列表中元素的顺序\n    * public static void shuffle(List&lt;?&gt; list)：使用默认的随机源随机排列指定的列表（随机排列，洗牌）\n\n二、Map1、map简介\n一次添加一对元素，是双列集合\n其实map中存储的就是键值对\nmap集合必须保证键的唯一性\n\n2、map常用方法\nV put(K key,V value)：添加元素put方法中，若键第一次添加，则进行添加，若不是第一次添加，则对原有元素进行修改\nV remove(Object key)：根据键删除键值对元素\nvoid clear()：清空map集合内所有键值对\nboolean containsKey(Object key)：判断集合是否包含指定的键\nboolean containsValue(Object value)：判断集合是否包含指定的值\nboolean isEmpty()：判断集合是否为空\nint size()：集合的长度，也就是集合中键值对的个数\n\n3、map获取功能\nV get(Objectkey)：根据键获取值\nSet keySet()：获取所有键的集合\nCollection values()：获取所有值的集合\nSet&lt;Map.Entry&lt;K,V&gt; &gt; entrySet()：获取所有键值对对象的集合\n\n4、map两种遍历操作常用第二种，还有只获取值的方法，不过只获取值没意义\n\n获取所有 键的集合 使用 KeySet方法增强for遍历键的集合，得到每一个键随后使用map的 get方法，以键找值\n获取所有 键值对对象集合 使用entrySet方法遍历键值对对象集合，得到每一个对象使用 getKey和getValue 得到每个对象的键和值\n\n5、map的常用子类子类中的方法和map中的差不多\n\nHashTable: 内部结构是哈希表，是同步的，不允许 Null 作为建，null 作为值， \nProperties：用来存储键值对型配置文件的信息，可以和 IO 技术相结合。 \nHashMap：内部构造是哈希表，不是同步的。允许 null 键，null 为 null \nTreeMap：内部构造是二叉树，不是同步的，可以对 map 集合进行排序\n\n三、HashMap源码分析\n\n\n\n\n\n\n\n\n引用：https://blog.csdn.net/qq_31903733/article/details/95075601\n1、整体介绍HashMap实现Map接口，用于存储key-value结构，能够根据其key快速查找其value。底层实现为采用一个table数组的hash表，数组中的每一项为一个链表结构。对于每个key，先计算其hash值，然后根据hash值计算其在table数组中的位置，若该位置没有元素，则直接将其放置在该位置，否则，则出现hash冲突，需要遍历查看其所在bucket是否已经有该key了（通过hash和key进行比较），若有了直接替换该key对应的value，否则在链表头部插入。\n需要注意的是如果一个桶中元素大于某个阈值，在JDK8中会将其右链表转换为红黑树。而且对于哈希表（table数组）太满时（大于负载因子），需要对其进行再散列，负载因子默认为0.75，如果表中超过了75%的位置已经填入了元素，那么这个表就会用双倍的桶数自动进行再散列。\n2、源码解析1. 成员变量主要有以下几个成员变量\n&#x2F;*静态常量*&#x2F;\n&#x2F;&#x2F;初始容量：16\nstatic final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16\n&#x2F;&#x2F;负载因子：0.75\nstatic final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;\n&#x2F;&#x2F;链表转换为红黑树的阈值：大于8\nstatic final int TREEIFY_THRESHOLD &#x3D; 8;\n&#x2F;&#x2F;红黑数转换为链表的阈值：小于6\nstatic final int UNTREEIFY_THRESHOLD &#x3D; 6;\n\n&#x2F;*成员变量*&#x2F;\n&#x2F;&#x2F;哈希表数组\ntransient Node&lt;K,V&gt;[] table;\n&#x2F;&#x2F;存储HashMap中的key-value对\ntransient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;\n&#x2F;&#x2F;元素实际个数\ntransient int size;\n&#x2F;&#x2F;是否重新散列的阈值\nint threshold;\n&#x2F;&#x2F;负载因子\nfinal float loadFactor;\n123456789101112131415161718192021\n\n2. 存储结构主要存储结构为Node&lt;K,V&gt;\n的结点，用于表示链表结构。\n\n还有用于表示红黑树结构的\nTreeNode&lt;K,V&gt;\n\n\n3. 构造函数\n\n可以看到，构造函数里并没有对table数组初始化，JDK8的初始化是放在第一次添加的时候进行的。\n4. put方法这是HashMap里的最核心的方法了。\npublic V put(K key, V value) &#123;\n    return putVal(hash(key), key, value, false, true);\n&#125;\n123\n\n首先计算key的hash值，然后调用putValue方法。计算hash值的代码如下\nstatic final int hash(Object key) &#123;\n    int h;\n    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n&#125;\n1234\n\n5、hash函数这里有个问题：为什么这样不是直接计算hashCode呢，还要与高16位做异或运算？\n这里的hash函数相当于是一个打扰函数，最终是减少碰撞。因为我们是要根据hash值来计算其在table数组中的位置，也就是后面的tab[i = (n - 1) &amp; hash]，这里(n-1) &amp; hash\n相当于取模运算，但比取模更高效，因为table的长度始终是2的n次方(初始容量16，后面扩容时也始终&lt;&lt;1)，所以其低位相当于全是1，高位全是0，最终&amp;运算只保留hash的低位。所以在table容量较小时，如n-1为15(1111)，hash和其相与后真正参与运算的也就是低4位，高位都为0了，这样可能会增加碰撞。所以在计算hash函数中将其和右移16位的值（高位16位变成0，低16位为之前的高16位）进行异或，由于右移始终为0，所以异或后原来的高位保持不变（原来是1的还是1，0的为0），低位变成低位与高位的异或，这样增加了低位的随机性，混合了高位和低位，高位的信息也被保留在低位中了。\n\n6、putVal方法\n上述有几处需要注意的地方：\n\n1 首先是判断table是否为空，即初次添加，是则调用resize()函数进行初始化\n2 当没有发生碰撞时，即tab[(n-1) &amp; hash]位置为null，直接添加元素\n3 如果发生碰撞，则首先判断该位置的hash以及key是否相等，如相等则记录下来（后续直接替换）\n4 判断该位置结点是否是红黑树结构，是的话就执行红黑树的插入方法\n5 遍历找是否有和待插入元素相等的key，找到则替换，没有的话则直接在尾部插入（JDK8以前是在头部插入），插入后如果发现其大于转换为红黑树的阈值，则将其转换为红黑树结构\n\n7、resize方法\n\n8. get方法public V get(Object key) &#123;\n    Node&lt;K,V&gt; e;\n    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;\n&#125;\n1234\n\n其调用的是getNode方法，根据key的hash和key找到该值。\n\n9. remove方法也是和get方法相似，根据key的hash值找到对应位置，然后分情况删除。\n3、HashMap总结\n底层实现：数组+链表+红黑树，允许key为null\n负载因子的默认值是0.75：初始值大了，可减少哈希表的再散列(扩容的次数)，但同时会导致散列冲突的可能性变大。初始值小了，可以减小散列冲突的可能性，但同时扩容的次数可能就会变多。\n初始容量的默认值是16：初始容量过大，遍历时速度就会受影响，初始容量过小，散列表再散列(扩容的次数)可能就变得多\nHashMap在计算hash值并不是直接根据key的hashCode，而是将其和高16位进行异或，增加其随机性。\n并不是桶子上有8位元素的时候它就能变成红黑树，它得同时满足我们的散列表容量大于64才行.\n\n4、线程安全的HashMap由于HashMap是线程不安全的,即多个线程可以同时put、get等，这在多线程环境下会出现问题，所以java又提供了线程安全的HashMap。\n1. Hashtable与HashMap存储结构基本相同，底层实现是数组+链表，其是线程安全的，实现方式是对整个Hashtable加锁（基本在所有操纵Hashtable的方法上都加了sysynchronized进行同步，所以同一时间只允许一个线程操作），且不允许key和value为null，但是其实现效率较低，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。Hashtable默认初始容量为11，扩容方式为原始容量x2 + 1.\n2. ConcurrentHashMap与Hashtable一样都是用来实现线程安全的HashMap，但是却比Hashtable效率高很多。主要是因为其采用了锁分段的机制，将数据分段存储，每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，所以可以供多个线程同时访问，而不是像Hashtable那样锁住整个表，同一时刻只能有一个线程访问。\nConcurrentHashMap从JDK1.5开始随java.util.concurrent包一起引入JDK中，主要为了解决HashMap线程不安全和Hashtable效率不高的问题。\n3、补充：JDK8和7实现差异\nJDK7中使用的是分段锁机制，即将整个table分成多个Segment，对每个Segment加锁，即有一个Segment数组，每一个Segment都是一个单独的哈希表。在执行put操作时首先根据hash算法定位到元素属于哪个Segment，然后对该Segment加锁即可\nJDK8对其进行了优化，底层采用和Node数组+链表+红黑树（和HashMap类似），并发控制使用Synchronized和CAS来操作，其与HashMap更接近。\n\n","slug":"12-集合（下）","date":"2021-09-13T14:47:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"42c17c71eb42c16b2fd355c959a76eb9","title":"集合（上）","content":"一、为什么使用集合为什么我们不采用数组存对象呢？\n\n因为数组长度是固定，而我们很多时候对对象的个数是 不确定的。\n所以，我们产生了集合框架，它是用于存储对象的。\n\n二、集合和数组的区别\n集合长度是可变的，集合中不能存储基本数据类型值，只能存储对象(引用数据类型)。 \n数组的长度是固定的，可以存储对象，也可以存储基本数据类型。\n\n数组只能存储同一种类型，集合可以存储不同类型（但一般来说，集合也只存储同一类型）\n\n什么时候用哪个? 长度不固定，用集合。 长度固定，可以集合，可用数组。\n\n\n三、集合的体系结构\n---------| Collection 单例集合的根接口\n------------| List  如果是实现了List接口的集合类， 具备的特点：有序，重复。\n----------------| ArraryList  底层 是使用了Object数组实现的，特点： 查询速度快，增删慢。\n----------------| LinkedList 底层是使用了链表数据结构实现 的， 特点： 查询速度慢，增删快。\n----------------| Vector Vector的实现与ArrayList是一致，但是是线程安全 的，操作效率低。 jdk1.0的时候出现的\n------------| Set  如果是实现了Set接口的集合类，具备的特点：无序，不可重复。\n----------------| HashSet  底层是使用了一个哈希表支持的， 特点：存取速度快。\n----------------| TreeSet  底层实现为二叉树，元素有序（从小到大）\n---------| Map 双链集合的根接口\n---------------| HashMap  接口实现类，没有同步，线程不安全\n---------------| LinkedHashMap  双向链表和哈希表实现\n---------------| TreeMap  红黑树对所有的key进行排序\n\n四、泛型1、基本和引用数据类型区别\n基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接答存储在栈上。\n而引用专数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的属引用指向堆中对象的地址。\n在数据做为参数传递的时候，基本数据类型是值传递，而引用数据类型是引用传递（地址传递）。\n\n2、泛型的概念\njdk1.5出现的安全机制，解决类型安全的问题，只能用于编译时期，提高安全性\n\n3、泛型的好处\n将运行时期的问题 classCastExceptoin 转到了编译时期。 \n避免了强制转换的麻烦。\n\n4、泛型类的定义格式1. 泛型类,在类上自定义泛型，实在创建对象实现确定,没指定为object类型\n   格式:修饰符    class     类名&lt;T t&gt; &#123; &#125;\n   范例: public     class     Generic&lt;T&gt;&#123; &#125;\n   此处T可以随便写为任意标识，常见的如T、E、 K、V等形式的参数常用于表示泛型\n\n2. 自定义方法泛型 格式： \n   修饰符 &lt;T&gt; 返回类型 方法名（T 参数） &#123; &#125;\n   范例: public static &lt;T&gt; void println(T t) &#123; &#125;\n         public static &lt;E&gt; E call(E e) &#123; &#125;\n\n3. 泛型接口,在实现接口是指定类型，没指定为object\n   interface CallBack&lt;T&gt; &#123; &#125;\n\n5、类型通配符   为了表示各种泛型List的父类，可以使用类型通配符\n\n类型通配符: &lt;?&gt;\nList&lt;?&gt;:     表示元素类型未知的List,它的元素可以匹配任何的类型\n这种带通配符的List仅表示它是各种泛型List的父类，     并不能把元素添加到其中\n\n   如果说我们不希望List&lt;?&gt;是任何泛型List的父类，只希望它代表某一类泛型List的父类,可以使用\n\n类型通配符的上限\n类型通配符 上限: &lt;? extends类型&gt;\nList&lt;? extends      Number&gt;:  它表示的类型是Number或者其子类型\n\n\n类型通配符下限\n类型通配符下限: &lt;?super 类型&gt;\nList&lt;? super      Number&gt;:  它表示的类型是Number或者其父类型五、collection集合\n\n\n\n1、注意collection集合不能直接实现，使用更为具体的子接口实现。牢记各种方法\n2、collection集合概述\ncollection集合是==单例集合的顶层接口==，他表示一组对象，这些对象也称为collection的元素\nJDK不提供此接口直接的实现，他提供更为具体的子接口的实现（Set 和 List）\n\n3、创建collection对象\n多态的方式\n使用具体的实现类\n\n4、collection接口的方法1. 添加\n   * Boolean  add(E e): 成功返回true，失败false\n   * Boolean  addAll(): 在集合中添加另外一个集合\n2. 删除\n   * Boolean  remove(object obj): 删除一个对象，会改变集合的长度\n   * Boolean  remove(Collection con): 删除一个集合，还有两个集合中相同的元素\n   * void  clear(): 删除所有 \n3. 判断\n   * Boolean  contains(object obj): 在集合中是否包含指定的对象\n   * Boolean  containsAll(Collection con): 在集合中是否包含另一个集合\n   * Boolean  isEmpty(): 判断集合是否为空\n4. 获取\n   * int  size():  得到集合的尺寸大小    数组：length   字符串：length();\n   * Iterator iterator()：取出元素的方式。迭代器。\n   - E next():  返回迭代中的下一个元素\n   * boolean hasNext():  如果迭代具有更多元素，则返回true\n   * 迭代器将容器的取出方式和容器的数据结构相分离，降低了耦合性\n5. 集合转数组\n   * Obiect[] toArray():  把集合转换为对象\n\n六、List集合1、注意list集合，有序，可重复，通过索引进行查询，数组查询速度快，增删慢，链表查询慢，增删快   \n2、List集合的特点\n有序（存入和取出的顺序一致）\n元素都有索引（角标）\n存储元素可以重复（set集合不可）\n规律：凡是有索引的容器，都有增删改查的方法。\n\n3、List集合的方法\nvoid add(int index,E element)： 在此集合指定位置添加元素\n\nObject remove(index):删除指定的元素—-获取并删除\n\nObject set(index,element):在指定位置改变元素，并返回被替换掉的元素。\n\nObject get(index): 获取指定的元素\n\nint indexOf(object ):返回对象所在的位置 \nString s &#x3D; &quot;dd&quot;;\nint i &#x3D; list.indexOf(s);\nSystem.out.println(i);\nListIterator：拥有了对元素进行增删改查的方法——-&gt;list 特有的！\n\n\n4、常见数据结构\n数组查询数据通过索引定位，查询任意数据耗时相同，查询速率高删除数据时，要将原始数据删除，同时后面每个数据前移，删除效率低添加数据时，添加位置后的数据每个要后移，再添加元素，添加效率极低\n链表链表是一种查询慢，增删快的模型（对比 数组 而言）每次查询都要重头开始查询\n\n5、List 接口的子类\nVector: 内部是数组数据结构，是线程安全的。增删查询都很慢！（基本不用） \nArrayList: 内部是数组数据结构，是不同步的，代替了 vector.，查询的速度快内存原理： 在 arrayList 集合中，是一种线性表，每个对象存储都是有序的，用角标确定对象所存储的位置查询时，直接通过角标进行查询，速度会很快但是如果要进行增添、修改、删除操作的 话，就要影响后面角标的对象，大部分对象都要移动，直接影响运行效率。 \nLinkedList: 内部是链表结构，有很多自己特有的方法，查询慢，增删快，线程不安全\n\n6、List集合子类特点\nArrayList：底层数据结构是数组，查询快，增删慢，线程不安全，效率高，可以存储重复元素\nLinkedList:：底层数据结构是双链表，查询慢，增删快，线程不安全，效率高，可以存储重复元素，（包括null ）\n\n七、Set集合1、Set集合概述和特点Set集合没有特有方法，他的方法都来自Collection。\n2、Set集合特点\n不包含重复元素的集合\n没有带索引的方法， 所以不能使用普通for循环遍历\n\n3、哈希值\n哈希值: 是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值\nObject类中有一一个方法可以获取对象的哈希值\npublic int hashCode():返回对象的哈希码值\n\n4、对象的哈希值特点\n同一个对象多次调用hashCode()方法返回的哈希值 是相同的\n默认情况下、不同对象的哈希值是不同的。而重写hashCode()方法, 可以实现让不同对象的哈希值相同\n\n5、HashSet集合特点\n底层数据结构是 哈希表 ， 元素无序且唯一，可以存储 null元素；\n唯一性是靠所存储元素类型是否重写hashCode()和equals()方法来保证的，如果没有重写这两个方法，则无法保证元素的唯一性。\n对集合的迭代顺序不作任何保证， 也就是说不保证存储和取出的元素顺序一致\n没有带索引的方法， 所以不能使用普通for循环遍历\n线程不安全\n\n6、HashSet的底层实现具体实现唯一性的比较过程：存储元素首先会使用hash()算法函数生成一个int类型hashCode散列值，然后已经的所存储的元素的hashCode值比较，如果hashCode不相等，则所存储的两个对象一定不相等，此时存储当前的新的hashCode值处的元素对象；如果hashCode相等，存储元素的对象还是不一定相等，此时会调用equals()方法判断两个对象的内容是否相等，如果内容相等，那么就是同一个对象，无需存储；如果比较的内容不相等，那么就是不同的对象，就该存储了，此时就要采用哈希的解决地址冲突算法，在当前hashCode值处类似一个新的链表， 在同一个hashCode值的后面存储存储不同的对象，这样就保证了元素的唯一性。\nSet的实现类的集合对象中不能够有重复元素，HashSet也一样他是使用了一种标识来确定元素的不重复，HashSet用一种算法来保证HashSet中的元素是不重复的， HashSet采用哈希算法，底层用数组存储数据。默认初始化容量16，加载因子0.75。\nObject类中的hashCode()的方法是所有子类都会继承这个方法，这个方法会用Hash算法算出一个Hash（哈希）码值返回，HashSet会用Hash码值去和数组长度取模， 模（这个模就是对象要存放在数组中的位置）相同时才会判断数组中的元素和要加入的对象的内容是否相同，如果不同才会添加进去。\nHash算法是一种散列算法。\nSet hs&#x3D;new HashSet();\nhs.add(o);\n\n* o.hashCode();\n\n  o%当前总容量 (0–15)\n\n* 是否发生冲突\n\n  * 不发生冲突  -------------  直接存放\n\n  * 发生冲突  ------------  o1.equals(o2)\n\n    假（不相等)  -------------  找一个空位添加\n\n    是（相等）-------------  不添加\n\n覆盖hashCode()方法的原则：\n1、一定要让那些我们认为相同的对象返回相同的hashCode值\n2、尽量让那些我们认为不同的对象返回不同的hashCode值，否则，就会增加冲突的概率。\n3、尽量的让hashCode值散列开（两值用异或运算可使结果的范围更广）\nHashSet 的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成，我们应该为保存到HashSet中的对象覆盖hashCode()和equals()，因为再将对象加入到HashSet中时，会首先调用hashCode方法计算出对象的hash值，接着根据此hash值调用HashMap中的hash方法，得到的值&amp; (length-1)得到该对象在hashMap的transient Entry[] table中的保存位置的索引，接着找到数组中该索引位置保存的对象，并调用equals方法比较这两个对象是否相等，如果相等则不添加，注意：所以要存入HashSet的集合对象中的自定义类必须覆盖hashCode(),equals()两个方法，才能保证集合中元素不重复。在覆盖equals()和hashCode()方法时， 要使相同对象的hashCode()方法返回相同值，覆盖equals()方法再判断其内容。为了保证效率，所以在覆盖hashCode()方法时， 也要尽量使不同对象尽量返回不同的Hash码值。\n如果数组中的元素和要加入的对象的hashCode()返回了相同的Hash值（相同对象）,才会用equals()方法来判断两个对象的内容是否相同。\n7、LinkedHashSet\n哈希表和链表实现的Set接口, 具有可预测的迭代次序\n由链表保证元素有序， 也就是说元素的存储和取出顺序是一致的\n由哈希表保证元素唯一， 也就是说没有重复的元素\n\n8、TreeSet集合特点\n底层数据结构采用二叉树来实现，元素唯一且已经排好序\n\n唯一性同样需要重写hashCode和equals()方法，二叉树结构保证了元素的有序性\n\n构造方法不同，分为自然排序（无参构造）和比较器排序（有参构造）\n\nTreeSet(): 根据其元素的自然排序进行排序\n\nTreeSet(Comparator comparator) :根据指定的比较器进行排序\n对Comparetor.compare(o1, o2)方法的返回值，\n返回0说明两个对象相同，不需要存储\n\n\n\n比较器排需要在TreeSet初始化是时候传入一个实现Comparator接口的比较器对象，或者采用匿名内部类的方式new一个Comparator对象，重写里面的compare()方法；\n\n没有带索引的方法， 所以不能使用普通for循环遍历\n\n\n八、集合的使用技巧1、同步和非同步\n明确具体集合名称的所属后缀，后缀是list和set的，属于list和set体系，通常为非同步。\n后缀不是所属接口名的，一般是同步的，如vector\n\n2、集合的数据结构\n前缀是数据结构，后缀是所属体系\n例如：ArrayList，Array明确是数组结构，查询快\narray：数组，查询快，有角标。 \nlink：链表，增删快，就要想到 add get remove+first last 的方法。\nhash：哈希表，唯一性，就要想到 hashcode 和 equals \ntree：排序，二叉树，就要想到 comparable 和 comparator \n通常这些常用的是线程不安全的。\n\n3、需要唯一嘛\n元素需要唯一：Set\n需要制定顺序：TreeSet\n不需要指定顺序：HashSet\n想要存储顺序一致的：LinkedList\n\n\n元素不需要唯一：List\n需要频繁增删改：LinkedList\n不需要：ArrayList\n\n\n\n","slug":"11-集合（上）","date":"2021-09-13T14:46:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"5a74204f11299c4fc6660b81cabe549b","title":"异常处理","content":"一、概述在使用计算机语言进行项目开发的过程中，即使程序员把代码写得尽善尽美，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避免的，比如：客户输入数据的格式，读取文件是否存在，网络是否始终保持通畅等等。\n异常的出现就是为了记录程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止的情况。在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。\n异常出现的目的是为了保证程序的健壮性。代码出现问题时，曝出异常，程序员解决这些异常以后再继续向下执行。如果不抛出异常，程序就会在错误的基础上继续执行，这样更加危险。\n二、异常体系\n\nError:严重错误Error，无法通过处理的错误，只能事先避免，例如常见的StackOverFlowError和OutOfMemoryError。\nException:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是需要处理的。\n\nThrowable中的常用方法：\n\npublic void printStackTrace():打印异常的详细信息。\n包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。\n\npublic String getMessage():获取发生异常的原因。\n提示给用户的时候,就提示错误原因。\n\npublic String toString():获取异常的类型和异常描述信息(不用)。\n\n\n三、异常分类根据在编译时期还是运行时期去检查异常?\n\n编译时期异常:  checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)\n运行时期异常:  runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数组索引越界异常)\n\n四、异常处理1、规避：只适用于RuntimeException，通过大量的条件判断语句，避免出现异常。\n2、try …  catch …\ntry...catch：\ntry&#123;\n   &#x2F;&#x2F; 有可能出现异常的代码\n&#125;catch(异常类型 异常变量名) &#123;\n  &#x2F;&#x2F; 发生异常以后执行的代码\n&#125;\n\n\n一个try可以有多个catch语句\n如果多个catch语句它的代码一样，可以使用 | 连接\n如果多个catch语句的异常类型有父子类继承关系，父类的异常捕获要在子类的后面\n在catch语句里，通常会调用异常对象printStackTrace()方法，打印异常调用堆栈\n在catch语句里，还可以再抛出一个新的异常(原因之前的错误类型可能不能很好的描述异常的情况，此时可以考虑定义一个新的异常类来描述错误)\n\n3、使用  throw  关键字抛出一个异常\n\nthrow 后面的对象，必须要继承自 Throwable\n\n一般情况下，如果使用了 throw 抛出了一个异常，就需要在方法的声明使用 throws 声明这个异常。\n\n如果代码里抛出的是 RuntimeException类型的异常，方法声明里可以不使用 throws 来声明异常\n\n父类的方法如果抛出了异常，子类在重写这个方法的时候\n\n如果没有使用super调用父类的方法，子类可以不用管父类抛出异常\n\n如果使用super调用了父类的方法，子类必须要处理父类的异常\n可以直接使用throws抛出一个和父类方法相同的异常\n也可以使用try…catch语句，解决父类的异常\n\n\n\n父类的方法里没有抛出异常，子类在重写父类方法时，也不能抛出编译时异常\n\n\n五、finally代码块1、概述因为异常会引发程序跳转，导致有些语句执行不到。\n但是如果有一些特定的代码无论异常是否发生，都需要执行，就可以讲这些代码写入到finally代码块里。（保证这段代码一定会被执行）\n2、finally 语法try&#123;\n  &#x2F;&#x2F; 程序代码\n&#125;catch(异常类型1 异常的变量名1)&#123;\n  &#x2F;&#x2F; 程序代码\n&#125;catch(异常类型2 异常的变量名2)&#123;\n  &#x2F;&#x2F; 程序代码\n&#125;finally&#123;\n  &#x2F;&#x2F; 程序代码\n&#125;\n\n3、注意\nfinally不能单独使用。\n\n一个方法可以有多个return语句，但是通常情况都只会执行一个return语句。\nreturn语句表示一个方法的结束，但是当方法里有finally语句时，finally语句里的return一定会执行，可能会覆盖之前的return语句结果\n\n\n六、自定义异常1、概述在有些情况下，Java内置的错误类型可能不能够很精确的描述我们的遇到的异常类型，此时就可以考虑自定义异常。\n2、如何自定义异常分为两大类，编译时异常和运行时异常。我们在开发中，也可以根据我们的业务逻辑，选择继承的异常类型。\n\n自定义编译时异常：自定义异常类需要继承自Exception类。\n自定义运行时异常：自定义异常类需要继承自RuntimeException类。\n根据自己的业务需求，还可以继承Exception或者RuntimeException的子类。\n\n","slug":"10-异常处理","date":"2021-09-13T14:45:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"2d669717a3bf1c4b448259cbc4c2654a","title":"常用的类（下）","content":"一、Arrays类1、概述Arrays类包含用于操作数组的各种方法，是操作属猪的工具类\n2、常用方法toString():将数组变成字符串\nint[] arr &#x3D; &#123;1, 2, 3&#125;;\nString x &#x3D; java.util.Arrays.toString(arr);\nSystem.out.pritnln(x);\n\nbinarySearch:二分查找\n\ncopyOf:从一个数组里赋值指定长度的数据\n\ncopyOfRange:从一个数组里赋值指定范围的数据\n\nequals:比较两个数组里的数据是否相等\n\nfill:使用指定的数据对数组进行填充\n\nsort:用来对数组里数据进行排序。如果是数字或者字符数组，会按照快速排序进行升序排序；如果是对象，这个对象必须要实现一个Compareable接口，并且实现compareTo方法\n\ntoString:用来将数组变成&quot;[元素1,元素2,....]&quot;格式的字符串。如果是一个对象类型的数组，会调用这个对象的toString方法，如果这个对象没有重写toString方法，默认会打印对象的类型以及hashCode.\n\ndeepToString:将多维数组转换成为字符串\n\nList&lt;String&gt; list &#x3D; Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);\n该方法是将数组转化成List集合的方法。\n注意：\n（1）该方法适用于对象型数据的数组（String、Integer...）\n（2）该方法不建议使用于基本数据类型的数组（byte,short,int,long,float,double,boolean）\n（3）该方法将数组与List列表链接起来：当更新其一个时，另一个自动更新\n（4）不支持add()、remove()、clear()等方法\n    \n【2.Arrays.asList()是个坑】\n用此方法得到的List的长度是不可改变的，\n当你向这个List添加或删除一个元素时（例如 list.add(&quot;d&quot;);）程序就会抛出异常（java.lang.UnsupportedOperationException）。 \n\n3、数组转集合可以对数组中的元素通过集合中的方法进行操作，只要不影响其长度，可以使用集合中的任意方法\n4、集合转数组为了限制集合中的元素操作，他只有一个length属性可以进行操作\n5、注意无论是集合转数组还是数组转集合，长度是 不可以改变的，不能对其进行增删操作\n\n增强for循环和普通for循环的区别循环多次的时候，普通for可以对其循环条件进行控制，而增强for不能\n什么时候用map？当问题中存在着映射关系时，首先考虑数组和map当映射关系中有一方是有序编号时，可以考虑数组，反之，就不用考虑了\n\n二、Date类1、构造方法\npublic Date()：创建一个当前时间的日期对象。\npublic Date(long date)：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。\n\n2、常用方法\npublic long getTime() ：把日期对象转换成对应的时间毫秒值。\npublic boolean after(Date when)：判断是否在when时间之后。\npublic boolean before(Date when)：判断是否在when时间之前。\npublic int compareTo(Date anotherDate)：判断时间和指定时间的大小关系。\n\n三、DateFormat类1、概述是一个抽象类，通常情况下使用SimpleDateFormat类来进行日期格式化\n\n格式化：按照指定的格式，从Date对象转换为String对象。\n解析：按照指定的格式，从String对象转换为Date对象。\n\n2、构造方法DateFormat是一个抽象类，不能直接创建对象，通常我们会选择创建一个**SimpleDateFormat**类型的对象。\npublic SimpleDateFormat(String pattern)：通常会传入一个格式化字符串参数。\nSimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-mm-dd HH:MM:SS&quot;);\n\n参数pattern是一个字符串，代表日期时间的自定义格式。\n3、常见方法\npublic String format(Date date)：将Date对象格式化为字符串。\npublic Date parse(String source)：将字符串解析为Date对象。\n\nyyyy     四位数年\nMM       两位数的月\ndd       在月里日期\nDD       在年里的天数\nHH       小时\nmm       分钟\nss       秒\n\n&#x2F;&#x2F; 创建一个 SimpleDateFormat 对象\nSimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-mm-dd HH:MM:SS&quot;);\n&#x2F;&#x2F; 创建一个 Date 对象\nDate date &#x3D; new Date();\n\n&#x2F;&#x2F; 将当前时间以指定的格式转换成为字符串\nString str1 &#x3D; sdf.format(date);\nSystem.out.println(str1);  &#x2F;&#x2F; 2020-03-15 11:22:35\n\n&#x2F;&#x2F; 按照格式创建一个字符串对象\nString dateStr &#x3D; &quot;2008-08-08 12:34:45&quot;;\n\n&#x2F;&#x2F; 将字符串加载成为一个 Date 对象\nDate newDate &#x3D; sdf.parse(dateStr);\n\n四、Calendar类1、概述java.util.Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。\n2、构造方法Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象。\n\npublic static Calendar getInstance()：使用默认时区和语言环境获得一个日历。\n\n3、 常见方法Calendar类里通常使用两个方法:\n\npublic int get(int field)：获取指定字段（年月日等）的值。\npublic void set(int filed, int vale)：给指定的字段设置值。\n\n4、Calendar里的字段Calendar类中提供很多成员常量，代表给定的日历字段：\n\n\n\n字段值\n含义\n\n\n\nYEAR\n年\n\n\nMONTH\n月（从0开始，可以+1使用）\n\n\nDAY_OF_MONTH\n月中的天（几号）\n\n\nHOUR\n时（12小时制）\n\n\nHOUR_OF_DAY\n时（24小时制）\n\n\nMINUTE\n分\n\n\nSECOND\n秒\n\n\nDAY_OF_WEEK\n周中的天（周几，周日为1，可以-1使用）\n\n\n五、其他日期类1、概述JDK8里还提供了LocalDate类，LocalTime类,以及LocalDateTime类来分别用来表示日期，时间以及日期和时间。\n这三个类的构造方法都是私有的，不要直接创建对象，都是通过静态方法now来获取到当前的日期和时间\n2、DateTimeFormatter\n用来将日期和字符串之间相互转换\n获取实例对象\n不允许调用构造方法直接创建实例对象\n只能调用 ofPattern 等静态方法，返回一个实例对象\n\n\n日期转换成为字符串，调用  format 方法\n把字符串加载成为日期，不是调用 DateTimeFormatter的parse方法，因为获取到结果是一个父接口，无法获取到日期时间等数据。分别使用 LocalDate / LocalTime / LocalDateTime 的 parse静态方法，将字符串和formatter传入，实现加载。\n\npublic class FormatDemo &#123;\n    public static void main(String[] args) throws ParseException &#123;\n        Date date &#x3D; new Date();\n\n        SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy年MM月dd日 HH点mm分ss秒&quot;);\n\n        &#x2F;&#x2F; 把 Date 类型的对象转换成为指定格式的字符串\n        String dateStr &#x3D; sdf.format(date);\n        System.out.println(dateStr);\n\n        String str &#x3D; &quot;2012-03-12 12:34:12&quot;;\n        SimpleDateFormat sdf2 &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n        Date date1 &#x3D; sdf2.parse(str);\n        System.out.println(date1.getYear());\n\n        DateTimeFormatter formatter &#x3D; DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);\n\n        &#x2F;&#x2F; 将日期变成字符串\n        LocalDate now &#x3D; LocalDate.now();\n        System.out.println(formatter.format(now));\n\n\n        String str1 &#x3D; &quot;2021-04-17&quot;;\n&#x2F;&#x2F;        LocalDate time &#x3D; (LocalDate) formatter.parse(str1);\n&#x2F;&#x2F;        System.out.println(time.getYear());\n        LocalDate d &#x3D; LocalDate.parse(str1, formatter);\n        System.out.println(d.getYear());\n\n        LocalTime time &#x3D; LocalTime.parse(&quot;12:34:56&quot;, DateTimeFormatter.ofPattern(&quot;HH:mm:ss&quot;));\n        System.out.println(time.getHour());\n\n        LocalDateTime ldt &#x3D; LocalDateTime.parse(&quot;2021年04月17日 15:09:20&quot;, DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH:mm:ss&quot;));\n        System.out.println(ldt.getYear());\n    &#125;\n&#125;\n\n六、String类1、概述String（字符串）在 Java中属于对象，Java提供了String类来创建和操作字符串。\nString的值是不可变的，所以导致每次对String的操作都会生成String对象\nString str &#x3D; &quot;hello&quot;;\nstr &#x3D; &quot;hello&quot;+&quot;world&quot;;\n上述world需要开辟一个堆内存\n相加时再开辟一个内存空间存储相加的值\n最后把str指向上一个开辟的空间（这个时候“hello”的对象已经丢弃了）\n\n上述开辟了三次内存空间，如果这种操作放到循环中，会造成内存极大浪费，引入StringBuffer与StringBuild处理这种问题\n\n2、字符串的特点\n字符串不可变, 它们的值在创健后不能被更改\n虽然 String的值是不可变的,但是它们可以被共享\n字符串效果上相当于字符数组( char[]).但是底层原理是字节数组( byte[])\n\n3、String 构造方法\n\n\n方法名\n说明\n\n\n\npublic String()\n创建一个空白字符审对象，不含有任何内容\n\n\npublic String(char[] chs)\n根据字符数组的内容，来创建字符串对象\n\n\npublic String(byte[] bys)\n根据字节数组的内容，来创建字符串对象\n\n\nString s= “abc” ;\n直接赋值的方式创建字符串对象，内容就是abc\n\n\n4、字符串比较使用==做比较\n\n基本类型:  比较的是数据值是否相同\n引用类型:  比较的是地址值是否相同\n\n字符串是对象，它比较内容是否相同，需要equals()\n\npublic boolean equals(Object a): 将此字符串与指定对象进行比较。\n由于我们比较的是字符串对象，所以参数直接传递一个字符串\n\n5、Split方法public String[] split(String regex)将此字符串拆分为给定的字符数组 \n例如，字符串”boo:and:foo”使用以下表达式得到以下结果：\n\nregex = : \n{ “boo”, “and”, “foo” } \n\nregex = o \n{ “b”, “”, “:and:f” } \n\n\n七、StringBuilder类当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder类。这两个类的对象能被多次修改，并且不产生新的未使用对象\nStringBuffer 和 StringBuilder的区别在于，StringBuilder的方法不是线程安全的（不能同步访问）但是 StringBulider速度较快，所以一般情况下建议使用 StirngBuilder类。然而在程序要求线程安全的情况下，必须使用StirngBuffer类\n\n\n\n序号\n方法描述\n\n\n\n1\npublic StringBuffer append(String s) 将指定的字符串追加到此字符序列。\n\n\n2\npublic StringBuffer reverse()  将此字符序列用其反转形式取代。\n\n\n3\npublic delete(int start, int end) 移除此序列的子字符串中的字符。\n\n\n4\npublic insert(int offset, int i) 将 int 参数的字符串表示形式插入此序列中。\n\n\n5\nreplace(int start, int end, String str) 使用给定 String 中的字符替换此序列的子字符串中的字符。\n\n\n下面的列表里的方法和 String 类的方法类似：\n\n\n\n序号\n方法描述\n\n\n\n1\nchar charAt(int index) 返回此序列中指定索引处的 char 值。\n\n\n2\nint indexOf(String str) 返回第一次出现的指定子字符串在该字符串中的索引。\n\n\n3\nint indexOf(String str, int fromIndex) 从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。\n\n\n4\nint lastIndexOf(String str) 返回最右边出现的指定子字符串在此字符串中的索引。\n\n\n5\nint length()  返回长度（字符数）。\n\n\n6\nvoid setCharAt(int index, char ch) 将给定索引处的字符设置为 ch。\n\n\n7\nvoid setLength(int newLength) 设置字符序列的长度。\n\n\n8\nString substring(int start) 返回一个新的 String，它包含此字符序列当前所包含的字符子序列。\n\n\n9\nString substring(int start, int end) 返回一个新的 String，它包含此序列当前所包含的字符子序列。\n\n\n10\nString toString() 返回此序列中数据的字符串表示形式。\n\n\n注意\n都可以直接赋为空值 String s = null；StringBuffer s1 = null;  StringBuilder s3 = null;\n小结\n（1）如果要操作少量的数据用 String；\n（2）多线程操作字符串缓冲区下操作大量数据 StringBuffer；\n（3）单线程操作字符串缓冲区下操作大量数据 StringBuilder\n","slug":"09-常用的类（下）","date":"2021-09-13T14:43:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"c660642989e58d8f24bf7e09ddf846f0","title":"常用的类（中）","content":"一、Math类1、特点提供了操作数学元素的方法，都是静态的\n2、常用方法int abs(int a)：返回整数的绝对值\n\nint max(int a, int b)：返回两个整数的最大值 \n\ndouble random()：返回一个伪随机值(0--1 之间) \n\ndouble sqrt(double a)：返回一个数的平方根 \n\ndouble ceil()：返回大于参数的最小整数\n\ndouble floor()：返回小于参数的最大整数 \n\ndouble round()：返回四舍五入的值。 \n\ndouble pow(a,b)：a 的 b 次方\n\n二、Scanner类1、概念接收键盘输入数据的类\n2、常用APIdelimiter()：返回此 Scanner 当前正在用于匹配分隔符的 Pattern\n\nhasNext()：判断扫描器中当前扫描位置后是否还存在下一段。（原APIDoc的注释很扯淡）\n\nhasNextLine()：如果在此扫描器的输入中存在另一行，则返回 true\n\nnext()：查找并返回来自此扫描器的下一个完整标记\n\nnextLine()：此扫描器执行当前行，并返回跳过的输入信息\n\n3、next() 与 nextLine() 区别next():\n    1、一定要读取到有效字符后才可以结束输入。\n    2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。\n    3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。    \n    \n注意：next() 不能得到带有空格的字符串。\n\nnextLine()：\n    1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。\n    2、可以获得空白。\n\n三、System类1、特点不能实例化对象，提供的方法都是静态的。\n2、获取本地系统信息系统属性信息：程序在运行时获取到Jvm以及所在操作系统的一些固有信息，获取了这些信息，能为后面的程序运行提供数据\npublic static void main(String[] args) &#123;\n\n    Properties pros &#x3D; System.getProperties();\n    \n    Set&lt;String&gt; names &#x3D; pros.stringPropertyNames();\n    \n    for (String name : names) &#123;\n        System.out.println(name+&quot;:&quot;+pros.getProperty(name));\n    &#125;\n\n&#125;\n\n结果：java.runtime.name:Java(TM) SE Runtime Environment\n     sun.boot.library.path:D:\\Myeclipse\\jdk1.8\\jre\\bin\n     java.vm.version:25.241-b07\n     java.vm.vendor:Oracle Corporation\n     ...\n         \n获取系统换行符：String s &#x3D; System.getProperty(&quot;line.separator&quot;);\n              System.out.println(&quot;hh&quot;+s+&quot;kk&quot;);\n\n3、常用方法* static long currentTimeMillis()：获取当前时间，以毫秒为单位。 \n\n* static void exit(int status) ：退出当前程序。 \n\n* static void gc()：调用垃圾回收器。 \n\n* static Properties getProperties()：获取当前系统属性 \n\n* static String getProperty(String key)：根据关键字获取系统属性名称 \n\n* static String setProperty(String key, String value)：设置属性的键和值。\n\n四、Properties类1、特点：properties集合类中储存的都是 string 类型的键和值，最好是用他自己的存储和取出方法来完成元素的操作\n主要用于读取 java中的配置文件\n2、常用方法：Properties getProperty(String key):返回指定的属性 \n\nObject setProperty(String key,String value):设置属性的键和值 \n\nvoid load(InputStream inStream) :加载输入流 \n\nSet&lt;String&gt; stringPropertyNames() ：返回属性键的集合。\n\n五、Runtime类1、使用单例模式没有构造方法摘要，说明该类不可以创建对象，又发现还有非静态的方法，说明该类应该提供静态的返回该类对象的方法，\n而且只有一个，说明 runtime 类使用了单例设计模式。\n2、打开记事本exec 方法返回的是一个进程，可以通过该方法启动一个程序\npublic static void main(String[] args) &#123;\n\tRuntime runtime &#x3D; Runtime.getRuntime();\n\n\ttry &#123;\n   \t\truntime.exec(&quot;notepad.exe&quot;);\n\t&#125; catch (IOException e) &#123;\n    \te.printStackTrace();\n\t&#125;\n&#125;\n\n","slug":"08-常用的类（中）","date":"2021-09-13T14:42:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"01fd53219624f0d973c128a92b2b96c5","title":"常用的类（上）","content":"一、单例设计模式1.1 概述单例模式，是一种常用的软件设计模式，在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中应用该模式的类一个类只有一个实例，即一个类只有一个对象实例。例如，windows操作系统里的回收站。\n单例设计模式分为饿汉式（立即加载型）和懒汉式（延迟加载型）。由于懒汉式有线程安全问题，又衍生出了线程安全版的懒汉式以及DLC双检查锁（最佳实现方式）的懒汉式\n1.2 做法\n将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。\n在该类内部产生一个唯一的实例化对象，并且将其封装为private static final类型。\n定义一个静态方法返回这个唯一对象。\n\n1.3 饿汉式1.3.1 概述立即加载就是使用类的时候已经将对象创建完毕\n不管以后会不会使用到该实例化对象，先创建了再说。很着急的样子，故又被称为“饿汉模式”，常见的实现办法就是直接new实例化。\npublic class Singleton &#123;\n\n    &#x2F;&#x2F; 将自身实例化对象设置为一个属性，并用static修饰\n    private static final Singleton instance &#x3D; new Singleton();\n\n    &#x2F;&#x2F; 构造方法私有化\n    private Singleton() &#123;&#125;\n\n    &#x2F;&#x2F; 静态方法返回该实例\n    public static Singleton getInstance() &#123;\n        return instance;\n    &#125;\n&#125;\n\n1.3.2 特点优点：实现起来简单，没有多线程同步问题。\n缺点：当类SingletonTest被加载的时候，会初始化static的instance，静态变量被创建并分配内存空间，从这以后，这个static的instance对象便一直占着这段内存（即便你还没有用到这个实例），当类被卸载时，静态变量被摧毁，并释放所占有的内存，因此在某些特定条件下会耗费内存。\n1.4 懒汉式1.4.1 概述延迟加载就是调用get()方法时实例才被创建（先不急着实例化出对象，等要用的时候才给你创建出来。不着急，故又称为“懒汉模式”），常见的实现方法就是在get方法中进行new实例化。\npublic class Singleton &#123;\n\n    &#x2F;&#x2F; 将自身实例化对象设置为一个属性，并用static修饰\n    private static Singleton instance;\n\n    &#x2F;&#x2F; 构造方法私有化\n    private Singleton() &#123;&#125;\n\n    &#x2F;&#x2F; 静态方法返回该实例\n    public static Singleton getInstance() &#123;\n        if(instance &#x3D;&#x3D; null) &#123;\n            instance &#x3D; new Singleton();\n        &#125;\n        return instance;\n    &#125;\n&#125;\n\n1.4.2 特点优点：实现起来比较简单，当类SingletonTest被加载的时候，静态变量static的instance未被创建并分配内存空间，当getInstance方法第一次被调用时，初始化instance变量，并分配内存，因此在某些特定条件下会节约了内存。\n缺点：在多线程环境中，这种实现方法是完全错误的，根本不能保证单例的状态\n二、枚举类2.1 概述枚举是一个被命名的整型常数的集合，用于声明一组带标识符的常数。枚举在曰常生活中很常见，例如一个人的性别只能是“男”或者“女”，一周的星期只能是 7 天中的一个等。类似这种当一个变量有几种固定可能的取值时，就可以将它定义为枚举类型。\n在 JDK 1.5 之前没有枚举类型，那时候一般用接口常量来替代。而使用 Java 枚举类型 enum 可以更贴近地表示这种常量。\n2.2  枚举类的实现2.2.1 JDK 1.5 之前public class Test &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(Season.SPRING);\n    &#125;\n&#125;\n\nclass Season &#123;\n    private Season() &#123;\n    &#125;\n    public static final Season SPRING &#x3D; new Season();\n    public static final Season SUMMER &#x3D; new Season();\n    public static final Season AUTUMN &#x3D; new Season();\n    public static final Season WINTER &#x3D; new Season();\n&#125;\n\n2.2.2 Enum的使用enum 枚举类类名 &#123;\n    对象1,对象2,对象3;\n&#125;\n\npublic enum Season&#123;\n    &#x2F;&#x2F; SPRING(),SUMMER(),AUTUMN(),WINTER();  调用构造函数，创建了四个对象，小括号可以省略\n\n    SPRINT,SUMMER,AUTUMN,WINTER;  &#x2F;&#x2F; 创建了四个对象\n    &#x2F;&#x2F; private Season()&#123;&#125; 构造方法可以不写，默认就有一个空参数构造方法\n&#125;\n\npublic enum WeekDay &#123;\n    &#x2F;&#x2F; 创建的实例对象时，必须要调用构造方法传入 name 参数\n    MON(&quot;周一&quot;), TUE(&quot;周二&quot;), WED(&quot;周三&quot;), THU(&quot;周四&quot;), FRI(&quot;周五&quot;), SAT(&quot;周六&quot;), SUN(&quot;周日&quot;);\n\n    private String name;\n    WeekDay(String name) &#123;  &#x2F;&#x2F; 还能自定义构造方法\n        this.name &#x3D; name;\n    &#125;\n\n    &#x2F;&#x2F; 像正常的类一样，可以使用 getter&#x2F;setter 方法\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n&#125;\n\n2.3 枚举类的特点\n所有的枚举都继承自java.lang.Enum类，由于Java 不支持多继承，所以枚举对象不能再继承其他类（但是可以实现接口）。\n枚举类的所有实例对象都必须放在第一行展示（逗号隔开），并且默认都是以public static final修饰的常量，所以变量名通常都全大写。\n在创建实例对象时，不需使用new 关键字，也不需使用小括号显式调用构造器\n使用enum定义非抽象的枚举类默认使用final修饰，不可以被继承。\n枚举类的构造器只能是私有的，不允许在外部创建对象。\n\n2.4  Enum中的方法\n\n\n\n方法名称\n描述\n\n\n\nvalues()\n以数组形式返回枚举类型的所有成员\n\n\nvalueOf()\n将普通字符串转换为枚举实例\n\n\ncompareTo()\n比较两个枚举成员在定义时的顺序\n\n\nordinal()\n获取枚举成员的索引位置\n\n\ntoString()\n返回对象名（常用♥）\n\n\nname()\n获取对象名（不常用）\n\n\n三、包装类3.1 概述在 Java 的设计中提倡一种思想，即一切皆对象。但是从数据类型的划分中，我们知道 Java 中的数据类型分为基本数据类型和引用数据类型，但是基本数据类型怎么能够称为对象呢？于是 Java 为每种基本数据类型分别设计了对应的类，称之为包装类（Wrapper Classes），也有地方称为外覆类或数据类型类。\n3.2 关系\n\n\n序号\n基本数据类型\n包装类\n\n\n\n1\nbyte\nByte\n\n\n2\nshort\nShort\n\n\n3\nint\nInteger\n\n\n4\nlong\nLong\n\n\n5\nchar\nCharacter\n\n\n6\nfloat\nFloat\n\n\n7\ndouble\nDouble\n\n\n8\nboolean\nBoolean\n\n\n从上表中我们可以看出，除了 Integer 和 Character 定义的名称与基本数据类型定义的名称相差较大外，其它的 6 种类型的名称都是很好掌握的。\n3.3 装箱和拆箱\n装箱：从基本类型转换为对应的包装类对象。\n拆箱：从包装类对象转换为对应的基本类型。\n\nint a &#x3D; 10;\n\n&#x2F;&#x2F; 装箱:使用构造方法 或者 valueOf 方法将基本数据类型a包装成为包装类型\nInteger i1 &#x3D; new Integer(a);\nInteger i2 &#x3D; Integer.valueOf(a);\n\n&#x2F;&#x2F; 拆箱:将包装类型转换成为基本数据类型\nint b &#x3D; i1.intValue();\n\n\n自动装箱拆箱:由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：\n\nInteger i &#x3D; 4; &#x2F;&#x2F;自动装箱。相当于Integer i &#x3D; Integer.valueOf(4);\ni &#x3D; i + 5; &#x2F;&#x2F;等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;\n&#x2F;&#x2F;加法运算完成后，再次装箱，把基本数值转成对象。\n\n3.4 包装类的应用3.4.1 int 和 Integer 的相互转换public class Demo &#123;\n    public static void main(String[] args) &#123;\n        int m &#x3D; 500;\n        Integer obj &#x3D; new Integer(m);  &#x2F;&#x2F; 手动装箱\n        int n &#x3D; obj.intValue();  &#x2F;&#x2F; 手动拆箱\n        System.out.println(&quot;n &#x3D; &quot; + n);\n       \n        Integer obj1 &#x3D; new Integer(500);\n        System.out.println(&quot;obj等价于obj1的返回结果为&quot; + obj.equals(obj1));\n    &#125;\n&#125;\n\n3.4.2 将字符串转换为数值类型① new Integer(String str);\n② Integer 类（String 转 int 型）parsenInt（）\nint parseInt(String s); s 为要转换的字符串。\n\n注意：使用以上两种方法时，字符串中的数据必须由数字组成，否则转换时会出现程序错误。\n3.4.3 将整数转换为字符串\nInteger 类有一个静态的 toString() 方法，可以将整数转换为字符串。例如：\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        int m &#x3D; 500;\n        String s &#x3D; Integer.toString(m);\n        System.out.println(&quot;s &#x3D; &quot; + s);\n    &#125;\n&#125;\n\n使用+将基本数据类型和字符串拼接，例如String x = 1 + &quot;&quot;;得到的结果x就是个字符串。\n调用String类的valueOf方法，例如String x = String.valueOf(1);得到的结果是一个字符串。\n","slug":"07-常用的类（上）","date":"2021-09-13T14:41:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"5a1c4f03caf8f9ffac125f63d3a94727","title":"面向对象（下）","content":"一、内部类1.成员内部类1.1  概念在成员位置定义的类（定义在另一个类的内部，最普通的内部类），称之为成员内部类\n1.2  成员内部类特点:\n不能使用 static关键字，但是可以使用static final关键字定义常量。\n成员内部类 可以无条件的访问外部类的 成员属性 和 成员方法 （包括private成员）\n注意：当成员内部类拥有和外部类同名的成员变量或方法时，默认访问的是 成员内部类 的\n如过要访问外部类 同名成员，可以下述方式访问：      \n外部类.this.外部成员变量\n外部类.this.外部成员方法\n\n\n可以使用final修饰内部类，表示不能被继承。\n编译以后也会有自己独立的字节码文件，只不过文件名是Outer$Inner.class\n外部函数的static成员里，不允许访问成员内部类。\n由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰\n\n1.3  创建成员内部类的对象前提是存在外部类的对象，然后通过外部类对象创建内部类对象\n\n第一种（Outter外，Inner内部类 类举例）\nOutter outter = new Outter;\nOutter.Inner inner = outter.new Inner();\n\n第二种，在内部类中给出 获取内部类实例化的方法（getInnerInstance(){return new Inner();}）\n\n\n2.局部内部类2.1  概述局部内部类是定义在一个方法或者一个作用域里面的类，他和成员内部类的区别在于 \n局部内部类的访问 仅限于 方法内 或者 该作用域内。\n2.2  语法格式[修饰符] class 外部类&#123;\n    [修饰符] 返回值类型  方法名([形参列表])&#123;\n            [final&#x2F;abstract] class 内部类&#123;\n        &#125;\n    &#125;    \n&#125;\n\n2.3  局部内部类特点\n局部内部类 可随意访问 外部类的成员变量和方法，即使是私有的；\n 局部内部类像是方法里面的一个局部变量，前面不能有权限修饰符！\n在外部类中不能创建内部类的实例；\n创建内部类的实例只能在包含他的方法中；\n\n\n局部内部类里不能使用static声明变量！\n局部内部类中能访问外部类的静态成员。\n如果这个局部内部类所在的方法是静态方法，它无法访问访问外部类的非静态成员。\n内部类和外部类有同名变量和方法时，需要通过Outer.this方式来访问外部类成员变量或方法\n局部内部类可以访问外部函数的局部变量，但是这个局部变量必须要被final修饰。JDK8以后，如果局部变量被局部内部类使用了，会自动在前面加final.\n\n2.4  为什么要加finalpublic class TestInner&#123;\n    public static void main(String[] args) &#123;\n        A obj &#x3D; Outer.method();\n        &#x2F;&#x2F;因为如果c不是final的，那么method方法执行完，method的栈空间就释放了，那么c也就消失了\n        obj.a();&#x2F;&#x2F;这里打印c就没有中可取了，所以把c声明为常量，存储在方法区中\n    &#125;\n&#125;\n\ninterface A&#123;\n    void a();\n&#125;\nclass Outer&#123;\n    public static A method()&#123;\n        final int c &#x3D; 3;\n        class Sub implements A&#123;\n            @Override\n            public void a() &#123;\n                System.out.println(&quot;method.c &#x3D; &quot; + c);\n            &#125;\n        &#125;\n        return new Sub();\n    &#125;\n&#125;\n\n3.匿名内部类1.  概念匿名内部类就是 局部内部类的简化写法\n2.  格式new 类名或接口名()&#123;\n\t重写方法\n&#125;;\n\n3.  注意\n根据格式看，所谓的匿名内部类，就是 实现了父类 或者 实现了父接口 的 子类匿名对象\n\n在匿名内部类中的this，代表的是 该匿名内部类 这个对象\n\n一个匿名内部类 最好对应一种 抽象方法的实现，可以使功能更加单一化，修改时不易出错\n\n匿名内部类没有类名，所以匿名内部类是唯一一种没有构造器的类，所以适用范围十分有限，大部分用于接口回调\n匿名内部类在编译的时候由系统自动起名为 Outter$1.class\n\n一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写\n\n\n4.静态内部类1.  定义静态内部类也是定义在 另一个类里面的类，只不过前面多了一个关键字 static\n静态内部类是不需要依赖于 外部类的，与类的静态成员有点类似，不能使用外部类的非静态成员方法\n在没有外部类的对象情况下，可以创建静态内部类的对象，外部类的费static成员必须依附于具体的对象\n2.  静态内部类特点:\n使用static关键字修饰。\n在静态内部类里，可以使用static关键字定义静态成员。\n只能访问外部的静态成员，不能访问外部的非静态成员。\n外部类可以直接通过静态内部类名.静态成员名访问静态内部类的静态成员。\n\n二、代码块1.概述\n普通代码块：就是类里方法体代码。\n构造代码块：类里直接使用 { } 编写的代码。\n静态代码块：在构造代码块前添加static关键字。\n同步代码块：使用synchronize关键字包裹起来的代码块，用于多线程。\n\n2.静态代码块2.1 语法结构【修饰符】 class 类名&#123;\n    static&#123;\n        静态代码块语句;\n    &#125;\n&#125;\n\n2.2 特点\n使用static关键字修饰，写在类里，方法外，用来对类进行初始化。\n一个类里可以有多个静态代码块，但是通常情况下只会定义一个。\n随着类加载而执行，只执行一次，只要类加载就会执行，所以执行的优先级很高。\n一般情况下,如果有些代码必须在项目启动的时候就执行的时候,就需要使用静态代码块\n\n3.构造代码块3.1 语法结构:&#123;\n    &#x2F;&#x2F;代码块里的内容\n&#125;\n\n3.2 特点\n对象一建立就会执行构造代码块，构造代码块先于构造方法执行，用来给对象进行初始化。\n每创建一个对象都会调用一次构造代码块。\n构造代码块是给所有对象统一初始化，构造函数是给各自对应的对象初始化。\n如果每个实例对象都需要统一的初始化，可以考虑将这部分代码写入到构造代码块里。\n\n三、初始化1.类的初始化当我们 用new关键字创建一个对象时，其实就是调用了这个对象的无参构造方法进行了初始化\n无参构造方法可以隐藏，由JVM自动添加，构造方法能保证类的初始化\n2.成员初始化Java 会尽量保证每个变量在使用前都会获得初始化。\n\n编译器默认指定的字段初始化，基本数据类型的初始化\n\n\n\n类型\n初始值\n\n\n\nboolean\nfalse\n\n\nchar\n/u0000\n\n\nbyte\n(byte)0\n\n\nshort\n(short)0\n\n\nint\n0\n\n\nlong\n0L\n\n\nfloat\n0.0f\n\n\ndouble\n0.0d\n\n\n引用类型\nnull\n\n\n\n指定数值初始化\n\n指定数值后，初始化值，就不是默认初始化值了，而是指定数值，基本类型和引用类型也一样\n\n\n3.构造器初始化可以利用构造器对某些方法和动作进行初始化，确定初始值（完成对象初始化）。\npublic class Test&#123;\n\n\tint i;\n\tpublic Test()&#123;\n\t\ti&#x3D;11;\n\t&#125;\n\n&#125;\n\n4.实例对象的初始化4.1 使用一个类来实例化对象的几种方式:\n最常见的方式，使用关键字new来创建一个实例对象。\n使用反射，调用Class或者java.lang.reflect.Constructor对象的newInstance()方法。\n调用对象的clone()方法。\n调用java.io.ObjectInputStream类的getOjbect()方法序列化。\n\n4.2 对象加载\n先给成员变量设置默认值。\n调用构造方法里 super 的构造方法。\n给成员变量赋值和执行构造代码块。\n执行构造方法里其他的代码。\n\n5.初始化顺序\n初始化顺序：父类的静态变量–&gt;父类的静态代码块–&gt;子类的静态变量–&gt;子类的静态代码快–&gt;父类的非静态变量(父类的非静态代码块)–&gt;父类的构造函数–&gt;子类的非静态变量（子类的非静态代码块）–&gt;子类的构造函数\n值得注意的是：父类的非静态变量(父类的非静态代码块)是同一级的，看哪个部分写在类的最前面谁就先被执行，子类的非静态变量（子类的非静态代码块）也是一样。\n\n","slug":"06-面向对象（下）","date":"2021-09-13T14:38:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"6a12650511ac8438957ec15fcbb76cbc","title":"面向对象（中）","content":"一、封装1.1    概述\n面向对象编程语言是对客观世界的模拟，客观世界里实例变量都是隐藏在对象内部的，外界无法直接操作和修改。\n封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。\n\n1.2    原则\n将类的某些信息隐藏在类内部，不允许外部程序直接访问\n通过该类提供的方法来实现对隐藏信息的操作和访问\n成员变量private，提供对应的  get / set  方法\n\n1.3    好处\n通过方法来控制成员量的操作，提高了代码的安全性\n\n把代码用方法进行封装，提高了代码的复用性\n\n\n二、继承2.1    概述\n继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。\n\n猫狗类都可以称为子类，也叫派生类；多个类抽取出来的这个动物类称为父类、超类（superclass）或者基类。\n\n继承描述的是事物之间的所属关系，父类更通用，子类更具体。\n\nextends 用在 class 或 interface声明中，用于指示所声明的类或接口是其名称后跟有 extends关键字的类或接口的子类\n\n子类继承父类的所有 public 和 protected 变量和方法。 \n\n子类可以重写父类的任何非 final 方法。\n\n一个类只能扩展一个其他类。\n\n\n2.2    好处子类继承父类，就使得子类对象具有与父类相同的属性，可以调用父类相同的行为。\n\n提高代码的复用性。\n提高代码的扩展性。\n类与类之间产生了关系，是学习多态的前提。\n\n2.3    注意事项\nJava中类只支持单继承， 不支持多继承\nJava中类支持多层继承\n\n2.4    常见写法class Animal &#123;\n    private String name;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n\n    Animal(String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n&#125;\n\nclass Dog extends Animal &#123;\n    Dog(String name) &#123;\n        super(name);\n    &#125;\n&#125;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        Dog dog &#x3D; new Dog(&quot;jerry&quot;);\n    &#125;\n&#125;\n\n2.5    继承中变量的访问特点2.5.1    成员变量不重名\n子类局部范围找\n子类成员范围找\n父类成员范围找\n如果都没有就报错(不考虑父亲的父亲.)（保持疑问）\n\n2.5.2    成员变量重名同不重名，但重名时，访问不了父类的成员变量\nclass Fu &#123;\n    &#x2F;&#x2F; Fu中的成员变量。\n    int num &#x3D; 3;\n&#125;\n\nclass Zi extends Fu &#123;\n    &#x2F;&#x2F; Zi中的成员变量\n    int num &#x3D; 4;\n    public void show() &#123;\n        &#x2F;&#x2F; 访问的num到底是子类还是父类？\n        System.out.println(&quot;num &#x3D; &quot; + num);\n    &#125;\n&#125;\nclass ExtendsDemo03 &#123;\n    public static void main(String[] args) &#123;\n          &#x2F;&#x2F; 创建子类对象\n        Zi z &#x3D; new Zi(); \n          &#x2F;&#x2F; 调用子类中的show方法\n        z.show(); \n    &#125;\n&#125;\n演示结果：\nnum &#x3D; 4\n\n子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用  super 关键字，修饰父类成员变量，类似于之前学过的  this 。\nclass Zi extends Fu &#123;\n    &#x2F;&#x2F; Zi中的成员变量\n    int num &#x3D; 6;\n    public void show() &#123;\n        &#x2F;&#x2F;访问父类中的num\n        System.out.println(&quot;Fu num&#x3D;&quot; + super.num);\n        &#x2F;&#x2F;访问子类中的num\n        System.out.println(&quot;Zi num&#x3D;&quot; + this.num);\n    &#125;\n&#125;\n演示结果：\nFu num &#x3D; 5\nZi num &#x3D; 6\n\n小贴士：\n\nFu 类中的成员变量是非私有的，子类中可以直接访问。\n若Fu 类中的成员变量私有了，子类是不能直接访问的。\n通常编码时，遵循封装的原则，使用private修饰成员变量。可以在父类中提供公共的getXxx方法和setXxx方法。\n\n2.6    继承中方法访问特点2.6.1    构造方法\n子类中所有的构造方法默认都会访问父类中无参的构造方法。\n因为子类会继承父类中的数据，可能使用父类数据。所以，子类初始化之前，一定要先完成父类的初始化\n每一个子类构造方法的第一 条语句默认都是: super()\n即便在子类的构造方法里没有手动使用super调用父类构造函数，子类也是会自动调用父类的空参数构造函数\n\n\n如果父类中没有无参构造方法，只有带参构造方法，该怎么办呢?\n通过使用super关键字 去显示的调用父类的带参构造方法\n在父类中自 己提供一个无参构造方法\n子类中也不要无参构造方法\n\n\n\n2.6.2    成员方法不重名会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。\n2.6.3    成员方法重名（重写）就是重写，直接覆盖。\n方法的覆盖重写特点：创建的是子类对象，则优先用子类方法。\n注意事项：\n\n必须保证父子类之间方法的名称相同，参数列表也相同。 @Override：写在方法前面，用来检测是不是有效的正确覆盖重写。这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。\n子类方法的返回值类型必须【小于等于】父类方法的返回值类型（小于其实就是是它的子类）。\n子类方法的权限必须【大于等于】父类方法的权限修饰符。 小扩展提示：public &gt; protected &gt; 缺省 &gt; private 备注：缺省不是汉字缺省，而是什么都不写，留空。\n\n三、static3.1    概述static 关键字可以应用于内部类（在另一个类中定义的类）、方法或字段（类的成员变量）。通常，static 关键字意味着应用它的实体在声明该实体的类的任何特定实例外部可用。static（内部）类可以被其他类实例化和引用（即使它是顶级类）static 字段（类的成员变量）在类的所有实例中只存在一次\n3.2    static修饰的特点\n被类的所有对象共享这也是我们判断是否使用静态关键字的条件\n静态修饰的优先于对象存在，所以可以直接被类名调用当然，也可以通过对象名调用，推荐使用类名调用\n\n3.3    static访问特点\n非静态的成员方法• 能访问静态的成员变量\n• 能访问非静态的成员变量\n• 能访问静态的成员方法\n• 能访问非静态的成员方法\n\n\n静态的成员方法• 能访问静态的成员变量\n• 能访问静态的成员方法\n总结成一句话就是：**静态成员方法只能访问静态成员**\n\n\n\n\n四、final1、可以用来修饰：类、方法、变量\n2、具体的：final 用来修饰一个类、此类不能被其他类所继承。\n\n     比如：String类、System类、StringBuffer类\n\n\n\n3、final 用来修饰方法：表明此方法不可以被重写\n\n        比如：Object类中getClass();\n\n\n\n4、 final 用来修饰变量：此时的”变量”就称为是一个常量\n\nfinal修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化\n\nfinal修饰局部变量：\n尤其是使用final修饰形参时，表明此形参是一个常量。\n当我们调用此方法时，给常量形参赋一个实参。\n一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。\n\n      static final 用来修饰属性：全局常量\n\n\n\n5、一个类不能同时是 abstract 又是 final。abstract 意味着必须扩展类，final 意味着不能扩展类\n五、抽象类abstract修饰类：抽象类\n\n 此类**不能实例化**\n\n\n 抽象类中一定有构造器（默认也会有无参构造），便于子类实例化时调用（涉及：子类对象实例化的全过程）\n\n\n 开发中，都会提供抽象类的子类，**让子类对象实例化**，完成相关的操作 ---&gt;抽象的**使用前提：继承性**\n\n\n\nabstract修饰方法：抽象方法\n\n    抽象方法只方法的声明，**没方法体**\n\n\n    包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。\n\n\n   若子类重写了父类中的所的抽象方法后，此子类方可实例化\n\n\n     若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰\n\n\n\n注意点：\n\n1.abstract不能用来修饰：属性、构造器等结构\n2.abstract不能用来修饰私方法、静态方法、final的方法、final的类\n抽象类可以有构造器、静态方法。构造器能被子类继承并完成初始化，但不会创建抽象类的实例对象。静态方法的好处是不实例化就可由子类类名直接调用\n\n六、接口1.接口使用interface来定义\n2.Java中，接口和类是并列的两个结构\n3.如何定义接口：定义接口中的成员\n4.JDK7及以前：只能定义全局常量和抽象方法\n\n        全局常量：public static final的.但是书写时，可以省略不写\n\n\n        抽象方法：public abstract的\n\n\n\n5.JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法\n   JDK9以后可以定义私有方法\n6.接口中不能定义构造器的！意味着接口不可以实例化\n7.Java开发中，接口通过让类去实现**(implements)**的方式来使用.\n\n如果实现类覆盖了接口中的所抽象方法，则此实现类就可以实例化\n如果实现类没覆盖接口中所的抽象方法，则此实现类仍为一个抽象类\n\n8.Java类可以实现多个接口   —&gt;弥补了Java单继承性的局限性\n\n格式：class AA extends BB implements CC,DD,EE\n\n9.接口与接口之间可以继承，而且可以多继承\n\n接口的具体使用，体现多态性\n接口，实际上可以看做是一种规范\n\n10.知识点\n接口中定义的静态方法，只能通过接口来调用。\n\n通过实现类的对象，可以调用接口中的默认方法。\n如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法\n\n如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法\n那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。–&gt;类优先原则\n\n如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，\n那么在实现类没重写此方法的情况下，报错。–&gt;接口冲突。\n这就需要我们必须在实现类中重写此方法\n\n如何在子类(或实现类)的方法中调用父类、接口中被重写的方法\npublic void myMethod()&#123;\n    method3();&#x2F;&#x2F;调用自己定义的重写的方法\n    super.method3();&#x2F;&#x2F;调用的是父类中声明的\n    &#x2F;&#x2F;调用接口中的默认方法\n    CompareA.super.method3();\n    CompareB.super.method3();\n&#125;\n\n七、多态1.多态： 就是指同一事物，具有多个不同表现形式。\n2.前提\n\n继承或者实现【二选一】\n方法的重写【意义体现：不重写，无意义】\n父类引用指向子类对象【格式体现】\n\n3.大大的提高了代码的灵活性，便于代码后期的扩展\n4.成员方法，编译看左边，运行看右边\n5.成员变量，等号左边是谁，优先用谁\n八、引用类型转换1.向上转型多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。当父类引用指向一个子类对象时，便是向上转型。\n使用格式：\n父类类型  变量名 &#x3D; new 子类类型();\n如：Animal a &#x3D; new Cat();\n\n2.向下转型父类类型向子类类型向下转换的过程，这个过程是强制的。一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。\n使用格式：\n子类类型 变量名 &#x3D; (子类类型) 父类变量名;\n如:Cat c &#x3D;(Cat) a; \n\n3.类型转换的意义调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。\n4.转型的异常为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验，格式如下：\n变量名 instanceof 数据类型 \n如果变量属于该数据类型，返回true。\n如果变量不属于该数据类型，返回false。\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 向上转型  \n        Animal a &#x3D; new Cat();  \n        a.eat();               &#x2F;&#x2F; 调用的是 Cat 的 eat\n\n        &#x2F;&#x2F; 向下转型  \n        if (a instanceof Cat)&#123;\n            Cat c &#x3D; (Cat)a;       \n            c.catchMouse();        &#x2F;&#x2F; 调用的是 Cat 的 catchMouse\n        &#125; else if (a instanceof Dog)&#123;\n            Dog d &#x3D; (Dog)a;       \n            d.watchHouse();       &#x2F;&#x2F; 调用的是 Dog 的 watchHouse\n        &#125;\n    &#125;  \n&#125;\n\n","slug":"05-面向对象（中）","date":"2021-09-13T14:37:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"0959816aacb592f211c0dd883a8ef3db","title":"面向对象（上）","content":"一、概述\nJava语言是面向对象的程序设计语言，而面向对象思想（Object Oriented Programming）是一种程序设计思想。\n\n这里的对象泛指现实中的一切事物，而每种事物都具有自己的属性和行为\n\n而面向对象编程就是参照现实中的事物，将其属性和行为抽象出来，描述成计算机事件的思想\n\n面向对象有以下特征：\n比较符合人们的思考习惯\n可以将复杂的逻辑简单化，易维护，易复用，易扩展\n具有封装，继承，多态的特性，可以设计出低耦合的系统，使之更加灵活\n性能比面向过程低\n\n面向对象的编程语言主要有：C++，Java，C# 等\n\n\n二、类和对象2.1    什么是类类：是一类具有相同特性的事物的抽象描述，是一组相关属性和行为的集合\n2.2    什么是对象对象：是一类事物的具体体现，对象是类的一个实例，必然具有该类事物的属性和行为\n2.3    定义类public class className&#123;\n\t&#x2F;&#x2F; 成员变量\n\t&#x2F;&#x2F; 方法\n&#125;\n\n\n一般，类的命名遵循大驼峰原则，每个首字母都要大写\n成员变量，和以前定义变量的方法一样，不过成员变量在类中方法外\n方法，有构造方法，各个成员方法，功能更加丰富，也更加灵活\n\n2.4    定义对象在Java中，万事万物都是对象，虽然一切可以看做对象，但是我们操纵的却是一个对象的    引用（reference） 也就是，我们有一个对象引用，但是不一定需要对象与之关联，如下：\nPerson p;\n\n这里创建的只是 引用，而并非对象，但是若想使用这个引用时，会返回异常，高数我们需要一个 对象 来进行关联。安全的做法是，在创建引用的同时吧对象赋给他。\nPerson p &#x3D; new Person();\n\n直接打印对象名和数组名都是显示“类型@对象的hashCode值”所以说类、数组都是引用数据类型，引用数据类型的变量中存储的是对象的地址，或者说指向堆中对象的首地址。\n那么像“Student@4e25154f”是对象的地址吗？不是，因为Java是对程序员隐藏内存地址的，不暴露内存地址信息，所以打印对象时不直接显示内存地址，而是JVM提取了对象描述信息给你现在，默认提取的是对象的运行时类型@代表对象唯一编码的hashCode值。\n2.5    属性和方法\n属性，也被称为字段，属性可以是任意类型的对象，可以是基本数据类型，也可以是引用数据类型；\n方法，表示的是  做某些事情的方式，方法其实就是函数\n方法的基本组成包括：权限修饰符，返回值类型，方法名，参数，方法体\n\n2.6    构造方法\n是一种特殊的方法，也被称为构造函数，构造器。\n在JAVA中，通过这种方法确保每个对象都被初始化。\n构造方法只能在对象的创建时期调用一次。\n没有返回值类型，他的名称要和类名保持一致，并且构造方法可以有多个。**(可以重载，不可以重写)**\n没有参数的称为 默认构造方法，如果没有定义其它构造方法，那JVM 会自动生成一个构造方法但是若手动定义了任何一个构造方法，JVM都不会再提供默认构造方法，必须手动指定。\n\npublic class Test&#123;\n\t\n\tint a;\n\tint b;\n\n\tpublic Test()&#123;\n\t\t&#x2F;&#x2F;无参构造、默认构造\n\t&#125;\n\t\n\tpublic Test(int a,int b)&#123;\n\t\t&#x2F;&#x2F; 满参构造\n\t&#125;\n&#125;\n\n2.8    成员和局部变量的区别\n\n\n区别\n成员变量\n局部变量\n\n\n\n类中位置不同\n类中方法外\n方法内或者方法声明上\n\n\n内存中位置不同\n堆内存\n栈内存\n\n\n生命周期不同\n随着对象的存在而存在，随着对象的消失而消失\n随着方法的调用而存在，随着方法的调用完毕而消失\n\n\n初始化值不同\n有默认的初始化值（默认的值在下方的成员初始化中）一种情况例外:被 final 修饰的成员变量也必须显式地赋值\n没有默认的初始化值\n\n\n作用域不同\n整个类中\n方法中\n\n\n成员变量如果被 ==static== 修饰，那么这个成员变量是属于这个类的（不会再存储到堆中，会和类一起到方法区中），如果没有，则是属于==实例==的\n2.9    对象的销毁Java 虚拟机进行管理和销毁\n2.10    作用域作用域定义了其内部定义的变量名的可见性和生命周期。作用域通常有 { } 的位置来决定\n三、重载和重写3.1    方法重载方法名相同，参数列表不同。构造函数，也是重载的一种\n每个重载方法都有独一无二的参数列表，其中包括参数的类型，顺序，数量等，满足一种因素就构成了重载。\n重载的条件：\n\n方法名必须相同\n参数列表必须不同（个数不同，类型不同，参数类型排列顺序不同）\n方法的返回值类型可以相同也可以不同\n仅仅返回值类型不足矣成为方法的重载\n重载发生在编译时，因为编译器可以根据参数类型选择使用哪个方法\n\n3.2    方法重写重写描述的是  父类和子类  之间；而重载是同一类中。\n方法的声明： 权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型&#123;\n\n\t\t\t\t&#x2F;&#x2F;方法体\n\n\t\t   &#125;\n\n约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法\n① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同\n② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符\n\n     特殊情况：子类**不能重写**父类中声明为**private权限的方法**\n\n\n\n③ 返回值类型：\n\n     父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void\n\n\n     父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是**A类或A类的子类**\n\n\n     父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是**相同的基本数据类型**(必须也是double)\n\n\n\n④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）\n\n   子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写，要么都声明为static的（不是重写)。\n\n四、this 和 superthis：代表本类对象的引用\nsuper：代表父类存储空间的标识（可以理解为父类对象引用）\n\n\n\n关键字\nthis\nsuper\n\n\n\n调用方式\n调用本类中的属性，构造函数，方法\n调用父类中的属性，构造函数，方法\n\n\n调用位置\n构造函数第一行，其他自行指定\n构造函数第一行，其他自行指定\n\n\n调用次数\n一个构造函数只能调用一次\n一个构造函数只能调用一次\n\n\n\n\n\n关键字\n访问成员变量\n访问构造方法\n访问成员方法\n\n\n\nthis\nthis.成员变量\nthis(…)\nthis.成员方法(…)\n\n\nsuper\nsuper.成员变量\nsuper(…)\nsuper.成员方法(…)\n\n\n五、访问控制权限\n\n\n\n同一类中\n同一包中（子类与无关类）\n不同包中的子类\n不同包中的无关类\n\n\n\npublic\n可以\n可以\n可以\n可以\n\n\nprotected\n可以\n可以\n可以\n不可以\n\n\n默认（friendly/default/没有）\n可以\n可以\n不可以\n不可以\n\n\nprivate\n可以\n不可以\n不可以\n不可以\n\n\npublic：用于类，需要别人调用的方法，构造方法\nprotected：通常用于继承，只想让子类使用\n缺省（默认）：包内使用\nprivate：用于成员变量，实现封装\n\nprivate是一个权限修饰符，代表最小权限，可以修饰实例变量和实例方法。\n被private修饰后的实例变量和实例方法，只在本类中才能访问。\n父类中的成员，无论是公有(public)还是私有(private)，均会被子类继承（private被继承有歧义）。\n子类虽会继承父类私有(private)的成员，但子类不能对继承的私有成员直接进行访问，可通过继承的公有方法进行访问\n\n","slug":"04-面向对象（上）","date":"2021-09-13T14:36:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"e16187d7a3c490f96b788338bdd79d24","title":"数组","content":"一、容器\n如果使用很多个变量来逐一保存数据，这样操作起来会非常的不便。把这80个数据想象成为80个鸡蛋，如果让你一个个的操作这些鸡蛋，你会非常的慌乱，此时我们可以使用一个篮子，将所有的鸡蛋(数据)全部存储到一个容器中，统一操作。 \n\n装鸡蛋用到的篮子我们可以称之为容器，容器里的一个个的鸡蛋数据，我们可以称之为元素。\n\nJava里的容器有很多种实现方式，数组是其中最基本也最重要的一种\n\n\n二、数组1.数组的特点\n他是一种数据结构(容器)，用来存储同一种类型数据的集合\n\n数组是有大小的，而且数组的大小确定后不允许改变\n\n数组里的元素是有序的，可以通过索引获取和修改数据，索引从0开始\n\n创建数组时会在内存中开辟一整块连续的空间，数组名指向这块内存的首地址。\n\n如果数组里的数据没有设置值，那么会有一个默认的值，\n整数（byte,short,in）默认0，long：0L\n浮点数   float：0.0F    double：0.0\n布尔默认false\n字符默认，0或  ‘ \\u0000 ’ （表现为空）\n引用类型，0默认null\n\n在 java中，允许长度为0的数组，长度为 0 的数组与null并不完全相同\n\n\n2.初始化（一维）\n动态初始化：创建数组时，不指定元素后续通过（下标，角标，索引）来给数组里的数据赋值。元素类型[]   数组名 = new   元素类型[元素个数或者数组长度] ;示例：int[] arr = new int[3]\n\n\n静态初始化：创建数组时，就给元素赋值。\n元素类型[] 数组名 = new 元素类型[]{元素1，元素2，元素3……};\n示例：int[] arr = new int[] {1,2,3,};    int[] arr = {1,2,3,4}\n\n注意：大括号直接赋值的方式只能写在一行，不能分开来写！\n\n注意：数组在创建时就已经指定好了长度，在代码里使用 length 属性来获取数组的长度。\n\n注意：当明确数组元素时，建议使用第二种方式\n\n\n3.数组遇到的问题\n数组索引越界异常：ArrayIndexOutOfBoundsException（程序运行的时候发生)）\n访问到了数组的最后一个元素后，你还在继续访问,此时就会出现此问题。\n\n空指针异常：NullPointerException（程序运行的时候发生）\n一个引用变量已经不再指向对内存的地址。这个时候，还在使用这个引用。\n\n\n4.遍历方法\n普通for循环\n\nfor each循环（增强for循环）\n\nwhile循环\n\n注意：for each循环语句的循环变量将会遍历数组中的每个元素，而不是下标值\n如果不希望遍历整个集合，或者在循环内部需要使用下标值时，用普通for循环\n\n\n5.选择排序\n\n\n\n\n\n\n\n\n从索引为0的元素开始与其他元素(自己除外)依次比较，每次比较完，最小值出现在最左边\npublic static void main(String[] args) &#123;\n     int[] arr &#x3D;&#123;12,22,53,65,45,32&#125;;\n     for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;\n         for (int j &#x3D; i+1; j &lt; arr.length; j++) &#123;\n             if (arr[i]&gt;arr[j]) &#123;\n                 int temp &#x3D; arr[i];\n                 arr[i]&#x3D;arr[j];\n                 arr[j]&#x3D;temp;\n             &#125;\n         &#125;\n     &#125;\n     System.out.println(Arrays.toString(arr));\n&#125;\n\n\n\n6.冒泡排序\n\n\n\n\n\n\n\n\n相邻的元素，两两相比，大的后移。每次比较完后，最大值出现在右边\npublic static void main(String[] args) &#123;\n  int[] arr &#x3D;&#123;12,22,53,65,45,32&#125;;\n  for (int i &#x3D; 0; i &lt; arr.length-1; i++) &#123;\n      for (int j &#x3D; 0; j &lt; arr.length-1-i; j++) &#123;\n          if (arr[j]&gt;arr[j+1])&#123;\n             int temp &#x3D; arr[j];\n             arr[j] &#x3D; arr[j+1];\n             arr[j+1] &#x3D; temp;\n          &#125;\n      &#125;\n  &#125;\n  System.out.println(Arrays.toString(arr));\n&#125;\n\n\n\n7.折半（二分）查找\n\n\n\n\n\n\n\n\n需要 有序数组\n三、基本和引用类型1.概述\n在 java 中只有值传递，引用传递的时候，传递的是地址值。\n基本数据类型传递过去后，形参改变对实参没有影响。引用类型传递过去后，形参改变直接影响实参 \n\n2.分类\n基本数据类型,基本数据类型只有8种，可按照如下分类\n整数类型：long、int、short、byte浮点类型：float、double字符类型：char布尔类型：boolean\n\n引用数据类型大致包括：\n类、 接口类型、 数组类型、 枚举类型、 注解类型、 字符串型\n简单来说，所有的非基本数据类型都是引用数据类型。\n\n\n3.形参实参public static void main(String[] args) &#123;\n    System.out.println(&quot;---基本数据类型---&quot;);\n    int a&#x3D;10;\n    System.out.println(&quot;形参改变前，实参：&quot;+a);\n    change(a);\n    System.out.println(&quot;作为形参改变后，实参：&quot;+a);\n\n    System.out.println(&quot;---引用数据类型---&quot;);\n    int[] arr&#x3D;&#123;1,2,3&#125;;\n    System.out.println(&quot;形参改变前，实参：&quot;+arr[2]);\n    change2(arr);\n    System.out.println(&quot;作为形参改变后，实参：&quot;+arr[2]);\n&#125;\n\nprivate static void change2(int[] arr) &#123;\n    arr[2] &#x3D; 100;\n    System.out.println(&quot;方法中，当a作为形参且改变后：&quot;+arr[2]);\n&#125;\n\nprivate static void change(int a) &#123;\n    a&#x3D;20;\n    System.out.println(&quot;方法中，当a作为形参且改变后：&quot;+a);\n&#125;\n\n\n四、数组内存图1.内存概述内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。其作用是用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。只要计算机在运行中，CPU就会把需要运算的数据调到内存中进行运算，当运算完成后CPU再将结果传送出来。我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。\nJava虚拟机要运行程序，必须要对内存进行空间的分配和管理。\n2.java虚拟机的内存划分为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。\n\n\n\n\n\n区域名称\n作用\n\n\n\n程序计数器\n程序计数器是CPU中的寄存器，它包含每一个线程下一条要执行的指令的地址\n\n\n虚拟机栈\n用于存储正在执行的每个Java方法的局部变量表等。局部变量表存放了编译期可知长度的各种基本数据类型、对象引用，方法执行完，自动释放。\n\n\n本地方法栈\n当程序中调用了native的本地方法时，本地方法执行期间的内存区域。在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。\n\n\n方法区\n存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。\n\n\n堆内存\n存储对象（包括数组对象），new来创建的，都存储在堆内存。\n\n\n3.数组在内存中的存储\n\n\n\n\n\n\n\n\n\n思考：打印arr为什么是[I@5f150435，它是数组的地址吗？\n答：它不是数组的地址。\n问？不是说arr中存储的是数组对象的首地址吗？\n答：arr中存储的是数组的首地址，但是因为数组是引用数据类型，打印arr时，会自动调用arr数组对象的toString()方法，默认该方法实现的是对象类型名@该对象的hashCode()值的十六进制值。\n问？对象的hashCode值是否就是对象内存地址？\n答：不一定，因为这个和不同品牌的JVM产品的具体实现有关。例如：Oracle的OpenJDK中给出了5种实现，其中有一种是直接返回对象的内存地址，但是OpenJDK默认没有选择这种方式。\n五、二维数组1. 第一种格式\n\n   int[][] arr &#x3D; new int[3] [2]; \n\n   定义了名称为 arr 的二维数组 二维数组中有 3 个一维数组 \n\n   每一个一维数组中有 2 个元素 一维数组的名称分别为 arr[0], arr[1], arr[2] \n\n   给第一个一维数组 1 脚标位赋值为 78 \n\n   写法是：arr[0] [1] &#x3D; 78;\n\n2. 第二种格式\n\n   int[][] arr &#x3D; new int[3] []; \n\n   二维数组中有 3 个一维数组 \n\n   每个一维数组都是默认初始化值 null----引用类型的初始化值为 Null \n\n   可以对这个三个一维数组分别进行初始化 \n\n   arr[0] &#x3D; new int[3]; arr[1] &#x3D; new int[1]; arr[2] &#x3D; new int[2];\n\n3. 第三种格式\n\n   int[][] arr &#x3D; &#123;&#123;3,8,2&#125;,&#123;2,7&#125;,&#123;9,0,1,6&#125;&#125;; \n\n   定义一个名称为 arr 的二维数组 \n\n   二维数组中的有三个一维数组 \n\n   一个一维数组中具体元素也都已初始化 \n\n   第一个一维数组 arr[0] &#x3D; &#123;3,8,2&#125;; \n\n   第二个一维数组 arr[1] &#x3D; &#123;2,7&#125;; \n\n   第三个一维数组 arr[2] &#x3D; &#123;9,0,1,6&#125;; \n\n   第三个一维数组的长度表示方式：arr[2].length;\n   \n   \n 4. 遍历格式\n \n \tpublic static void main(String[] args) &#123; \n \t\n \t\tint[][] arr &#x3D; &#123;&#123;60,12,23&#125;,&#123;0,50,69&#125;,&#123;98,120&#125;,&#123;111,222,333&#125;&#125;;\n \t\t\n \t\tfor(int x &#x3D; 0;x&lt;arr.length;x++)&#123; \n \t\t\n \t\t\tfor(int y &#x3D; 0;y&lt;arr[x].length;y++)&#123; \n \t\t\t\n \t\t\t\tSystem.out.println(arr[x][y]+&quot; &quot;);\n\t\t\t&#125; \n\t\t\t\n\t\t\tSystem.out.println(); \n\t\t&#125;\n\n六、可变参数1. int add(T... a)：该函数可以添加多个同种类型的数据，相当于函数的参数是数组形式。 \n\n2. int add(T a,T... a1)：在传参数是，除了第一个为 a，其他全部都是属于可变参数。\n\n注意：可变参数必须放在其他参数的最后边。 传入的实参必须是根据形参的同种类型的参数","slug":"03-数组","date":"2021-09-13T14:35:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"7689509bc540e79b176cff8111263e2f","title":"流程控制语句","content":"一、顺序结构顺序结构就是从上到下逐行执行，中间没有任何跳转和判断。\npublic static void main(String[] args)&#123;\n    System.out.println(&quot;&quot;);\n    System.out.println(&quot;&quot;);\n    System.out.println(&quot;&quot;);\n    System.out.println(&quot;&quot;);\n&#125;\n\n\n\n二、分支结构2.1    if 语句if(条件表达式)&#123;  &#x2F;&#x2F; 条件表达式必须是一个布尔类型的值\n      语句体;\n&#125;\n\n执行流程\n    \n    首先判断条件表达式，看其结果是true还是false\n    \n    如果是true就执行语句体\n    \n    如果是false就不执行\n\n2.2    if … else … 语句if(关系表达式) &#123; \n      语句体1;\n&#125;else &#123;\n      语句体2;\n&#125;\n\n执行流程\n\n\t首先判断关系表达式看其结果是true还是false\n\n    如果是true就执行语句体1\n\n    如果是false就执行语句体2\n\n2.3    if … else if … else … 语句if (判断条件1) &#123;\n      执行语句1;\n&#125; else if (判断条件2) &#123;\n      执行语句2;\n&#125;\n...\n&#125;else if (判断条件n) &#123;\n     执行语句n;\n&#125; else &#123;\n      执行语句n+1;\n&#125;\n\n执行流程\n    \n\t首先判断关系表达式1看其结果是true还是false\n\n    如果是true就执行语句体1，然后结束当前多分支\n\n    如果是false就继续判断关系表达式2看其结果是true还是false\n\n    如果是true就执行语句体2，然后结束当前多分支\n\n    如果是false就继续判断关系表达式…看其结果是true还是false\n\n    …\n\n    如果没有任何关系表达式为true，就执行语句体n+1，然后结束当前多分支。\n\n2.4    switch … case … 语句switch(表达式)&#123;\n    case 常量值1:\n     语句块1;\n        【break;】\n    case 常量值2:\n        语句块2;\n        【break;】   \n    。。。\n   【default:\n        语句块n+1;\n        【break;】\n     】\n&#125;\n\n执行过程\n（1）入口\n\t\n\t当switch(表达式)的值与case后面的某个常量值匹配，就从这个case进入；\n\t\n\t当switch(表达式)的值与case后面的所有常量值都不匹配，寻找default分支进入;不管\tdefault在哪里\n\n（2）一旦从“入口”进入switch，就会顺序往下执行，直到遇到“出口”，即可能发生贯穿\n\n（3）出口\n\n\t自然出口：遇到了switch的结束&#125;\n\n\t中断出口：遇到了break等\n        \n（4）在switch语句中，如果case的后面不写break，将出现穿透现象，\n    也就是一旦匹配成功，不会在判断下一个case的值，直接向后运行，\n    直到遇到break或者整个switch语句结束，switch语句执行终止。\n\n\n\n三、循环结构3.1    while循环while (循环条件语句①) &#123;\n    循环体语句②；\n&#125;\n\n执行流程\n\n第一步：执行循环条件语句①，看循环条件语句的值是true，还是false；\n       如果是true，执行第二步；\n       如果是false，循环语句中止，循环不再执行。\n第二步：执行循环体语句②；\n第三步：循环体语句执行完后，重新从第一步开始再执行一遍\n\n3.1.2    while循环语句扩展格式初始化语句①；\nwhile (循环条件语句②) &#123;\n    循环体语句③；\n    迭代语句④；\n&#125;\n\n执行流程\n第一步：执行初始化语句①，完成循环变量的初始化；\n第二步：执行循环条件语句②，看循环条件语句的值是true，还是false；\n\t   如果是true，执行第三步；\n\t   如果是false，循环语句中止，循环不再执行。\n第三步：执行循环体语句③\n第四步：执行迭代语句④，针对循环变量重新赋值\n第五步：根据循环变量的新值，重新从第二步开始再执行一遍\n\n案例：遍历1-100之间的偶数\nint num &#x3D; 2;\nwhile(num&lt;&#x3D;100)&#123;\n    System.out.println(num);\n    num+&#x3D;2;\n&#125;\n\n3.2    do … while … 循环do &#123;\n    循环体语句①；\n&#125; while (循环条件语句②)；\n\n执行流程\n第一步：执行循环体语句①；\n第二步：执行循环条件语句②，看循环条件语句的值是true，还是false；\n\t   如果是true，执行第三步；\n\t   如果是false，循环语句终止，循环不再执行。\n第三步：循环条件语句执行完后，重新从第一步开始再执行一遍\n    \n    \n注意：\n（1）while(循环条件)中循环条件必须是boolean类型\n\n（2）do&#123;&#125;while();最后有一个分号\n\n（3）do...while结构的循环体语句是至少会执行一次，这个和for和while是不一样的\n\n3.2.1    do … while … 循环语句扩展格式初始化语句①\ndo &#123;\n    循环体语句②；\n    迭代语句③；\n&#125; while (循环条件语句④)；\n\n执行流程\n第一步：执行初始化语句①，完成循环变量的初始化；\n第二步：执行循环体语句②；\n第三步：执行迭代语句③，针对循环变量重新赋值；\n第四步：执行循环条件语句④，看循环条件语句的值是true，还是false；\n\t   如果是true，根据循环变量的新值，重新从第二步开始再执行一遍；\n\t   如果是false，循环语句中止，循环不再执行\n\npublic static void main(String[] args)&#123;\n    &#x2F;&#x2F;随机生成一个100以内的整数\n    &#x2F;*\n        Math.random() &#x3D;&#x3D;&gt; [0,1)的小数\n        Math.random()* 100 &#x3D;&#x3D;&gt; [0,100)的小数\n        (int)(Math.random()* 100) &#x3D;&#x3D;&gt; [0,100)的整数\n        *&#x2F;\n    int num &#x3D; (int)(Math.random()* 100);\n    &#x2F;&#x2F;System.out.println(num);\n\n    &#x2F;&#x2F;声明一个变量，用来存储猜的次数\n    int count &#x3D; 0;\n\n    java.util.Scanner input &#x3D; new java.util.Scanner(System.in);\n    int guess;&#x2F;&#x2F;提升作用域\n    do&#123;\n        System.out.print(&quot;请输入100以内的整数：&quot;);\n        guess &#x3D; input.nextInt();\n\n        &#x2F;&#x2F;输入一次，就表示猜了一次\n        count++;\n\n        if(guess &gt; num)&#123;\n            System.out.println(&quot;大了&quot;);\n        &#125;else if(guess &lt; num)&#123;\n            System.out.println(&quot;小了&quot;);\n        &#125;\n    &#125;while(num !&#x3D; guess);\n\n    System.out.println(&quot;一共猜了：&quot; + count+&quot;次&quot;);\n\n&#125;\n\n3.3    for 循环for(初始化语句①; 循环条件语句②; 迭代语句④)&#123;\n    循环体语句③\n&#125;\nfor(;;)&#123;\n    循环体语句块；&#x2F;&#x2F;如果循环体中没有跳出循环体的语句，那么就是死循环\n&#125;\n\n注意：\n\n（1）for(;;)中的两个；是不能多也不能少\n\n（2）循环条件必须是boolean类型\n\n（3）如果循环条件语句②省略的话，就默认为循环条件成立\n\n执行流程：\n\n第一步：执行初始化语句①，完成循环变量的初始化；\n第二步：执行循环条件语句②，看循环条件语句的值是true，还是false；\n如果是true，执行第三步；\n如果是false，循环语句中止，循环不再执行。\n第三步：执行循环体语句③\n第四步：执行迭代语句④，针对循环变量重新赋值\n第五步：根据循环变量的新值，重新从第二步开始再执行一遍\n\n3.3.1    for … each … 循环for ( 变量类型  变量名 : 数组名 ) &#123;\n    \n    需要执行的循环语句;\n \n&#125;\n\n\n\n\n\n\n\n\n\n\n不使用下标变量就可以顺序地遍历整个数组\n3.4    嵌套循环所谓嵌套循环，是指一个循环的循环体是另一个循环。\n比如for循环里面还有一个for循环，就是嵌套循环。\n总共的循环次数&#x3D;外循环次数*内循环次数。\n当然可以是三种循环任意互相嵌套。\n\nfor(初始化语句①; 循环条件语句②; 迭代语句⑦) &#123;\n    for(初始化语句③; 循环条件语句④; 迭代语句⑥) &#123;\n          循环体语句⑤;\n    &#125;\n&#125;\n\n案例1：打印倒三角形\n🐟 🐟 🐟 🐟 🐟 \n 🐟 🐟 🐟 🐟 \n  🐟 🐟 🐟 \n   🐟 🐟 \n    🐟 \npublic class Test07 &#123;\n\tpublic static void main(String[] args)&#123;\n\t\tfor(int i&#x3D;1; i&lt;&#x3D;5; i++)&#123;&#x2F;&#x2F;控制行数\n\t\t\t&#x2F;*\n\t\t\t每一行有三件事：\n\t\t\t（1）打印n个空格\n\t\t\t（2）打印m个&quot; *&quot;\n\t\t\t（3）换行\n\t\t\t*&#x2F;\n\t\t\t&#x2F;&#x2F;（1）打印n个空格\n\t\t\t&#x2F;*\n\t\t\t第1行：0个，当i&#x3D;1, j应该让它第一次循环都不满足\tj&lt;i\n\t\t\t第2行：1个，当i&#x3D;2, j运行1次，j&#x3D;1\n\t\t\t第3行：2个，当i&#x3D;3, j运行2次，j&#x3D;1,2\n\t\t\t第4行：3个，当i&#x3D;4, j运行3次，j&#x3D;1,2,3\n\t\t\t第5行：4个，当i&#x3D;5, j运行4次，j&#x3D;1,2,3,4\n\t\t\t*&#x2F;\n\t\t\tfor(int j&#x3D;1; j&lt;i; j++)&#123;\n\t\t\t\tSystem.out.print(&quot; &quot;);\n\t\t\t&#125;\n\t\t\t&#x2F;&#x2F;（2）打印m个&quot; *&quot;\n\t\t\t&#x2F;*\n\t\t\t第1行：5个，当i&#x3D;1,j运行5次，j&#x3D;1,2,3,4,5\t\tj&lt;&#x3D;6-i\n\t\t\t第2行：4个，当i&#x3D;2,j运行4次，j&#x3D;1,2,3,4\n\t\t\t第3行：3个，当i&#x3D;3,j运行3次，j&#x3D;1,2,3\n\t\t\t第4行：2个，当i&#x3D;4,j运行2次，j&#x3D;1,2\n\t\t\t第5行：1个，当i&#x3D;5,j运行1次，j&#x3D;1\n\t\t\t*&#x2F;\n\t\t\tfor(int j&#x3D;1; j&lt;&#x3D;6-i; j++)&#123;\n\t\t\t\tSystem.out.print(&quot; *&quot;);\n\t\t\t&#125;\n\t\t\t\n\t\t\t&#x2F;&#x2F;（3）换行\n\t\t\tSystem.out.println();\n\t\t&#125;\n\t&#125;\n&#125;\n\n案例2：打印『X』对称图形，效果如图所示：\n        🐅*****🐅\n        *🐅***🐅*\n        **🐅*🐅**\n        ***🐅***\n        **🐅*🐅**\n        *🐅***🐅*\n        🐅*****🐅\n    \npublic class Test08 &#123;\n\tpublic static void main(String[] args)&#123;\n\t\tfor(int i&#x3D;1; i&lt;&#x3D;7; i++)&#123;&#x2F;&#x2F;控制行数\n\t\t\t&#x2F;&#x2F;(1)打印该行的*或o\n\t\t\t&#x2F;*\n\t\t\t发现O+*的总个数是7个\n\t\t\t当i&#x3D;1, 当j&#x3D;1和j&#x3D;7的时候是O，其余的是* \n\t\t\t当i&#x3D;2, 当j&#x3D;2和j&#x3D;6的时候是O，其余的是* \n\t\t\t当i&#x3D;3, 当j&#x3D;3和j&#x3D;5的时候是O，其余的是* \n\t\t\t当i&#x3D;4, 当j&#x3D;4的时候是O，其余的是* \n\t\t\t当i&#x3D;5, 当j&#x3D;5和j&#x3D;3的时候是O，其余的是* \n\t\t\t当i&#x3D;6, 当j&#x3D;6和j&#x3D;2的时候是O，其余的是* \n\t\t\t当i&#x3D;7, 当j&#x3D;7和j&#x3D;1的时候是O，其余的是* \n\t\t\t*&#x2F;\n\t\t\tfor(int j&#x3D;1; j&lt;&#x3D;7; j++)&#123;\n\t\t\t\tif(i&#x3D;&#x3D;j || i&#x3D;&#x3D;8-j)&#123;\n\t\t\t\t\tSystem.out.print(&quot;O&quot;);\n\t\t\t\t&#125;else&#123;\n\t\t\t\t\tSystem.out.print(&quot;*&quot;);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\t\n\t\t\t&#x2F;&#x2F;(2)每一行的最后一件事是换行\n\t\t\tSystem.out.println();\n\t\t&#125;\n\t&#125;\n&#125;\n\n3.5    循环语句的区别\n从循环次数角度分析 \ndo…while循环至少执行一次循环体语句\nfor和while循环先循环条件语句是否成立，然后决定是否执行循环体，至少执行零次循环体语句\n\n\n从循环变量的生命周期角度分析\nfor循环的循环变量在for()中声明的，在循环语句结束后，不可以被访问；\nwhile和do…while循环的循环变量因为在外面声明的，所以while和do…while结束后可以被继续使用的；\n\n\n如何选择\n遍历有明显的循环次数（范围）的需求，选择for循环\n遍历没有明显的循环次数（范围）的需求，循环while循环\n如果循环体语句块至少执行一次，可以考虑使用do…while循环\n本质上：三种循环之间是可以互相转换的，都能实现循环的功能\n\n\n三种循环结构都具有四要素：\n循环变量的初始化表达式\n循环条件\n循环变量的修改的迭代表达式\n循环体语句块\n\n\n\n3.6    关键字：break使用场景：终止switch 或者 当前循环\n\n在选择结构switch语句中\n\n在循环语句中\n\n离开使用场景的存在是没有意义的\n\nbreak用于，跳出所在的当前整个循环，到外层代码继续执行。\n不管是哪种循环，一旦在循环体中遇到break，系统将完全结束循环，开始执行循环之后的代码。 \nbreak不仅可以结束其所在的循环，还可结束其外层循环。此时需要在break后紧跟一个标签，这个标签用于标识一个外层循环。\nJava中的标签就是一个紧跟着英文冒号（:）的标识符。且它必须放在循环语句之前才有作用。\npublic class BreakTest\n&#123;\n　　public static void main(String[] args)&#123;\n　　　　&#x2F;&#x2F; 外层循环，outer作为标识符\n　　　　outer:\n　　　　for (int i &#x3D; 0 ; i &lt; 5 ; i++ )&#123;\n　　　　　　&#x2F;&#x2F; 内层循环\n　　　　　　for (int j &#x3D; 0; j &lt; 3 ; j++ )&#123;\n　　　　　　　　System.out.println(&quot;i的值为:&quot; + i + &quot; j的值为:&quot; + j);\n　　　　　　　　if (j &#x3D;&#x3D; 1)&#123;\n　　　　　　　　　　&#x2F;&#x2F; 跳出outer标签所标识的循环。\n　　　　　　　　　　　break outer;\n　　　　　　　　&#125;\n　　　　　　&#125;\n　　　　&#125;\n　　&#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n案例：从键盘输入一个大于1的自然数，判断它是否是素数 提示：素数是指大于1的自然数中，除了1和它本身以外不能再有其他因数的自然数，即某个素数n，在[2,n-1]范围内没有其他自然数可以把n整除\nclass Test07BreakExer1&#123;\n    public static void main(String[] args)&#123;\n        java.util.Scanner input &#x3D; new java.util.Scanner(System.in);\n\n        int num;\n        while(true)&#123;\n            &#x2F;&#x2F;true是常量，常量是编译期间就可以确定的值\n            System.out.print(&quot;请输入一个大于1的自然数：&quot;);\n            num &#x3D; input.nextInt();\n\n            if(num&gt;1)&#123;\n                break;\n            &#125;\n        &#125;\n        System.out.println(&quot;num &#x3D; &quot; + num);\n\n        boolean flag &#x3D; true;&#x2F;&#x2F;假设num是素数\n\n        &#x2F;&#x2F;判断它是否是素数\n        for(int i&#x3D;2; i&lt;num; i++)&#123;\n            if(num % i &#x3D;&#x3D;0)&#123;&#x2F;&#x2F;num被某个i整除了，num就不是素数\n                System.out.println(num + &quot;不是素数&quot;);\n                flag &#x3D; false;\n                break;&#x2F;&#x2F;找到其中一个可以把num整除的数，就可以结束了，因为num已经可以判定不是素数了\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F;只有把[2,num-1]之间的所有数都检查过了，才能下定结论，num是素数\n        if(flag)&#123;\n            System.out.println(num + &quot;是素数&quot;);\n        &#125;\n\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n案例：从键盘输入不断输入整数，输入0表示结束，统计一共有几个正数、负数。\npublic static void main(String[] args) &#123;\n    java.util.Scanner input &#x3D; new java.util.Scanner(System.in);\n\n    int positive &#x3D; 0;\n    int negative &#x3D; 0;\n    while(true)&#123;\n        System.out.print(&quot;请输入整数（0）结束：&quot;);\n        int num &#x3D; input.nextInt();\n        if(num&#x3D;&#x3D;0)&#123;\n            break;\n        &#125;else if(num&gt;0)&#123;\n            positive++;\n        &#125;else&#123;\n            negative++;\n        &#125;\n    &#125;\n    System.out.println(&quot;正数：&quot; + positive + &quot;，负数：&quot; + negative);\n&#125;\n\n3.7    关键字：continue执行continue操作，跳出本次循环，从下一个迭代继续运行循环，内层循环执行完毕，外层代码继续运行。\ncontinue结束的是本次循环，将接着开始下一次循环。\n3.8    returnreturn关键字并不是专门用于跳出循环的，return的功能是结束一个方法。 一旦在循环体内执行到一个return语句，return语句将会\n结束该方法，循环自然也随之结束。\n四、综合案例","slug":"02-流程控制语句","date":"2021-09-13T14:34:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"},{"id":"7f9eaea51aac5991b1ad0d8e6f097110","title":"基础知识","content":"一、终端命令（Windows）\n\n\n命令\n说明\n\n\n\n盘符名称：\n盘符切换，d: 表示切换到d盘\n\n\ndir\n查看当前路径下的内容\n\n\ncd\n查看当前路径\n\n\ncd  目录\n进入单级目录\n\n\ncd  ..\n回退到上一-级目录\n\n\ncd\\\n回退到盘符目录\n\n\ncls\n清屏\n\n\nexit\n退出命令提示符窗口\n\n\n\n\n\n命令\n说明\n\n\n\ncalc\n启动计算器\n\n\nappwiz.cpl\n程序和功能\n\n\ncleanmgr\n打开磁盘清理工具\n\n\ncontrol\n控制面板\n\n\ndevmgmt.msc\n设备管理器\n\n\nexplorer\n资源管理器\n\n\ngpedit.msc\n组策略\n\n\nmspaint\n画图\n\n\nnotpad\n记事本\n\n\nregedit.exe\n注册表\n\n\nstikyNot\n便签\n\n\nwrite\n写字板\n\n\n二、注释分类• 单行注释格式：//信息\n• 多行注释格式：/信息/    \n• 文档注释格式：/*信息/\n三、八大数据类型\n\n\n简单类型\nboolean\nbyte\nchar\nshort\nInt\nlong\nfloat\ndouble\n\n\n\n二进制位数\n1\n8\n16\n16\n32\n64\n32\n64\n\n\n封装器类\nBoolean\nByte\nCharacter\nShort\nInteger\nLong\nFloat\nDouble\n\n\n对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。如：\n例如：基本类型byte 二进制位数：Byte.SIZE 最小值：Byte.MIN_VALUE 最大值：Byte.MAX_VALUE\n\nbyte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。\n\nshort：16位，最大数据存储量是65536，数据范围是-32768~32767之间。\n\nint：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。\n\nlong：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。\n\nfloat：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。\n\ndouble：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。\n\nboolean：只有true和false两个取值。\n\nchar：16位，存储Unicode码，用单引号赋值。\n\n* jvm 内存空间\n\n  （1）. Heap 堆空间：分配对象 new Student（）\n\n  （2）. Stack 栈空间：临时变量 Student stu\n\n  （3）. Code 代码区 ：类的定义，静态资源 Student.class\n  \n* eg：Student stu &#x3D; new Student（）； &#x2F;&#x2F;new 在内存的堆空间创建对象\n\n  stu.study(); &#x2F;&#x2F;把对象的地址赋给stu引用变量\n\n  上例实现步骤：\n  \n  a.JVM加载Student.class 到Code区\n\n  b.new Student()在堆空间分配空间并创建一个Student实例；\n  \n  c.将此实例的地址赋值给引用stu， 栈空间；\n\n\n\n四、三大引用数据类型\n类 Class    接口 Interface    数组 Array\n\n八种基本类型在java中都有对应的 封装类型，也就是 引用类型：\n整数类型 Byte、Short、Integer、Long浮点数类型 Float、Double字符型 Character布尔类型 Boolean\n\n\n五、数据转换简单类型数据间的转换,有两种方式: 自动转换 和 强制转换, 通常发生在表达式中或方法的参数传递时.\n\n自动转换\n具体地讲,当一个较”小”数据与一个较”大”的数据一起运算时,系统将自动将”小”数据转换成”大”数据,再进行运算\n这里我们所说的”大”与”小”,并不是指占用字节的多少,而是指表示值的范围的大小\n这些类型由”小”到”大”分别为 (byte，short，char)–int–long–float—double\na 如果低级类型为char型，向高级类型（整型）转换时，会转换为对应ASCII码值\nb 对于byte,short,char三种类型而言，他们是平级的，因此不能相互自动转换，可以使用强制类型转换\n\n\n强制类型转换\n将”大”数据转换为”小”数据时，使用强制类型转换\n格式： 用圆括号括起来目标类型，置于变量前例如： int n=(int)3.14159/2;\n这种转换肯定可能会导致溢出或精度的下降\n\n\n六、标识符1. 标识符是用户编程时使用的名字，用于给类、方法、变量、常量等命名。\n\n2. Java中标识符的组成规则：\n   \n   由字母、数字、下划线“_”、美元符号“$”组成，第一个字符不能是数字\n   \n   不能使用java中的关键字作为标识符\n   \n   标识符对大小写敏感（区分大小写）\n\n3. Java中标识符的命名约定：\n\n   * 小驼峰式命名：变量名、方法名\n   \n     首字母小写，从第二个单词开始每个单词的首字母大写\n   \n   * 大驼峰式命名：类名\n   \n     每个单词的首字母都大写\n     \n4. 标识符的命名最好可以做到见名知意\n\n七、进制（了解）7.1    计算机中，数字共有四种不同进制的表示方式\n\n\n十进制\n二进制\n八进制\n十六进制\n\n\n\n0\n0\n0\n0\n\n\n1\n1\n1\n1\n\n\n2\n10\n2\n2\n\n\n3\n11\n3\n3\n\n\n4\n100\n4\n4\n\n\n5\n101\n5\n5\n\n\n6\n110\n6\n6\n\n\n7\n111\n7\n7\n\n\n8\n1000\n10\n8\n\n\n9\n1001\n11\n9\n\n\n10\n1010\n12\na或A\n\n\n11\n1011\n13\nb或B\n\n\n12\n1100\n14\nc或C\n\n\n13\n1101\n15\nd或D\n\n\n14\n1110\n16\ne或E\n\n\n15\n1111\n17\nf或F\n\n\n16\n10000\n20\n10\n\n\n7.2    代码中不同进制的表示方式\n十进制：默认就是十进制\nSystem.out.println(10);\n二进制：0b或0B开头\nSystem.out.println(0B10);\n八进制：0开头\nSystem.out.println(010);\n十六进制：0x或0X开头\nSystem.out.println(0X10);\n\n7.3    进制转换\n十进制转二进制、八进制和十六进制\n二进制、八进制和十六进制 转换成为 十进制\n二进制、八进制和十六进制相互转换\n\n\n7.4    计算机存储单位\n位（bit）：是数据存储的最小单位，也就是二进制。二进制数系统中，每个0或1就是一个位，叫做bit（比特）\n\n字节（Byte）：是计算机信息技术用于计量存储容量的一种计量单位，也是是计算机的基本存储单位，一字节等于八位。\n\n转换关系：\n\n8 bit = 1 Byte\n1024 Byte = 1 KB\n1024 KB = 1 MB\n1024 MB = 1 GB\n1024 GB = 1 TB\n\n\n\n7.5    数据二进制表示\n原码\n反码\n补码\n\n八、运算符8.1    运算符和表达式运算符：对常量或者变量进行操作的符号\n表达式：用运算符把常量或者变量连接起来符合java语法的式子就可以称为表达式。\n例如：int c = a + b;    +是运算符   a+b 是表达式\n8.2    算术运算符\n\n\n算术运算符\n符号解释\n\n\n\n+\n加法运算，字符串连接运算，正号\n\n\n-\n减法运算，负号\n\n\n*\n乘法运算\n\n\n/\n除法运算，整数/整数结果还是整数\n\n\n%\n求余运算，余数的符号只看被除数\n\n\n++ 、 --\n自增自减运算\n\n\n\n注意：\n/和%的区别：两个数据做除法，/取结果的商，%取结果的余数。\n整数操作只能得到整数，要想得到小数，必须有浮点数参与运算\n\nchar类型参与算术运算，使用的是计算机底层对应的十进制数值。需要我们记住三个字符对应的数值：‘a’ – 97 a-z是连续的，所以’b’对应的数值是98，’c’是99，依次递加‘A’ – 65 A-Z是连续的，所以’B’对应的数值是66，’C’是67，依次递加‘0’ – 48 0-9是连续的，所以’1’对应的数值是49，’2’是50，依次递加\n\n\n当“+”操作中出现 字符串 时，这个”+”是字符串连接符，而不是算术运算。\n“itheima”+ 666; // 输出：itheima666\n\n自增自减运算符\n符号  作用  说明++     自增  变量的值加1–       自减  变量的值减1\n\n注意事项：自加自减运算\n++ 运算，变量自己的值加1。反之，-- 运算，变量自己的值减少1，用法与++ 一致。\n先自增运算符: ++在前，先自加，后赋值，例如, ++a;\n后自增运算符: ++在后，先赋值，后自加，例如, a++;\n\n\n8.3    赋值运算符\n\n\n赋值运算符\n符号解释\n\n\n\n=\n将符号右边的值，赋值给左边的变量\n\n\n+=\n将符号**左边的值和右边的值进行相加操作，最后将结果赋值给左边的变量**\n\n\n-=\n将符号**左边的值和右边的值进行相减操作，最后将结果赋值给左边的变量**\n\n\n*=\n将符号**左边的值和右边的值进行相乘操作，最后将结果赋值给左边的变量**\n\n\n/=\n将符号**左边的值和右边的值进行相除操作，最后将结果赋值给左边的变量**\n\n\n%=\n将符号**左边的值和右边的值进行取余操作，最后将结果赋值给左边的变量**\n\n\n* 赋值运算符的作用是将一个表达式的值赋给左边，左边必须是可修改的，不能是常量        \n\n8.4    关系运算符\n\n\n关系运算符\n符号解释\n\n\n\n&lt;\n比较符号左边的数据是否小于右边的数据，如果小于结果是true。\n\n\n&gt;\n比较符号左边的数据是否大于右边的数据，如果大于结果是true。\n\n\n&lt;=\n比较符号左边的数据是否小于或者等于右边的数据，如果大于结果是false。\n\n\n&gt;=\n比较符号左边的数据是否大于或者等于右边的数据，如果小于结果是false。\n\n\n==\n比较符号两边数据是否相等，相等结果是true。\n\n\n！=\n不等于符号 ，如果符号两边的数据不相等，结果是true。\n\n\n* 注意事项：\n     关系运算符的结果都是boolean类型，要么是true，要么是false。\n     千万不要把“&#x3D;&#x3D;”误写成“&#x3D;”，&quot;&#x3D;&#x3D;&quot;是判断是否相等的关系，&quot;&#x3D;&quot;是赋值。\n\n8.4    逻辑运算符\n\n\n逻辑运算符\n符号解释\n运算规则\n\n\n\n&amp;\n逻辑与,逻辑且\n只有所有的运算数都是true,结果才是true,只要有一个是false,结果就是false\n\n\n|\n逻辑或\n只有所有的运算数都是false,结果才是flase,只要有一个是true,结果就是true\n\n\n^\n逻辑异或\n相同为false，不同为true\n\n\n!\n逻辑非\n非false则true，非true则false\n\n\n&amp;&amp;\n双与，短路与\n左边为false，则右边就不看\n\n\n||\n双或，短路或\n左边为true，则右边就不看\n\n\n* 用来连接两个布尔类型结果的运算符（!除外），以判断程序中的表达式是否成立，判断的结果是 true 或 false。\n\n* 短路逻辑运算符\n     符号   作用    说明\n     &amp;&amp;    短路作用和&amp;相同，但是有短路效果\n     ||    短路或  作用和|相同，但是有短路效果\n     \n     在逻辑与运算中，只要有一个表达式的值为false，那么结果就可以判定为false了，没有必要将所有表达式的值都计算出来，\n     短路与操作就有这样的效果，可以提高效率。\n     同理在逻辑或运算中，一旦发现值为true，右边的表达式将不再参与运算\n     \n     逻辑与&amp;，无论左边真假，右边都要执行。\n     短路与&amp;&amp;，如果左边为真，右边执行；如果左边为假，右边不执行。\n     逻辑或|，无论左边真假，右边都要执行。\n     短路或||，如果左边为假，右边执行；如果左边为真，右边不执行。\n\n8.5    三元运算符\n运算符格式关系表达式 ? 表达式1 : 表达式2;\n解释：问号前面的位置是判断的条件，判断结果为boolean型，为true时调用表达式1，为false时调用表达式2。 其逻辑为：如果条件表达式成立或者满足则执行表达式1，否则执行第二个。\n\n\n\n8.6    位运算符\n\n\n位运算符\n运算规则\n\n\n\n&amp;\n按位与，同为1则为1,否则为0\n\n\n|\n按位或，只要有一个为1则为1,否则为0\n\n\n~\n按位取反，将操作数的每个位（包括符号位）全部取反\n\n\n^\n按位异或,相同时返回0，不同时返回1\n\n\n&lt;&lt;\n左移运算符\n\n\n&gt;&gt;\n右移运算符\n\n\n&gt;&gt;&gt;\n无符号右移运算符\n\n\n位运算是将数字转换成为二进制然后再进行运算，它的运算过程都是基于补码的。\n\n思考：如何区分&amp;,|,^是逻辑运算符还是位运算符？\n\n如果操作数是boolean类型，就是逻辑运算符，如果操作数是整数，那么就位运算符。\n\n8.6.1    左移：&lt;&lt;运算规则：左移几位就相当于乘以2的几次方\n注意：当左移的位数n超过该数据类型的总位数时，相当于左移（n-总位数）位\n8.6.2    右移：&gt;&gt;快速运算：类似于除以2的n次，如果不能整除，向下取整\n8.6.3    无符号右移：&gt;&gt;&gt;运算规则：往右移动后，左边空出来的位直接补0，不看符号位\n正数：和右移一样\n负数：右边移出去几位，左边补几个0，结果变为正数\n8.6.4    按位与：&amp;运算规则：对应位都是1才为1\n             1 &amp; 1 结果为1\n \n             1 &amp; 0 结果为0\n\n​                 0 &amp; 1 结果为0\n​                 0 &amp; 0 结果为0\n8.6.5    按位或：|运算规则：对应位只要有1即为1\n 1 | 1 结果为1\n 1 | 0 结果为1\n 0 | 1 结果为1\n 0 &amp; 0 结果为0\n8.6.6    按位异或：^ 运算规则：对应位一个为1一个为0，才为1\n 1 ^ 1 结果为0\n 1 ^ 0 结果为1\n 0 ^ 1 结果为1\n 0 ^ 0 结果为0\n8.6.7    按位取反运算规则：~0就是1\n ~1就是0\n8.7    运算符优先级\n\n\n优先级\n运算符\n\n\n\n1\n()\n\n\n2\n!、+、-、~、++、–\n\n\n3\n、/、%\n\n\n4\n+、-\n\n\n5\n«、»、&gt;&gt;&gt;\n\n\n6\n&lt;、&lt;=、&gt;、&gt;=、instanceof\n\n\n7\n==、!=\n\n\n8\n&amp;\n\n\n9\n^\n\n\n10\n|\n\n\n11\n&amp;&amp;\n\n\n12\n||\n\n\n13\n=、+=、-=、=、/=、&amp;=、|=、^=、~=、«=、»=、&gt;&gt;&gt;=\n\n\n要求:\n\n表达式不要太复杂\n对于比较复杂的表达式，要求使用()来提升运算符的优先级。\n一般而言，单目运算符优先级较高，赋值运算符优先级较低。\n算术运算符优先级较高，关系和逻辑运算符优先级较低。\n\n九、高级输出语句9.1    转义字符的使用\n\n\n转义字符\n作用\n\n\n\n\\t\n表示一个制表符(tab键)\n\n\n\\n\n表示换行\n\n\n\\r\n表示回车\n\n\n\\ ‘\n表示一个单引号\n\n\n\\ “\n表示一个双引号\n\n\n\\\n表示一个\\\n\n\n9.2    格式化输出使用System.out.printf方法传入占位符还能实现格式化输出。常见的格式化占位符如下:\n\n\n\n占位符\n含义\n示例\n输出结果\n\n\n\n%d\n表示整数(byte,short,int,long类型)\nSystem.out.printf(“我今年%d岁了”,18);\n我今年18岁了\n\n\n%nd\n如果整数不够n位，前面使用空格补齐\nSystem.out.printf(“我是第%3d号选手”,8);\n我是第 8号选手\n\n\n%0nd\n如果整数不够n位，前面使用0补齐\nSystem.out.printf(“我是第%03d号选手”,8);\n我是第008号选手\n\n\n%-nd\n如果整数不够n位，后面使用空格补齐\nSystem.out.printf(“我是第%-3d号选手”,8);\n我是第8 号选手\n\n\n%.nf\n表示浮点数四舍五入保留到小数点后n位\nSystem.out.printf(“您卡上的余额是%.2f元”,34.5678);\n您卡上的余额是34.57元\n\n\n%c\n表示单个字符\nSystem.out.printf(“我的幸运字母是%c”,’s’);\n我的幸运字母是s\n\n\n%s\n表示字符串\nSystem.out.printf(“我的名字是是%s”,”张三”);\n我的名字是张三\n\n\n%%\n表示%\nSystem.out.printf(“我的名字是是%%d”);\n我的名字是%d\n\n\n十、几个关键字10.1    class类\nclass 关键字用来声明新的 Java 类，该类是相关变量和/或方法的集合。\n类是面向对象的程序设计方法的基本构造单位。\n类通常代表某种实际实体，如几何形状或人。类是对象的模板。每个对象都是类的一个实例.\n\n10.2    native 本地native 关键字可以应用于方法，以指示该方法是用 Java 以外的语言实现的可以将native方法比作Java程序同Ｃ程序的接口，其实现步骤：１、在Java中声明native()方法，然后编译；２、用javah产生一个.h文件；３、写一个.cpp文件实现native导出方法，其中需要包含第二步产生的.h文件（注意其中又包含了JDK带的jni.h文件）；４、将第三步的.cpp文件编译成动态链接库文件；５、在Java中用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问了。 \n10.3    synchronized\nsynchronized 关键字可以应用于方法或语句块，并为一次只应由一个线程执行的关键代码段提供保护。 \nsynchronized 关键字可防止代码的关键代码段一次被多个线程执行。 \n如果应用于静态方法，那么，当该方法一次由一个线程执行时，整个类将被锁定。 \n如果应用于实例方法，那么，当该方法一次由一个线程访问时，该实例将被锁定。 \n如果应用于对象或数组，当关联的代码块一次由一个线程执行时，对象或数组将被锁定。\n\n10.4    static、abstract、final、implements在面向对象详细介绍\n","slug":"01-基础知识","date":"2021-09-13T14:33:32.000Z","categories_index":"JavaSE","tags_index":"JavaSE","author_index":"大黄"}]